                              Covers both C89               hgfe
                                          onmlkjihgfedcbaZYXWVU




K . N .K IN G                    ^ . andC99                 aZY




P R O G R A M M IN G ^
AModernApproach   s E c o N D E o m o N
        K .N .K IN G

        P R O G R A M M IN G                                                             ZYXWVUTSRQPONMLKJIHGFEDCBA

^ T "hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                A jp p V O C b C h           S E C O N D   E D IT IO N




                                                                                                   a n d I lo o k f o r w a r d t o u s in g i t in
                     c o m p kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                 f u t u r e c o u r s e s ."

                                                                                                  — K a re n R e id , S e n io r L e c tu re r,


                            !H /n n n ff'
                                                                                                   U n iv e r s ity o f T o ro n to
                                 ^■ ' ir < ifb o th * t
                                                                                                   " T h e s e c o n d e d it io n o f K in g 's

                                                                                                   C P r o g r a m m in g im p r o v e s o n a n

                                                                                                   a lr e a d y im p r e s s iv e b a s e , a n d is t h e

                                                                                                   b o o k T re c o m m e n d t o a n y o n e w h o


                                                                                                  — P e te r S e e b a ch , m o d e r a to r,

                                                                                                  c o m p .la n g .c m o d e r a te d




                                                                                                  y e a r e n g in e e r in g s t u d e n t s . It is

       FEA TU RES OF THE SECO N D ED ITIO N                                                       c o n c is e , c le a r, a c c e s s ib le t o t h e

                                                                                                  b e g in n e r , a n d y e t a ls o c o v e r s a ll



                                                                                                  — P ro fe s s o r M a rk u s B u s s m a n n ,

                                                                                                  D e p a r t m e n t o f M e c h a n ic a l a n d



                                                                                                  o f T o ro n to onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          New coverage ofabslratT daia types
          1Jpdalcd to reflect todays CPUs and operating systems
                                                                                                      K . N . K IN G (P h .D ., U n i v e r s i t y o f
          Nearly 5()0 exorcises aiul programming projecls—60% more                                    C a lif o r n ia , B e r k e le y ) is a n
          than in the first edition
          Source code and solutions lo selected exercises and                                         s c ie n c e a t G e o r g ia S ta te
          programming projecls for students, available al the author’s                                U n iv e r s it y . H e is a ls o t h e a u t h o r
                    (ki/khty.cviri)
          websit e cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                      o f M o d u la - 2 : A C o m p le t e G u id e
          Password-protected instructor sil.e (also al kH khuj.com )                                  a n d J a v a P r o g r a m m in g : F r o m
          cuiiiaining solutions to lhc remaining exe.ruises and prujeris,
                                                                                                      t h e B e g in n in g .
          plus PowerPoint presentations formost chapters
PREFACE               ZYXWVUTSRQPONMLKJIHGFEDCBA




                                             In c o m p u tin g , tu r n in g th e o b v io u s in to th e u s e fu l
                                                   is a liv in g d e fin itio n o f th e w o r d “fr u s tr a tio n .” onmlkjihgfedcbaZYXW




                                          C Program m ing: A M odern A pproach was
In the years since the first edition of cbaZYXWVUTSRQPONMLKJIHGFEDCBA
published, a host of new C-based languages have sprung up— Java and C# forem ost
among them— and related languages such as C++ and Perl have achieved greater
prominence. Still, C remains as popular as ever, plugging away in the background,
quietly powering much o fth e world's software. It remains the lin g u a fra n c a o f the
computer universe, as it was in 1996.
     But even C must change with the times. The need for a new edition of C P ro­
gram m ing: A M odern A pproach became apparent when the C99 standard was pub­
lished. Moreover, the first edition, with its references to DOS and 16-bit processors,
was becom ing dated. The second edition is fully up-to-date and has been improved
in many other ways as well.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


W h a t ’s N e w in th e S e c o n d E d itio n

Here’s a list of new features and improvements in the second edition:
  ■ C om plete coverage o fb o th th e C89 sta n d a rd a n d th e C99 standard. The big­
    g est difference between the first and second editions is coveUrrage of the C99 stan-
    O
    dard. My goal was to cover every significant difference between C89 and C99,
    including all the language features and library functions added in C99. Each
    C99 change is clearly marked, either with “C99” in the heading o fa se ctio n or—
    in the case o fsh o rter discussions— with a special icon in the left margin. I did
    this partly to draw attention to the changes and partly so that readers who aren’t
    interested in C99 or don’t have access to a C99 com piler will know what to skip.
    Many of the C99 additions are of interest only to a specialized audience, but
    some of the new features will be of use to nearly all C programmers.




                                                                                                               xxi
xxii ZYXWVUTSRQPONMLKJIHGFEDCBA
            P r e fa c e cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        ■ In c lu d e s a q u ic k referen ce to a ll C89 a n d C99 library fu n c tio n s . onmlkjihgfedcbaZYXWVUTSRQPON
                                                                                                                               Appendix
                                          D in the first edition described all C89 standard library functions. In this edi­
                                          tion, the appendix covers all C89 and C99 library functions.
                                        ■ E x p a n d e d coverage o f GCC. In the years since the first edition, use of GCC
                                          (originally the GNU C Compiler, now the GNU Compiler Collection) has
                                          spread. GCC has some significant advantages, including high quality, low (i.e.,
                                          no) cost, and portability across a variety of hardware and software platform s.
                                          In recognition o fits growing importance, I ’ve included more information about
                                          GCC in this edition, including& discussions o fh o w to use it as well as common
                                          GCC error messages and warnings,GFEDCBA
                                                                 c?                  o



                                        ■ N ew coverage o f abstract data types. In the first edition, a significant portion
                                          of Chapter 19 was devoted to C++. This material seems less relevant today,
                                          since students may already have learned C++, Java, or C# before reading this
                                          book. In this edition, coverage of C++ has been replaced by a discussion of
                                          how to set up abstract data types in C.
                                         ■ E x p a n d e d coverage o fin te r n a tio n a l fe a tu re s. Chapter 25, which is devoted
                                           to C ’s international features, is now much loncg5er and more detailed. Inform a-
                                           tion about the Unicode/UCS character set and its encodings is a highlight of
                                                                                                                      S^          4^    t«»


                                           the expanded coverage.
                                        ■ U pdated to reflect to d a y ’s CPU s a n d op era tin g system s. When I wrote the
                                          first edition, 16-bit architectures and the DOS operating system were still rele­
                                          vant to many readers, but such is not the case today, f v e updated the discus­
                                          sion to focus more on 32-bit and 64-bit architectures. The rise of Linux and
                                          other versions of UND< has dictated a stronger focus on that family ofo p erat-
                                          ing systems, although aspects ofW indow s and the Mac OS operating system
                                          that affect C program m ers are mentioned as well.
                                        ■ M o re exercises a n d p ro g ra m m in g projects. The first edition o fth is book con­
                                          tained 311 exercises. This edition has nearly 500 (498, to be exact), divided
                                          into two groups: exercises and programming projects.
                                        ■ S o lu tio n s to selected exercises a n d p ro g ra m m in g pro jects. The most frequent
                                          request 1 received from readers of the first edition was to provide answers to
                                          the exercises. In response to this request, Tve put the answers to roughly one-
                                          third of the exercises and programming projects on the web at kn kin g .co m /
                                          books/c2. This feature is particularly useful for readers who arenT enrolled in
                                          a college course and need a way to check their work. Exercises and projects
                                          for which answers are provided are marked with a © icon (the “W ” stands for
                                          “answer available on the Web”).
                                        ■ P assw ord-protected in stru c to r website. For this edition, Tve built a new in­
                                          structor resource site (accessible through knking.com fo ooks/c2) containing
                                          solutions to the remaining exercises and projects, plus PowerPoint presenta­
                                          tions for most chapters. Faculty may contact me at cbook@ knking.com for a
                                          password. Please use your campus email address and include a Jink to your
                                          departm ent’s website so that I can verify your identity.
                                                                                                       xxiii onmlkjihgfedcbaZYXWV
                                                                                   P re fa c e hgfedcbaZYXWVUTSRQPONMLKJIHGF


     I ’ve also taken the opportunity to improve wording and explanations through­
out the book. The changes are extensive and painstaking: every sentence has been
checked and— if necessary— rewritten.
     A lthou ^s>h much haGs changed in this edition, I’ve tried to retain othe original
chapter and section num bering as much as possible. Only one chapter (the last one)
is entirely new, but many chapters have additional sections. In a few cases, existing
sections have been renum bered. One appendix (C syntax) has been dropped, but a
new appendix that com pares C99 with C89 has been added.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


G o a ls

The goals of this edition remain the same as those o f the first edition:cbaZYXWVUTSRQPONMLKJIHGFEDCBA

  ■ B e clear, readable, a n d p o ssib ly even e n te rta in in g . M any C books are too
    concise for the average reader. Others arc badly written or just plain dull. Tve
    tried to give clear, thorough explanations, leavened with enough hum or to hold
    the reader's interest.
  ■ B e a ccessible to a b ro a d ra n g e o f readers. 1 assum e that the reader has at least
    a little previous program m ing experience, but 1 d on’t assum e know ledge o f a
    particular language. I've tried to keep jargon to a minim um and to define the
    terms that I use. Tve also attem pted lo separate advanced material from more
    elem entary topics, so that the beginner w on’t gel discouraged.
  ■ B e a u th o rita tiv e without, b e in g p ed a n tic. To avoid arbitrarily deciding what to
    include and whal not to include. I ’ve tried to cover all the features of the C lan­
    guage and library. At the sam e time, Tve tried to avoid burdening the reader
    with unnecessary detail.
  ■ B e o r g a n iz e d fo r easy le a rn in g . My experience in teaching C underscores the
    im portance of presenting the features of C gradually. I use a spiral approach, in
    which difficult topics are introduced briefly, then revisited one or m ore limes
    later in the book with details added each time. Pacing is deliberate, with each
    chapter building gradually on what has com e before. For most students, this is
    probably the best approach: il avoids the extrem es o fb o red o m on the one hand,
    or “ inform ation overload” on the other.
 ■ M o tiva te la n g u a g e fe a tu r e s . Instead o fju s t describing each feature o f the lan­
   guage and giving a few sim ple exam ples o fh o w the feature is used, I ’ve tried to
   motivate each feature and discuss how it's used in practical situations.
  ■ E m p h a size style. Il’s im portant for every C program m er to develop a consis­
    tent style. Rather than dictating what this style should be, though, I usually
    describe a few possibilities and let the reader choose the one that's most
    appealing. Knowing alternative styles is a big help when reading other people’s
    programs (which program m ers often spend a great deal o f time doing).
  ■ A v o id d e p en d e n ce on a p a r tic u la r m a c h in e , com piler, o r o p era tin g system .
    Since C is available on such a wide variety o f platform s, I’ve tried to avoid
x x iv ZYXWVUTSRQPONMLKJIHGFEDCBA
            P re fa c e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             dependence on any particular machine, compiler, or operating system. All pro­
                                             gram s are designed to be portable to a wide variety of platforms.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         ■ Use illu stra tio n s to clarify key concepts, I ’ve tried to put in as many figures as
                                           I could, since I think these are crucial for understanding many aspects of C. hi
                                           particular, I’ve tried to “anim ate” algorithms whenever possible by showing
                                           snapshots of data at different points in the computation.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      W h a t ’s S o M o d e r n a b o u t A RQPONMLKJIHGFEDCBA
                                                                             M odern A p p ro a ch ?

                                      One of my most important goals has been to take a “modern approach” to C. Here
                                      are some of the ways I ’ve tried to achieve this goal:

                                         ■ P u t C in perspective. Instead oftreating C as the only programming language
                                           worth knowing, I treat it as one of many useful languages. I discuss what kind
                                           of applications C is best suited for; I also show how to capitalize on C ’s
                                           strengoths while mionimizing its weaknesses,
                                         ■ E m p h a size sta n d a rd versions o f C. I pay minimal attention to versions of the
                                           language prior to the C89 standard. There arejust a few scattered references to
                                           K&R C (the 1978 version o fth e language described in the first edition ofB rian
                                           Kernighan and Dennis Ritchie’s book, The C Program m ing Language}. Appen­
                                           dix C lists the major differences between C89 and K&R C.
                                         ■ D e b u n k m yth s. Today’s compilers are often at odds with commonly held
                                           assumptions about C. I don’t hesitate to debunk some of the myths about C or
                                           challenge beliefs that have long been part of the C folklore (for example, the
                                           beliefthat pointer arithmetic is always faster than array subscripting). I’ve re­
                                           examined the old conventions o fC , keeping the ones that are still helpful.
                                         ■ E m p h a size so ftw a re engin eerin g. I treat C as a mature software engineering
                                           tool, emphasizing how to use it to cope with issues that arise during program-
                                           ming-in-the-large. I stress making programs readable, maintainable, reliable,
                                           and portable, and I put special emphasis on information hiding.
                                         ■ P o stpone C ’s lo w -level fe a tu re s. These features, although handy for the kind
                                           ofsystem s programming originally done in C, are not as relevant now that C is
                                           used for a great variety of applications. Instead of introducing them in the early
                                           chapters, as many C books do, 1 postpone them until Chapter 20.
                                         ■ D e-em p h a size “m a n u a l o p tim iza tio n .” Many books teach the reader to write
                                           tricky code in order to gain small savings in program efficiency. With today’s
                                           abundance of optimizing C compilers, these techniques are often no longer
                                           necessary; in fact, they can result in programs that are less efficient.


                                       Q & A S e c tio n s

                                       Each chapter ends with a “Q&A section”— a series ofquestions and answers related
                                       to material covered in the chapter. Topics addressed in these sections include:
                                                                                                                                     P re fa c e      xxv cbaZYXWVUTSRQPONM

                                                          ■ F re q u e n tly a s k e d q uestions. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                     Tve tried to answ er questions that coine up fre­
                                                            quently in my own courses, in other books, and on newsgroups related to C.
                                                          ■ A d d itio n a l d iscu ssio n a n d cla rifica tio n o f tricky issues. Although readers
                                                            with experience in a variety of languages may be satisfied with a brief expla­
                                                            nation and a couple of examples, readers with less experience need more.
                                                          ■ S id e issu es th a t d o n ’t b e lo n g in th e m a in flo w . Som e questions raise techni­
                                                            cal issues that w on’t be of interest to all readers.
                                                          ■ M a te ria l too a d v a n ce d o r too esoteric to in te re st th e average reader. Q ues­
                                                            tions of this nature are marked with an asterisk (*). Curious readers with a fair
                                                            bit o f program m ing experience may wish lo delve into these questions im m e­
                                                            diately; others should definitely skip them on a first reading. W arning: These
                                                            questions often refer to topics covered in later chapters.
                                                          ■ C o m m o n d iffe re n c e s a m o n g C com pilers. I discuss som e frequently used (but
                                                            nonstandard) features provided by particular compilers.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  Some questions in Q&A sections relate directly to specific places in the chap­
                             Q&A            ter; these places are marked by a special icon lo signal the reader that additional
                                            inform ation is available.


                                            O t h e r F e a tu r e s aZYXWVUTSRQPONMLKJIHGFEDCBA

                                            In addition to Q&A sections, I’ve included a num ber o f useful features, many of
                                            which are marked with sim ple but distinctive icons (shown at left).
                                                      ■      W a r n in g s alert readers to common pitfalls. C is famous for its traps; docu­
                                                             menting them all is a hopeless— if not im possible— task. I’ve tried to pick out
                                                             the pitfalls that are most com mon and/or m ost im portant.
                                >P retace
c r o s s - r e f e r e n c e s BA                    ■      C r o s s -r e fe r e n c e s provide a hypertext-like ability to locate inform ation. A1-
                                                             though many o f these are pointers lo topics covered later in the book, some
                                                             point to previous topics that lhe reader may wish to review.
                           id io m                    ■      I d io m s — code patterns frequently seen in C program s— are marked for quick
                                                             reference.
        p o r ta b ility tip                          ■ P o r ta b il it y tip s give hints for writing programs that are independent of a par­
                                                             ticular machine, compiler, or operating system .
                                                  ■          S id e b a r s cover topics that aren’t strictly part of C but that every know ledge­
                                                             able C program m er should be aware of. (See “Source Code” on the next page
                                                             for an exam ple of a sidebar.)
                                              ■              A p p e n d ic e s provide valuable reference information.



                                            P rogram s

                                            Choosing illustrative programs isn't an easyjob. Tfprogram s are too brief and arti­
                                            ficial, readers w on’t gel any sense ofh o w the features are used in the real world. On
                                            the other hand, if a program is too realistic, its point can easily be lost in a forest of
x x v i ZYXWVUTSRQPONMLKJIHGFEDCBA
             P r e f a c e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        details. I’ve chosen a m iddle course, using sm all, sim ple exam ples to m ake con­
                                        cepts clear when they’re first introduced, then gradually building up to com plete
                                        program s. 1 haven’t included program s o f great length; it’s been my experience that
                                        instructors d o n 't have the tim e to cover them and students d o n ’t have the patience to
                                        read them. 1 d o n ’t ignore the issues that arise in the creation o f large program s,
                                        though— C hapter 15 (W riting Large Program s) and C hapter 19 (Program D esign)
                                        cover them in detail.
                                              I’ve resisted the urge to rewrite program s to take advantage of the features of
                                        C99, since not every reader m ay have access to a C99 com piler or wish to use C99.
                                        I have, however, used C 9 9 ’s < s t d b o o l .h > header in a few program s, because it
                                        conveniently defines m acros nam ed b o o l , t r u e , and f a l s e . If your com piler
                                        doesn’t support the < s t d b o o l . h > header, y o u ’ll need to provide your own defi­
                                        nitions for these nam es.
                                              The program s in this edition have undergone one very m inor change. T he
                                        m a i n function now has the form i n t m a i n ( v o i d ) { ... } in most cases. This
                                        change reflects recom m ended practice and is com patible with C99, w hich requires
                                        an explicit return type for each function.



                                                                                           S o u rc e C o d e

                                        S o u rc e c o d e fo r all p ro g ra m s is a v a ila b le a t k n k in g .c o m /b o o k s /c 2 . U p d a te s , c o rr e c ­
                                        tio n s , a n d n e w s a b o u t th e b o o k c a n a ls o b e fo u n d a t th is site. dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                        A u d ie n c e

                                        This book is designed as a prim ary text for a C course at the undergraduate level.
                                        Previous program m ing experience in a high-level language or assem bler is helpful
                                        but not necessary for a com puter-literate reader (an “adept beginner,” as one o f my
                                        form er editors put it).
                                             Since the book is self-contained and usable for reference as well as learning, it
                                        m akes an excellent com panion text for a course in data structures, com piler design,
                                        operating system s, com puter graphics, em bedded system s, or other courses that use
                                        C for project work. T hanks to its Q&A sections and em phasis on practical prob­
                                        lems, the book will also appeal to readers who are enrolled in a training class or who
                                        are learning C by self-study.


                                        O r g a n iz a tio n

                                        T he book is divided into four parts:RQPONMLKJIHGFEDCBA
                                           ■                             C hapters 1-10 cover enough o f C to allow the reader to
                                                 B a s ic F e a tu r e s o f C .
                                                 w rite single-file program s using arrays and functions.
                                           ■ A                              C hapters 11-20 build on the m aterial in the earlier
                                                   d v a n c e d F e a tu r e s o f C .
                                                 chapters. T he topics becom e a little harder in these chapters, w hich provide in-
                                                                                           x x v ii onmlkjihgfedcbaZYXWV
                                                                        P re fa c e hgfedcbaZYXWVUTSRQPONMLKJIHGF


          depth coverage of pointers, strings, the preprocessor, structures, unions, enu­
          merations, and low-level features o fC . In addition, two chapters (15 and 19)
          offer guidance on program design.RQPONMLKJIHGFEDCBA
      ■                              Chapters 21-27 focus on the C library, a large col­
          T h e S ta n d a r d C L ib r a ry .
          lection of functions that come with every compiler. These chapters are most
          likely to be used as reference material, although portions are suitable for lec­
          tures.
  ■                    Appendix A gives a complete list of C operators. Appendix B de­
          R e fe re n c e .
          scribes the major differences between C99 and C89, and Appendix C covers
          the differences between C89 and K&R C. Appendix D is an alphabetical listing
          of all functions in the C89 and C99 standard libraries, with a thorough descrip­
          tion of each. Appendix E lists the ASCII character set. An annotated bibliogra­
          phy points the reader toward other sources of information.

A full-blown course on C should cover Chapters 1-20 in sequence, with topics from
Chapters 21-27 added as needed. (Chapter 22, which includes coverage of file
inpuL/output, is the most important chapter ofthis group.) A shortercourse can omit
the following topics without losing continuity: Section 8.3 (variable-length arrays),
Section 9.6 (recursion), Section 12.4 (pointers and multidimensional arrays). Sec­
tion 12.5 (pointers and variable-length arrays), Section 14.5 (miscellaneous direc­
tives), Section 17.7 (pointers to functions), Section 17.8 (restricted pointers),
Section 17.9 (flexible array members). Section 18.6 (inline functions), Chapter 19
(program design), Section 20.2 (bit-fields in structures), and Section 20.3 (other
low-level techniques).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


E x e r c is e s a n d P r o g r a m m in g P r o j e c t s

Having a variety of good problems is obviously essential for a textbook. This edi­
tion of the book contains both exercises (shorterprobIems that don’t require writing
a full program) and programming projects (problems that require writing or modi­
fying an entire program).
     A few exercises have nonobvious answers (some individuals uncharitably call
these “trick questions”— the nerve!). Since C programs often contain abundant
examples ofsuch code, I feel it’s necessary to provide some practice. However, Tll
play fair by marking these exercises with an asterisk (*). Be careful with a starred
exercise: either pay close attention and think hard or skip it entirely.


E r r o r s , L a c k o f (? )

Tve taken great pains to ensure the accuracy of this book. Inevitably, however,
any book of this size contains a few errors. If you spot one, please contact me at
c b o o k @ k n k i n g .c o m . Td also appreciate hearing about which features you found
especially helpful, which ones you could do without, and what yotfd like to see
added.
xxviii ZYXWVUTSRQPONMLKJIHGFEDCBA
           P re fa c e dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  A c k n o w le d g m e n ts onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  First, I’d like to thank my editors at Norton, Fred McFarland and Aaron Javsicas.
                                  Fred got the second edition underway and Aaron stepped in with brisk efficiency to
                                  bring it to completion. I’d also like to thank associate managing editor Kim Yi, copy
                                  editor Mary Kelly, production manager Roy Tedoff, and editorial assistant Carly
                                  Fraser.
                                       I owe a huge debt to the following colleagues, who reviewed some or all of the
                                  manuscript for the second edition:
                                        Markus Bussinann, University ofToron(o
                                        Jim Clarke, University ofToronto
                                        Karen Reid, University ofToronto
                                        Peter Seebach, moderator of conip.lang.c.m    oderated
                                                                    cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  Jim and Peter deserve special mention for their detailed reviews, which saved m e
                                  from a number of embarrassing slips. The reviewers for the first edition, in alpha­
                                  betical order, were: Susan Anderson-Freed, Manuel E. Bermudez, Lisa J. Brown,
                                  Steven C. Cater, Patrick Harrison, Brian Harvey, Henry H. Leitner, Darrell Long,
                                  Arthur B. Maccabe, Carolyn Rosner, and Patrick Terry.
                                       I received many useful comments from readers of the first edition; I thank
                                  everyone who took the tim e to write. Students and colleagues at Georgia State Uni­
                                  versity also provided valuable feedback. Ed Bullwinkel and his wife Nancy were
                                  kind enough to read much o fth e manuscript. ITn particularly grateful to my depart­
                                  ment chair, Yi Pan, who was very supportive of the project.
                                       My wife, Susan Cole, was a pillar of strength as always. Our cats, Dennis,
                                  Pounce, and Tex, were also instrumental in the completion of the book. Pounce and
                                  Tex were happy to contribute the occasional catfight to help keep me awake while
                                  I was working late at night.
                                       Finally, I’d like to acknowledge the late Alan J. Perlis, whose epigrams appear
                                  at the beginning of each chapter. I had the privilege of studying briefly under Alan
                                  at Yale in the mid-70s. I think he’d be amused at finding his epigrams in a C book.
B R IE F C O N T E N T S                                 aZYXWVUTSRQPONMLKJIHGFEDCBA




      B a s ic F e a t u r e s o f C                                 T h e S t a n d a r d C L ib r a r y

  1   In tr o d u c in g C                           1         21    T h e S ta n d a rd L ib ra ry               529
  2   C F u n d a m e n ta ls                        9         22    ln p u t/O u tp u t                          539
  3   F o rm a tte d ln p u t/O u tp u t            37         23    L ib ra ry S u p p o r t fo r N u m b e rs
  4   E x p re s s io n s                           53               a n d C h a r a c te r D a ta                589
  5   S e le c tio n S ta te m e n ts               73         24    E rro r H a n d lin g                        627
  6   Loops                                         99         25    In te rn a tio n a l F e a tu re s           641
  7   B a s ic T y p e s                           125         26    M is c e lla n e o u s L ib ra ry
  8   A rra y s                                    161               F u n c tio n s                              677
  9   F u n c tio n s                              183         27    A d d itio n a l C 9 9 S u p p o rt fo r
 10   P ro g ra m O rg a n iz a tio n              219               M a th e m a tic s                           705




      A d v a n c e d F e a tu re s o f C                            R e fe r e n c e
 11   P o in te rs                                 241          A    C O p e ra to rs                             735
 12   P o in t e r s a n d A r r a y s             257          B    C 9 9 v e rs u s C 8 9                       737
 13   S trin g s                                   277          C    C 8 9 v e rs u s K & R C                     743
 14   T h e P re p ro c e s s o r                  315          D    S ta n d a rd L ib ra ry F u n c tio n s     747
 15   W ritin g L a rg e P ro g ra m s             349          E    A S C II C h a r a c te r S e t              801
 16   S tru c tu re s , U n io n s , a n d                           B ib lio g ra p h y                          803
      E n u m e ra tio n s                         377               In d e x                                     807
 17   A d v a n c e d U s e s o f P o in t e r s   413
 18   D e c la ra tio n s                          457
 19   P ro g ra m D e s ig n                       483
 20   L o w -L e v e l P ro g ra m m in g          509




                                                                                                                        v
CO NTEN TS                      aZYXWVUTSRQPONMLKJIHGFEDCBA




    P re fa c e                                                          xxi


1   IN T R O D U C I N G C                                                  1
    1.1      H is to r y o fC                                               1
             O rig in s                                                     1
             S ta n d a rd iz a tio n                                       2
             C -B a s e d L a n g u a g e s                                 3
    1 .2     S tre n g th s a n d W e a k n e s s e s o f C                 4
             S tre n g th s                                                 4
             W eaknesses                                                    5
             E ffe c tiv e U s e o f C                                      6


2   C FUNDAM ENTALS                                                        9
    2.1      W r it in g a S im p le P r o g r a m                          9
             P ro g ra m : P rin tin g a P u n                              9
             C o m p ilin g a n d L in k in g                            10
             In te g ra te d D e v e lo p m e n t E n v iro n m e n ts   11
    2 .2     T h e G e n e r a lF o r m o fa S im p le P r o g r a m     12
             D ire c tiv e s                                             12
             F u n c tio n s                                             13
             S ta te m e n ts                                            14
             P r in tin g S tr in g s                                    14
    2 .3     C o m m e n ts                                              15
    2 .4     V a r ia b le s a n d A s s ig n m e n t                    17
             Types                                                       17
             D e c la ra tio n s                                         17
             A s s ig n m e n t                                          18



                                                                          v ii
              C o n te n ts
V III ZYXWVUTSRQPONMLKJIHGFEDCBA



                                               P rin tin g th e V a lu e o f a V a ria b le                                    19
                                               P ro g ra m : C o m p u tin g th e D im e n s io n a l W e ig h t o f a B o x   20
                                               In itia liz a tio n                                                             21
                                               P rin tin g E x p re s s io n s                                                 2 2 aZYXWVUTS
                                       2 .5    R e a d in g In p u t                                                           22
                                               P ro g ra m : C o m p u tin g th e D im e n s io n a l W e ig h t o f a B o x
                                               (R e v is ite d )                                                               22
                                       2 .6    D e f in in g N a m e s f o r C o n s t a n t s                                 23
                                               P ro g ra m : C o n v e rtin g fro m F a h re n h e it to C e ls iu s           24
                                       2 .7    Id e n t if ie r s                                                              25
                                               K e y w o rd s                                                                  26
                                       2 .8    L a y o u t o f a C P ro g r a m                                                27


                                   3   F O R M A T T E D IN P U T /O U T P U T                                                 37
                                       3.1     T h e p r i n t f F u n c t io n                                                37
                                               C o n v e rs io n S p e c ific a tio n s                                        38
                                               P ro g ra m : U s in g p r i n t f to F o rm a t N u m b e rs                   40
                                               E scape S eq ue nc es                                                           41
                                       3 .2    T h e s c a n f F u n c t io n                                                  42
                                               H o w s c a n f W o rk s                                                        43
                                               O rd in a ry C h a ra c te rs in F o rm a t S trin g s                          45
                                               C o n fu s in g p r i n t f w ith s c a n f                                     45
                                               P ro g ra m : A d d in g F ra c tio n s                                         46


                                   4   E X P R E S S IO N S                                                                    53
                                       4.1     A r it h m e t ic O p e r a t o r s                                             54
                                               O p e ra to r P re c e d e n c e a n d A s s o c ia tiv ity                     55
                                               P ro g ra m : C o m p u tin g a U P C C h e c k D ig it                         56
                                       4 .2    A s s ig n m e n t O p e r a t o r s                                            58
                                               S im p le A s s ig n m e n t                                                    58
                                               L v a lu e s                                                                    59
                                               C o m p o u n d A s s ig n m e n t                                              60
                                       4 .3    In c r e m e n t a n d D e c r e m e n t O p e r a t o r s                      61
                                       4 .4    E x p r e s s io n E v a lu a t io n                                            62
                                               O rd e r o f S u b e x p re s s io n E v a lu a tio n                           64
                                       4 .5    E x p r e s s io n S t a t e m e n t s                                          65


                                   5   S E L E C T IO N S T A T E M E N T S                                                    73
                                       5.1     L o g ic a l E x p r e s s io n s                                               74
                                               R e la tio n a l O p e ra to rs                                                 74
                                               E q u a lity O p e ra to rs                                                     75
                                               L o g ic a l O p e ra to rs                                                     75
                                       5 .2    T h e i f S ta te m e n t                                                       76
                                               C o m p o u n d S ta te m e n ts                                                77
                                                                                      C o n te n ts hgfedcbaZYXWVUTSRQPONMLK
                                                                                                               ix


           T h e e l s e C la u s e                                                                         78
           C a s c a d e d i f S ta te m e n ts                                                             80
           P ro g ra m : C a lc u la tin g a B ro k e r’s C o m m is s io n                                 81
           T h e “ D a n g lin g e l s e ” P ro b le m                                                     82
           C o n d itio n a l E x p re s s io n s                                                           83
            B o o le a n V a lu e s in C 8 9                                                               84
            B o o le a n V a lu e s in C 9 9                                                               8 5 aZYXWVUTSRQP
    5 .3   T h e s w i t c h S ta te m e n t                                                                86
           T h e R o le o f th e b r e a k S ta te m e n t                                                  88
           P ro g ra m : P rin tin g a D a te in L e g a l F o rm                                           89


6   LOOPS                                                                                                99
    6.1    T h e w h ile S ta te m e n t                                                                    99
            In finite L o o p s                                                                           101
            P ro g ra m : P rin tin g a T a b le o f S q u a re s                                         102
            P ro g ra m : S u m m in g a S e rie s o f N u m b e rs                                       102
    6 .2   T h e d o S ta te m e n t                                                                      103
            P ro g ra m : C a lc u la tin g th e N u m b e r o f D ig its in an In te g e r               104
    6 .3   T h e fo rS ta te m e n t                                                                      105
            f o r S ta te m e n t Id io m s                                                               106
           O m ittin g E x p re s s io n s in a f o r S ta te m e n t                                     107
            f o r S t a t e m e n t s in C 9 9                                                            108
           T h e C o m m a O p e r a to r                                                                 109
            P ro g ra m : P rin tin g a T a b le o f S q u a re s (R e v is ite d )                       110
    6 .4   E x itin g fr o m a L o o p                                                                    111
           T h e b r e a k S ta te m e n t                                                                111
           T h e c o n t i n u e S ta te m e n t                                                          112
           T h e g o t o S ta te m e n t                                                                  113
            P ro g ra m : B a la n c in g a C h e c k b o o k                                             114
    6 .5   T h e N u llS ta te m e n t                                                                    116


7   B A S IC T Y P E S                                                                                   125
    7.1    ln t e g e r T y p e s                                                                         125
            In te g e r T yp es in C 9 9                                                                  128
            ln te g e rC o n s ta n ts                                                                    128
            In te g e r C o n s ta n ts in C 9 9                                                          129
            ln te g e rO v e rflo w                                                                       130
            R e a d in g a n d W ritin g In te g e rs                                                     130
            P ro g ra m : S u m m in g a S e rie s o f N u m b e rs (R e vis ite d )                      131
    7 .2   F lo a t i n g T y p e s                                                                       132
            F lo a tin g C o n s ta n ts                                                                  133
            R e a d in g a n d W ritin g F lo a tin g -P o in t N u m b e rs                              134
    7 .3   C h a ra c te rT y p e s                                                                       134
           O p e ra tio n s on C h a ra c te rs                                                           135
            S ig n e d a n d U n s ig n e d C h a r a c te r s                                            136
            C o n te n ts
X ZYXWVUTSRQPONMLKJIHGFEDCBA


                                           A rith m e tic T y p e s                                                           136
                                           Escape S e q ue n ce s                                                             137
                                           C h a ra c te r-H a n d lin g F u n c tio n s                                      138
                                           R e a d in g a n d W ritin g C h a ra c te rs u sing s c a n f a n d p r i n t f   139
                                           R e a d in g a n d W ritin g C h a ra c te rs u sing g e t c h a r a n d
                                          p u ,tc h a r                                                                       140
                                           P ro g ra m : D e te rm in in g th e L e n g th o f a M e s s a g e                141 aZYXWVUTSRQ
                                   7 .4   T y p e C o n v e r s io n                                                          142
                                          T h e U su a l A rith m e tic C o n v e rs io n s                                   143
                                           C o n v e r s io n D u rin g A s s ig n m e n t                                    145
                                           lm p lic itC o n v e r s io n s in C 9 9                                           146
                                           C a s tin g                                                                        147
                                   7 .5   T y p e D e f i n it io n s                                                         149
                                           A d v a n ta g e s o f Type D e fin itio n s                                       149
                                          T ype D e fin itio n s a n d P o rta b ility                                        150
                                   7 .6   T h e s i z e o f O p e ra to r                                                     151


                               8   ARRAYS                                                                                     161
                                   8.1    O n e - D im e n s io n a l A r r a y s                                             161
                                           A rr a y S u b s c rip tin g                                                       162
                                           P ro g ra m : R e v e rs in g a S e rie s o f N u m b e rs                         164
                                           A rra y in itia liz a tio n                                                        164
                                           D e s ig n a te d In itia lize rs                                                  165
                                           P ro g ra m : C h e c k in g a N u m b e r fo r R e p e a te d D ig its            166
                                           U s in g th e s i z e o f O p e ra to r w ith A rra y s                            167
                                           P ro g ra m : C o m p u tin g In te re s t                                         168
                                   8 .2   M u lt i d im e n s io n a lA r r a y s                                             169
                                           In itia liz in g a M u ltid im e n s io n a l A rra y                              171
                                           C o n s ta n t A rra y s                                                           172
                                           P ro g ra m : D e a lin g a H a n d o f C a rd s                                   172
                                   8 .3   V a r ia b le - L e n g t h A r r a y s ( C 9 9 )                                   174


                               9   F U N C T IO N S                                                                           183
                                   9.1    D e fin in g a n d C a llin g F u n c tio n s                                       183
                                           P ro g ra m : C o m p u tin g A v e ra g e s                                       184
                                           P ro g ra m : P rin tin g a C o u n td o w n                                       185
                                           P ro g ra m : P rin tin g a P un (R e vis ite d )                                  186
                                           F u n c tio n D e fin itio n s                                                     187
                                           F u n c tio n C a lls                                                              189
                                           P ro g ra m : T e s tin g W h e th e r a N u m b e r Is P rim e                    190
                                   9 .2   F u n c t io n D e c la r a tio n s                                                 191
                                   9 .3   A rg u m e n ts                                                                     193
                                           A rg u m e n tC o n v e rs io n s                                                  194
                                           A rra y A rg u m e n ts                                                            195
                                           V a ria b le -L e n g th A rra y P a ra m e te rs                                  198
                                                                                                             xi
                                                                                    C o n te n ts hgfedcbaZYXWVUTSRQPONMLKJIHGF


              U s in g s t a t i c in A rra y P a ra m e te r D e c la ra tio n s                       200
              C o m p o u n d L ite ra ls                                                               2 0 0 aZYXWVUTSRQPONM
     9 .4     T h e r e t u r n S ta te m e n t                                                         201
     9 .5     P r o g r a m T e r m in a t io n                                                         202
              T h e e x i t F u n c tio n                                                               203
     9 .6     R e c u r s io n                                                                          204
              T h e Q u ic k s o rt A lg o rith m                                                       205
              P ro g ra m : Q u ic k s o rt                                                             207


10   P R O G R A M O R G A N IZ A T IO N                                                               219
     1 0 .1   L o c a lV a r ia b le s                                                                  219
              S ta tic L o ca l V a ria b le s                                                          220
              P a ra m e te rs                                                                          221
     1 0 .2   E x t e r n a l V a r ia b le s                                                           221
              E x a m p le : U s in g E x te rn a l V a ria b le s to Im p le m e n t a S ta c k        221
              P ro s a n d C o n s o f E x te rn a lV a ria b le s                                      222
              P ro g ra m : G u e s s in g a N u m b e r                                                224
     1 0 .3   B lo c k s                                                                                227
     1 0 .4   Scope                                                                                     228
     1 0 .5   O r g a n iz in g a C P r o g r a m                                                       229
              P ro g ra m : C la s s ify in g a P o k e r H a n d                                       230


11   P O IN T E R S                                                                                    241
     11.1     P o i n t e r V a r ia b le s                                                             241
              D e c la rin g P o in te r V a ria b le s                                                 242
     1 1 .2   T h e A d d r e s s a n d In d ir e c t io n O p e r a t o r s                            243
              T h e A d d re s s O p e ra to r                                                          243
              T h e In d ire ctio n O p e ra to r                                                       244
     1 1 .3   P o in t e r A s s ig n m e n t                                                           245
     1 1 .4   P o in te r s a s A r g u m e n ts                                                        247
              P ro g ra m : F in d in g th e L a rg e s t a n d S m a lle s t E le m e n ts in a n
              A rra y                                                                                   249
              U s in g c o n s t to P ro te c t A rg u m e n ts                                         250
     1 1 .5   P o in te r s a s R e tu r n V a lu e s                                                   251


12   P O IN T E R S A N D A R R A Y S                                                                   257
     12.1     P o in t e r A r i t h m e t i c                                                          257
              A d d in g an In te g e r to a P o in te r                                                258
              S u b tra c tin g an In te g e r fro m a P o in te r                                      259
              S u b tra c tin g O n e P o in te r fro m A n o th e r                                    259
              C o m p a rin g P o in te rs                                                              260
              P o in te rs to C o m p o u n d L ite ra ls                                               260
     1 2 .2   U s in g P o in te r s fo r A r r a y P r o c e s s in g                                  260
              C o m b in in g th e * a n d ++ O p e ra to rs                                            262
              C o n te n ts aZYXWVUTSRQPONMLKJIHGFEDCBA
x ii ZYXWVUTSRQPONMLKJIHGFEDCBA


                                            12. 3     U s in g a n A r r a y N a m e a s a P o in te r                                  263
                                                      P ro g ra m : R e v e rs in g a S e rie s o f N u m b e rs (R e v is ite d )      264
                                                     A rra y A rg u m e n ts (R e v is ite d )                                          265
                                                      U s in g a P o in te r a s a n A rra y N a m e                                    266
                                            12. 4     P o in te r s a n d M u ltid im e n s io n a lA r r a y s                         267
                                                      P ro c e s s in g th e E le m e n ts o f a M u ltid im e n s io n a l A rra y     267
                                                      P ro c e s s in g th e R o w s o f a M u ltid im e n s io n a l A rra y           268
                                                      P ro c e s s in g th e C o lu m n s o f a M u ltid im e n s io n a l A rra y      269
                                                      U s in g th e N a m e o f a M u ltid im e n s io n a l A rra y as a P o in te r   269
                                            12. 5     P o in te r s a n d V a r ia b le -L e n g th A r r a y s (C 9 9 )                270


                                    13      S T R IN G S                                                                                277
                                            1 3 .1    S t r in g L i t e r a ls                                                         277
                                                      E s c a p e S e q u e n c e s in S trin g L ite ra ls                             278
                                                     C o n tin u in g a S trin g L ite ra l                                             278
                                                     H o w S trin g L ite ra ls A re S to re d                                          279
                                                     O p e ra tio n s o n S trin g L ite ra ls                                          279
                                                     S trin g L ite ra ls v e rs u s C h a ra c te r C o n s ta n ts                    280
                                            1 3 .2    S tr in g V a r ia b le s                                                         281
                                                      In itia liz in g a S trin g V a ria b le                                          281
                                                     C h a ra c te r A rra y s v e rs u s C h a ra c te r P o in te rs                  283
                                            1 3 .3    R e a d in g a n d W r itin g S tr in g s                                         284
                                                     W ritin g S trin g s U s in g p r i n t f a n d p u t s                            284
                                                      R e a d in g S trin g s U s in g s c a n f a n d g e t s                          285
                                                      R e a d in g S trin g s C h a ra c te r b y C h a ra c te r                       286
                                            1 3 .4    A c c e s s in g th e C h a r a c te r s in a S tr in g                           287
                                            1 3 .5    U s in g th e C S tr in g L ib r a r y                                            289
                                                     T h e s t r c p y (S trin g C o p y ) F u n c tio n                                290
                                                     T h e s t r l e n (S trin g L e n g th ) F u n c tio n                             291
                                                     T h e s t r c a t (S trin g C o n c a te n a tio n ) F u n c tio n                 291
                                                     T h e s t r c m p (S trin g C o m p a ris o n ) F u n c tio n                      292
                                                      P ro g ra m : P rin tin g a O n e -M o n th R e m in d e r L ist                  293
                                            1 3 .6    S tr in g id io m s                                                               296
                                                     S e a rc h in g fo r th e E n d o f a S trin g                                     296
                                                     C o p y in g a S trin g                                                            298
                                            1 3 .7    A r r a y s o fS tr in g s                                                        300
                                                     C o m m a n d - L in e A rg u m e n ts                                             302
                                                      P ro g ra m : C h e c k in g P la n e t N a m e s                                 303


                                    14      THEPREPROCESSO R                                                                            315
                                            1 4 .1    H o w th e P re p ro c e s s o rW o rk s                                          315
                                            1 4 .2    P r e p r o c e s s in g D ir e c tiv e s                                         318
                                            1 4 .3    M a c r o D e f i n i t io n s                                                    319
                                                     S im p le M a c r o s                                                              319
                                                      P a ra m e te riz e d M a c ro s                                                  321
                                                                                                            x iii
                                                                                     C o n te n ts hgfedcbaZYXWVUTSRQPONMLKJIHG


               T h e # O p e ra to r                                                                     324
               T h e # # O p e ra to r                                                                   324
               G e n e ra l P ro p e r tie s o f M a c ro s                                              325
               P a re n th e s e s in M a c ro D e fin itio n s                                          326
               C re a tin g L o n g e r M a c ro s                                                       328
               P re d e fin e d M a c ro s                                                               329
               A d d itio n a l P re d e fin e d M a c ro s in C 9 9                                     330
               E m p ty M a c ro A rg u m e n ts                                                         331
               M a c ro s w ith a V a ria b le N u m b e r o f A rg u m e n ts                           332
               The        fu n c          Id e n tifie r                                                 3 3 3 aZYXWVUTSRQPONM
     1 4 . 4 C o n d it io n a l C o m p ila t io n                                                      333
               T h e # i f a n d # e n d i f D ire c tiv e s                                             334
               T h e d e fin e d O p e r a to r                                                          335
               T h e # i f d e f a n d # i f n d e f D ire c tiv e s                                     335
               T h e # e l i f a n d # e l s e D ire c tiv e s                                           336
               U s e s o f C o n d itio n a l C o m p ila tio n                                          337
     1 4 . 5 M is c e ll a n e o u s D ir e c t iv e s                                                   338
               T h e # e r r o r D ire c tiv e                                                           338
               T h e # l i n e D ire c tiv e                                                             339
               T h e # p r a g m a D ire c tiv e                                                         340
               T h e _ P r a g m a O p e ra to r                                                         341


15   W R IT IN G L A R G E P R O G R A M S                                                              349
     1 5 .1   S o u r c e F ile s                                                                        349
     1 5 .2   H e a d e r F ile s                                                                        350
               T h e # i n c l u d e D ire c tiv e                                                       351
               S h a rin g M a c ro D e fin itio n s a n d T yp e D e fin itio n s                       353
               S h a rin g F u n c tio n P ro to ty p e s                                                354
               S h a rin g V a ria b le D e c la ra tio n s                                              355
               N e s te d In c lu d e s                                                                  357
               P ro te c tin g H e a d e r F ile s                                                       357
               # e r r o r D ire c tiv e s in H e a d e r F ile s                                        358
     1 5 .3   D iv id in g a P r o g r a m in to F ile s                                                 359
               P ro g ra m : T e x t F o rm a ttin g                                                     359
     1 5 .4   B u ild in g a M u ltip le -F ile P r o g r a m                                            366
               M a k e file s                                                                            366
               E rro rs D u rin g L in k in g                                                            368
               R e b u ild in g a P ro g ra m                                                            369
               D e fin in g M a c ro s O u ts id e a P ro g ra m                                         371


16   S T R U C T U R E S , U N IO N S , A N D E N U M E R A T I O N S                                   377
     1 6 .1   S t r u c t u r e V a r ia b le s                                                          377
               D e c la rin g S tr u c tu re V a ria b le s                                              378
               In itia liz in g S tr u c tu re V a ria b le s                                            379
               D e s ig n a te d In itia liz e rs                                                        380
               O p e ra tio n s on S tru c tu re s                                                       381
x iv ZYXWVUTSRQPONMLKJIHGFEDCBA
             C o n te n ts aZYXWVUTSRQPONMLKJIHGFEDCBA


                                           1 6 .2    S tru c tu re T y p e s                                                               382
                                                     D e c la rin g a S tru c tu re T a g                                                  383
                                                     D e fin in g a S tru c tu re T y p e                                                  384
                                                     S tr u c tu re s a s A rg u m e n ts a n d R e tu rn V a lu e s                       384
                                                     C o m p o u n d L ite ra ls                                                           386
                                           1 6 .3    N e s te d A rra y s a n d S tru c tu re s                                            386
                                                     N e s te d S tru c tu re s                                                            387
                                                    A rra y s o f S tru c tu r e s                                                         387
                                                     In itia liz in g a n A rra y o f S tr u c tu re s                                     388
                                                     P ro g ra m : M a in ta in in g a P a rts D a ta b a s e                              389
                                           1 6 .4    U n io n s                                                                            396
                                                     U s in g U n io n s to S a v e S p a c e                                              398
                                                     U s in g U n io n s to B u ild M ix e d D a ta S tru c tu re s                        399
                                                    A d d in g a “T ag F ie ld " to a U n io n                                             400
                                           1 6 .5    E n u m e ra tio n s                                                                  401
                                                     E n u m e ra tio n T a g s a n d T y p e N a m e s                                    402
                                                     E n u m e r a tio n s a s In te g e rs                                                403
                                                     U s in g E n u m e ra tio n s to D e c la re ‘T a g F ie ld s "                       404


                                    17     A D V A N C E D U S E S O F P O IN T E R S                                                      413
                                           1 7 .1    D y n a m ic S to r a g e A llo c a tio n                                             414
                                                     M e m o ry A llo c a tio n F u n c tio n s                                            414
                                                     N u ll P o in te rs                                                                   414
                                           1 7 .2    D y n a m ic a lly A (lo c a te d S tr in g s                                         416
                                                     U s in g m a l l o c to A llo c a te M e m o r y fo r a S trin g                      416
                                                     U s in g D y n a m ic S to ra g e A llo c a tio n in S trin g F u n c tio n s         417
                                                    A rra y s o f D y n a m ic a lly A llo c a te d S trin g s                             418
                                                     P ro g ra m : P rin tin g a O n e - M o n th R e m in d e r L ist (R e v is ite d )   418
                                           1 7 .3    D y n a m ic a lly A llo c a te d A r r a y s                                         420
                                                     U s in g m a l l o c to A llo c a te S to ra g e fo r a n A rra y                     420
                                                    T h e c a l l o c F u n c tio n                                                        421
                                                    T h e r e a l l o c F u n c tio n                                                      421
                                           1 7 .4    D e a ll o c a t in g S t o r a g e                                                   422
                                                    T h e f r e e F u n c tio n                                                            423
                                                    T h e “ D a n g lin g P o in te r” P ro b le m                                         424
                                           1 7 .5    L in k e d L is ts                                                                    424
                                                    D e c la rin g a N o d e T yp e                                                        425
                                                    C re a tin g a N o d e                                                                 425
                                                    T h e - > O p e ra to r                                                                426
                                                     In s e rtin g a N o d e a t th e B e g in n in g o f a L in ke d L is t               427
                                                    S e a rc h in g a L in k e d L is t                                                    429
                                                    D e le tin g a N o d e fro m a L in k e d L is t                                       431
                                                    O rd e re d L is ts                                                                    433
                                                    P ro g ra m : M a in ta in in g a P a rts D a ta b a s e (R e v is ite d )             433
                                           1 7 .6    P o in te r s to P o in te r s                                                        438
                                                                                       C o n te n ts aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                             xv


     17. 7     P o in te r s to F u n c tio n s                                                           4 3 9 hgfedcbaZYXWVUTSR
              F u n c tio n P o in te rs a s A rg u m e n ts                                              439
              T h e q s o r t F u n c tio n                                                               440
              O th e r U s e s o f F u n c tio n P o in te rs                                             442
              P ro g ra m : T a b u la tin g th e T r ig o n o m e tr ic F u n c tio n s                  443
     17. 8     R e s t r ic t e d P o i n t e r s ( C 9 9 )                                               445
     17. 9     F le x ib le A r r a y M e m b e r s ( C 9 9 )                                             447


18   D E C L A R A T IO N S                                                                              457
     1 8 .1   D e c l a r a t io n S y n t a x                                                            457
     1 8 .2   S to r a g e C la s s e s                                                                   459
              P ro p e rtie s o f V a ria b le s                                                          459
              T h e a u t o S to ra g e C la s s                                                          460
              T h e s t a t i c S to ra g e C la s s                                                      461
              T h e e x t e r n S to ra g e C la s s                                                      462
              T h e r e g i s t e r S to ra g e C la s s                                                  463
              T h e S to ra g e C la s s o f a F u n c tio n                                              464
              S u m m a ry                                                                                465
     1 8 .3   T y p e Q u a lifie r s                                                                     466
     1 8 .4   D e c la r a t o r s                                                                        467
              D e c ip h e rin g C o m p le x D e c la ra tio n s                                         468
              U s in g T yp e D e fin itio n s to S im p lify D e c la ra tio n s                         470
     1 8 .5   In it ia liz e r s                                                                          470
              U n in itia liz e d V a ria b le s                                                          472
     1 8 .6   ln lin e F u n c tio n s (C 9 9 )                                                           472
              In lin e D e fin itio n s                                                                   473
              R e s tric tio n s o n In lin e F u n c tio n s                                             474
              U s in g In lin e F u n c tio n s w ith G C C                                               475


19   P R O G R A M D E S IG N                                                                            483
     1 9 .1   M o d u le s                                                                                484
              C o h e s io n a n d C o u p lin g                                                          486
              T y p e s o f M o d u le s                                                                  486
     1 9 .2   In f o r m a t i o n H id in g                                                              487
              A S ta c k M o d u le                                                                       487
     1 9 .3   A b s tra c tD a ta T y p e s                                                               491
              E n c a p s u la tio n                                                                      492
              In c o m p le te T y p e s                                                                  492
     1 9 .4   A S ta c k A b s tra c tD a ta T y p e                                                      493
              D e fin in g th e In te rfa c e fo r th e S ta c k A D T                                    493
              Im p le m e n tin g th e S ta c k A D T U s in g a F ix e d -L e n g th A rra y             495
              C h a n g in g th e Ite m T y p e in th e S ta c k A D T                                    496
              Im p le m e n tin g th e S ta c k A D T U s in g a D y n a m ic A rra y                     497
              Im p le m e n tin g th e S ta c k A D T U s in g a L in k e d L is t                        499
x v i ZYXWVUTSRQPONMLKJIHGFEDCBA
              C o n te n ts aZYXWVUTSRQPONMLKJIHGFEDCBA


                                           1 9 .5   D e s ig n ls s u e s fo r A b s tr a c tD a ta T y p e s                           502
                                                     N a m in g C o n v e n tio n s                                                     502
                                                     E rro r H a n d lin g                                                              502
                                                     G e n e ric A D T s                                                                503
                                                     A D T s in N e w e r L a n g u a g e s                                             503


                                    20     L O W - L E V E L P R O G R A M M IN G                                                       509
                                           2 0 .1    B itw is e O p e r a to r s                                                        509
                                                     B itw is e S h iftO p e r a to r s                                                 510
                                                     B itw ise C o m p le m e n t, A n d , E x c lu s ive Or, a n d In c lu s ive O r   511
                                                     U sing th e B itw is e O p e ra to rs to A c c e s s B its                         512
                                                     U s in g th e B itw is e O p e ra to rs to A c c e s s B it-F ie ld s              513
                                                     P ro g ra m : X O R E n c ry p tio n                                               514
                                           2 0 .2    B it-F ie ld s in S tr u c tu r e s                                                516
                                                     H o w B it- F ie ld s A r e S to r e d                                             517
                                           2 0 .3    O t h e r L o w - L e v e lT e c h n iq u e s                                      518
                                                     D e fin in g M a c h in e -D e p e n d e n t T yp e s                              518
                                                     U s in g U n io n s to P ro v id e M u ltip le V ie w s o f D a ta                 519
                                                     U s in g P o in te rs as A d d re s s e s                                          520
                                                     P ro g ra m : V ie w in g M e m o ry L o c a tio n s                               521
                                                     T h e v o l a t i l e T ype Q u a lifie r                                          523


                                    21     T H E S T A N D A R D L IB R A R Y                                                           529
                                           21.1      U s in g th e L ib r a r y                                                         529
                                                     R e s tric tio n s o n N a m e s U se d in th e L ib ra ry                         530
                                                     F u n c tio n s H id d e n by M a c ro s                                           531
                                           2 1 .2    C 8 9 L ib r a r y O v e r v ie w                                                  531
                                           2 1 .3    C 9 9 L ib r a r y C h a n g e s                                                   534
                                           2 1 .4    T h e < s td d e f.h > H e a d e r :C o m m o n D e fin itio n s                   535
                                           2 1 .5    T h e < s t d b o o l . h > H e a d e r (C 9 9 ): B o o le a n T y p e a n d
                                                     V a lu e s                                                                         536


                                    22     IN P U T /O U T P U T                                                                        539
                                           2 2 .1    S tre a m s                                                                        540
                                                     F ile P o inte rs                                                                  540
                                                     S ta n d a rd S tre a m s a n d R e d ire c tio n                                  540
                                                     Text F ile s v e rs u s B in a ry F ile s                                          541
                                           2 2 .2    F ile O p e r a t io n s                                                           543
                                                     O p e n in g a F ile                                                               543
                                                     M odes                                                                             544
                                                     C lo s in g a File                                                                 545
                                                     A tta c h in g a F ile to an O p e n S tre a m                                     546
                                                     O b ta in in g F ile N a m e s fro m th e C o m m a n d L in e                     546
                                                     P ro g ra m : C h e c k in g W h e th e r a F ile C a n B e O p e n e d            547
                                                                                                                x v ii
                                                                                         C o n te n ts hgfedcbaZYXWVUTSRQPONMLKJIHG


              T e m p o ra ry F ile s                                                                        548
              File B u ffe rin g                                                                             549
              M is c e lla n e o u s F ile O p e ra tio n s                                                  551 aZYXWVUTSRQPONM
     2 2 .3   F o r m a t te d I/O                                                                           551
              T h e ...p r in tfF u n c tio n s                                                              552
              . . . p r i n t f C o n v e rs io n S p e c ific a tio n s                                     552
              C 9 9 C h a n g e s to . . . p r i n t f C o n ve rs io n S p e c ific a tio n s               555
              E x a m p le s o f . . . p r i n t f C o n v e rsio n S p e c ific a tio n s                   556
              T h e ...s c a n f F u n c tio n s                                                             558
              ...s c a n f F o rm a t S trin g s                                                             559
              ...s c a n f C o n v e rs io n S p e c ific a tio n s                                          560
              C 9 9 C h a n g e s to .. . s c a n f C o n v e rsio n S p e c ific a tio n s                  562
              s c a n f E x a m p le s                                                                       563
              D e te c tin g E n d -o f-F ile a n d E rro r C o n d itio n s                                 564
     2 2 .4   C h a r a c t e r I/O                                                                          566
              O u tp u t F u n c tio n s                                                                     566
              In p u t F u n c tio n s                                                                       567
              P ro g ra m : C o p y in g a File                                                              568
     2 2 .5   L in e I/O                                                                                     569
              O u tp u t F u n c tio n s                                                                     56 9
              In p u t F u n c tio n s                                                                       570
     2 2 .6   B lo c k I/O                                                                                   571
     2 2 .7   F ile P o s itio n in g                                                                        572
              P ro g ra m : M o d ify in g a File o f P a rt R e c o rd s                                    574
     2 2 .8   S t r in g I/O                                                                                 575
              O u tp u t F u n c tio n s                                                                     576
              In p u t F u n c tio n s                                                                       576


23   L IB R A R Y S U P P O R T F O R N U M B E R S A N D C H A R A C T E R
     DATA                                                                                                   589
     2 3 .1   T h e < f l o a t . h > H e a d e r : C h a r a c t e r is t ic s o f F lo a t in g
              Types                                                                                          589
     2 3 .2   T h e < l i m i t s . h > H e a d e r : S iz e s o f In t e g e r T y p e s                    591
     2 3 .3   T h e < m a t h . h > H e a d e r (C 8 9 ): M a t h e m a tic s                                593
              E rro rs                                                                                       593
              T rig o n o m e tric F u n c tio n s                                                           594
              H y p e rb o lic F u n c tio n s                                                               595
              E x p o n e n tia l a n d L o g a rith m ic F u n c tio n s                                    595
              P o w e r F u n c tio n s                                                                      596
              N e a re s t Integer, A b s o lu te V alue, a n d R e m a in d e r F u n c tio n s             596
     2 3 .4   T h e < m a t h . h > H e a d e r (C 9 9 ): M a t h e m a tic s                                597
              IE E E F lo a tin g -P o in t S ta n d a rd                                                    598
              T yp e s                                                                                       599
              M a c ro s                                                                                     600
x v iii ZYXWVUTSRQPONMLKJIHGFEDCBA
              C o n te n ts


                                                   E rro rs                                                                               600
                                                   F u n c tio n s                                                                        601
                                                   C la s s ific a tio n M a c ro s                                                       602
                                                   T r ig o n o m e tric F u n c tio n s                                                  603
                                                   H y p e rb o lic F u n c tio n s                                                       603
                                                   E x p o n e n tia l a n d L o g a rith m ic F u n c tio n s                            604
                                                   P o w e r a n d A b s o lu te V a lu e F u n c tio n s                                 605
                                                   E rro r a n d G a m m a F u n c tio n s                                                606
                                                   N e a re s t In te g e r F u n c tio n s                                               606
                                                   R e m a in d e r F u n c tio n s                                                       608
                                                   M a n ip u la tio n F u n c tio n s                                                    608
                                                   M a x im u m , M in im u m , a n d P o s itiv e D iffe re n c e F u n c tio n s        609
                                                   F lo a tin g M u ltip ly - A d d                                                       610
                                                   C o m p a ris o n M a c ro s                                                           611
                                          2 3 . 5 T h e < c t y p e . h > H e a d e r: C h a ra c te r H a n d lin g                      612
                                                   C h a ra c te r-C la s s ific a tio n F u n c tio n s                                  612
                                                   P ro g ra m : T e s tin g th e C h a ra c te r-C la s s ific a tio n F u n c tio n s   613
                                                   C h a ra c te r C a s e - M a p p in g F u n c tio n s                                 614
                                                   P ro g ra m : T e s tin g th e C a s e -M a p p in g F u n c tio n s                   614
                                          23. 6 T h e < s tr in g .h > H e a d e r :S tr in g H a n d lin g                               615
                                                   C o p y in g F u n c tio n s                                                           616
                                                   C o n c a te n a tio n F u n c tio n s                                                 617
                                                   C o m p a ris o n F u n c tio n s                                                      617
                                                   S e a rc h F u n c tio n s                                                             619
                                                   M is c e lla n e o u s F u n c tio n s                                                 6 2 2 aZYXWVUTSRQP


                                     24   E R R O R H A N D L IN G                                                                        627
                                          24.1     T h e < a s s e r t.h > H e a d e r :D ia g n o s tic s                                628
                                          2 4 .2   T h e < e rm o .h > H e a d e r:E rro rs                                               629
                                                   T h e p e r r o r a n d s t r e r r o r F u n c tio n s                                630
                                          24.3     T h e < s i g n a i . h > H e a d e r: S ig n a l H a n d lin g                        631
                                                   S ig n a l M a c ro s                                                                  631
                                                   T h e s i g n a l F u n c tio n                                                        632
                                                   P re d e fin e d S ig n a l H a n d le rs                                              633
                                                   T h e r a i s e F u n c tio n                                                          634
                                                   P ro g ra m : T e s tin g S ig n a ls                                                  634
                                          2 4 .4   T h e < s e t jm p . h > H e a d e r : N o n lo c a lJ u r n p s                       635
                                                   P r o g r a m :T e s tin g s e t j m p / l o n g j m p                                 636


                                     25   IN T E R N A T IO N A L F E A T U R E S                                                         641
                                          25.1     T h e < io c a ie .h > H e a d e r :L o c a liz a tio n                                642
                                                   C a te g o rie s                                                                       642
                                                   T h e s e t l o c a l e F u n c tio n                                                  643
                                                   T h e l o c a l e c o n v F u n c tio n                                                644
                                          2 5 .2   M u ltib y te C h a ra c te rs a n d W id e C h a ra c te rs                           647
                                                                                                                x ix
                                                                                         C o n te n ts hgfedcbaZYXWVUTSRQPONMLKJIHG


              M u ltib y te C h a ra c te rs                                                                 648
              W id e C h a ra c te rs                                                                        649
              U n ico d e a n d th e U n iv e rsa l C h a ra c te r S e t                                    649
              E n c o d in g s o f U n ic o d e                                                              650
              M u ltib y te A A /id e -C h a ra c ter C o n v e rsio n F u n c tio n s                       651
              M u ltib y te A M d e -S trin g C o n v e rsio n F u n c tio n s                               6 5 3 aZYXWVUTSRQPONM
     2 5 .3   D ig r a p h s a n d T r ig r a p h s                                                          654
              T rig ra p h s                                                                                 654
              D ig ra p h s                                                                                  655
              T h e < is o 6 4 6 . h > H e a d e r: A lte rn a tiv e S p e llin g s                          656
     2 5 .4   U n iv e r s a l C h a r a c t e r N a m e s ( C 9 9 )                                         656
     2 5 .5   T h e < w c h a r . h > H e a d e r (C 9 9 ): E x t e n d e d M u ltib y t e a n d
              W id e - C h a r a c t e r U tilit ie s                                                        657
              S tre a m O rie n ta tio n                                                                     658
              F o rm a tte d W id e -C h a ra c te r ln p u t/O u tp u t F u n c tio n s                     659
              W id e -C h a ra c te r ln p u t/O u tp u t F u n c tio n s                                    661
              G e n e ra l W id e -S trin g U tilitie s                                                      662
              W id e -C h a ra c te r T im e -C o n v e rs io n F u n c tio n s                              667
              E x te n d e d M u ltib y te A M d e -C h a ra c te r C o n v e rs io n U tilitie s            667
     2 5 .6   T h e < w c t y p e . h > H e a d e r (C 9 9 ): W id e - C h a r a c t e r
              C la s s if ic a tio n a n d M a p p in g U t ilitie s                                         671
              W id e -C h a ra c te r C la s s ific a tio n F u n c tio n s                                  671
              E x te n s ib le W id e -C h a ra c te r C la s s ific a tio n F u n c tio n s                 672
              W id e -C h a ra c te r C a s e -M a p p in g F u n c tio n s                                  673
              E x te n s ib le W id e -C h a ra c te r C a s e -M a p p in g F u n c tio n s                 673


26   M IS C E L L A N E O U S L IB R A R Y F U N C T IO N S                                                 677
     2 6 .1   T h e < s t d a r g . h > H e a d e r : V a r ia b le A r g u m e n ts                         677
              C a llin g a F u n c tio n w ith a V a ria b le A rg u m e n t L ist                           679
              T h e v . . . p r i n t f F u n c tio n s                                                      680
              T h e v ...s c a n f F u n c tio n s                                                           681
     2 6 .2   T h e < s t d l i b . h > H e a d e r : G e n e r a l U t ilit ie s                            682
              N u m e ric C o n v e rs io n F u n c tio n s                                                  682
              P ro g ra m : T e s tin g th e N u m e ric C o n v e rs io n F u n c tio n s                   684
              P s e u d o -R a n d o m S e q u e n c e G e n e ra tio n F u n c tio n s                      686
              P ro g ra m : T e s tin g th e P s e u d o -R a n d o m S e q u e n c e G e n e ra tio n
              F u n c tio n s                                                                                687
              C o m m u n ic a tio n w ith th e E n v iro n m e n t                                          687
              S e a rc h in g a n d S o rtin g U tilitie s                                                   689
              P ro g ra m : D e te rm in in g A ir M ile a g e                                               690
              In te g e r A rith m e tic F u n c tio n s                                                     691
     2 6 .3   T h e < t i m e . h > H e a d e r : D a te a n d T im e                                        692
              T im e M a n ip u la tio n F u n c tio n s                                                     693
              T im e C o n v e rs io n F u n c tio n s                                                       695
              P ro g ra m : D is p la y in g th e D a te a n d T im e                                        698
            C o n te n ts
X X ZYXWVUTSRQPONMLKJIHGFEDCBA



                                         A D D IT IO N A L C 9 9 S U P P O R T F O R M A T H E M A T IC S
                                 2 7 aZYXWVUTSRQPONMLKJIHGFEDCBA                                                                             705
                                       27.1       T h e < s t d i n t . h > H e a d e r (C 9 9 ): In te g e r T y p e s                      705
                                                  < s td in t.h > T y p e s                                                                  706
                                                  L im its o f S p e c ifie d -W id th In te g e r T y p e s                                 707
                                                  L im its o f O th e r In te g e r T y p e s                                                708
                                                  M a c ro s fo r In te g e r C o n s ta n ts                                                708
                                       2 7 .2     T h e < i n t t y p e s . h > H e a d e r (C 9 9 ): F o rm a t C o n v e rs io n o f
                                                  In te g e r T y p e s                                                                      709
                                                  M a c r o s f o r F o r m a t S p e c if ie r s                                            710
                                                  F u n c tio n s fo r G re a te s t-W id th In te g e r T y p e s                           711
                                       2 7 .3     C o m p le x N u m b e r s ( C 9 9 )                                                       712
                                                  D e fin itio n o f C o m p le x N u m b e rs                                               713
                                                  C o m p le x A r ith m e tic                                                               714
                                                  C o m p le x T y p e s in C 9 9                                                            714
                                                  O p e ra tio n s o n C o m p le x N u m b e rs                                             715
                                                  C o n v e rs io n R u le s fo r C o m p le x T y p e s                                     715
                                       2 7 .4     T h e < c o m p le x . h > H e a d e r (C 9 9 ): C o m p le x A r it h m e t ic            717
                                                  < c o m p le x . h > M a c r o s                                                           717
                                                  T h e c x _ L iM iT E D _ R A N G E P r a g m a                                            718
                                                  < c o m p le x . h > F u n c t io n s                                                      718
                                                  T r ig o n o m e tr ic F u n c tio n s                                                     719
                                                  H y p e rb o lic F u n c tio n s                                                           720
                                                  E x p o n e n tia l a n d L o g a rith m ic F u n c tio n s                                721
                                                  P o w e r a n d A b s o lu te -V a lu e F u n c tio n s                                    721
                                                  M a n ip u la tio n F u n c tio n s                                                        722
                                                  P ro g ra m : F in d in g th e R o o ts o f a Q u a d ra tic E q u a tio n                 722
                                       2 7 .5     T h e < t g m a t h . h > H e a d e r ( C 9 9 ) : T y p e - G e n e r ic M a t h           723
                                                  T y p e - G e n e r ic M a c ro s                                                          724
                                                  In v o k in g a T y p e -G e n e ric M a c ro                                              725
                                       2 7 .6     T h e < f e n v . h > H e a d e r (C 9 9 ): F lo a tin g - P o in t E n v ir o n m e n t   726
                                                  F lo a tin g -P o in t S ta tu s F la g s a n d C o n tro l M o d e s                      727
                                                  < f e n v . h > M a c ro s                                                                 727
                                                  T h e FENV_ACCESS P ra g m a                                                               728
                                                  F lo a tin g -P o in t E x c e p tio n F u n c tio n s                                     729
                                                  R o u n d in g F u n c tio n s                                                             730
                                                  E n v iro n m e n t F u n c tio n s                                                        730

                    A p p e n d ix A    C O p e ra to rs                                                                                     735

                    A p p e n d ix B    C 99 v e rs u s C 89                                                                                 737

                    A p p e n d ix C   C 89 v e rs u s K & R C                                                                               743

                    A p p e n d ix D   S t a n d a r d L ib r a r y F u n c t io n s                                                         747

                    A p p e n d ix E   A S C II C h a r a c t e r S e t                                                                      801

                                       B ib lio g r a p h y                                                                                  803

                                       In d e x                                                                                              807
1     In t r o d u c in g C                                ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                       ‘7 w a n t a p r o g r a m m in g la n g u a g e in w h ic h
                                        W h e n s o m e o n e s a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                     I n e e d o n ly s a y w h a t I w is h d o n e , ” g iv e h im a lo llip o p . *




      W hat is C? The simple answer— a widely used programming language developed
      in the early l970s at Bell Laboratories— conveys little of C\s special flavor. Before
      we become immersed in the details of the language, Iet?s take a look at where C
      came from, what it was designed for, and how it has changed over the years (Sec­
      tion 1.1). W e’lI also discuss C ?s strengths and weaknesses and see how to get the
      most out of the language (Section 1.2).




1.1   H is to r y o fC

      Let's take a quick look al C ’s history, from its origins, to its com ing of age as a
      standardized language, to its influence on recent languages.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


      O r ig in s

      C is a by-product of the UND< operating system, which was developed at Bell Lab­
      oratories by Ken Thompson, Dennis Ritchie, and others. Thom pson single-hand­
      edly wrote the original version ofU N IX , which ran on the DEC PDP-7 computer,
      an early minicom puter with only 8K words o fm a in memory (this was 1969, after
      all!).
            Like other operating systems of the time, UNIX was written in assem bly lan­
      guage. Programs written in assembly language arc usually painful to debug and
      hard to enhance; UNE< was no exception. Thompson decided that a higher-level

      *The epigrams ai the beginning o f each chapter arc froni “Epigrams on Program m ing” by Alan .1. Perlis cbaZYXWVUTSRQPONM
      (A C M S fG P L A N N o tic e s(S c p le m b c r, 1982): 7-13).




                                                                                                                                   1
2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 1 In tr o d u c in g C


                                 language was needed for the further developm ent o f U NIX, so he designed a small
                                 language named B. Thom pson based B on BCPL, a system s program m ing lan­
                                 guage developed in (he m id-1960s. BCPL, in turn, traces its ancestry to Algol 60,
                                 one o fth e earliest (and most influential) program m ing languages.
                                       Ritchie so o n jo in ed the UNIX project and began program m ing in B. In 1970.
                                 Bell Labs acquired a P D P -1 1 for the UNIX project. Once B was up and running on
                                 the PDP-11, Thom pson rewrote a portion o f UNIX in B. By 1971, it becam e
                                 apparent that B was not w ell-suited to the P D P -1 1, so R itchie began to develop an
                                 extended version o fB . He called his language NB (“New B") at first, and then, as
                                 it bes^^j'an to d^*iverse m ore from B, he c4^h anged the nam e to C. TheU.' lan^*guage was sta-
                                 ble enough by 1973 that UNIX could be rewritten in C. T he switch to C provided
                                 an im portant benefit: portability. By writing C com pilers for other com puters at
                                 Bell Labs, the team could get UNIX running on those m achines as well.dcbaZYXWVUTSRQPONMLKJIHG



                                  S ta n d a r d iz a tio n

                                 C continued to evolve during the 1970s, especially betw een 1977 and 1979. It was
                                                                                           T h e C P rogram m ing L a n ­
                                 during this period that the first book on C appeared. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 guage. written by Brian Kernighan and Dennis Ritchie and published in 1978.
                                 quickly becam e the bible o f C program m ers. In the absence o fa n official standard
                                 for C. this book— known as K&R or the “W hite B ook v to aficionados— served as a
                                 de facto standard.
                                      During the l970s, there were relatively few C program m ers, and m ost o fth e m
                                 were UND< users. By the 1980s, however, C had expanded beyond the narrow con­
                                 fines o f the UNIX world. C com pilers becam e available on a variety o f m achines
                                 running under different operating system s. In particular, C began to establish itself
                                 on the fast-grow ing IBM PC platform .
                                      With C ’s increasing popularity cam e problem s. Program m ers who wrote new
                                 C com pilers relied on K&R as a reference. Unfortunately, K & R was fuzzy about
                                 som e language features, so com pilers often treated these features differently. Also.
                                 K&R failed to make a clear distinction between which features belonged to C and
                                 which w ere part of UNDC. To make m atters worse, C continued to change after
                                 K&R was published, with new features being added and a few older features
                                 removed. The need for a thorough, precise, and up-to-date description o f the lan­
                                 guage soon becam e apparent. W ithout such a standard, num erous dialects would
                                 have arisen, threatening the portability o fC program s, one o f the language’s m ajor
                                 strengths.
                                      The developm ent o f a U.S. standard for C began in 1983 under the auspices o f
                                 the A m erican National Standards Institute (A NSI). A fter m any revisions, the stan­
                                 dard was com pleted in 1988 and form ally approved in D ecem ber 1989 as ANSI
                                 standard X 3.159-1989. In 1990, it was approved by the International O rganization
                                 for Standardization (ISO) as international standard lSO /IEC 9899:1990. This ver­
                                 sion o f the language is usually referred to as C89 or C90, to distinguish it from the
                                                                       1.1   H i s t o r y o f C hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                             3 onmlkjihgfedcbaZYXWVU


        original version of C, often called K&R C. Appendix C summarizes the major dif­
        ferences between C89 and K&R C.
             The language underwent a few changes in 1995 (described in a document
        known as Amendm ent I). More significant changes occurred with the publication
        of a new standard, ISO/IEC 9899:1999, in 1999. The language described in this
        standard is commonly known as C99. The terms “ANSI C,” “ANSI/ISO C,” and
        “ISO C”— once used to describe C89— are now ambigV     *^uous,} thanks to the existence
        of two standards.
             Because C99 isn't yet universal, and because o fth e need to maintain millions
<*^E>   (ifnot billions) oflines ofcode written in older versions of C. I’ll use a special icon
        (shown in the left margin) to mark discussions of features that were added in C99.
        A com piler that doesn’t recognize these features isn’t “C99-compliant.” Ifh isto ry
        is any guide, it will be some years before all C compilers are C99-compliant, if they
        ever are. Appendix B lists the major differences between C99 and C89.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



        C -B a s e d L a n g u a g e s

        C has had a huge influence on modern-day programming languages, many o f
        which borrow heavily from it. Of the many C-based languages, several are espe­
        cially prominent:

              ■     C++ includes all the features o fC , but adds classes and other features to sup­
                    port object-oriented programming.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                  ■ Ja v a is based on C++ and therefore inherits many C features.
          ■         C# is a more recent language derived from C+4- and Java.
          ■ P erl was originally a fairly simple scripting language; over time it has grown
            and adopted many o fth e features o fC .

             Considering the popularity of these newer languages, it’s logical to ask
        whether it’s worth the trouble to learn C. 1 think it is, for several reasons. First,
        learning C can give you greater insight into the features ofC+4-, Java, C#, Perl, and
        the other C-based lan9g uagc?es. Programmers
                                            G                G* ^ one of these languages firstPONMLKJIHGFEDCBA
                                                       who leam
        often fail to master basic features that were inherited from C. Second, there are a
        lot of older C programs around; you may find yourself needing to read and main­
        tain this code. Third, C is still widely used for developing new software, especially
        in situations where memory or processing power is limited or where the simplicity
        of C is desired.                        •
              If you haven’t already used one of the newer C-based languages, you’ll find
        that this book is excellent preparation for learning these languages. 11 em phasizes
        data abstraction, information hiding, and other principles that play a large role in
        object-oriented programming. C++ includes all the features o fC , so you’ll be able
        to use everything you learn from this book if you later tackle C++. Many of the
        features o fC can be found in the other C-based languages as well.
4ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 In tr o d u c in g C aZYXWVUTSRQPONMLKJIHGFEDCBA




                       1 .2      S t r e n g t h s a n d W e a k n e s s e s o f C onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                 Like any other programming language, C has strengths and weaknesses. Both stem
                                 from the language’s original use (writing operating systems and other systems
                                 software) and its underlying philosophy:RQPONMLKJIHGFEDCBA
                                   ■                                                   To serve as a suitable language for systems pro­
                                                           C is a lo w - le v e l la n g u a g e .
                                                           gramming, C provides access to machine-level concepts (bytes and addresses,
                                                           for example) that other programming languages try to hide. C also provides
                                                           operations that correspond closely to a computer’s built-in instructions, so (hat
                                                           programs can be fast. Since application programs rely on it for input/output.
                                                           storage management, and numerous other services, an operating system can’t
                                                           afford to be slow.
                                       ■                                           C provides a more limited set of features than many
                                                           C is a s m a ll la n g u a g e .
                                                           languages. (The reference manual in the second edition of K&R covers the
                                                           entire language in 49 pages.) To keep the number of features small. C relies
                                                           heavily on a “library” ofstandard functions. (A “function” is similar to what
                                                           other programming languages might call a “procedure.” “subroutine,” or
                                                           “m ethod”)
                                           ■               C i s a p e r m i s s i v e l a n g u a g e . C assumes that you know what you’re doing, so it
                                                           allows you a wider degree of latitude than many languages. Moreover, C
                                                           doesn’t mandate the detailed error-checkin^a> found in other lanV
                                                                                                                           gv*uag<**es.dcbaZYXWVUTSRQPONMLKJIH


                                 S tr e n g th s

                                 C ’s strengths help explain why the language has become so popular:
                                               ■                       Efficiency has been one of C ’s advantages from the beginning.
                                                           E ffic ie n c y .
                                                           Because C was intended for applications where assembly language had tradi­
                                                           tionally been used, it was crucial that C programs could run quickly and in
                                                           limited amounts of memory.
                                                   ■                    Although program portability wasn’t a primary goal of C, it has
                                                           P o r ta b ility .
                                                           turned out to be one of the language’s strengths. When a program must run on
                                                           computers ranging from PCs to supercomputers, it is often written in C. One
                                                           reason for the portability o fC programs is that— thanks to C ’s early associa­
                                                           tion with UNIX and the later ANSI/ISO standaids— the language hasn’t splin­
                                                           tered into incompatible dialects. Another is that C compilers are small and
                                                           easily written, which has helped make them widely available. Finally, C itself
                                                           has features that support portability (although there’s nothing to prevent pro­
                                                           grammers from writing nonportable programs).
                                                       ■   P ow er. C ’s large collection o fd ata types and operators help make it a power­
                                                           ful language. In C, it’s often possible to accomplish quite a bit with just a few
                                                           lines of code.
                                    1 .2                                                                 5 cbaZYXWVUTSRQPONM
                                           S t r e n g t h s a n d W e a k n e s s e s o f C hgfedcbaZYXWVUTSRQPONMLKJIHGF


     ■ F lexib ility. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                        Although C was originally designed for system s programming, it
       has no inherent restrictions that limit it to this arena. C is now used for appli­
       cations of all kinds, from embedded systems to commercial data processing.
       Moreover, C imposes very few restrictions on the use of its features; opera­
       tions that would be illegal in other languages are often permitted in C. For
       example, C allows a character to be added to an integer value (or, for that mat­
       ter, a floating-point number). This flexibility can make programming easier,
       although it may allow some bugs to slip through.
 ■ S ta n d a rd library. One o f C ’s great strengths is its standard library, which con­
   tains hundreds of functions for input/output. string handling, storage alloca­
   tion, and other useful operations.
     ■ In teg ra tio n with U N IX . C is particularly powerful in combination with UNIX
       (including the popular variant known as Linux). In fact, some UNLX tools
       assum e that the user knows C.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



W eak n esses

C ’s weaknesses arise from the same source as many of its strengths: C ’s closeness
to the machine. Here are a few of C ’s most notorious problems:

 ■     C pro g ra m s can be error-prone. C ’s flexibility makes it an error-prone lan­
       guage. Programming mistakes that would be caught in many other languages
       can’t be detected by a C compiler. In this respect. C is a lot like assembly lan­
       guage, where most errors aren't detected until the program is run. To make
       matters worse, C contains a number of pitfalls for the unwary. In later chap­
       ters, w e’ll see how an extra semicolon can create an infinite loop or a missing
       & symbol can cause a program crash.
 ■ C p ro g ra m s can be d ifficu lt to understand. Although C is a small language
   by most measures, it has a number of features that aren't found in all program ­
   ming languages (and that consequently are often misunderstood). These fea­
   tures can be com bined in a great variety of ways, many o f which— although
   obvious to the original author of a program— can be hard for others to under­
   stand. Another problem is the terse nature of C programs. C was designed at a
   time when interactive communication with computers was tedious at best. As
   a result, C was purposefully kept terse to minimize the time required to enter
   and edit programs. C ’s flexibility can also be a negative factor; program m ers
   who are too clever for their own good can make programs almost impossible
   to understand.
 ■ C p ro g ra m s can be d ifficu lt to m odify. Large programs written in C can be
   hard to change if they haven’t been designed with maintenance in mind. M od­
   ern programming languages usually provide features such as classes and pack­
   ages that support the division o f a large program into more manageable pieces.
   C, unfortunately, lacks such features.
            C h a p te r 1 In tro d u c in g C RQPONMLKJIHGFEDCBA
6 ZYXWVUTSRQPONMLKJIHGFEDCBA



                                                                                   O b fu s c a te d C

                                  E v e n C ’s m o s t a rd e n t a d m ir e rs a d m it th a t C c o d e c a n b e h a rd to re a d . T h e a n n u a l
                                  In te rn a tio n a l O b fu s c a te d C C o d e C o n te s t a c tu a lly e n c o u ra g e s c o n te s ta n ts to w rite
                                  th e m o s t c o n fu s in g C p ro g ra m s p o s s ib le . T h e w in n e rs a re tru ly b a fflin g , a s 1 9 9 0 ’s
                                  “ B e s t S m a ll P ro g ra m ” s h o w s : kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  v,i,j,k,l,s,a[99];
                                  m a i n ()

                                     for(scanf ("%d",&s) ;*a-s,-v=a [j*=v] -a [i] ,k = i < s ,j+= (v=j <s&&
                                  (!k & & !!prin t f ( 2 + " \ n \ n % c " -(!1<<!j )," # Q " [lA v ? ( l A j )& 1 :2])&&
                                  + + 1 1 |a [i]<s&&v&&v-i+j & & v + i - j ))& & ! (l%=s),v| | (i==j ?a[i+=k]=0:
                                  ++a [i])>=s*k&&++a [--i])
                                          f




                                  T h is p ro g ra m , w ritte n by D o ro n O s o v la n s k i a n d B a ru c h N is s e n b a u m , p r in ts all s o lu ­
                                  tio n s to th e E ig h t Q u e e n s p ro b le m         (th e p ro b le m o f p la c in g e ig h t q u e e n s o n a
                                  c h e s s b o a rd in s u c h a w a y th a t n o q u e e n a tta c k s a n y o th e r q u e e n ). In fact, it w o rk s
                                  fo r a n y n u m b e r o f q u e e n s b e tw e e n fo u r a n d 9 9 . F o r m o re w in n in g p ro g ra m s , v is it cbaZYXWVU
                                  www.ioccc.org, th e c o n te s t’s w e b s ite . dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                  E ffe c tiv e U se o f C onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  Using C effectively requires taking advantage of C ’s strengths while avoiding its
                                  weaknesses. Here are a few suggestions:

                                    ■ L e a rn how to a vo id C p itfa lls. Hints for avoiding pitfalls are scattered through­
                                      out this book—just look for the ZL symbol. For a more extensive list of pitfalls,
                                         see Andrew Koenig's C Traps and P itfalls (Reading, Mass.: Addison-W esley,
                                         1989). M odern com pilers will detect common pitfalls and issue warnings, but
                                         no com piler spots them all.
                                    ■ Use so ftw a re tools to m a k e p ro g ra m s m o re reliable. C programmers are pro­
                        Q&A           lific tool builders (and users). One o fth e most famous C tools is named l i n t ,
                                      l i n t , which is traditionally provided with UNIX, can subject a program to a
                                      more extensive error analysis than most C compilers. If l i n t (or a sim ilar
                                      program) is available, it’s a good idea to use it. Another useful tool is a debug­
                                      ger. Because of the nature of C, many bugs can’t be detected by a C compiler;
                                      these show up instead in the form of run-time errors or incorrect output. C on­
                                      sequently. using a good debugger is practically mandatory for C programmers.
                                    ■ T a ke a d va n ta g e o f e x istin g code libraries. One of the benefits of using C is
                                      that so many other people also use it; it’s a good bet that they’ve written code
                                      you can employ in your own programs. C code is often bundled into libraries
                                      (collections offunctions); obtaining a suitable library is a good way to reduce
                                      errors— and save considerable programming effort. Libraries for common
                                                                                                  7onmlkjihgfedcbaZYXWV
                                                                                Q & A kjihgfedcbaZYXWVUTSRQPONMLKJIHG


           tasks, including user-interface development, graphics, communications, data­
           base management, and networking, are readily available. Some libraries are in
           the public domain, some are open source, and some are sold commercially.RQPONMLKJIHGFEDCBA
                                                           A coding convention is a style
       ■ A d o p t a s e n s ib le s e t o f c o d in g c o n v e n tio n s .
           rule that a programmer has decided to adopt even though it's not enforced by
           the language. Well-chosen conventions help make programs more uniform,
           easier to read, and easier to modify. Conventions are important when using
           any programming language, but especially so with C. As noted above, C 's
           highly flexible nature makes it possible for programmers to write code that is
           all but unreadable. The programming examples in this book follow one set of
           conventions, but there are other, equally valid, conventions in use. ^V e’ll dis­
           cuss some of the alternatives from time to time.) Which set you use is less
           important than adopting s o m e conventions and sticking to them.
                                                         C encourages programming tricks.
       ■ A v o id “tr ic k s ” a n d o v e r ly c o m p le x c o d e .
          There are usually several ways to accomplish a given task in C: programmers
          are often tempted to choose the method that’s most concise. Don’t get carried
          away; the shortest solution is often the hardest to comprehend. In this book,
          1’11 illustrate a style that’s reasonably concise but still understandable.
                                    Most C compilers provide language features and library'
       ■ S tic k to th e s ta n d a r d .
           functions that aren’t part of the C89 or C99 standards. For portability, it’s best
           to avoid using nonstandard features and libraries unless they’re absolutely
           necessary.aZYXWVUTSRQPONMLKJIHGFEDCBA




     Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q:   W h a t is th is Q & A s e c tio n a n y w a y ?
A:   Glad you asked. The Q&A section, which appears at the end of each chapter,
     serves several purposes.
          The primary purpose of Q&A is to tackle questions that are frequently asked
     by students learning C. Readers can participate in a dialogue (more or less) with
     the author, much the same as if they were attending one of my C classes.
          Another purpose of Q&A is to provide additional information about topics
     covered in the chapter. Readers o f this book will likely have widely varying back­
     grounds. Some will be experienced in other programming languages, whereas oth­
     ers will be learning to program for the first time. Readers with experience in a
     variety of languages may be satisfied with a brief explanation and a couple of
     examples, but readers with less experience may need more. The bottom line: Lfyou
     fmd the coverage of a topic to bc sketchy, check Q&A for more details.
          On occasion, Q&A will discuss common differences among C compilers. For
     example, we'lI cover some frequently used (but nonstandard) features that are pro­
     vided by particular compilers.
8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 1   In tro d u c in g C dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                           Q:     W h a t d o e s l i n t d o ? [p . 6 ]
                           A:     l i n t checks a C program for a host of potential errors, including— but not limited
                                  to— suspicious combinations of types, unused variables, unreachable code, and
                                  nonportable code. It produces a list ofdiagnostic messages, which the programmer
                                  must then sift througoh . The advantagc e ofusingG l i n t is that it can detect errors thatPONMLKJIHGF
                                  are missed by the compiler. On the other hand, you've got to remem ber to use
                                  l i n t ; it’s all too easy to forget about it. Worse still, l i n t can produce messages
                                  by the hundreds, of which only a fraction refer to actual errors.

                           Q:     W h e r e d id l i n t g e t its n a m e ?
                           A:     Unlike the names of many other UNDC tools, l i n t isn’t an acronym; it got its
                                  name from the way it picks up pieces of “flu ff’ from a program.

                           Q:     H ow do I get a copy o f l i n t ?
                           A:     l i n t is a standard UNIX utility; ifyou rely on another operating system, then you
                                  probably don’t have l i n t . Fortunately, versions of l i n t are available from third
                                  parties. An enhanced version of l i n t known as s p l i n t (Secure Programming
                                  Lint) is included in many Linux distributions and can be downloaded for free from cbaZYXWVUTSR
                                  ww w.splint.org.

                           Q:     Is th e r e s o m e w a y to fo r c e a c o m p ile r to d o a m o r e th o r o u g h j o b o f e r r o r ­
                                  c h e c k in g , w ith o u t h a v in g to u s e l i n t ?
                           A:     Yes. Most compilers will do a more thorough check of a program if asked to. In
                                  addition to checking for errors (undisputed violations of the rules of C), most com ­
                                  pilers also produce warning messages, indicating potential trouble spots. Some
                                  compilers have more than one “warning level”; selecting a higher level causes the
                                  compiler to check for more problems than choosing a lower level. If your compiler
                                  supports warning levels, it’s a good idea to select the highest level, causing the
                                  compiler to perform the most thorough job of checking that it’s capable of. Error-
                     Gcc>2j       checking options for the GCC compiler, which is distributed with Linux, are dis­
                                  cussed in the Q&A section at the end of Chapter 2.

                         *Q :     I ’m in te r e s te d in m a k in g m y p r o g r a m a s r e lia b le a s p o s s ib le . A r e th e r e a n y
                                  o th e r to o ls a v a ila b le b e s id e s l i n t a n d d e b u g g e r s ?
                           A:     Yes. Other common tools include “bounds-checkers” and “leak-finders.” C doesn’t
                                  require that array subscripts be checked; a bounds-checker adds this capability. A
                                  leak-finder helps locate “memory leaks”: blocks of memory that are dynamically
                                  allocated but never deallocated.




                                  *Starred questions cover material too advanced or too esoteric to interest the average reader, and often
                                  refer to topics covered in later chapters. Curious readers with a fair bit of programming experience may
                                  wish to delve into these questions immediately; others should definitely skip them on a first reading.
                   C F u n d a m e n t a ls                             ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                 O n e m a n 's c o n s t a n t is a n o t h e r m a n ’s v a r ia b le . onmlkjihgfedcbaZYXWV




                  This chapter introduces several basic concepts, including preprocessing directives,
                  functions, variables, and statem ents, that w e'll need in order to w rite even the sim ­
                  plest program s. Later chapters will cover these topics in much greater detail.
                       To start off, Section 2.1 presents a small C program and describes how to com ­
                  pile and link it. Section 2.2 then discusses how to generalize the program , and Sec­
                  tion 2.3 shows how to add explanatory rem arks, known as com m ents. Section 2.4
                  introduces variables, which store data that may change during the execution o f a
                  program , and Section 2.5 shows how to use the s c a n f function to read data into
                  variables. C onstants— data that w on’t change during program execution— can be
                  given names, as Section 2.6 shows. Finally, Section 2.7 explains C ’s rules for cre­
                  ating names (identifiers) and Section 2.8 gives the rules for laying out a program .




         2.1      W r it in g a S im p le P r o g r a m

                  In contrast to program s written in som e languages. C program s require little “boil­
                  erplate”— a com plete program can be as short as a few lines.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                   P r in tin g a P u n
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                               The C P rogram m ing L a n ­
                  The first program in Kernighan and R itchie’s classic cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                  g u a g e is extrem ely short; it does nothing but write the m essage h e l l o , w o r l d .
                  Unlike other C authors, I w on’t use this program as my first exam ple. 1 will, how ­
                  ever, uphold another C tradition: the bad pun. H ere’s the pun:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  To C, or not to C: that is the question.



                                                                                                                                      9
10 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2   C F u n d a m e n ta ls cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  The following program, which w e'll name p u n . c , displays this message each
                                  time it is run.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                       p u n .c    #include <stdio.h>

                                   int main(void)

                                      printf("To C, or not to C: that is the question.\n");
                                      return 0;


                                   Section 2.2 explains the form of this program in some detail. For now. I'll just
                                   make a few brief observations. The line

                                   #include <stdio.h>

                                   is necessary to “include” information about C\s standard 1/0 (inpuU'output) library.
                                   The program 's executable code goes inside m a in , which represents the “main"
                                   program. The only line inside m a in is a com mand to display the desired message,
                                   p r i n t f is a function frpm the standard I/O library that can produce nicely for­
                                   matted output. The \ n code tclls p r i n t f to advance to the next line after printing
                                   the message. The line

                                   return 0;

                                   indicates that the program “returns” the value 0 to the operating system when it ter­
                                   minates.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   C o m p ili n g a n d L in k in g

                                   Despite its brevity, getting p u n . c to run is more involved than you might expect.
                                   First, we need to create a file named p u n . c containing the program (any text edi­
                                   tor will do). The name of the file doesn’t matter, but the . c extension is often
                                   required by compilers.
                                        Next, w e've got to convert the program to a form that the machine can exe­
                                   cute. For a C program, that usually involves three steps:

                                     ■ P reprocessing, The program is first given to a preprocessor, which obeys
                                       commands that begin with # (known as directives). A preprocessor is a bit like
                                       an editor; it can add things to the program and make modifications.
                                     ■ C om piling. The modified program now goes to a com piler, which translates it
                                       into machine instructions (object code). The program isn’t quite ready to run
                                       yet, however.
                                     ■ L in k in g . In the final step, a lin k e r combines the object code produced by the
                                       com piler with any additional code needed to yield a com plete executable pro­
                                       gram. This additional code includes library functions (like p r i n t f ) that are
                                       used in the program.
                                                                    2 .1                                                  11 onmlkjihgfedcbaZYXWV
                                                                              W ritin g a S im p le P ro g ra m hgfedcbaZYXWVUTSRQPONMLKJIHG


           Fortunately, this process is often autom ated, so you w on't find it too onerous. In
           fact, the preprocessor is usually integrated with the compiler, so you probably
           w on’t even notice it at work.
                The com m ands necessary to com pile and link vary, depending on the com piler
           and operating system. Under UNIX, the C com piler is usually named c c . To com ­
           pile and link the p u n . c program , enter the follow ing com m and in a term inal or
           com m and-line window:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           % cc p u n .c

           (The % character is the UNIX prom pt, not som ething that you need to enter.) Link­
           ing is autom atic when using c c : no separate link com m and is necessary.
                 After com piling and linking the program, c c leaves the executable program in
           a file named a . o u t by default, c c has many options; one o f them (the - o option)
           allows us to choose the name of the file containing the executable program . For
           exam ple, ifw e want the executable version o f p u n . c to be named p u n , we would
           enter the following command:

           % cc -0 pun pun.cdcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                      T h e G C C C o m p ile r

           O n e o f th e m o s t p o p u la r C c o m p ile r s is th e G C C c o m p ile r, w h ic h is s u p p lie d w ith
           L in u x b u t is a v a ila b le fo r m a n y o th e r p la tfo rm s a s w e ll. U s in g th is c o m p ile r is s im ila r
           to u s in g th e tra d itio n a l U N IX c c c o m p ile r. F o r e x a m p le , to c o m p ile th e p u n . c p ro ­
           g ra m , w e w o u ld u s e th e fo llo w in g c o m m a n d :

           % gcc -o pun pun.c

        T h e Q & A s e c tio n a t th e e n d o f th e c h a p te r p ro v id e s m o re in fo rm a tio n a b o u t G C C .
Q&A RQPONMLKJIHGFEDCBA




           I n te g r a te d D e v e lo p m e n t E n v ir o n m e n ts

           So far, w e’ve assumed the use of a “com m and-line” com piler that's invoked by
           entering a com m and in a special window provided by the operating system . The
                                     in te g ra te d d e v e lo p m e n t e n v ir o n m e n t (ID E ), a software
           alternative is to use an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
           package that allows us to edit, compile, link, execute, and even debug a program
           without leaving the environm ent. The com ponents o fa n ID E are designed to work
           together. For example, when the com piler detects an error in a program , it can
           arrange for the editor to highlight the line that contains the error. T here's a great
           deal of variation am ong IDEs, so 1 w on’t discuss them further in this book. H ow ­
           ever, I would recom m end checking to see which IDEs are available for your plat­
           form.
12 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2     C F u n d a m e n ta ls aZYXWVUTSRQPONMLKJIHGFEDCBA




                             2 .2         T h e G e n e r a l F o r m o f a S im p le P r o g r a m onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGF

                                          L et’s take a closer look at p u n . c and see how we can generalize it a bit. Simple C
                                          programs have the form PONMLKJIHGFEDCBA

                                          directiveskjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                          int main(void)

                                             statements


                                          In this template, and in sim ilar templates elsewhere in this book, items printed in
                                          C o u r i e r would appear in a C program exactly as shown: items in cbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                                   italics repre­
                                          sent text to be supplied by the programmer.
                                               Notice how the braces show where m a in begins and ends. C uses { and } in
                                          much the same way that some other languages use words like b e g i n and e n d .
                                          This illustrates a general point about C: it relies heavily on abbreviations and spe­
                                          cial symbols, one reason that C programs are concise (or— less charitably— cryp-
                            Q&A

                                               Even the sim plest C programs rely on three key language features: directives
                                          (editing commands that modify the program prior to com pilation), functions
                                          (named blocks ofexecutable code, ofw hich m a in is an example), and statements
                                          (com mands to be performed when the program is run). We’ll take a closer look at
                                          these features now.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          D ir e c tiv e s

                                          Before a C program is compiled, it is first edited by a preprocessor. Commands
                                          intended for the preprocessor are called directives. Chapters 14 and 15 discuss
                                          directives in detail. For now ? w e’re interested only in the # i n c l u d e directive.
                                               The p u n . c program begins with the line

                                          #include <stdio.h>

                                          This directive states that the information in < s t d i o . h > is to be “included” into
                                          the program before it is compiled, < s t d i o . h > contains information about C 's
                 h e a d e r s > 7 5 ,2   standard 1/0 library. C has a number of h eaders like < s t d i o .h > ; each contains
                                          information about some part of the standard library. The reason w e’re including
                                          < s t d i o . h > is that C, unlike some programming languages, has no built-in
                                          “read” and “write” commands. The ability to perform input and output is provided
                                          instead by functions in the standard library.
                                                Directives always begin with a # character. which distinguishes them from
                                          other items in a C program. By default, directives are one line long: there’s no
                                          semicolon or other special marker at the end of a directive.
                             2 .2    T h e G e n e ra l F o rm o f a S im p le P ro g ra m hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                     13 dcbaZYXWVUTSRQPO


F u n c tio n s RQPONMLKJIHGFEDCBA

                    are like “procedures’’ or “subroutines”
F u n c t i o n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA         in other programmmg lan­
guages— they’re the building blocks from which programs are constructed. In fact,
a C program is little more than a collection of functions. Functions fall into two
categories: those written by the programmer and those provided as part of the C
implementation. I'll refer to the latter as l i b r a r y f u n c t i o n s , since they belong to a
“library” of functions that are supplied with the compiler.
     The term “function” comes from mathematics, where a function is a rule for
computing a value when given one or more arguments:

    Av) = x + 1
    g(y> z) = .y2 - ^


C uses the term “function” more loosely. In C. a function is simply a series of
statements that have been grouped together and given a name. Some functions
compute a value; some don’t. A function that computes a value uses the r e t u r n
statement to specify what value it “returns.” For example, a function that adds l to
its argument might execute the statementkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

return x + 1;

while a function that computes the difference of the squares of its arguments might
execute the statement

return y * y - z * z;

     Although a C program may consist of many functions, only the m a in func­
tion is mandatory, m a in is special: it gets called automatically when the program
is executed. Until Chapter 9, where we’lI learn how to write other functions, m a in
will be the only function in our programs.


The name m a in is critical; it can’t be b e g i n or s t a r t or even MAIN.


     T fm a in is a function, does it return a value? Yes: it returns a status code that
is given to the operating system when the program terminates. Let's take another
look at the p u n . c program:

#include <stdio.h>

int main(void)

    printf("To C, or not to C: that is the question.\n");
    return 0;
}
The word i n t just before m a in indicates that the m a in function returns an inte­
ger value. The word v o i d in parentheses indicates that m a in has no arguments.
14 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2     C F u n d a m e n ta ls aZYXWVUTSRQPONMLKJIHGFEDCBA


                                   The statementkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   return 0;

                                                   has two effects: it causes the m a in function to term inate (thus ending the program)
                                                   and it indicates that the m a i n function returns a value o f0 . W e’ll have more to say
                                                   about m a i n ’s return value in a later chapter. For now, w e’ll always have m a in
                                        > 9 .5dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
       r e tu r n v a lu e o f m a i n BA

                                       Q&A         return the value 0, which indicates normal program termination.
                                     ■                  Ifth e re ’s no r e t u r n statement at the end of the m a in function, the program
                                                   will still terminate. However, many compilers will produce a warning message
                                       Q&A         (because the function was supposed to return an integer but failed to).


                                   S ta te m e n ts                                                               [

                                      sta te m e n t is a com m and to be executed when the program runs. W e’ll explore
                                   A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   statements later in the book, primarily in Chapters 5 and 6. The p u n . c program
                                   uses only two kinds of statements. One is the r e t u r n statement; the other is the
                                  fu n c tio n call. Asking a function to perform its assigned task is known as ca llin g
                                   the function. The p u n . c program, for example, calls the p r i n t f function to dis­
                                   play a string on the screen:

                                   printf("To C, or not to C: that is the question.\n”);

                                                             C requires that each statem ent end with a semicolon. (As with any good rule,
                                                    there's one exception: the com pound statement, which w e’ll encounter later.) The
       c o m p o u n d s t a t e m e n t > 5.2onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                    semicolon shows the com piler where the statement ends; since statements can con­
                                                    tinue over several lines, it's not always obvious where they end. Directives, on the
                                                    other hand, are normally one line long, and they d o n 't end with a semicolon.


                                   P r in t in g S tr in g s

                                  p r i n t f is a powerful function that w e'll examine in Chapter 3. So far. w e’ve only
                                  used p r i n t f to display a strin g literal — a series ofcharacters enclosed in double
                                  quotation marks. When p r i n t f displays a string literal, it doesn’t show the quo­
                                  tation marks.
                                        p r i n t f doesn’t autom atically advance to the next output line when it fin­
                                  ishes printing. To instruct p r i n t f to advance one line, we must include \ n (the
                                  n ew -lin e character) in the string to be printed. W riting a new-line character term i­
                                  nates the current output line; subsequent output goes onto the next line. To illus­
                                  trate this point, consider the effect of replacing the statement

                                   printf("To C z or not to C: that is the question.\n");

                                   by two calls o f p r i n t f :

                                  printf("To C, or not to C: ”);
                                  printf("that is the question.\n");
                                                                 2 .3                              15
                                                                        C o m m e n ts onmlkjihgfedcbaZYXWVUTSRQPONMLK


       The first call of p r i n t f writes To C z o r n o t t o C : . The second call writes
       t h a t i s t h e q u e s t i o n , and advances to the next line. The net effect is the
       same as the original p r i n t f — the u sercan ’t tell the difference.
             The new-line character can appear inore than once in a string literal. To dis­
       play the message kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

       Brevity is the soul of wit.
         --Shakespeare

       we could write

       printf("Brevity is the soul of wit.\n                   --Shakespeare\n");aZYXWVUTSRQPONMLKJIHGFE




2 .3   C o m m e n ts

       Our p u n . c program still lacks something important: documentation. Every pro­
       gram should contain identifying information: the program name, the date written,
       the authOr, the purpose of the program, and so forth. Tn C, this information is
                  c o m m e n t s . The symbol / * marks the beginning of a comment and the
       placed in RQPONMLKJIHGFEDCBA
       symbol * / marks the end:

       /* This is a comment */

           Comments may appear almost anywhere in a program, either on separate lines
       or on the same lines as other program text. Here's what p u n . c might look like
       with comments added al the be ginning:
                                        C?    C^




       /* Name: pun.c                */
       /* Purpose: Prints a bad pun. */
       /* Author: K. N. King         */

       #include <stdio.h>

       int main(void)

                    C, or not to C: that is the question.\n");
         printf(”To PONMLKJIHGFEDCBA
         return 0;


            Comments may extend over more than one line: once it has seen the / * sym­
       bol, the compiler reads (and ignores) whatever follows until it encounters the * /
       symbol. Ifw e like, we can combine a series o fshort comments into one long com­
       ment:

       /* Name: pun.c
          Purpose: Prints a bad pun.
          Author: K. N. King */

       A comment like this can be hard to read, though, because it’s not easy to see where
16 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2    C F u n d a m e n ta ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    the comment ends. Putting * / on a line by itselfhelps:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    /* Name: p u n .c
                                       Purpose: Prints a bad pun.
                                       Author: K. N. King


                                    Even better, we can form a “box*’ around the comment to make it stand out:
                                      ★ *RQPONMLKJIHGFEDCBA
                                           * * ★ * * ★ * ★ ★ * ★ ★                  *   *   ★    *   ★ ★       *   ★       *   ★     *   * *     * *      * k   *   * *   *   ★   *   ★   * *       *   *   ★   * *   ★       *   ★ ★       *   *   ★       * *   ★       *   *   ★

                                      * N a m e : p u n .c                                                                                                                                                                                                                            *
                                      * Purpose: Prints a bad pun.                                                                                                                                                                                                                    *
                                      * Author: K. N. King                                                                                                                                                                                                                            *
                                      ★ ★   *   ★ ★   *   ★   *   ★ ★   * *   ★ ★   *   ★ ★      * *       *   ★       *   *       ★ ★   *   ★   k   -k   ★ ★ ★ ★ ★ ★ ★ ★ ★               *   ★ ★       ★ ★ ★     k       k   k k       k   k k         k   k k       k   k k         k




                                    Programmers often simplify boxed comments by omitting three o fth e sides:


                                      * Name: p u n .c
                                      * Purpose: Prints a bad pun.
                                      * Author: K. N. King


                                            A short comment can go on the same line with other program code:

                                    int main(void)                                              /* Beginning of main program */

                                    A comment like this is sometimes called a “winged comment.”


                                    Forgetting to terminate a comment may cause the compiler to ignore part of your
                                    program. Consider the following example:
                                    printf("My ");                                              /* forgot to close this comment...
                                    printf("cat ”);
                                    printf("has ”);                                             /* so it ends here */
                                    printf("fleas");

                                    Because w e’ve neglected to terminate the first comment, the compiler ignores the
                                    middle two statements, and the example prints My f l e a s .


                                         C99 provides a second kind ofcom m eni, which begins with | | (two adjacent
                                    slashes):

                                    // This is a comment

                                    This style ofcom m eni ends automatically at the end o fa line. To create a comment
                                    that’s more than one line long, we can either use the older comment style ( / * ...
                                    * / ) or else put | | at.the beginning of each comment line:

                                    // Name: pun.c
                                    // Purpose: Prints a bad pun.
                                    // Author: K. N. King
                                                                                      2 .4                                                       17
                                                                                             V a ria b le s a n d A s s ig n m e n t onmlkjihgfedcbaZYXWVUTSRQPONMLK


                                            The newer comment style has a couple of important advantages. First, because a
                                            comment automatically ends al the end of a Hne, there’s no chance that an unterm i­
                                            nated comment will accidentally consume^part of a program. Second, multiline
                                            comments stand out better, thanks to the | | that’s required at the beginning of
                                            each line.aZYXWVUTSRQPONMLKJIHGFEDCBA




                            2 .4            V a r ia b le s a n d A s s ig n m e n t

                                            Few programs are as simple as the one in Section 2.1. Most programs need lo per­
                                            form a series ofcalculations before producing output, and thus need a way to store
                                            data temporarily during program execution. In C, as in most programming lan­
                                                                                       variables. dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            guages, these storage locations are called cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            T ypes

                                            Every variable must have a type, which specifies whal kind of data it will hold. C
                                            has a wide variety of types. For now, w e’ll Hmit ourselves to just two: i n t and
                                            f l o a t . Choosing the proper type is critical, since the type affects how the variable
                                            is stored and what operations can be performed on the variable. The type of a
                                            numeric variable determines the largest and sm allest numbers that the variable can
                                            store; it also determines whether or not digits are allowed after the decimal point.
                                                  A variable of type i n t (short for integer) can store a whole number such as 0,
ra n g e o f i n t                     1
                     v a l u e s > 7 . BA    I, 392, o r-2 5 5 3 . The range ofpossible values is limited, though. The largest i n t
                                            value is typically 2.147,483,647 but can be as small as 32,767.
                            Q&A                   A variable of type f l o a t (short fo v flo a tin g -p o in f) can store much larger
                                            numbers than an i n t variable. Furthermore, a f l o a t variable can store numbers
                                            with digits after the decimal point, like 379.125. f l o a t variables have drawbacks,
                                            however. Arithmetic on f l o a t numbers may be slower than arithmetic on i n t
                                            numbers. Most significantly, the value of a f l o a t variable is o ftenjusi an approx­
                                            imation of the number that was stored in it. If we store 0.1 in a f l o a t variable, we
                                            may later find that the variable has a value such as 0.09999999999999987, thanks
                                            to rounding© error.


                                            D e c la r a tio n s

                                            Variables must be declared— described for the benefit of the com piler— before
                                            they can be used. To declare a variable, we first specify the type of the variable,
                                            then its nam e. (Variable names are chosen by the programmer, subject to the rules
                                            described in Section 2.7.) For example, we might declare variables h e i g h t and
                                            p r o f i t as follows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            int height;
                                            float profit;
           C h a p te r 2   C F u n d a m e n ta ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
18 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                   The first declaration states that h e i g h t is a variable of type i n t , meaning that
                                   h e i g h t can store an integer value. The second declaration says that p r o f i t is a
                                   variable oftype f l o a t .
                                         Ifsevcral variables have the same type, their declarations can be combined:kjihgfedcbaZYX

                                    int height, length, width, volume;
                                    float profit, loss;

                                    Notice that each complete declaration ends with a semicolon.
                                        Our first template for m a in didn’t include declarations. When m a in contains
                                    declarations, these must precede statements:

                                    int main(void)cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       declarations
                                       statem ents


                   biocks>/0.3      As we’ll see in Chapter 9, this is true of functions in general, as well as blocks
                                    (statements that contain embedded declarations). As a matter of style, it’s a good
                                    idea to leave a blank line between the declarations and the statements.
                                         In C99, declarations don’t have to come before statements. For example,
                                    m a in might contain a declaration, then a statement, and then another declaration.
                                    For compatibility with older compilers, the programs in this book don’t take
                                    advantage of this rule. However, it’s common in C++ and Java programs not to
                                    declare variables until they’re first needed, so this practice can be expected to
                                    become popular in C99 programs as well.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    A s s ig n m e n t

                                    A variable can be given a value by means of aRQPONMLKJIHGFEDCBA
                                                                                   s s i g n m e n t . For example, the state­
                                    ments

                                    height = 8;
                                    length = 12;
                                    width = 10;

                                    assign values to h e i g h t , l e n g t h , and w i d t h . The numbers 8, 12, and 10 are
                                    said to be c o n s t a n t s .
                                         Before a variable can be assigned a value— or used in any other way, for that
                                    matter— it must first be declared. Thus, we could write

                                    int height;
                                    height = 8;

                                    but not

                                    height = 8;              /*** WRONG ***/
                                    int height;
                                                    2 .4                                                         19
                                                            V a r ia b le s a n d A s s ig n m e n t onmlkjihgfedcbaZYXWVUTSRQPONML


          A constant assigned to a f l o a t variable usually contains a decimal point. For
      example, i f p r o f i t is a f l o a t variable, we might write kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      profit = 2150.48;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q&A   It's best to append the letter f (for “float”) to a constant that contains a decimal
      point if the number is assigned to a f l o a t variable:

      profit = 2150.48f;

      Failing to include the f may cause a waming from the compiler.
           An i n t variable is normally assigned a value of type i n t , and a f l o a t vari­
      able is normally assigned a value o fty p e f l o a t . Mixing types (such as assigning
      an i n t value to a f l o a t variable or assigning a f l o a t value lo an i n t variable)
      is possible but not always safe, as w e’ll see in Section 4.2.
           Once a variable has been assigned a value, it can be used to help compute the
      value of another variable:

      height = 8;
      length-= 12;
      width = 10;
      volume = height * length * width;                          /* volume is now 960 */

      In C. * represents the multiplication operator, so this statement multiplies the val­
      ues stored in h e i g h t , l e n g t h , and w i d t h , then assigns the result to the vari­
      able v o lu m e . In general, the right side of an assignment can be a formula (or cbaZYXWVUTSRQPON
      expression, in C terminology) involving constants, variables, and operators.


      P r i n t i n g th e V a lu e o f a V a r ia b le

      We can use p r i n t f to display the current value of a variable. For example, to
      write the message

      Height: h

      where h is the current value o fth e h e i g h t variable, we’d use the following call of
      p rin tf:

      printf("Height: %d\n", height);

      %d is a placeholder indicating where the value o f h e i g h t is to be filled in during
      printing. Note the placement of \ n j u s t after %d, so that p r i n t f will advance to
      the next line after printing the value o f h e i g h t .
           %d works only for i n t variables; to print a f l o a t variable, w e’d use %f
      instead. By default, %f displays a number with six digits after the decimal point.
      To force %f to display p digits after the decimal point, we can put ,p between %
      and f . For example, lo print the line

      Profit: $2150.48
2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2     C F u n d a m e n ta ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     w e ?d call p x ^ i n t f as follows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     printf("Profit:                $%.2f\n” , profit);

                                          There's no limit to the number of variables that can be printed by a single call
                                     of p r i n t f . To display the values o fb o th the h e i g h t and l e n g t h variables, we
                                     could use the following call of p r i n t f :

                                     printf("Height:               %d      Length:        %d\n", height, length);


                                 C o m p u tin g th e D im e n s io n a i W e ig h t o f a B o x
               P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     Shipping companies don’t especially like boxes that are large but very light, since
                                     they take up valuable space in a truck or airplane. In fact, com panies often charge
                                     extra for such a box,7 basing<^ the fee on its volumo e instead o f its weight, hi the
                                     United Stales, lhe usual method is to divide the volume by 166 (the. allowable num ­
                                     ber of cubic inches per pound), lfth is number— the box’s “dim ensional" or “volu­
                                     metric” weight— exceeds its actual weight, the shipping fee is based on the
                                     dimensional weight. (The 166 divisor is for international shipments; the dim en­
                                     sional weight o f a dom estic shipment is typically calculated using 194 instead.)
                                          Let’s say that you’ve been hired by a shipping company to write a program
                                     that com putes the dimensional weight of a box. Since youTe new to C, you decide
                                     to start off by writing a program that calculates the dimensional weight of a partic­
                                     ular box that’s 12" x 10" x 8". Division is represented by / in C, so the obvious
                                     way to compute the dimensional weight would be

                                     weight = volume / 166;

                                     where w e i g h t and v o lu m e are integer variables representing the box’s weight
                                     and volume. Unfortunately, this form ula isn’t quite what we need. In C. when one
                                     integer is divided by another, the answer is “truncated” : all digits after the decimal
                                     point are lost. The volume of a 12" x 10" x 8" box will be 960 cubic inches. Divid­
                                                                                                                       dow n
                                     ing by 166 gives the answer 5 instead of5.783, so we have in effect rounded cbaZYXWVUTSRQPONM
                                     to the next lowest pound; the shipping company expects us to round np. One solu­
                                     tion is to add 165 to the volume before dividing by 166:

                                     weight = (volume 4- 165) / 166;

                                     A volume of 166 would give a weight of 331/166, or 1, while a volume of 167
                                     would yield 332/166, or 2. Calculating the weight in this fashion gives us the fol­
                                     lowing program.

                   d w e ig h tc     /★    Computes the dimensional weight of a 1 2 ” x 10” x 8 ” box */

                                     #include <stdio.h>

                                     int main(void)
                                                                                                         2 .4   V a ria b le s a n d A s s ig n m e n t hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                                                                  21 kjihgfedcbaZYXWVUTS


                                                        int height, length, width, volume, weight;

                                                        height = 8;
                                                        length = 12;
                                                        width = 10;
                                                        volume = height * length * width;
                                                        weight = (volume + 165) / 166;

                                                        printf("Dimensions: %dx%dx%d\n 1', length, width, height);
                                                        printf("Volume (cubic inches): %d\n", volume);
                                                        printf("Dimensional weight (pounds): %d\n", weight);

                                                        return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                          The output of the prograin is

                                                     Dimensions: 12x10x8
                                                     Volume (cubic inches): 960
                                                     Dimensional weight (pounds): 6dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                     I n itia liz a t io n aZYXWVUTSRQPONMLKJIHGFEDCBA

v a ria b ie i n i t i a i i z a t i o n > 7 s . 5   Some variables are automatically set lo zero when a program begins to execute, but
                                                     most are not. A variable that doesn’t have a default value and hasn’t yet been
                                                     assigned a value by the program is said to be cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                   uninitialized.


                                                     Attempting to access the value of an uninitialized variable (for example, by dis­
                                   A                 playing the variable using p r i n t f or using it in an expression) may yield an
                                                     unpredictable result such as 2568, -30891, or some equally strange number. With
                                                     some compilers, worse behavior— even a program crash— may occur.


                                                         We can always give a variable an initial value by using assignment, of course.
                                                     But there’s an easier way: put the initial value of the variable in its declaration. For
                                                     example, we can declare the h e i g h t variable and initialize it in one step:

                                                     int height = 8 ;

                                                     In C jargon, the value 8 is said to be an initializer.
                                                          Any number of variables can be initialized in the same declaration:

                                                     int height = 8, length = 12, width = 10;

                                                     Notice that each variable requires its own initializer. In the following example, the
                                                     initializer 10 is good only for the variable w i d t h , not for h e i g h t or l e n g t h
                                                     (which remain uninitialized):

                                                     int height, length, width = 10;
2 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2   C F u n d a m e n t a ls dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  P r in ti n g E x p r e s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  p r i n t f isn’t limited to displaying numbers stored in variables; it can display the
                                  value of any      numeric expression. Taking advantage of this property can simplify a
                                             cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  program and reduce the number of variables. For instance, the statements kjihgfedcbaZYXWVUTSRQ

                                  volume = height * length * width;
                                  printf("%d\n", volume);

                                  could be replaced by

                                  printf("%d\n", height * length * width);

                                  p r i n t f ’s ability to print expressions illustrates one of C ’s general principles:
                                  W herever a value is needed, any expression o fth e sam e type will do. aZYXWVUTSRQPONMLKJIHGFEDC




                        2 .5      R e a d in g In p u t

                                  Because the d w e i g h t . c program calculates the dimensional weight o fju st one
                                  box, it isn’t especially useful. To improve the program, w e’ll need to allow the user
                                  to enter the dimensions.
                                        To obtain input, w e’ll use the s c a n f function, the C library’s counterpart to
                                  p r i n t f . The f in s c a n f , like the f in p r i n t f , stands for “form atted” ; both
                                  s c a n f and p r i n t f require the use of & form at strin g to specify the appearance
                                  of the input or output data, s c a n f needs to know what form the input data will
                                  take,just as p r i n t f needs to know how to display output data.
                                        To read an i n t value, we’d use s c a n f as follows:

                                  scanf("%d", &i);                   /* reads an integer; stores into i */

                                  The "%d" string tells s c a n f to read input that represents an integer; i is an i n t
               &operator>//.2     variable into which we want s c a n f to store the input. The & symbol is hard to
                                  explain at this point; for now, I’ll just note that it is usually (but not always)
                                  required when using s c a n f .
                                       Reading a f l o a t value requires a slightly different call of s c a n f :

                                  scanf("%f", &x);                   /* reads a float value; stores into x */

                                  %f works only with variables of type f l o a t , so I ’m assuming that x is a f l o a t
                                  variable. The " %f" string tells s c a n f to look for an input value in f l o a t format
                                  (the number may contain a decimal point, but doesn’t have to).


              PROGRAM             C o m p u tin g th e D im e n s io n a l W e ig h t o f a B o x (R e v is ite d )

                                  Here’s an improved version of the dimensional weight program in which the user
                                  enters the dimensions. Note that each call of s c a n f is immediately preceded by a
                                                     V6         D e fin in g N a m e s f o r C o n s ta n ts
                                                            ZYXWVUTSRQPONMLKJIHGFEDCBA                         2 3 onmlkjihgfedcbaZYXW


                call o f p r i n t f . That way, the user will know when to enter input and what input
                l0 enter.RQPONMLKJIHGFEDCBA

                        /* Computes the dimensional
                                              weight of a
d w e i g h t 2 . c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                     box from input provided by the user */

                #include <stdio.h>

                int main(void)

                    int height, length, width, volume, weight;

                    printf("Enter height of box: ");
                    scanf(”%d”, &height);
                    printf("Enter length of box: ");
                    scanf(”%d", &length);
                    printf("Enter width of box: ");
                    scanf("%d”, &width);
                    volume = height * length * width;
                    weight = (volume + 165) / 166;

                    printf("Volume (cubic inches): %d\n", volume);
                    printf("Dimensional weight (pounds): %d\n", weight);

                    return 0;
                )

                The output of the program has the following appearance (input entered by the user
                is underlined):

                Enter height of box: j3
                Enter length of box: 12
                Enter width of box: 10
                Volume (cubic inches): 960
                Dimensional weight (pounds): 6

                A message that asks the user to enter input (a p r o m p t ) normally shouldn’t end with
                a new-line character, because we wanl lhe user to enter inpul on the sam e line as
                the prompt itself. When the user presses the Enter key, the cursor autom atically
                moves to the next line— the program doesn't need to display a new-line character
                lo terminate the current line.
                     The d w e i g h t 2 . c program suffers from one problem: it doesn’t work cor­
                rectly ifth e userenters nonnum eric input. Section 3.2 discusses this issue in more
                detail.aZYXWVUTSRQPONMLKJIHGFEDCBA




       2 .6     D e fin in g N a m e s f o r C o n s t a n t s

                When a program contains constants, it’s often a good idea to give them names. The
                d w e i g h t . c and d w e i g h t 2 . c programs rely on the constant 166, whose m ean­
                ing may not be at all clear to someone reading the program later. Using a feature
           C h a p te r2     C F u n d a m e n t a ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
2 4 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                                             m a c r o d e f i n i t i o n , we can name this constant: kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                    known as RQPONMLKJIHGFEDCBA

                                                    #define INCHES_PER_POUND 166

                                                    # d e f i n e is a preprocessing directive,just as # i n c l u d e is, so there’s no sem ico­
                                                    lon at the end of the line.
                                                         When a program is com piled, the preprocessor replaces each macro by the
                                                    value that it represents. For example, the statement

                                                    weight = (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND;

                                                    will becom e

                                                    weight = (volume + 166 - 1) / 166;

                                                    giving the same effect as if w e’d written the latter statem ent in the first place.
                                                         The value of a macro can be an expression:

                                                    #define RECIPROCAL_OF_PI                    (1.0f / 3.14159f)

     p a r e n t h e s e s in m a c r o s > M . 3   If it contains operators; the expression should be enclosed in parentheses.
                                                          Notice that w e’ve used only upper-case letters in macro names. This is a con­
                                                    vention that most C program m ers follow, not a requirem ent o fth e language. (StiU,
                                                    C programmers have been doing this for decades; you w ouldn’t want to be the first
                                                    to deviate.)


                                       C o n v e r tin g fr o m F a h r e n h e it to C e ls iu s
                     P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                    The following program prom pts the user to enter a Fahrenheit temperature; it then
                                                    prints the equivalent Celsius temperature. The output o fth e program will have the
                                                    following appearance (as usual, input entered by the user is underlined):

                                                    Enter Fahrenheit temperature: 212
                                                    Celsius equivalent: 100.0

                                                    The program will allow tem peratures that aren’t integers; that’s why the Celsius
                                                    tem perature is displayed as 1 0 0 . 0 instead of 1 0 0 . L et’s look first at the entire
                                                    program, then see how it’s put together.BA

                            celsius.c               /* Converts a Fahrenheit temperature to Celsius */

                                                    #include <stdio.h>

                                                    #define FREEZING_PT 32.0f
                                                    #define SCALE_FACTOR (5.0f / 9.0f)

                                                    int main(void)
                                                    {
                                                      float fahrenheit, celsius;

                                                       printf(”Enter Fahrenheit temperature:                              ti
                                                                                                                        2 ,7                             2 5 kjihgfedcbaZYXWVU
                                                                                                                               Id e n tifie rs hgfedcbaZYXWVUTSRQPONMLKJIHGF


                                                        scanf("%f", &fahrenheit);

                                                        celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

                                                        printf("Celsius equivalent: %.lf\n", celsius);

                                                        return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                             The >statement

                                                     celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

                                                     converts the Fahrenheit temperature to Celsius. Since FREEZING_PT stands for
                                                     3 2 . 0 f and SCALE_FACTOR stands for ( 5 . 0 f / 9 . 0 f ) , the compiler sees this
                                                     statement as

                                                     celsius = (fahrenheit - 32.0f) * (5.0f / 9.0f);

                                                     Defining SCALE_FACTOR to be ( 5 . 0 f / 9 . 0 f ) instead of (5 / 9) is impor­
                                                     tant, because C truncates the result when two integers are divided. The value of
                                                         7
                                                                                                                   <^


                                                      (5 / 9 j would be 0, which definitely isnT what we want.
                                                          The call o f p r i n t f writes the Celsius temperature:

                                                     printf("Celsius equivalent: %.lf\n", celsius);

                                                     Notice the use of %. I f to display c e l s i u s with just one digit after the decimal
                                                     point.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                      2 .7           Id e n t if ie r s

                                                     As w e’re writing a program, w e’ll have to choose names for variables, functions,
                                                     macros, and other entities. These names are called cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                         identifiers. In C, an identifier
                                                     may contain letters, digits, and underscores, but must begin with a letter or under-
                                           <ffi>     score. (In C99, identifiers may contain certain “universal character names” as
u n iv e r s a l c h a r a c t e r n a m e s >25.4   WC11.)
                                                          Here are some examples of legal identifiers:

                                                     timesl0         get_next_char           _done

                                                     The following are not legal identifiers:

                                                     10times         get-next-char

                                                     The symbol 1 0 t i m e s begins with a digit, not a letter or underscore, g e t - n e x t -
                                                     c h a r contains minus sigOns,7 not underscores.
                                                           C is case-sensitive: it distinguishes between upper-case and lower-case letters
                                                     in identifiers. For example, the following identifiers are all different:

                                                     job       joB    jOb     jOB     Job     JoB      JOb   JOB
2 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2    C F u n d a m e n ta ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     These eight identifiers could all be used simultaneously, each for a com pletely dif­
                                     ferent purpose. (Talk about obfuscation!) Sensible programmers try to make identi­
                                     fiers look different unless they’re somehow related.
                                          Since case matters in C, many programmers foLlow the convention of using
                                     only lower-case letters in identifiers (other than macros), with underscores inserted
                                     when necessary for legibility:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     symbol_table              current_page              name_and_address

                                     Other programmers avoid underscores, instead using an upper-case letter to begin
                                     each word within an identifier: ^

                                     symbolTable             currentPage             nameAndAddressdcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     (The first letter is sometimes capitalized as well.) Although the former style is
                                     common in traditional C, the latter style is becoming more popular thanks to its
                                     widespread use in Java and C# (and. to a lesser extent. C++). Other reasonable
                                     conventions exist; just be sure to capitalize an identifier the same way each time it
                                     appears in a program.
                          Q&A            C places no limit on the maximum length of an identifier, so don’t be afraid to
                                     use long, descriptive names. A name such as c u r r e n t _ p a g e is a lot easier to
                                     understand than a name like c p .


                                     K eyw o rd s

                                         keyw ords in Table 2.1 have special significance to C compilers and therefore
                                     The cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         <j^f>       can’t be used as identifiers. Note that five keywords were added in C99.

                    T able 2.1                                                            ------ ;— f—
                                                      auto               enum              restrict       unsigned
                    Keywords                          break              extern            return         void
                                                      case               float             short          volatile
                                                      char               for               signed         while
                                                      const              goto              sizeof         _Bool'
                                                      continue           if                static         -Complex’
                                                      default            inline’           struct         —Imaginary7
                                                      do                 int               switch
                                                      double             long              typedef
                                                      else               register          union
                                                      j C99 only



                                          Because o f C ’s case-sensitivity, keywords must appear in programs exactly as
                                     shown in Table 2.1, with all letters in lower case. Names o ffunctions in the stan­
                                     dard library (such as p r i n t f ) contain only lower-case letters also. Avoid the
                                     plight of the unfortunate programmer who enters an entire program in upper case,
                                     only to find that the com piler can’t recognize keywords and calls of library func­
                                     tions.
                                                                                         2 .8                                              2 7 kjihgfedcbaZYXWVUTS
                                                                                                L a y o u t o f a C P r o g ra m hgfedcbaZYXWVUTSRQPONMLKJIHGFED




                                                        Watch out for other restrictions on identifiers. Some compilers treat certain identi­

                    A
re s tric tio n s o n id e n tifie r s > 2 1 . 1
                                                        fiers (asm , for example) as additional keywords. Identifiers that belong to the stan­
                                                 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                        dard library are restricted as well. Accidentally using one of these names can cause
                                                        an error during compilation or linking. Identifiers that begin with an underscore
                                                        are also restricted.aZYXWVUTSRQPONMLKJIHGFEDCBA




                     2 .8      L a y o u t o f a C P ro g ra m

                               We can think of a C program as a series of to     ken s: groups of characters that can’t
                                                                              cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                               be split up without changing their meaning. Identifiers and keywords are tokens.
                               So are operators like + and - , punctuation marks such as the com m a and sem ico­
                               lon, and string literals. For example, the statement

                               printf(''Height: %d\n", height);

                               consists of seven tokens:

                               printf         (       "Height: %d\n"                 ,      height          )      ;
                                  ©           ©              ®                      ®         ®             ®      ®

                               Tokens © and ® are identifiers, token ® is a string^»* literal, and tokens ®. @. ©, and
                               ® are punctuation.
                                    The amount of space between tokens in a program isn't critical in most cases.
                               At one extreme, tokens can be crammed together with no space between them at
                               all, except where this would cause two tokens to merge into a third token. For
                               example, we could delete most of the space in the c e l s i u s . c program of Sec­
                               tion 2.6, provided that we leave space between tokens such as i n t and m a in and
                               between f l o a t and f a h r e n h e i t :

                               /* Converts a Fahrenheit temperature to Celsius */
                               #include <stdio.h>
                               #define FREEZING_PT 32.0f
                               #define SCALE_FACTOR (5.0f/9.0f)
                               int main(void){float fahrenheit,celsius;printf(
                               "Enter Fahrenheit temperature: ");scanf("%f", &fahrenheit);
                               celsius=(fahrenheit-FREEZING_PT)*SCALE_FACTOR;
                               printf("Celsius equivalent: %.lf\n", celsius);return 0;)

                               ln fact, ifth e page were wider, we could put the entire m a in function on a single
                               Line. We can’t put the whole program on one line, though, because each prepro­
                               cessing directive requires a separate line.
                                    Com pressing programs in this fashion isn’t a good idea. In fact, adding spaces
                               and blank lines to a program can make it easier to read and understand. Fortunately,
            C h a p te r 2
2 8 ZYXWVUTSRQPONMLKJIHGFEDCBA C F u n d a m e n ta ls dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   C allows us to insert any am ount o fsp ace— blanks, tabs, and new-line characters—
                                   between tokens. This rule has several im portant consequences for program layout:cbaZYXWVU

                                     ■ Statem ents can be d ivid ed over any number of lines. The following statement,
                                       for example, is so long that it would be hard to squeeze it onto a single line:kjihgfedcbaZ

                                         printf("Dimensional weight (pounds): %d\n",
                                           (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND);

                                     ■ Space betw een tokens makes it easier for the eye to separate them. For this
                                       reason, 1 usually put a space before and after each operator:

                                         volume = height * length * width;

                                         1 also put a space after each comma. Some programmers go even further, put­
                                         ting spaces around parentheses and other punctuation.
                                       ■ Indentation can m ake nesting easier to spot. For example, we should indent
                                            declarations and statem ents to make it clear that they’re nested inside m a in .
                         Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     ■ B lank lines can divide a program into logical units, making it easier for the
                                       reader to discern the program ’s structure. A program with no blank lines is as
                                       hard to read as a book with no chapters.
                                        The c e l s i u s . c program of Section 2.6 illustrates several of these guide­
                                   lines. L et’s take a closer look at the m a in function in that program:

                                   int main(void)

                                       float fahrenheit, celsius;

                                       printf("Enter Fahrenheit temperature:                   ”);
                                       scanf("%f", &fahrenheit);

                                       celsius = (fahrenheit - FREEZING_PT)                  * SCALE_FACTOR;

                                       printf("Celsius equivalent: %.lf\n'\ celsius);

                                       return 0;


                                   First, observe how the space around =, - , and * makes these operators stand out.
                                   Second, notice how the indentation of declarations and statements makes it obvi­
                                   ous that they all belong to m a in . Finally, note how blank lines divide m a i n into
                                   five parts: (1) declaring the f a h r e n h e i t and c e l s i u s variables; (2) obtaining
                                   the Fahrenheit temperature; (3) calculating the value of c e l s i u s ; (4) printing the
                                   Celsius temperature; and (5) returning to the operating system.
                                        W hile w e’re on the subject of program layout, notice how I’ve placed the {
                                   token underneath m a in () and put the matching } on a separate line, aligned with
                                    {. Putting } on a separate line lets us insert or delete statem ents at the end of the
                                   function; aligning it with { makes it easy to spot the end o f m a in .
                                        A final note: Although extra spaces can be added betw een tokens, it’s not pos-
                                                                                                                                   29
                                                                                                                Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


                                       sible ro add space cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                           wiihin a token without changing the meaning of the program or
                                       causing an error. Writing kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       fl oat fahrenheit, celsius;                            /*** WRONG ***/

                                       or

                                       fl
                                       oat fahrenheit, celsius;                               /*** WRONG ***/

                                       produces an error when the program is compiled. Putting a space inside a string lit­
                                       eral is allowed, although it changes the meaning of the string. However, putting a
                                       new-line character in a string (in other words, splitting the string over two lines) is
                                       illegal:

                                       printf("To C, or not to C:
                                       that is the question.\n");                             /*** WRONG ***/

                                       Continuing a string from one line to the next requires a special technique that w e'llhgfedcbaZYXWVUTSRQ
c o n iin u in g a s tr in g > 7 3 j   learn in a later chapter.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                       Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Q:       W h a t d o e s G C C s ta n d fo r ? [p . 1 1 ]
                               A:      GCC originally stood for “GNU G compiler.” It now stands for “GNU G om piler
                                       Collection,” because the current version o fG C C compiles programs written in a
                                       variety oflanguages. including Ada. C. C++. Fortran. Java, and Objective-C.

                              Q:       O K , s o w h a t d o e s G N U s ta n d fo r ?
                               A:      GNU stands for “G N U ’s Not UNIX!'" (and is pronounced guh-NEW> by the way).
                                       GNU is a project of the Free Software Foundation, an organization set up by Rich­
                                       ard M. Stallman as a protest against the restrictions of licensed UNIX software.
                                       According to its web site, the Free Software Foundation believes that users should
                                       be free to “run. copy, distribute, study, change and im prove” software. The GNU
                                       Project has rewritten much traditional UNIX software from scratch and made it
                                       publicly available at no charge.
                                            GCC and other GNU software are crucial to Linux. Linux itself is only the
                                       “kernel” of an operating system (the part that handles program scheduling and
                                       basic I/O services): the GNU software is necessary to have a fully functional oper­
                                       ating system.
                                            For more information on the GNU Project, visit w w w .gm i.org.

                              Q:       W h a t ’s th e b ig d e a l a b o u t G C C , a n y w a y ?
                               A:      GCC is significant for many reasons, not least the fact that it’s free and capable of
                                       compiling a number of languages. It runs under many operating systems and gen­
                                       erates code for many different CPUs, including all the widely used ones. GCC is
3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2    C F u n d a m e n ta ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     the primary compiler for many UNIX-based operating systems, including Linux,
                                     BSD, and Mac OS X, and it’s used extensively for commercial software develop­
                                                                                 gcc.g nu.o rg. dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     ment. For more information about GCC, visit cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      H o w g o o d is G C C a t fin d in g e r r o r s in p r o g r a m s ?
                             A:      GCC has various command-line options that control how thoroughly il checks pro­
                                     grams. When these options are used, GCC is quite good at finding potential trouble
                                     spots in a program. Here are some of the more popular options:

                                           -W a ll                 Causes the compiler to produce warning messages when it
                                                                   detects possible errors. (-W can be followed by codes for
                                                                   specific warnings; - W a l l means u all -W options.” ) Should
                                                                   be used in conjunction with - 0 for maximum effect.
                                           -W                      Issues additional warning messages beyond diose produced
                                                                   by - W a ll.
                                           -p e d a n tic          Issues all warnings required by the C standard. Causes pro­
                                                                   grams that use nonstandard features to be rejected.
                                           -a n si                 Turns off features of GCC that aren’t standard C and enables
                                                                   a few standard features that are normally disabled.
                                           -s td = c 8 9
                                           -s td = c 9 9           Specifies which version of C the compiler should use to
                                                                   check the program.
                                     These options are often used in combination:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     % gcc -0 -Wall -W -pedantic -ansi -std=c99 -o pun pun.c

                             Q:      W h y is C s o te r s e ? I t s e e m s a s th o u g h p r o g r a m s w o u ld b e m o r e r e a d a b le i f C
                                     u s e d b e g i n a n d e n d in s te a d o f { a n d } , i n t e g e r in s te a d o f i n t , a n d so
                                     fo r th , [p . 12]
                             A:      Legend has it that the brevity o fC programs is due to the environment that existed
                                     in Bell Labs at the tim e the language was developed. The first C com piler ran on a
                                     DEC P D P -11 (an early minicomputer); programmers used a teletype— essentially
                                     a typewriter connected to a computer— to enter programs and print listings.
                                     Because teletypes were very slow (they could print only 10 characters per second),
                                     minimizing the number ofcharacters in a program was clearly advantageous.

                             Q:      In s o m e C b o o k s , th e m a i n fu n c tio n e n d s w ith e x i t ( 0 ) in s te a d o f r e t u r n
                                     0 . A r e th e s e th e s a m e ? [p . 1 4 ]
                             A:      When they appear inside m a in , these statements are indeed equivalent: both ter­
                                     minate the program, returning the value 0 to the operating system. Which one lo
                                     use is mostly a matter of taste.

                             Q:      W h a t h a p p e n s i f a p r o g r a m r e a c h e s th e e n d o f th e m a i n fu n c tio n w it h o u t e x e ­
                                     c u tin g a r e t u r n s ta te m e n t? [p . 14 ]
                             A:      The r e t u r n statement isn’t mandatory; if it’s missing, the program will still ter-
                                                                                                          Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFED
                                                                                                                           31 aZYXWVUTSRQPONML


                minate. ln C89, the value returned to the operating system is undefined. In C99, if
                m a in is declared to return an i n t (as in our examples), the program returns 0 to
   ?C 9SL onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                the operating system; otherwise, the program returns an unspecified value.dcbaZYXWVUTSRQPONMLKJIHGFED

      Q:     D o e s th e c o m p ile r r e m o v e a c o m m e n t e n tir e ly o r r e p la c e it w ith b la n k s p a c e ?
       A:    Some old C compilers deleted all the characters in each comment, making it possi­
             ble to write kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

             a/**/b = 0;

             and have the compiler interpret it as

             ab = 0 ;

             According to thc C standard, however, the compiler must replace each comment by
             a single space character, so this trick doesn’t work. Instead, we’d end up with the
             following (illegal) statement:

             a b = 0;

      Q:     H o w c a n I tell if m y p r o g r a m h a s a n u n te r m in a te d c o m m e n t?
       A:    If you’re lucky, the program w on't compile because the comment has rendered the
             program illegal. Ifth e program does compile, there are several techniques that you
             can use. Stepping through the program line by line with a debugger will reveal if
             any lines are being skipped. Some IDEs display comments in a distinctive color to
             distinguish them from surrounding code. Ify o u 're using such an environment, you
             can easily spot unterminated comments, since program text will have a different
iin t> /.2   color if it's accidentally included in a comment. A program such as l i n t can also
             help.

      Q:     Is it leg a l to n e s t o n e c o m m e n t in s id e a n o th e r ?
       A:    Old-style comments ( / * ... * / ) can’t be nested. For instance, the following code
             is illegal:

             /*
                  /*** WRONG ***/
             */

             The * / symbol on the second line matches the / * symbol on the first line, so the
             compiler will flag the * / symbol on the third line as an error.
                  C ’s prohibition against nested comments can sometimes be a problem. Sup­
             pose we’ve written a long program containing many short comments. To disable a
             portion of the program temporarily (during testing, say), our first impulse is to
             “comment out” the offending lines with / * and * / . Unfortunately, this method
   <*^E>     won’t work if the lines contain old-style comments. C99 comments (those begin­
             ning with / / ) can be nested inside old-style comments, however— another advan­
               ge to usinos this kind ofcom m ent.
             ta&
3 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2    C F u n d a m e n ta ls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                     Ln any event, there’s a better way to disable portions of a program , as w e’ll see aZYXWV
             d is a b lin g c o d e >   M .4   latCl*.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        Q:     W h e r e d o e s th e f l o a t ty p e g e t its n a m e ? [p . 17]
                                        A:     f l o a t is short for “floating-point,” a technique for storing numbers in which the
                                               decimal point “floats.” A f l o a t value is usually stored in two parts: the fraction
                                               (or mantissa) and the exponent. The number 12.0 might be stored as 1.5 x 2 3 , for
                                               example, where 1.5 is the fraction and 3 is the exponent. Some program m ing lan­
                                               guages call this type r e a l instead of f l o a t .

                                        Q:     W h y d o fl o a ti n g -p o in t c o n s t a n ts n e e d to e n d w ith th e le tt e r f ? [p . 19]
                                        A:     For the fuU explanation, see Chapter 7. H ere’s the short answer: a constant that
                                               contains a decimal point but doesn’t end with f has type d o u b l e (short for “dou­
                                               ble precision”), d o u b l e values are stored more accurately than f l o a t values.
                                               Moreover, d o u b l e values can bc larger than f l o a t values, which is why we
                                               need to add the letter f when assigning to a f l o a t variable. W ithout the f , a
                                               warning may be generated about the possibility of a number being stored into a
                                               f l o a t variable that exceeds the capacity o fth e variable.

                                    *Q :       Is it r e a lly tr u e th a t t h e r e ’s n o lim it o n th e le n g th o f an id e n t if ie r ? [p . 2 6 ]
                                        A:     Yes and no. The C89 standard says that identifiers may be arbitrarily long. How­
                                               ever, com pilers are only required to rem em ber the first31 characters (63 characters
                                 <ffi>         in C99). Thus, if two names begin with the same 31 characters, a com piler might
                                               be unable to disting^^uish between them.
                                                    To make matters even more complicated, there are special rules for identifiers
           e x te m a iiin k a g e > /s .2     with external linkage; most function names fall into this category. Since these
                                               names must be made available to the linker, and since some older linkers can han­
                                               dle only short names, only the first six characters are significant in C89. Moreover,
                                               the case of letters may not matter. As a result. ABCDEFG and a b c d e f h might be
                                 <ffi>         treated as the same name. (In C99, the first 31 characters are significant, and the
                                               case of letters is taken into account.)
                                                    Most compilers and linkers are more generous than the standard, so these rules
                                               aren’t a problem in practice. Don’t worry about making identifiers too long—
                                               worry about making them too short.

                                        Q:     H o w m a n y s p a c e s s h o u ld I u se fo r in d e n ta tio n ? [p . 28 ]
                                        A:     T hat’s a tough question. Leave too little space, and the eye has trouble detecting
                                               indentation. Leave too much, and lines run off the screen (or page). Many C pro­
                                               grammers indent nested statements eight spaces (one tab stop), which is probably
                                               too much. Studies have shown that the optimum amount of indentation is three
                                               spaces, but many programmers feel uncomfortable with numbers that aren’t a
                                               power of two. Although 1 normally prefer to indent three or four spaces. I ’ll use
                                               two spaces in this book so that my programs will fit within the margins.
                                                                                                                                                3 3 aZYXWVUTSRQPON
                                                                                                                      E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIHG




                                E x e r c is e s

                                     I.    Create and run Kemighan and Ritchie’s famous “hello, world" program:
S e c t i o n 2 .1 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                # in c lu d e     < s td io .h >
                                i n t m a in (v o id )
                                {
                                    p rin tf(" h e llo ,        w o rld \n " );

                                Do you gct a warning message from the compiler? Ifso , what’s needed to make it go away?

S e c tio n 2 .2    ©     2.    C onsiderihefollow ingprogram :
                                # in c lu d e     < s td io .h >
                                i n t m a in (v o id )

                                      p r i n t f ( * 'P a r k i n s o n * s L a w :\n W o rk e x p a n d s s o a s   to    ");
                                      p r i n t f ( " f i l l th e tim e \n " ) ;
                                      p r i n t f ( " a v a i l a b l e f o r i t s c o m p le tio n .\n " ) ;
                                      r e t u r n 0;


                                (a) Identify the directives and statements in this program.
                                (b) What output does the program produce?

S e c tio n 2 .4    ©     3.    Condense the d w e i g h t . c program by (!) replacing the assignments to h e i g h t ,
                                l e n g t h , and w i d t h with initializers and (2) removing the w e i g h t variable, instead cal­
                                culating (v o lu m e 4 -1 6 5 ) / 1 6 6 within the l a s t p r i n t f .

                    ©     4.    Write a program that declares several i n t and f l o a t variables— without initializing
                                them— and then prints their values. Is there any pattern to the values? (Usually there isn’t.)

S e c tio n 2 .7    ©     5.    Which of the following are not legal C identifiers?
                                (a)    1 0 0 _ b o ttle s
                                (b)    _ 1 0 0 _ b o ttle s
                                (c)    o n e __ h u n d r e d __ b o t t l e s
                                (d)    b o ttle s _ b y _ th e _ h u n d re d _

                          6.    Why is it not a good idea for an identifier to contain more than one adjacent underscore (as
                                in c u r r e n t  b a l a n c e , for example)?

                          7.    Which of the following are keywords in C?
                                (a)    fo r
                                (b)    If
                                (c)    m a in
                                (d)    p rin tf
                                (e)    w h ile


                                © A nsw er available on the Web at cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                   knking.coinfl>ooks/c2.
3 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2     C F u n d a m e n ta ls


                            ©      8.    How many tokens are there in the following statem ent? kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
S e c tio n 2.8 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   answer=(3*q-p*p)/3;

                             9.    Insert spaces between the tokens in Exercise 8 to make the statement easier to read.

                            10.    In the d w e i g h t . c program (Section 2.4). which spaces are essential? aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   P r o g r a m m in g P r o je c t s

                             1.    Write a program that uses p r i n t f to display the following picture on the screen:
                                                         *
                                                     ★
                                                 *
                                   *         *
                                       * *
                                        *

                             2.    W rite a program that computes the volume o f a sphere with a 10-meter radius, using the for­
                                   mula v = 4/3jr/^. Write the fraction 4/3 as 4 . 0 f / 3 . 0 f . (Try writing it as 4 / 3 . W hat hap­
                                           H int: C doesn't have an exponentiation operaton so you'll need to multiply r by itself
                                   pens?) cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   twice to compute A

                             3.    Modify the program of Programming Project 2 so that it prompts the user to enter the radius
                                   o f the sphere.

                       ©     4.    Write a program that asks the user to enter a dollars-and-cents amount, then displays the
                                   amount with 5% tax added:
                                   Enter an amount: 100.00
                                   With tax added: $105.00

                             5.    W rite a program that asks the user to enter a value for .v and then displays the value o f the
                                   following polynomial:
                                   3.v5 + 2x 4 - 5.v3 - x 2 + 7 r - 6
                                   H int: C doesn’t have an exponentiation operator, so you’ll need to multiply .v by itself
                                   repeatedly in order lo compute the powers o f i . (For exam ple, x * x * x is x cubed.)

                             6.    M odify the program of Program ming Project 5 so that the polynomial is evaluated using the
                                   following formula:
                                   ((((3A + 2).v-5)A *-I).r + 7 ).v -6
                                   Note that the modified program perform s fewer multiplications. This technique for evaluat­
                                   ing polynomials is known as H o r n e r ’s R u le .

                             7.    W rite a program that asks the user to enter a U.S. dollar amount and then shows how to pay
                                   that amount using the smallest num ber ofS 20, $10, $5, and $1 bills:
                                   Enter a dollar amount: 93
                                   $20 bills:                4
                                   $10 bills:                1
                                    $5 bills:                0
                                    $1 bills:                3
                                                                                                          3 5 cbaZYXWVUTSRQPONMLK
                                                               P r o g ra m m in g P ro je c ts hgfedcbaZYXWVUTSRQPONMLKJIHGFE


            Divide the amount by 20 to determine the number of$ 2 0 bills needed, and then reduce
     Hint: onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
     the amount by the total value of the $20 bills. Repeat for the other bill sizes. Be sure to use
     integer values throughout, not floating-point numbers.

8.   W rite a program that calculates the remaining balance on a loan after the first, second, and
     third monthly payments:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
     Enter amount of loan: 20000.00
     Enter interest rate: 6.0
     Enter monthly payment: 386.66
     Balance remaining after first payment: $19713.34
     Balance remaining after second payment: $19425.25
     Balance remaining after third payment: $19135.71
     Display each balance with two digits after the decimal point. Hint: Each month, the balance
     is decreased by the amount of the payment, but increased by lhc balance times the monthly
     interest rate. To find the monthly interest rate, convert the interest rate entered by the user to
     a percentage and divide it by 12.
3      F o r m a t te d ln p u t /O u t p u t                                                                      ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                       In s e e k in g th e u n a tta in a b le , s im p lic it y o n ly g e t s in th e w a y onmlkjihgfedcbaZYXWVU




      s c a n f and p r i n t f , which support form atted reading and writing, are two of the
      most frequently used functions in C. As this chapter shows, both are powerful but
      tricky to use properly. Section 3.1 describes p r i n t f , and Section 3.2 covers
      s c a n f . Neither section gives com plete details, which will have to wait until Chap­
      ter 22.




3.1   T h e p r in tfF u n c tio n

       The p r i n t f function is designed to display the contents o f a siring, known as the cbaZYXWVUTSRQPONML
      fo r m a t strin g, with values possibly inserted at specified points in the string. When
       it’s called, p r i n t f must be supplied with the format string, followed by any val­
       ues that are to be inserted into the string during printing:hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      p r in tf( s m n g ,   e x p r^   e x p r - i,     ...);


       The values displayed can be constants, variables, or more com plicated expressions.
       There's no limit on the number o f values that can be printed by a single call of
       p rin tf.
             The format string may contain both ordinary characters and co n version sp e ci­
      fic a tio n s , which begin with the % character. A conversion specification is a place­
       holder representing a value to be filled in during printing. The inform ation that
       follows the % character specifies how thc value is converted from its intemal form
       (binary) to printed form (characters)— that’s where the term ' ‘conversion specifica­
       tion” comes from. For exam ple. the conversion specification %d specifies that
       p r i n t f is to convert an i n t value from binary to a string of decimal digits, while
       %f does the same for a f l o a t value.



                                                                                                                                         37
38 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 3    F o rm a tte d ln p u t/O u tp u t


                                        Ordinary characters in a format string are printed exactly as they appear in the
                                   string; conversion specifications are replaced by the values to be printed. Consider
                                   the following example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   int i , j ;
                                   float x, y;

                                   i = 10;
                                   j = 20;
                                   x = 43.2892f;
                                   y = 5527.0f;

                                   printf("i = %d, j = %d, x = %f, y = %f\n", i, j z x, y);

                                   This call of p r i n t f produces the following output:

                                   i = 10, j = 20, x = 43.289200, y = 5527.000000

                                   The ordinary characters in the format string are simply copied to the output line.
                                   The four conversion specifications are replaced by the values of the variables i , j ,
                                   x . and y, in that order.


                                   C com pilers aren’t required to check that the num ber o f conversion specifications

                        A          in a form at string matches the num ber of output items. The following call of
                                   p r i n t f has more conversion specifications than values to be printed:
                                   printf("%d %d\n", i);                   /*** WRONG ***/

                                   p r i n t f will print the value of i correctly, then print a second (m eaningless) inte­
                                   ger value. A call with too few conversion specifications has sim ilar problem s:
                                   printf("%d\n", i, j);                   /*** WRONG ***/

                                   ln this case, p r i n t f prints the value of i but doesn’t show the value of j .
                                        Furtherm ore, compilers aren’t required to check that a conversion specifica­
                                   tion is appropriate for the type of item being printed. If the program m er uses an
                                   incorrect specification, the program will simply produce m eaningless output. Con­
                                   sider the following call o f p r i n t f , in which the i n t variable i and the f l o a t
                                   variable x are in the wrong^* order:
                                   printf("%f %d\n", i, x);                    /*** WRONG ***/

                                   Since p r i n t f must obey the form at string, it will dutifully display a f l o a t
                                   value, followed by an i n t value. Unfortunately, both will be meaningless.dcbaZYXWVUTSRQPO




                                   C o n v e r s io n S p e c ific a tio n s

                                   Conversion specifications give the program m er a great deal of control over the
                                   appearance ofoutput. On the other hand, they can be com plicated and hard to read.
                                   In fact, describing conversion specifications in com plete detail is too arduous a
                                                             3.1    The p r i n t f Function hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                       3 9 onmlkjihgfedcbaZYXWVU


      task to tackle this early in the book. Instead, w e’llju st take a brief look at some of
      their more important capabilities.
             In Chapter 2, we saw that a conversion specification can include formatting
      information. In particular, we used %. I f to display a f l o a t value with one digit
      after the decimal point. More generally, a conversion specification can have the
      form % m .p X or % -/n.pX , where m and p are integer constants and X is a letter.
      Both m and p are optional; if p is omitted, the period that separates m and p is also
      dropped. In the conversion specification % 10. 2 f . m is 10, p is 2, and X is f . In
      the specification % 10f. ni is 10 and p (along with the period) is missing, but in the
      specification %. 2 f , p is 2 and in is missing.
             The m in iin u m fie ld width, ni. specifies the minimum number ofcharacters to
      print. If the value to be printed requires fewer than m characters, the value is right-
      justified within the field. (In other words, extra spaces precede the value.) For
      example, the specification %4d would display the number 123 as « 1 2 3 . (In this
      chapter, I’ll use • to represent the space character.) If the value to be printed
      requires more than in characters, the field width automatically expands to the nec­
      essary size. Thus, the specification %4d would display the number 12345 as
       1 2 3 4 5 — no digits are lost. Putting a minus sign in front of m causes leftjustifica-
      tion; the specification % -4d would display 123 as 1 2 3 * .
             The meaning of the p recisio n , p, isnT as easily described, since it depends on
      the choice ofX , the conversion specifier, X indicates which conversion should be
      applied to the value before it’s printed. The most common conversion specifiers for
      numbers are:aZYXWVUTSRQPONMLKJIHGFEDCBA
Q&A     ■             d — Displays an integer in decimal (base 10) form, p indicates the minimum
                      number of digits to display (extra zeros are added to the beginning of the num­
                      ber if necessary); if/? is omitted, it is assumed to have the value 1. (In other
                      words, %d is the same as %. Id .)
            ■         e — Displays a floating-point number in exponential format (scientific nota­
                      tion). p indicates how many digits should appear after the decimal point (the
                      default is 6). I f ^ is 0, the decimal point is not displayed.
                    ■ f — Displays a floating-point number in “fixed decim al” format, without an
                        exponent, p has the same meaning as for the e specifier.
                ■     g — Displays a floating-point number in either exponential format or fixed
                      decimal format, depending on the num ber’s size, p indicates the maximum
                      number of significant digits (not digits after the decimal point) to be dis­
                      played. Unlike the f conversion, the g conversion w on’t show trailing zeros.
                      Furthermore, if the value to be printed has no digits after the decimal point, g
                      doesn’t display the decimal point.
      The g specifier is especially useful for displaying numbers whose size can’t be
      predicted when the program is written or that tend to vary widely in size. When
      used to print a moderately large or moderately small number, the g specifier uses
      fixed decimal format. But when used to print a very large or very small number,
      the g specifier switches to exponential format so that the number will require fewer
      characters.
4 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 3    F o rm a tt e d ln p u t/O u tp u t aZYXWVUTSRQPONMLKJIHGFEDCBA


                                                        1
         s p e c i f i e r s fo r I n t e g e r s > 7 . BA        There are many other specifiers besides %d. %e. %f. and %g. Tll gradually
             s p e c ifie r s fo r flo a ts >       7.2      introduce many of them in subsequent chapters. For lhe full list, and for a complete
     s p e c ifie r s fo r c h a r a c t e r s > 7 . 3       explanation of the other capabilities of conversion specifications, consult Section
         s p e c i f i e r s fo r s t r in g s >   13.3      22.3.


                                           U s in g p r i n t f to F o r m a t N u m b e r s
                       P R O G R A M onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                             The following program illustrates the use o f p r i n t f to print integers and float­
                                                             ing-point numbers in various formats.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    tprintf.cdcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  /* Prints int and float values in various formats */

                                                             #include <stdio.h>

                                                             int main(void)

                                                                         int i ;
                                                                         float X;

                                                                         i = 40;
                                                                         x = 839.21f;

                                                                         printf(" %d|%5d %-5d|%5.3d|\n", i, i, i, i);
                                                                         printf(” %10.3f %10.3e|%-10g|\n", x, x, x);

                                                                         return 0;
                                                             }

                                                                  The | characters in the p r i n t f format strings are there merely to help show
                                                             how much space each number occupies when printed; unlike % or \ , the | charac­
                                                             ter has no special significance to p r i n t f . The output of this program is:

                                                              40|             40|40   | 040|
                                                                           839.210| 8.392e+02|839.21

                                                                          Let’s take a closer look at the conversion specifications used in this program:

                                                                     ■ %d —      Displays i in decimal form, using a minimum amount of space.
                                                                 ■ % 5d — Displays i in decimal form, using a minimum of five characters.
                                                                    Since i requires only two characters, three spaces were added.
                                                                     ■ % - 5d — Displays i in decimal form, using a minimum of five characters;
                                                                        since the value of i doesn’t require five characters, the spaces are added after­
                                                                        ward (that is, i is left-justified in a field of length five).
                                                                     ■    % 5. 3 d — Displays i in decimal form, using a minimum of five characters
                                                                          overall and a minimum of three digits. Since i is only two digits long, an extra
                                                                          zero was added to guarantee three digits. The resulting number is only three
                                                                          characters long, so two spaces were added, for a total of five characters ( i is
                                                                          right-justified).
                                                                 ■        % 1 0 .3 f — Displays x in fixed decimal form, using 10 characters overall,
                                                                     3.1    T he p r i n t f Function onmlkjihgfedcbaZYXWVUTSRQPONMLKJI
                                                                                                                  41

                             with three digits after the decim al point. Sincc x requires only seven charac­
                             ters (three before the decimal point, three after the decimal point, and one for
                             the decimal point itself), three spaces precede x.
                           ■ % 1 0. 3 e — Displays x in exponential form, using 10 characters overaU, with
                              three digits after the decim al point, x requires nine characters altogether
                              (including the exponent), so one space precedes x.
                       ■     % -1 0 g — Displays x in either fixed decimal form or exponential form, using
                             10 characters overall, fn this case, p r i n t f chose to display x in fixed deci­
                             mal form. The presence of the minus sign forces left justification, so x is fol­
                             lowed by four spaces.


                     E scap e S eq uen ces

                            The \ n code that we often use in format strings is called an escape se q u e n c e .
                            Escape sequences enable strings lo contain characters that would otherw ise cause
                            problem s for the compiler, including nonprinting (control) characters and charac­
                            ters that have a special meaning to the com piler (such as "). W e’ll provide a com ­
                            plete list ofescape sequences later; for now, here’s a sample:
escape sequences> 7 .3 dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                             Alert (bell)      \a
                             Backspace         \b
                             New line          \n
                             H orizontaltab    \t

                     When they appear in p r i n t f format strings, these escape sequences represent
                     actions to perform upon printing. Printing \ a causes an audible beep on most
                     machines. Printing \ b moves the cursor back one position. Printing \ n advances
                     the cursor to the be ^g**inning^>* of thiwe' next line. Printing \ t moves the cursor to the
            Q&A      next tab stop.
                           A string may contain any num ber ofescape sequences. Consider the following
                     p r i n t f exam ple, in which the form at string contains six escape sequences:kjihgfedcbaZYXWVUTSRQPONMLK

                     printf ("Item\tUnit\tPurchase\n\tPrice\tDate\n") ;

                     Executing this statement prints a tw o-line heading:

                     Item          Unit       Purchase
                                   Price      Date

                         Another common escape sequence is \ ” . which represents the ” character.
                     Since the ” character marks the beginning and end of a string, it can’t appear
                     within a string without the use of this escape sequence. H ere’s an example:

                     printf(”\ "Hello!\"");

                     This statement produces the following output:

                     "Hello!"
            C h a p te r 3
4 2 ZYXWVUTSRQPONMLKJIHGFEDCBAF o rm a tte d ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          Incidentally, you can’t just put a single \ character in a string; the com piler
                                     will assume that it’s the beginning of an escape sequence. To print a single \ char­
                                     acter, put two \ characters in the string:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     printf("\\");                 /* prints one \ character */aZYXWVUTSRQPONMLKJIHGFEDCBA




                          3 .2       T h e s c a n f F u n c t io n

                                     Just as p r i n t f prints output in a specified format, s c a n f reads input according
                                     lo a particular format. A s c a n f format string, like a p r i n t f format string, may
                                     contain both ordinary characters and conversion specifications. The conversions
                                     allowed with s c a n f are essentially the same as those used with p r i n t f .
                                          In many cases, a s c a n f format string will contain only conversion specifica­
                                     tions, as in the following example:

                                     int i , j ;
                                     float x, y;

                                     scanf("%d%d%f%f",                 &i, &j, &x, &y);

                                     Suppose that the user enters the following input line:

                                     1 -20 .3 -4.0e3

                                     s c a n f will read the line, converting its characters to the numbers they represent,
                                     and then assign 1, -2 0 , 0.3, and ^4000.0 to i , j , x , and y, respectively. “Tightly
                                     packed” format strings like "%<d%d%f%f" are common in s c a n f calls, p r i n t f
                                     form at strings are less likely to have adjacent conversion specifications.
                                           s c a n f , like p r i n t f , contains several traps for the unwary. When using
                                     s c a n f , the programmer must check that the number ofconversion specifications
                                     matches the number of input variables and that each conversion is appropriate for
                                     the corresponding variable— as with p r i n t f , the compiler isn’t required to check
                                     for a possible mismatch. Another trap involves the & symbol, which normally pre­
                                     cedes each variable in a s c a n f call. The & is usually (but not always) required,
                                     and it’s the program m er’s responsibility to remember to use it.


                                     Forgetting to put the & symbol in front of a variable in a call of s c a n f will have
                                     unpredictable— and possibly disastrous— results. A program crash is a common
                                     outcome. At the very least, the value that is read from the input w on’t be stored in
                                     the variable; instead, the variable will retain its old value (which may be meaning­
                                     less if the variable wasn’t given an initial value). Omitting the & is an extremely
                                     common error— be careful! Some compilers can spot this error and produce a
                                                                 “fo rm a t argum ent is not a pointer." (The term p o in ter is
                                     warning message such as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     defined in Chapter 11; the & symbol is used to create a pointer to a variable.) lfyou
                                     get a warning, check for a missing &.
                                                                                                           3 .2                                              43
                                                                                                                   T h e s c a n f F u n c tio n onmlkjihgfedcbaZYXWVUTSRQPONMLK


                                                            Calling s c a n f is a powerful but unforgiving way to read data. Many profes­
                                                       sional C programmers avoid s c a n f , instead reading all data in characterform and
                                                       converting it to numeric form later. W e’ll use s c a n f quite a bit, especially in the
                                                       early chapters of this book, because it provides a simple way to read numbers. Be
                                                       aware, however, that many of our programs won’t behave properly if the user
                                                       enters unexpected input. As w e’ll see later, it’s possible to have a program testhgfedcbaZYXWVUTSR
d e t e c i i n g e r r o r s in s c a n f > 2 2 . 3   whether s c a n f successfully read the requested data (and attempt to recover if it
                                                       didn’t). Such tests are impractical for the programs in this book— they would add
                                                       too many statements and obscure the point of the examples.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                       H ow s c a n f W orks
                                                       s c a n f can actually do much more than I've indicated so far. It is essentially a
                                                       “pattern-m atching’’ function that tries to match up groups of input characters with
                                                       conversion specifications.
                                                               Like the p r i n t f function, s c a n f is controlled by the format string. When it
                                                       is called, s c a n f begins processing the information in the string, starting at the
                                                       left. For each conversion specification in the format string, s c a n f tries to locate
                                                       an item o fth e appropriate type in the input data, skipping blank space if necessary,
                                                       s c a n f then reads the item, stopping when it encounters a character that can’t pos­
                                                       sibly belong to the item. If the item was read successfully, s c a n f continues pro­
                                                       cessing the rest of the format string. If any item is not read successfully, s c a n f
                                                       returns immediately without looking at the rest of the format string (or the remain­
                                                       ing input data).
                                                               As it searches for the beginning of a number, s c a n f ignores RQPONMLKJIHGFEDCBA
                                                                                                                                       w h ite - s p a c e
                                                       c h a r a c t e r s (the space, horizontal and vertical tab, form-feed, and new-line charac­
                                                       ters). As a result, numbers can be put on a single line or spread out over several
                                                       lines. Consider the following call of s c a n f :
                                                       scanf("% d% d% f% f", & i, & j, &x, &y);
                                                       Suppose that the user enters three lines of input:
                                                          1
                                                       - 20        .3
                                                              - 4. 0e3

                                                       s c a n f sees one continuous stream ofcharacters:
                                                       • • i a- 20<* * . 3 a * <<- 4 . 0e3O

                                                       (I’m using • to represent the space character and ° to represent the new-line char­
                                                       acter.) Since it skips over white-space characters as it looks for the beginning of
                                                       each number, s c a n f will be able to read the numbers successfully. In the follow­
                                                       ing diagram, an s under a character indicates that it was skipped, and an r indi­
                                                       cates it was read as part of an input item:
                                                       • • 1 O- 20* * * . 3D* e>- 4. 0e3O
                                                       ssr sr r r sssr r s sssr r r r r r
4 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 3   F o r m a t t e d ln p u t / O u t p u t


                                     s c a n f “peeks” at the final new-line character without actually reading it. This
                                     new-line will be the first character read by the next call of s c a n f .
                                            W hat rules does s c a n f follow to recognize an integer or a floating-point
                                     num ber? W hen asked to read an integer, s c a n f first searches for a digit, a plus
                                     si<
                                       sM               s^ign; it then reads d^zigits until it reaches a nond^^igit. W hen asked to
                                        *n , or a minus C
                                     read a floating-point number, s c a n f looks for

                                                    a plus or minus sign (optional), followed by
                                                    a series of digits (possibly containing a decimal point), followed by
                                                    an exponent (optional). An exponent consists o f the letter e (or E). an optional
                                                        sigfc^n, and one or m^o^ re digits,

                                   The %e,7 %f,7 and %^qJ conversions are in&terchangeable when used with s c a n f : all
                                   three follow the same rules for recognizing a floating-point number.
                                            When s c a n f encounters a character that can ’t be part o f the current item, the
                                   character is “put back” to be read again during the scanning o f th e next input item
                          Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   or during the next call o f s c a n f . Consider the following (adm ittedly pathological)
                                   arrang&em ent of our four numbers:

                                      l - 20. 3- 4. 0e3O

                                      Let’s use the same call of s c a n f as before:

                                      scanf("% d% d% f% f",              & i,   & j,   &x, & y);

                                      H ere’s how s c a n f would process the new input:

                                        ■           Conversion specification: %d. The first nonblank input character is 1; since
                                                    integers can begin with 1, s c a n f then reads the next character, - . Recogniz­
                                                    ing that - can’t appear inside an integer, s c a n f stores 1 into i and puts the -
                                                    character back.
                                            ■ Conve rsion specification: %d. s c a n f then reads thecharacters - , 2. 0, and .
                                               (period). Since an integer can’t contain a decimal point, s c a n f stores -2 0
                                               into j and puts the . character back.
                                            ■       Conversion specification: %f. s c a n f reads the characters ., 3, and - . Since a
                                                    floating-point num ber can’t contain a minus sign after a digit, s c a n f stores
                                                    0.3 into x and puts the - character back.
                                                ■   Conversion specification: %f. Lastly, s c a n f reads the characters - . 4, ., 0,
                                                    e, 3, and o (new-line). Since a floating-point num ber can ’t contain a new-line
                                                                                          o
                                                    character, s c a n f stores ^ L 0 x 10* into y and puts the new-line character
                                                    back.

                                      In this example, s c a n f was able to match every conversion specification in the
                                      form at string with an input item. Since the new-line character w asn't read, it will
                                      be left for the next call of s c a n f .
                                                           3 .2                                            4 5 dcbaZYXWVUTSRQPON
                                                                   T h e s c a n f F u n c tio n hgfedcbaZYXWVUTSRQPONMLKJIHGFED


O r d in a r y C h a r a c te r s in F o r m a t S t r in g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

The concept of pattern-matching can be taken one step further by writing format
strings that contain ordinary characters in addition to conversion specifications.
The action that s c a n f takes when it processes an ordinary character in a format
string depends on whether or not it’s a white-space character.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
  ■ W hite-space characters. When it encounters one or more consecutive white­
    space characters in a format string, s c a n f repeatedly reads white-space char­
    acters from the input until it reaches a non-white-space character (which is
    “put back”). The number of white-space characters in the format string is
    irrelevant; one white-space character in the format string will match any num­
    ber of white-space characters in the input. (Incidentally, putting a white-space
    character in a format string doesn’t force the input to contain white-space
    characters. A white-space character in a format string matches any number of
    white-space characters in the input, including none.)
  ■ O ther characters. When it encounters a non-white-space character in a format
    string, s c a n f compares it with the next input character. If the two characters
    match, s c a n f discards the input character and continues processing the for­
    mat string. If the characters don’t match, s c a n f puts the offending character
    back into the input, then aborts without further processing the format string or
    reading characters from the input.
      For example, suppose that the format string is ” % d/% d". If the input is kjihgfedcbaZYXWVUTSRQPONMLKJ

•5/*96

s c a n f skips the first space while looking for an integer, matches %d with 5,
matches / with / , skips a space while looking for another integer, and matches %d
with 96. On the other hand, if the input is

*5>/*96

s c a n f skips one space, matches %d with 5, then attempts to match the / in the
format string with a space in the input. There’s no match, so s c a n f puts the space
back; the < /* 9 6 characters remain to be read by the next call of s c a n f . To allow
spaces after the first number, we should use the format string " %d / %d” instead.


C o n f u s i n g p r i n t f w ith s c a n f

Although calls of s c a n f and p r i n t f may appear similar, there are significant
differences between the two functions; ignoring these differences can be hazardous
to the health of your program.
     One common mistake is to put & in front ofvariables in a call o f p r i n t f :

printf("%d %d\n'\ &i, &j);                          /*** WRONG ***/
            C h a p te r 3
4 6 ZYXWVUTSRQPONMLKJIHGFEDCBA F o rm a tte d ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     Fortunately, this mistake is fairly easy to spot: p r i n t f will display a couple of
                                     odd-looking numbers instead of the values of i and j .
                                           Since s c a n f normally skips white-space characters when looking for data
                                     items,' there's often no need for a formalK~Jsiring to include characters other lhan
                                     conversion specifications. Incorrectly assuming lhal s c a n f format strings should
                                     resemble p r i n t f format strings— another common error— may cause s c a n f to
                                     behave in unexpected ways. Let's see what happens when the following call of
                                     s c a n f is executed:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     scanf("%d, %d", &i, &j);

                                     s c a n f will first look for an integer in the input, which it stores in the variable i .
                                     s c a n f will then try to match a comma with the next input character. Ifth e next
                                     input character is a space, not a comma, s c a n f will terminate without reading a
                                     value for j .


                                     Although p r i n t f format strings often end with \ n , putting a new-line character

                          A          al the end of a s c a n f format string is usually a bad idea. To s c a n f , a new-line
                                     character in a format siring is equivalent to a space; both cause s c a n f to advance
                                     to the next non-white-space character. For example, if the form at string is
                                     " % d \n " , s c a n f will skip white space, read an integer, then skip to the next non­
                                     white-space character. A format string like this can cause an interactive program to
                                     “hangc ” until the user enters a nonblank character,




                                 A d d in g F r a c ti o n s
               P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     To illustrate s c a n f ’s ability to match patterns, consider the problem of reading a
                                                                                                                    m tm era-
                                     fraction entered by the user. Fractions are customarily written in the form cbaZYXWVUTSRQPONML
                                     iorldenom inator. Instead of having the user enter the num erator and denominator
                                     o f a fraction as separate integers, s c a n f makes it possible to read Lhe entire frac­
                                     tion. The following program, which adds two fractions, illustrates this technique.BA

                   addfrac.c         /* Adds two fractions */

                                     #include <stdio.h>

                                     int main(void)

                                         int numl, denoml, num2, denom2, result_num, result_denom;

                                         printf("Enter first fraction: ");
                                         scanf(**%d/%d", &numl, &denoml);

                                         printf("Enter second fraction: ");
                                         scanf("%d/%d", &num2, &denom2);

                                         result num = numl * denom2 + num2 * denoml;
                                                                                                                                             Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                                                            4 7 kjihgfedcbaZYXWVUTSRQ


                                                result_denom = denoml * denom2;
                                                printf(”The sum is %d/%d\n", result_num, result_denom);

                                                return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            }

                                                  A session with this program might have the following appearance:

                                            Enter first fraction: 5/6
                                            Enter second fraction: 3/4
                                            The sum is 38/24

                                            Note that the resulting fraction isn’t reduced to lowest terms.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                            Q & A

                                *Q :        I ’v e s e c n th e % i c o n v e r sio n u s e d to r e a d a n d w r ite in te g e r s . W h a t ’s th e d if f e r ­
                                            e n c e b e tw e e n % i a n d %d? [p. 3 9 ]
                                    A:      ln a p r i n t f format string, there’s no difference between the two. In a s c a n f for­
                                            mat string, however, %d can only match an integer written in decimal (base 10) hgfedcbaZYXWVUTSRQPO
           o c ta in u m b e r s > 7 j      form. while %i can match an integer expressed in octal (base 8). decimal, or hexa-
h e x a d e c im a in u m b e r s > 7 . ;   decimal (base 16). Ifa n input number has a 0 prefix (as in 0 5 6 ), %i treats it as an
                                            octal number; if it has a 0x or 0X prefix (as in 0 x 5 6 ), %i treats it as a hex number.
                                            Using %i instead of %d to read a number can have surprising results if the user
                                            should accidentally put 0 at thc beginning of thc number. Because of this trap, I
                                            recommend sticking with %d.

                                   Q:       I f p r i n t f tr e a ts % a s th e b e g in n in g o f a c o n v e r s io n s p e c ifi c a tio n , h o w c a n I
                                            p r in t th e % c h a r a c te r ?
                                    A:      I f p r i n t f encounters two consecutive % characters in a format siring, it prints a
                                            single % character. For example, the statement

                                            printf("Net profit: %d%%\n", profit);

                                            might print

                                            Net profit: 10%

                                   Q:       T h e \ t e s c a p e is s u p p o s e d to c a u s e p r i n t f to a d v a n c e to th e n e x t ta b s to p .
                                            H o w d o I k n o w h o w fa r a p a r t ta b s to p s a r e ? [p . 4 1 ]
                                    A:      You don't. The effect of printing \ t isn’t defined in C; il depends on what your
                                            operating system does when asked to prim a tab character. Tab stops are typically
                                            eight characters apart, but C makes no guarantee.

                                   Q:       W h a t d o e s s c a n f d o if i t ’s a s k e d to r e a d a n u m b e r b u t th e u s e r e n te r s n o n n u ­
                                            m e r ic in p u t?
            C h a p te r 3
4 8 ZYXWVUTSRQPONMLKJIHGFEDCBAF o r m a tte d ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              A:       Let’s look at the following example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                       printf("Enter a number:                     ");
                                                       scanf("%d”, &i);

                                                       Suppose that the user enters a valid number, followed by nonnumeric characters:

                                                       Enter a number: 23foo

                                                       In this case, s c a n f reads the 2 and the 3. storing*fc^ 23 in i . The remainingG7 charac-
                                                       ters ( f o o ) are left to be read by the next call of s c a n f (or some other input func­
                                                       tion). On the other hand, suppose that the input is invalid from the beginning:

                                                       Enter a number: foo

                                                       .In this case, the value of i is undefined and f o o is left for the next s c a n f .aZYXWVUTSRQPONM
                                                             What can we do about this sad state of affairs? Later, we’ll see how to test
                                            > 2 2 .3
  d e t e c t in g e r r o r s in s c a n f BA         whether a call of s c a n f has succeeded. If the call fails, we can have the program
                                                       either terminate or try to recover, perhaps by discarding the offending input and
                                                       asking the user to try again. (Ways to discard bad input are discussed in the Q&A
                                                       section at the end of Chapter 22.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              Q:       I d o n ’t u n d e r sta n d h o w s c a n f c a n “ p u t b a c k ” c h a r a c te r s a n d r e a d th e m
                                                       a g a in later, [p. 4 4 ]
                                              A:       As it turns out, programs don’t read user input as it is typed. Instead, input is stored
                                                       in a hidden buffer, to which s c a n f has access. It’s easy for s c a n f to put charac­
                                                       ters back into the buffer for subsequent reading. Chapter22 discusses input buffer­
                                                       ing^>' in more detail.

                                              Q:       W b a t d o e s s c a n f d o if th e u s e r p u ts p u n c tu a tio n m a r k s (c o m m a s , fo r e x a m ­
                                                       p le ) b e tw e e n n u m b e r s ?
                                               A:      Let’s look at a simple example. Suppose that we try to read a pair of integers using
                                                       sc a n f:

                                                       printf("Enter two numbers:                        ");
                                                       scanf("%d%d 11, &i, &j);

                                                       Lf the user enters

                                                       4,28

                                                       s c a n f will read the 4 and store it in i . As it searches for the betg*inning<^ of the sec-
                                                       ond number, s c a n f encounters the comma. Since numbers can't begin with a
                                                       comma, s c a n f returns immediately. The comma and the second number are left
                                                       for the next call of s c a n f .
                                                             O fcourse, we can easily solve the problem by adding a comma to the format
                                                       string if we're sure that the numbers will cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                      alw ays be separated by a comma:

                                                       printf("Enter two numbers, separated by a comma:                                          ");
                                                       scanf("%d,%d", &i, &j);
                                                                                                                                         49 hgfedcbaZYXWVUTSRQ
                                                                                                            E x e r c is e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJI




                             E x e rc is e s

S e c tio n 3.1              What output do the following calls o f p r i n t f produce? kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                             (a)printf("%6d,%4d", 86, 1040);
                             (b) printf("%12.5e", 30.253);
                             (c) printf("%.4f", 83.162);
                             (d) printf("%-6.2g", .0000009979);

                   ©    2.   Write calls of p r i n t f that display a f l o a t variable x in the following forinats.
                             (a) Exponential notation; left-justified in a Held o fsize 8: one digit after the decimal point.
                             (b) Exponential notation; right-justified in a field of size 10; six digits after Lhe decimal
                                 point.
                             (c) Fixed decimal notation; left-justified in a field of.size 8; three digits after the decimal
                                 point.
                             (d) Fixed decimal notation; right-justified in a field of size 6; no digits after the decimal
                                 point.

S e c tio n 3 .2        3.   For each of the following pairs of s c a n f format strings, indicate whether or not the two
                             strings arc equivalent. If lhey ?re not. show how they can be distinguished.
                             (a) "%d"          versus ” %d"
                             (b) "% d-% d-% d" versus "%d -% d -% d"
                             (c) ” %f"         versus "%f "
                             (d) " % f,% f"          versus ” % f,    %f"

                       *4.   Suppose that we call s c a n f as follows:
                             sc a n f("% d % f% d ",    & i,   &x,    & j);
                             If the user enters
                             1 0 .3   5 6
                             what will be the values of i . x. and j after the call? (Assume that i and j are i n t variables
                             and x is a f l o a t variable.)

                   © *5.     Suppose that we call s c a n f as follows:
                             sc a n f("% f% d % f",     &x,    & i,   & y );
                             If the user enters
                             1 2 .3   4 5 .6   789
                             what will be the values of x, i . and y after the call? (Assume that x and y are f l o a t vari­
                             ables and i is an i n t variable.)

                        6.   Show how to modify the a d d f r a c . c program ofSection 3.2 so that the user is allowed to
                             enter fractions that contain spaces before and after each / character.

                             *Starred exercises are tricky— the correct answer is usually not the obvious one. Read the question
                             thoroughly, review the relevant section ifneccssary, and be careful!
50 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 3   F o rm a tte d ln p u t/O u tp u t aZYXWVUTSRQPONMLKJIHGFEDCBA




                                  P r o g r a m m in g P r o je c t s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      ©      I.                                                                        m m /d d /y y y y and then dis­
                                  Write a program that accepts a date from the user in the form cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  plays it in the form yyyymmdd: kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  Enter a date (mm/dd/yyyy): 2/17/2011
                                  You entered the date 20110217

                            2.    Write a program that formats product information entered by the user. A session with the
                                  program should look like this:
                                  Enter item number: 583
                                  Enter unit price: 13.5
                                  Enter purchase date (mm/dd/yyyy): 10/24/2010
                                  Item                       Unit                       Purchase
                                                              Price                     Date
                                  583                        $ 13.50                    10/24/2010
                                  The item number and date should be leftjustified; the unit price should be rightjustified.
                                  Allow dollar amounts up to S9999.99. Hint: Use tabs to line up the columns.

                      ©     3.    Books are identified by an International Standard Book Number (lSBN). ISBNs assigned
                                  after January I, 2007 contain 13 digits, arranged in five groups, such as 978-0-393-97950-3.
                                  (Older ISBNs use 10 digits.) The first group (the GS1 prefix) is currently either 978 or 979.
                                  The group identifier specifies the language or country of origin (for example. 0 and 1 are
                                  used in English-speaking countries). The publisher code identifies the publisher (393 is the
                                  code for W. W. Norton). The item num ber is assigned by the publisher to identify a specific
                                  book (97950 is the code for this book). An ISBN ends with a check digit that\s used to verify
                                  the accuracy of the preceding digits. Write a program that breaks down an ISBN entered by
                                  the user:
                                  Enter ISBN: 978-0-393-97950-3
                                  GS1 prefix: 978
                                  Group identifier: 0
                                  Publisher code: 393
                                  Item number: 97950
                                  Check digit: 3
                                  Note: The number ofdigits in each group may vary, you can’t assume that groups have the
                                  lengths shown in this example. Test your program with actual lSBN values (usually found
                                  on the back cover of a book and on the copyright page).

                            4.    Write a program that prompts the user to enter a telephone number in the form (xxx) xxx-
                                  xxxx and then displays the number in the form xxx.xxx.xxx:
                                  Enter phone number [(xxx) xxx-xxxx]: (404) 817-6900
                                  You entered 404.817.6900

                            5.    Write a program that asks the user to enter the numbers from I to 16 (in any order) and then
                                  displays the numbers in a 4 by 4 arrangement, followed by the sums of the rows, columns,
                                  and dia w
                                          s>onals:
                                  Enter the numbers from 1 to 16 in any order:
                                  16 3 2 13 5 10 11 8 9 6 7 12 4 15 14 1
                                                                                                               51
                                                                  P ro g ra m m in g P ro je c ts onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


     16  3  2 13
      5 10 11  8
      9  6  7 12
      4 15 14  1

     Row s u m s : 34 34 34 34
     C o lu m n s u m s : 34 34 34 34
     D i a g o n a l s u m s : 34 34
     If the row, column, and diagonal sums are all the sam e (as they are in this exam ple), the
     numbers are said to form a RQPONMLKJIHGFEDCBA
                                  m a g i c s q u a r e . The magic square shuwn here appears in a 1514
     engraving by artist and m athem atician Albrecht Diirer. (Note that the middle num bers in the
     last row give the date of the engraving.)

6.   Modify the a d d f r a c . c program o f Section 3.2 so that the uscr enters both fractions at the
     same time, separated by a plus sign:
     E n t e r tw o f r a c t i o n s   s e p a ra te d   by a p lu s    s ig n :   5 /6 4 -3 /4
     T h e sum i s 3 8 / 2 4
4   E x p r e s s io n s                  ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                 O n e d o e s n o t le a rn c o m p u tin g b y u s in g a h a n d
                                                          c a lc u la to r, b u t o n e c a n fo rg e t a rith m e tic . onmlkjihgfedcbaZYXWV




    One o f C ’s distinguishing characteristics is its emphasis on expressions— formulas
    that show how to compute a value—rather than statements. The simplest expres­
    sions are variables and constants. A variable represents a value to be computed as
    the program runs: a constant represents a value that doesn't change. More compli­
    cated expressions apply operators to operands (which are themselves expressions).
    In the expression a + (b * c ) . the + operator is applied to the operands a and
     (b * c ) , both of which are expressions in their own right.
         Operators are the basic tools for building expressions, and C has an unusually
    rich collection of them. To start off. C provides the rudimentary operators that are
    found in most programming languages:
     ■ Arithmetic o perators, including addition, subtraction, multiplication, and divi­
        sion.
     ■ Rel ational operators to perform comparisons such as “i is g r e a t e r t h a n 07
     ■ Logica l operators to build conditions such as u i is greater than 0 a n d i is less
        than 10
    But C doesn’t stop here; it goes on to provide dozens of other operators. There are
    so many operators, in fact, that w e’ll need to introduce them gradually over the
    first twenty chapters of this book. Mastering so many operators can be a chore, but
    it’s essential to becoming proficient at C.
          Tn this chapter, we’ll cover some o f C ’s most fundamental operators: the arith­
    metic operators (Section 4.1). the assignment operators (Section 4.2). and the
    increment and decrement operators (Section 4.3). Section 4.1 also explains opera­
    tor precedence and associativity, which are important for expressions that contain
    more than one operator. Section 4.4 describes how C expressions are evaluated.
    Finally, Section 4.5 introduces the expression statement, an unusual feature that
    allows any expression to serve as a statement.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                                                                   53
5 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 4    E x p re s s io n s aZYXWVUTSRQPONMLKJIHGFEDCBA




                                    4.1           A r it h m e t ic O p e r a t o r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                       a rith m etic operators — operators that perforin addition, subtraction, m ultipli­
                                                  The cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  cation, and division— are the workhorses ofm any programming languages, includ­
                                                  ing C. Table 4.1 shows C ’s arithmetic operators.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                           T a b I e 4 .1                                      U nary                          B in a ry
      Arithmetic Operators                                                                       A dditive            M ultip licative
                                                                          +   unary plus     +   addition           * multiplication
                                                                          -   unary minus    -   subtraction        / division
                                                                                                                    % remainder

                                                      The additive and multiplicative operators are said to be b in a ry because they
                                                  require two operands. The u n a ry operators require one operand:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFED

                                                  i = +1;               /* + used as a unary operator */
                                                  •    a
                                                  3 = -i;               /* - used as a unary operator */

                                                  The unary + operator does nothing; in fact, it didn’t even exist in K&R C. It’s used
                                                  primarily to em phasize that a numeric constant is positive.
                                                       The binary operators probably look familiar. The only one that might not is %,
                                                  the rem ainder operator. The value of i % j is the remainder when i is divided by
                                                  j . For example, the value of 10 % 3 is 1, and the value of 12 % 4 is 0.
                                    Q&A                The binary operators in Table 4.1— with the exception of %— allow either inte­
                                                  ger or floating-point operands, with mixing allowed. When i n t and f l o a t oper­
                                                  ands are mixed, the result has type f l o a t . Thus, 9 4- 2 . 5 f has the value 11.5.
                                                  and 6 . 7 f / 2 has the value 3.35.
                                                       The / and % operators require special care:

                                                            ■ The / operator can produce surprising results. When both of its operands are
                                                               integers, the / operator “truncates” the result by dropping the fractional pan.
                                                               Thus, the value of 1 / 2 is 0, not 0.5.
                                                    ■         The % operator requires integer operands; if either operand is not an integer,
                                                              the program w on’t compile.
         u n d e fin e d b e h a v io r > 4 . 4         ■ Using zer o as the right operand o feith er / or % causes undefined behavior.
                                    Q&A                 ■     Describing the result when / and % are used with negative operands is tricky.
                                                              The C89 standard states that ifeith e r operand is negative, the result o f a divi­
                                                              sion can be rounded either up or down. (For example, the value of - 9 / 7
                                                              could be either -1 or -2 ). If i or j is negative, the sign of i % j in C89
                                                              depends on the implem entation. (For example, the value of - 9 % 7 could be
                                                              either -2 or 5). In C99. on the other hand, the result of a division is always
                                                              truncated toward zero (so - 9 / 7 has the value - 1 ) and the value of i % j has
                                                              the same sign as i (hencc thc value of - 9 % 7 is -2).
                                                                                       4 .1                                               55 RQPONMLKJIHGFED
                                                                                                 A rith m e tic O p e ra to rs hgfedcbaZYXWVUTSRQPONMLKJIHGF



                                               I m p le m e n ta tio n -D e fin e d B e h a v io r

             implementation-defined w ill a ris e o fte n e n o u g h th a t it’s w o rth ta k in g a
T h e te rm BA
m o m e n t to d is c u s s it. T h e C s ta n d a rd d e lib e ra te ly le a v e s p a rts o f th e la n g u a g e
u n s p e c ifie d , w ith th e u n d e rs ta n d in g th a t a n “ im p le m e n ta tio n ”— th e s o ftw a re n e e d e d
to c o m p ile , lin k , a n d e x e c u te p ro g ra m s o n a p a rtic u la r p la tfo rm — w ill fill in th e
d e ta ils . A s a re s u lt, th e b e h a v io r o f th e p ro g ra m m a y v a ry s o m e w h a t fro m o n e
im p le m e n ta tio n to a n o th e r. T h e b e h a v io r o f th e / a n d % o p e ra to rs fo r n e g a tiv e o p e r ­
a n d s in C 8 9 is a n e x a m p le o f im p le m e n ta tio n -d e fin e d b e h a v io r.
        L e a v in g p a rts o f th e la n g u a g e u n s p e c ifie d m a y s e e m o d d o r e v e n d a n g e ro u s ,
b u t it re fle c ts C ’s p h ilo s o p h y . O n e o f th e la n g u a g e ’s g o a ls is e ffic ie n c y , w h ic h o fte n
m e a n s m a tc h in g th e w a y th a t h a rd w a re b e h a v e s . S o m e C P U s y ie ld - 1 w h e n - 9 is
d iv id e d b y 7, w h ile o th e rs p ro d u c e - 2 ; th e C 8 9 s ta n d a rd s im p ly re fle c ts th is fa c t o f
life.
        It’s b e s t to a v o id w ritin g p r o g ra m s th a t d e p e n d o n im p le m e n ta tio n -d e fin e d
b e h a v io r. If th a t’s n o t p o s s ib le , a t le a s t c h e c k th e m a n u a l c a r e fu lly — th e C s ta n d a rd
re q u ire s th a t im p le m e n ta tio n -d e fin e d b e h a v io r b e d o c u m e n te d . dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




O p e r a t o r P r e c e d e n c e a n d A s s o c ia tiv i ty

W h e n an e x p re s s io n c o n ta in s m o re th a n o n e o p e ra to r, its in te r p r e ta tio n m a y n o t be
im m e d ia te ly c le a r. F o r e x a m p le , d o es i + j                          * k m e a n “ a d d i a n d j , th e n m u lt ip ly
th e re s u lt b y k , ” o r d o e s it m e a n “ m u lt ip ly j a n d k , th e n a d d i ” ? O n e s o lu tio n to
th is p ro b le m is to a d d p a re n th e s e s , w r it in g e ith e r ( i + j ) * k o r i + ( j                             * k ) . As
a g e n e ra l ru le , C a llo w s th e use o f p a re n th e s e s f o r g r o u p in g in a ll e x p re s s io n s .
        W h a t i f w e d o n ’ t use p a re n th e s e s , th o u g h ? W il l th e c o m p ile r in te r p r e t i + j                   *
k as ( i          + j ) * k or i                       + (j          * k ) ? L ik e m a n y o th e r la n g u a g e s , C uses operator
precedence ru le s to re s o lv e th is p o te n tia l a m b ig u ity . T h e a r ith m e tic o p e r a to rs h a v e
th e f o llo w in g r e la tiv e p re c e d e n c e :

        H ig h e s t:           +              -    ( u n a ry ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  *^           //     ^L
                                                      S

        L o w e s t:            +              -    ( b in a r y )

O p e ra to rs lis te d o n th e sam e lin e (s u c h as + and - ) h a v e e q u a l p re c e d e n c e .
        W h e n tw o o r m o re o p e ra to rs a p p e a r in th e sa m e e x p re s s io n , w e c a n d e te rm in e
h o w th e c o m p ile r w i l l in te r p r e t th e e x p re s s io n b y re p e a te d ly p u ttin g p a re n th e s e s
a r o u n d s u b e x p re s s io n s , s ta rtin g w i t l i h ig h -p re c e d e n c e o p e ra to rs a n d w o r k in g d o w n
to lo w -p re c e d e n c e o p e ra to rs . T h e f o llo w in g e x a m p le s illu s tr a te th e re s u lt:

        i     +       j       *        k            is e q u iv a le n t to       i + (j * k)
        - i       *       - j                       is e q u iv a le n t t o       (-i) * (-j)
        +i        +       j       /        k                                       (+i) + (j / k)
                                                    is e q u iv a le n t t o kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

        O p e ra to r p re c e d e n c e ru le s a lo n e a re n ’ te n o u g h w h e n an e x p re s s io n c o n ta in s tw o
o r m o re o p e ra to rs at th e sam e le v e l o fp re c e d e n c e . In th is s itu a tio n , ihtassociativity
           C h a p te r 4    E x p re s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                                    o f the operators com es into play. An operator is said to be le ft a sso cia tive if it groups
                                                                                                                  cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                    from left to right. The binary arithm etic operators (*, / , %, +, and - ) a r e all left asso­
                                                    ciative, so

                                                          i   - j      - k       is equivalent to         (i   - j ) - k
                                                          i   * j      / k       ise q u iv a le n tto    (i   * j) / k

                                                    An operator is rig h t asso cia tive if it groups from right to left. The unary arithm etic
                                                    operators (+ and - ) are both right associative, so

                                                          - + i                   isc q u iv a le n lto   -(+ i)

                                                         Precedence and associativity rules are im portant in many languages, but espe­
                                                    cially so in C. However, C has so many operators (alm ost fifty!) that few program ­
                                                    mers bother to m em orize the precedence and associativity rules. Instead, they aZYXWV
                                 > A p p en d ixA
   ta b iG o f o p e r a t o r s BA                 consult a table of operators when in doubt o rju s t use plenty o f parentheses.


                                       C o m p u tin g a U P C
                     P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA                   C h e c k D ig it

                                                    For a num ber o f years, m anufacturers o f goods sold in U.S. and Canadian stores
                                                    have put a bar code on each product. This code, known as a Universal Product
                                                    Code (UPC), identifies both the m anufacturer and the product. Each bar code rep­
                                                    resents a tw elve-digit number, which is usually printed underneath the bars. For
                                                    example, the following bar code com es from a package o f Stouffer's French Bread
                                                    Pepperoni Pizza:




                                                    The digits kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                    0    13800 15173            5

                                                    appear undem eath the bar code. The first digit identifies the type o f item (0 or 7
                                                    for most items, 2 for items that must be wei w   g hed, 3 for drugOs and health-related
                                                    m erchandise, and 5 for coupons). The first group o f five digits identifies the m anu­
                                                    facturer (13800 is the code for Nestle USA's Frozen Food Division). The second
                                                    group o f five digits identifies the product (including package size). The final digit
                                                    is a “check d ig it? whose only purpose is to help identify an error in the preceding
                                                    digits. Ifth e UPC is scanned incorrectly, the first 11 digits probably w on’t be con­
                                                    sistent with the last digit, and the store’s scanner will reject the entire code.
                                                         H ere's one method of com puting the check digit:

                                                          Add the first,• third, fifth, seventh, ninth, and eleventh dig^?its.
                                                          Add the second, fourth, sixth, eighth, and tenth digits.
                                                                                              4 .1                                            5 7 onmlkjihgfedcbaZYX
                                                                                                     A rith m e tic O p e ra to rs hgfedcbaZYXWVUTSRQPONMLKJIH


                  M ultiply the fust sum by 3 and add it to the second sum.
                  Subtract 1 from the total.
                  Com pute the rem ainder when the adjusted total is divided by 10.
                  Subtract the rem ainder from 9.

        Using the Stouffer’s example, we get 0 + 3 + 0 + I + 1 + 3 = 8 for the first sum and
        1 + 8 + 0 + 5 + 7 = 21 for the second sum. M ultiplying the first sum by 3 and add­
        ing the second yields 45. Subtracting 1 gives 44. The rem ainder upon dividing by
        10 is 4. W hen the rem ainder is subtracted from 9, the result is 5. Here are a couple
        of other UPCs, in case you want lo try your hand at com puting the check digit
        (raiding the kitchen cabinet for the answer is cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                       not allowed):

        JifC re a n iy P e a n u tB u tte r(1 8 o z .):                                       0 51500 24128             ?
        O c e aiiS p ra y Jellied C ra n b erry S a iice (8 o z .):                          0 31200 01005              ?

        The answers appear at the bottom o f the page.
             L et’s write a program that calculates the check digit for an arbitrary UPC.
        W e’ll ask the user to enter the first 11 digits o fth e UPC, then w e’ll display the cor­
        responding check digit. To avoid confusion, w e’ll ask the user to enter the num ber
        in three parts: the single digit at the left, the first group of five digits, and the sec­
        ond group o ffiv e digits. H ere’s what a session with the program will look like:kjihgfedcbaZYXWVUTSRQ

        Enter the first (single) digit: 0
        Enter first group of five digits: 13800
        Enter second group of five digits: 15173
        Check digit: 5

              Instead of reading each digit group as a/h>e-digil num ber, w e’ll read it as five
        o/?<?-digit numbers. Reading the numbers as single digits is more convenient; also,
        we w on’t have to worry that one o f the five-digit numbers is too large to store in an
        i n t variable. (Some older com pilers limit the maxim um value o f an i n t variable
        to 32,767.) To read single digits, w e’ll use s c a n f with the % ld conversion speci­
        fication, which matches a one-digit integer.

upc.C   /* Computes a Universal Product Code check digit */

        #include <stdio.h>

        int main(void)

               int d, il, i2, i3, i4, i5, jl, j2, j3, j4, j5,
                   first_sum, second_sum, total;

              printf("Enter the first (single) digit: ");
              scanf("%ld", &d);
              printf("Enter first group of five digits: ");
              scanf("%ld%ld%ld%ld%ld", &il, &i2, &i3, &i4, &i5);
              printf("Enter second group of five digits: ");
              scanf("%ld%ld%ld%ld%ld", &jl, &j2, &j3, &j4, &j5);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

        T h e m is s in g c h e c k d ig its a rc 8 (J if) a n d 6 (O c c n n S p r a y ).
58 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 4     E x p re s s io n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                              first_sum = d + i2 + i4 + jl + j3 + j5;
                                                              second_sum = il + i3 + i5 + j2 + j4;
                                                              total = 3 * first_sum + second_sum;

                                                              printf("Check digit: %d\n",             9 - ((total - 1) % 10));

                                                              return 0;


                                                               Note that the expression 9 - ( ( t o t a l - 1) % 1 0 ) could have been written
                                                           as 9 - ( t o t a l - 1) % 10, but the extra set of parentheses makes it easier to
                                                           understand.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                             4 .2          A s s ig n m e n t O p e r a t o r s

                                                           Once the value of an expression has been computed, w e’ll often need to store it in
                                                                                            {sim ple assignm ent} operator is used for that pur­
                                                           a variable for later use. C\s = cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                           pose. For updating a value aJready stored in a variable, C provides an assortment of
                                                           compound assignment operators.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                           S im p le A ss ig n m e n t

                                                           The effect of the assignment v = e is to evaluate the expression e and copy its value
                                                           into v. As the following examples show, e can be a constant, a variable, or a more
                                                           complicated expression:

                                                           i = 5;                        /* i is now 5 */
                                                           j = i;                        /* j is now 5 */
                                                           k = 10 * i + j ;              /* k i s now 5 5 */

                                                           If v and e don’t have the same type, then the value of e is converted to the type of v
                                                           as the assignment takes place:

                                                           int i ;
                                                           float f;

                                                           i = 72.99f;          /* i is now 72 */
                                                           f = 136;             /* f is now 136.0 */

c o n v e r s i o n d u r in g a s s i g n m e n t > 7.4
                                                     BA    Wc’ll return to the topic ofty p e conversion later.
                                                                 In many programming languages, assignment is a statement', in C, however,
                                                           assignment is an operator, just like +. In other words, the act of assignment pro­
                                                           duces a result, just as adding two numbers produces a result. The value of an
                                                           assignment v = e is the value of v after the assignment. Thus, the value of i =
                                                           7 2 . 9 9 f i s 72 (not72.99).
                                                       4 .2                                                      59
                                                                  A s s ig n m e n t O p e ra to rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJ



                                             Sid e Ef f e c t s

       We don’t normally expect operators to modify their operands, since operators in
       mathematics don't. Writing i + j doesn’t modify either i or j ; it simply computes
       the result of adding i and j .
            Most C operators don’t modify their operands, but some do. We say that these
       operators have side effects, since they do more than just compute a value. The
       simple assignment operator is the first operator we’ve seen that has side effects; it
       modifies its left operand. Evaluating the expression i = o produces the result 0
       and—as a side effect—assigns 0 to i.


              Since assignment is an operator, several assignments can be chained together: kjihgfedcbaZYXWVUT

        i = j = k = 0;

       The = operator is right associative, so this assignment is equivalent to

        i =    (j =    (k = 0) ) ;

       The effect is to assign 0 first to k, then to j , and finally to i .


       Watch out for unexpected results in chained assignments as a result of type conver­

A      sion:

        int i ;
        float f;

        f = i = 33.3f;

        i is assigned the value 33. then f is assigned 33.0 (not 33.3. as you might think).


              In general, an assignment ol’ the form v = e is allowed wherever a value oft ype
        v would be permitted. In the follow ing example, the expression j = i copies i to
        j ; the new value of j is then added to 1, producing the new value of k:

       i = 1;
       k = 1 + (j = i) ;
       printf("%d %d %d\n",            i, j, k);          /* prints             "1 1 2" */

        Using the assignment operator in this fashion usually isnT a good idea. For one
        thing, “ embedded assignments” can make programs hard to read. They can also be
        a source ofsubt le bugs, as we’ ll see in Section 4.4.aZYXWVUTSRQPONMLKJIHGFEDCBA


        L v a lu e s

            Most C operators allow their operands to be variables, constants, or expressions
            containing other operators. The assignment operator, however, requires an lvalue
Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
60 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 4   E x p r e s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                      as its left operand. An lvalue (pronounced “L-value") represents an object stored in
                                                      com puter memory, not a constant or the result of a com putation. Variables are lval­
                                                      ues; expressions such as 10 or 2 * i are not. At this point, variables are the only
                                                      lvalues that we know about; other kinds o f lvalues will appear in later chapters.
                                                            Since the assignm ent operator requires an lvalue as its left operand, it’s illegal
                                                      to put any other kind ofexpression on the left side o f an assignm ent expression:

                                                      12 = i ;                    /* * *   WRONG * * * /
                                                      i + j = 0;                  /* * *   WRONG * * * /
                                                      -i = j;                     /* * *   WRONG * * * /

                                                      The com piler will detect errors o f this nature, and you’ll get an error m essage such
                                                          “invalid lvalue in assignm ent." dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                      as cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                      C o m p o u n d A s s ig n m e n t
                                                      Assignm ents that use the old value of a variable to com pute its new value are com ­
                                                      mon in C programs. The following statem ent, for exam ple, adds 2 to the value
                                                      stored in i :

                                                      i    = i       + 2;

                                                      C ’s c o m p o u n d a s s ig n m e n t operators allow us to shorten this statem ent and others
                                                      like it. Using the += operator. we sim ply write:

                                                      i    +=    2;         /*    sam e a s     i   = i   + 2;    */

                                                      The += operator adds the value o f the right operand to the variable on the left.
                                                          There are nine other com pound assignm ent operaiors, including the following:
                                                      -=        *=     /=        %= aZYXWVUTSRQPONMLKJIHGFEDCBA

o th e r a s s ig n m e n io p e r a to r s > 2 0 j   (W e’Il cover the rem aining com pound assignm ent operators in a later chapter.) All
                                                      com pound assignm ent operators work in much the sam e way:

                                                            v + = e adds v to e, storing the result in v
                                                            v - = e subtracts e from v, storing the result in v
                                                            v * = e m ultiplies v by e. storing the result in v
                                                            v / = e divides v by e. storing the result in v
                                                            v %= e com putes the rem aindcr when v is divided by e, storing the result in v

                                                      Note that I ’ve been careful not to say that v += e is “equivalent” to v = v + e. One
                                                      problem is operator precedence: i *= j + k isn’t the sam e as i = i * j + k. There
                                                      are also rare cases in which v += e differs from v = v + e because v itseIfh as a side
                                        Q&A           effect. Sim ilar rem arks apply to the other com pound assignm ent operators.kjihgfedcbaZYXWVU


                                                      W hen using the com pound assignm ent operators, be careful not to sw itch the two

                                       A              characters that make up the operator. Sw itching the characters may yield an
                                                      expression that is acceptable to the com piler but that d oesn’t have the intended
                                                      meaning. For exam ple, ify o u meant to write i += j but typed i =+ j instead, the
                                                  4 .3      In c r e m e n t a n d D e c re m e n t O p e ra to rs hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                              61 onmlkjihgfedcbaZYXWVU


       program will still compile. Unfortunately, the latter expression is equivalent to
       i = (+ j ) , which merely copies the value of j into i .


             The com pound assignm ent operators have the sam e properties as the = opera­
       tor. In particular, they're right associative, so the statem ent

       i    += j            += k ;

       means

       i    +=         (j    += k ) ;aZYXWVUTSRQPONMLKJIHGFEDCBA




4 .3 dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          In c r e m e n t a n d D e c r e m e n t O p e r a t o r s

       Two of the most com m on operations on a variable are “increm enting" (adding l)
       and “decrem enting" (subtracting l). We can, o fco u rse, accom plish these tasks by
       writing^^

        i   = i + 1;
       i = j - i;
       The com pound assignm ent operators allow us to condense these statem ents a bit:

       i    += 1 ;
       j    -= 1 ;

       But C allows increm ents and decrem ents to be shortened even further, using the ++ cbaZYXWVUTSRQPONM
Q&A    {in crem en t) and - - {d ecrem en t) operators.
            At First glance, the increm ent and decrem ent operators are sim plicity itself: ++
       adds 1 to its operand, whereas - - subtracts 1. Unfortunately, this sim plicity is m is­
       leading— the increm ent and decrem ent operators can be tricky to use. O ne com pli­
       cation is that ++ and - - can be used as p r e fix operators ( + + i and - - i , for
       example) o r p o s tfix operators ( i+ + and i - - ) . The correctness of a program may
       hinge on picking the proper version.
            Another com plication is that, like the assignm ent operators. ++ and - - have
       side effects: they modify the values o f their operands. Evaluating the expression
       + + i (a “pre-increm ent”) yields i + 1 and— as a side effect— increm ents i :

       i = 1;
       p rin tf(" i             is   % d \n " ,   + + i);          /* p r i n t s " i i s 2" * /
       p rin tf(" i             is   % d \n " ,   i);             /* p r i n t s " i i s 2" * /

       Evaluating the expression i + + (a “post-increm ent” ) produces the result i , but
       causes i to be increm ented afterwards:

       JL. *“    ^ >   f




       p rin tf(" i             is   % d \n " ,   i+ + );          /* p r i n t s ” i i s 1" * /
       p rin tf(" i             is   % d \n " ,   i);             /* p r i n t s ”i i s 2 ” * /
62 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 4     E x p re s s io n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   The first p r i n t f shows the original value o f i . before it is increm ented. T he sec­
                                   ond p r i n t f shows the new value. As these exam ples illustrate, + + i means
                                   “ increm ent i im m ediately;’ while i + + means “use the old value o f i for now, but
                                   increm ent i later.” How much later? The C standard doesn’t specify a precise time,
                                   but it’s safe to assum e that i will be increm ented before the next statem ent is exe­
                                   cuted.
                         Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            The - - operator has sim ilar properties:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    i = 1;
                                    printf("i is              %d\n", --i);         /* prints ”i is 0” */
                                    printf("i is              %d\n", i);           /* prints "i is 0” */

                                    i = 1;
                                    printf("i is              %d\n", i--);         /* prints ”i is 1” */
                                    printf("i is              %d\n", i);           /* prints "i is 0" */

                                         W hen ++ or - - is used more than once in the same expression, the result can
                                    often be hard to understand. C onsider the following statements:

                                    i = 1;
                                    j = 2;
                                    k = 4-4-i 4- j4-4-;

                                    W hat are the values of i . j , and k after these statem ents are executed? Since i is
                                                   before its value is used, but j is incremented a fte r it is used, the last
                                    increm ented cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    statem ent is equivalent to

                                    i = i + 1;
                                    k = i 4- j ;
                                    j = j + 1;

                                    so the final values of i , j , and k are 2, 3, and 4, respectively. In contrast, executing
                                    the statem ents




                                    will give i , j , and k the values 2, 3, and 3, respectively.
                                         For the record, the postfix versions o f 4-4- and - - have higher precedence than
                                    unary plus and minus and are left associative. The prefix versions have the same
                                    precedence as unary plus and minus and are right associative.aZYXWVUTSRQPONMLKJIHGFEDCBA




                         4 .4       E x p r e s s i o n E v a lu a t io n

                                    Table 4.2 sum m arizes the operators w e’ve seen so for. (A ppendix A has a similar
                                    table that shows a ll operators.) The first colum n shows the precedence of each
                                                                                              4 .4                                                     6 3 dcbaZYXWVUTSR
                                                                                                           E x p re s s io n E v a lu a tio n RQPONMLKJIHGFEDCBA


       T a b le 4 .2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    P receden ce       N am e                S y m b o l(s )                                       A s s o c ia tiv ity
A Partial List of               i                     increment (postfix)    +    +                                                       left
   C Operators ZYXWVUTSRQPONMLKJIHGFEDCBA             decrem ent (postfix)   — —



                                       2              increment (prefix)     4— F                                                        ri^eht
                                                      decrem ent (prefix)    — —


                                                      unary plus             4~

                                                      unary minus            —



                                       3              multiplicative         4*
                                                                             ^        /
                                                                                          /     Qz
                                                                                                ^                                         left
                                       4              additive               4^       —
                                                                                                                                          ieft
                                       5              assignment             =
                                                                                      4-
                                                                                      * =
                                                                                                      /
                                                                                                     / =
                                                                                                             Q^
                                                                                                             ^ =    +=    -=             rig^»»ht

                         operator relative to the other operators in the table (the highest precedence is 1; the
                         lowest is 5). The last column shows the associativity of each operator.
                              Table 4.2 (or its larger cousin in Appendix A) has a variety of uses. Let’s look
                         at one ofthese. Suppose that we run across a complicated expression such as kjihgfedcbaZYXWVUTSRQPO

                         a = b += c++ - d + --e / -f

                         as we’re reading someone’s program. This expression would be easier to under­
                         stand if there were parentheses to show how the expression is constructed from
                         subexpressions. With the help of Table 4.2, adding parentheses to an expression is
                         easy: after examining the expression to find the operator with highest precedence,
                         we put parentheses around the operator and its operands, indicating that it should
                         be treated as a single operand from that point onwards. We then repeat the process
                         until the expression is fully parenthesized.
                              In our example, the operator with highest precedence is ++, used here as a
                         postfix operator, so we put parentheses around ++ and its operand:

                         a = b += (c++) - d + --e / -f

                             We now spot a prefix - - operator and a unary minus operator (both prece­
                         dence 2) in the expression:

                         a = b += (c++) - d + (--e) / (-f)

                         Note that the other minus sign has an operand to its immediate left, so it must be a
                         subtraction operator, not a unary minus operator.
                             Next, we notice the / operator (precedence 3):

                         a = b += (c++) - d + ((--e) / (-f))

                               The expression contains two operators with precedence 4, subtraction and
                         addition. Whenever two operators with the same precedence are adjacent to an
                         operand, we’ve got to be careful about associativity, In our example, - and + are
                         both adjacent to d, so associativity rules apply. The - and + operators group from
                         left to right, so parentheses go around the subtraction first, then the addition:

                         a = b += (((c++) - d) + ((--e) / (-f)))
64 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 4    E x p re s s io n s


                                                               The only remaining operators are = and +=. Both operators are adjacent to b.
                                                          so we must take associativity into account. Assignment operators group from right
                                                          to left, so parentheses go around the += expression first, then the = expression:

                                                          (a =     (b +=     (((c + + )    - d)   +    ((--e )       /   (-f)))))

                                                          The expression is now fully parenthesized.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                          O r d e r o f S u b e x p r e s s io n E v a lu a t io n

                                                          The rules ofoperator precedence and associativity allow us to break any C expres­
                                                          sion into subexpressions— to determine uniquely where the parentheses would go
                                                          if the expression were fully parenthesized. Paradoxically, these rules don’t always
                                                          allow us to determine the value of the expression, which may depend on the order
                                                          in which its subexpressions are evaluated.aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                > 5 .1
 lo g i c a l a n d a n d o r o p e r a t o r s BA             C doesn’t define the order in which subexpressions are evaluated (with the
             c o n d it io n a l o p e r a t o r > 5 .2                                                        and* logical or, conditional, and
                                                          exception ofsubexpressions involving the logical cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                   c o m m a o p e r a to r > 6 .3        comma operators). Thus, in the expression (a + b ) * (c - d) we don't know
                                                          whether (a + b) will bc evaluated before (c - d ) .
                                                                Most expressions have the same value regardless of lhe order in which their
                                                          subexpressions are evaluated. However, this may not be true when a subexpression
                                                          modifies one of its operands. Consider the following example:

                                                          a = 5;
                                                          c = (b = a + 2)            -    (a = 1 ) ;

                                                          The effect of executing the second statement is undefined: the C standard doesn't
                                                          say what will happen. With most compilers, the value of c will be either 6 or 2. If
                                                          the subexpression (b = a + 2) is evaluated first, b is assigned the value 7 and c is
                                                          assigG?ned 6. But if (' a = 1)f is evaluated first, ^b is assigned
                                                                                                                        ^    3 and c is assigned    2.PONMLKJIH
                                                                                                                                            £2hgfedcbaZYXWVUTSR




                                                          Avoid writing expressions that access the value of a variable and also modify the
                                          A               variable elsewhere in the expression. The expression (b = a + 2) - (a = 1)
                                                          accesses the value of a (in order to compute a + 2) and also modifies the value of
                                                          a (by assigning il 1). Some compilers may produce a warning message such as
                                                          “operation on *a' m ay he undefinecF when they encounter such an expression.


                                                               To prevent problems, it’s a good idea to avoid using the assignment operators
                                                          in subexpressions; instead, use a series of separate assignments. For example, the
                                                          statements above could be rewritten as

                                                          a   =   5;
                                                          b   =   a + 2;
                                                          a   =   1;
                                                          c   =   b - a;

                                                          The value of c will always be 6 after these statements are executed.
                                                                            4 .5                                                   6 5 onmlkjihgfedcbaZYX
                                                                                    E x p r e s s io n S ta te m e n ts hgfedcbaZYXWVUTSRQPONMLKJIH


                                 Besides the assignm ent operators, the only operators that m odify their oper­
                          ands are increm ent and decrem ent. W hen using these operators, be careful that
                          y o u r expressions d o n ’t depend on a particular order o fev a k ia tio n . In the follow ing
                          exam ple, j m ay be assigned one o f two values:

                          i   = 2;
                          j   = i * i + + ;aZYXWVUTSRQPONMLKJIHGFEDCBA

                          It’s natural to assum e that j is assigned the value 4. However, the effect o f execut­
                          ing the statem ent is undefined, and j could ju st as well be assigned 6 instead.
                          H ere's the scenario: ( ! ) T he second operand (the original value o f i ) is fetched,
                          then i is increm ented. (2) T he first operand (the new value o f i ) is fetched. (3) The
                          new and old values o f i are m ultiplied, yielding 6. “F etching” a variable m eans to
                          retrieve the value o f the variable from mem ory. A later change to the variable
                          w o n ’t affect the fetched value, which is typically stored in a special location
                   18.2
r e g is t e r s > BA     (know n as a RQPONMLKJIHGFEDCBA
                                         r e g i s t e r ) inside the CPU. cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                             U ndefined B ehavior
                          According to the C standard, statem en ts such a s c = (b = a + 2) - (a = 1) ,- and
                          j = i * i+ + ; c a u se u n d e f i n e d b e h a v i o r , which is different from im plem entation-
                          defined behavior (see Section 4.1). W hen a program v entures into the realm of
                          undefined behavior, all b ets are off. T he program may behave differently w hen com ­
                          piled with different compilers. But that’s not the only thing that can happen. The pro­
                          gram may not compile in the first place, if it com piles it m ay not run, and if it d o e s
                          run, it may crash, behave erratically, or produce m ean in g less results. In other
                          words, undefined behavior should be avoided like the plague.




            4 .5          E x p r e s s io n S t a t e m e n t s

                          C has the unusual rule that a n y expression can be used as a statem ent. T hat is, any
                          expression— regardJess o f its type or what it com putes— can be turned into a state­
                          m ent by appending a sem icolon. For exam ple, we could turn the expression + + i
                          into a statem ent:dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                          ++ i ;

                          W hen this statem ent is executed, i is first increm ented, then the new value o f i is
                          fetched (as though it were to be used in an enclosing expression). However, since
            Q&A           + + i isn ’t part of a larger expression, its value is discarded and the next statem ent
                          executed. (The change to i is perm anent, o fc o u rse .)
                               Since its value is discarded, th ere’s little point in using an expression as a
                          statem ent unless the expression has a side effect. L e t’s look at three exam ples. In
            C h a p te r 4
6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA E x p re s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               the fust example, 1 is stored into i , then the new value of i is fetched but not used:kjihgf

                                               i = 1;
                                               In the second example, the value of i is fetched but not used; however, i is decre­
                                               mented afterwards:

                                               i--;
                                               In the third example, the value of the expression i * j - 1 is computed and then
                                               discarded:

                                               i * j - 1;
                                               Since i and j aren’t changed, this statement has no effect and therefore serves no
                                               purpose.


                                               A slip of the fmger can easily create a “do-nothing” expression statement. For

                                    A          example, instead of entering
                                                •
                                               i = 3;
                                                     •

                                               we might accidentally type
                                               «   I
                                               i + 3;
                                               (This kind of error is more common than you might expect, since the = and + char­
                                               acters usually occupy the same key.) Some compilers can detect meaningless
                                                                                                    “sta tem ent with no effect.” aZYXWVUTSR
                                               expression statements; you’ll get a warning such as cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                               Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        Q:     I n o tic e th a t C h a s n o e x p o n e n tia t io n o p e r a to r . H o w c a n I r a is e a n u m b e r to a
                                               p ow er?
                                         A:    Raising an integer to a small positive integer power is best done by repeated multi­
                                               plication ( i * i * i is i cubed). To raise a number lo a noninteger power, call the
                  p o w fu n c tio n   >23.3   pOW funCtiOll.

                                        Q:     I w a n t to a p p ly th e % o p e r a t o r to a flo a t in g - p o in t o p e r a n d , b u t m y p r o g r a n i
                                               w o n ’t c o m p ile . W h a t c a n I d o ? [p . 5 4 ]
     f m o d fu n c tio n   >23.3        A:    The % operator requires integer operands. Try the fm o d function instead.

                                        Q:     W h y a r e th e r u le s fo r u s in g th e / a n d % o p e r a to r s w ith n e g a tiv e o p e r a n d s so
                                               c o m p lic a t e d ? [p . 5 4 ]
                                         A:    The rules aren’t as complicated as they may first appear. In both C89 and C99. the
                                               goal is to ensure that the value of (a / b ) * b + a % b will always be equal to a
                                                                                                            Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                             6 7 onmlkjihgfedcbaZYXWV


        (and indeed, both standards guarantee that this is the case, provided that the value
        ot' a / b is “representable” ). The problem is that there are two ways for a / b and
        a % b to satisfy this equality if either a or b is negative, as seen in C89, where
        either - 9 / 7 is - I and - 9 % 7 is -2 , or - 9 / 7 is - 2 and - 9 % 7 is 5. In the first
        case, ( - 9 / 7) * 7 + - 9 % 7 has the value -1 x 7 + - 2 = —9, and in the second
<^^>    case, ( - 9 / 7) * 7 + - 9 % 7 has the value -2 x 7 + 5 = -9 . By the time C99 rolled
        around, most CPUs were designed to truncate the result ofdivision toward zero, so
        this was written into the standard as the only allowable outcome.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

  Q:    I f C h a s lv a lu e s , d o e s it a lso h a v e r v a lu e s ? [p . 5 9 ]
  A:    Yes, indeed. An Zvalue is an expression that can appear on the left    side of an assign­
                                                                         cbaZYXWVUTSRQPONMLKJIHGFEDCBA

        ment; an rvalue is an expression that can appear on the right side. Thus, an rvalue
        could be a variable, constant, or more complex expression. In this book, as in the C
        standard, w e’ll use the term “expression” instead o f “rvalue.”

 *Q :   Y ou s a id th a t v + = e i s n ’t e q u iv a le n t to v = v + e i f v h a s a s id e e f fe c t. C a n y o u
        e x p la in ? [p . 6 0 ]
  A:    Evaluating v + = e causes v to be evaluated only once; evaluating r' = v + e causes v
        to be evaluated twice. Any side effect caused by evaluating v will occur twice in
        the latter case. In the following example, i is incremented once:

        a [ i + + ] += 2 ;

        If we use = instead of +=, here’s what the statement will look like:

        a [i+ + ]     = a [i+ + ]       + 2;

        The value of i is modified as well as used elsewhere in the statement, so the effect
        of executing the statement is undefined. It’s likely that i will be incremented
        twice, but we can’t say with certainty what will happen.

  Q:    W h y d o e s C p r o v id e th e + + a n d - - o p e r a to r s ? A r e th e y fa s te r th a n o t h e r
        w a y s o f in c r e m e n t i n g a n d d e c r e m e n tin g , o r th e y a r e j u s t m o r e c o n v e n ie n t ? [p .
        61]
  A:    C inherited ++ and - - from Ken Thom pson’s earlier B language. Thompson
        apparently created these operators because Ids B compiler could generate a more
        compact translation for + + i than for i = i + 1. These operators have become a
        deeply ingrained part o fC (in fact, many o f C ’s most famous idioms rely on them).
        With modern compilers, using ++ and - - w on’t make a compiled program any
        smaller or faster; the continued popularity of these operators stems mostly from
        their brevity and convenience.

  Q:    D o + + a n d - - w o r k w ith f l o a t v a r ia b le s ?
  A:    Yes; the increment and decrement operations can be applied to floating-point num­
        bers as well as integers. In practice, however, it’s fairly rare to increment or decre­
        ment a f l o a t variable.
68ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 4   E x p re s s io n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                         *Q :     W h e n 1 u s e th e p o s tfix v e r sio n o f + + o r - - , j u s t w h e n is th e in c r e m e n t o r d e c ­
                                  r e m e n t p e r fo r m e d ? [p . 6 2 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                           A:     That’s an excellent question. Unfortunately, it’s also a difficult one to answer. The
                                  C standard introduces the concept of “sequence point” and says that “updating the
                                  stored value ofthe operand shall occur between the previous and the next sequence
                                  point.” There are various kinds of sequence points in C: the end of an expression
                                  statement is one example. By the end of an expression statement, all increments
                                  and decrements within the statement must have been performed; the next statement
                                  can’t be°^in to execute until this condition has been met.
                                                                                                          and. logical or.
                                        Certain operators that we’ll encounter in later chapters (logical cbaZYXWVUTSRQPONMLKJIHGFEDCB
                                  conditional, and comma) also impose sequence points. So do function calls: the
                                  arguments in a function call must be fully evaluated before the call can be per­
                                  formed. Ifa n argument happens to be an expression containing a ++ or - - opera­
                                  tor, the increment or decrement must occur before the call can take place.

                          Q:      W h a t d o y o u m e a n w h e n y o u s a y th a t th e v a lu e o f a n e x p r e s s io n s ta te m e n t is
                                  d is c a r d e d ? [p . 6 5 ]
                           A:     By definition, an expression represents a value. If i has the value 5, for example,
                                  then evaluating i + 1 produces the value 6. Let’s turn i + 1 into a statement by
                                  putting a semicolon after it:
                                  i + 1;
                                  When this statement is executed, the value of i + 1 is computed. Since we have
                                  failed to save this value— or at least use it in some way— it is lost.

                          Q:      B u t w h a t a b o u t s ta te m e n ts lik e i = 1 ; ? I d o n ’t s e e w h a t is b e in g d is c a r d e d .
                           A:     Don’t forget that = is an operator in C and produces a value just like any other
                                  operator. The assignment

                                  i = 1;
                                  assigns 1 to i . The value o fth e entire expression is 1, which is discarded. Discard­
                                  ing the expression’s value is no great loss, since the reason for writing the state­
                                  ment in the first place was to modify i .aZYXWVUTSRQPONMLKJIHGFEDCBA




                                  E x e r c is e s

S e c ti o n 4.1            l.    Show the output produced by each of the following program fragments. Assume that i . j ,
                                  and k are i n t variables.
                                  (a) i = 5; j = 3;
                                      printf("%d %<3.”z i / j, i % j);
                                  (b) i = 2; j = 3;
                                      printf("%d", (i + 10) % j);
                                  (c) i = 7; j = 8; k = 9;
                                      printf("%d", (i + 10) % k / j);
                                                                                                                                     69 kjihgfedcbaZYXWVU
                                                                                                         E x e rc is e s onmlkjihgfedcbaZYXWVUTSRQPONML


                             (d) i = 1; j = 2; k = 3;
                                 printf("%d", (i + 5)               %   (j + 2)     / k);

                    © *2.    If i and j are positive integers, does ( - i ) / j always have the same value as - ( i / j ) ? Jus­
                             tify your answer.

                        3.   What is the value of each of the following expressions in C89? (Give all possible values if
                             an expression may have more than one value.)
                             (a) 8 / 5
                             (b) -8 / 5
                             (C) 8 / -5
                             (d) -8 / -5

                        4.   Repeat Exercise 3 for C99.

                        5.   What is the value of each of the following expressions in C89? (Give all possible values if
                             an expression may have more than one value.)
                             (a) 8 % 5
                             (b) -8 % 5
                             (c) 8 % -5
                             (d) -8 % -5

                        6.   Repeat Exercise 5 for C99.

                        7.   The algorithm for computing the UPC check digit ends with the following steps:
                             Subtract I from the total.
                             Compute the remainder when the adjusted total is divided by 10.
                             Subtract the remainder from 9.
                             It's tempting to try to simplify the algorithm by using these steps instead:
                             Compute the remainder when the total is divided by 10.
                             Subtract the remainder from 10.
                             Why doesn't this technique work?

                        8.   Would t h e u p c . c prograin still work if the expression 9 - ( ( t o t a l - 1) % 1 0 ) were
                             replaced by (10 - ( t o t a l % 10) ) % 10? aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 4 . 2   ©   9.   Show the output produced by each o fth e following program fragments. Assume that i . j .
                             and k arc i n t variables.
                             (a) i = 7; j = 8;
                                 i *= j + 1 ;
                                 p r i n t f ( " % d %d", i, j);
                             (b) i = j = k = 1;
                                 i += j 4-= k;
                                 p r i n t f ( " % d %d %d", i, j , k) ;
                             (c) i = 1; j = 2; k = 3;
                                 i -= j -= k;
                                 p r i n t f ( " % d %d %d", i, j , k) ;
                             (d) i = 2; j = 1; k
                                 i *= j *= k;
                                 p r i n t f ( " % d %d %d", i, j, k) ;
7 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 4    E x p re s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                              10.     Show (he output produced by each of (he following prognun fragments. Assume (hat i and
                                      j are i n t variables.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      (a) i = 6;
                                          j = i += i;
                                          printf("%d. %d", i, j);
                                      (b) i = 5;
                                          j = (i -= 2) + 1;
                                          printf("%d %d", i, j);




                                      (d) i = 2; j = 8;
                                          j = (i = 6) + (j = 3) ;
                                          printf("%d %d", i, j);aZYXWVUTSRQPONMLKJIHGFEDCBA


S e c t io n 4 .3            *11.     Show the output produced by each of the following program fragments. Assume that i , j ,
                                      and k are i n t variables.
                                      (a) i = 1;
                                          printf("%d ”, i++ - 1);
                                          printf("%d", i ) ;
                                      (b) i = 10; j = 5;
                                          printf("%d ", i++ - ++j);
                                          printf("%d %d", i, j);
                                      (c) i = 7; j = 8;
                                          printf("%d ", i++ - --j);
                                          printf("%d %d", i, j);
                                      (d) i = 3; j = 4; k = 5;
                                          printf("%d ", i++ - j++ + --k);
                                          printf("%d %d %d", i, j, k);

                              12.     Show the output produced by each of the following program fragments. Assume that i and
                                      ja re i n t variables.
                                      (a) i = 5;
                                          j = ++i * 3 - 2;
                                          printf("%d %d", i, j);
                                      (b) i = 5;
                                          j = 3 - 2 * i++;
                                          printf("%d %d", i, j);




                                      (d) i = 7 ;
                                          j = 3 + --i ♦ 2;
                                          printf("%d %d", i, j);


                         ©    13.     Only one of the expressions + + i and i+ + is exactly the same as ( i += 1 ) : which is it?
                                      Justify your answer.


S e c t io n 4 .4             14.     Supply parentheses (o show how a C compiler would interpret each of the following expres­
                                      sions.
                                                                                                                                      71 onmlkjihgfedcbaZYXWVU
                                                                                            P ro g ra m m in g P ro je c ts hgfedcbaZYXWVUTSRQPONMLKJIHGF


                              (a)   a   * b   - c * d + e
                              (b)   a   / b   %c / d
                              (c)   -   a -   b 4- c - + d
                              (d)   a   * -   b / c - d aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 4 . 5       l5.   Give the values of i and j after each of the following expression statements has been exe­
                              cuted. (Assume that i has the value l initially and j has thc value 2.)
                              (a) i     += j ;
                              (b) i - - ;
                              (c) i * j / i ;
                              (d) i % + + j ;




                              P r o g r a m m in g P r o je c t s

                         1.   Write a program that asks the user to enter a two-digit number, then prints the number with
                              its digits reversed. A session with thc program should have thc following appearance:
                              E n te r a t w o - d i g i t n u m b er:     28
                              T h e r e v e r s a l i s : 82
                              Read the number using %d, then break it into two digits. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                           Hint: I f n is an integer, then n % 10
                              is the last digit in n and n / 10 is n with thc last digit removed.

                    ©    2.   Extend the program in Programming Project 1 to handle /Zzree-digit numbers.

                         3.   Rewrite the program in Programming Project 2 so that it prints thc reversal of a three-digit
                              number without using ariUimetic to split the number into digits. Hint: See the u p c . c pro­
                              gram of Section 4.1.

                         4.   Write a program that reads an integer entered by the user and displays it in octal (base 8):
                               E n t e r a n u m b er b e tw e e n 0 a n d 3 2 7 6 7 :      1953
                              'I n o c t a l , y o u r n u m b e r i s : 0 3 6 4 1
                              Thc output should be displayed using five digits, even if fewer digits are sufficient. Hint: To
                              convert the number to octal, first divide it by 8; the remainder is the last digit of the octal
                              number (1, in this case). Then divide the original number by 8 and repeat the process to
                              arrive at the nexl-to-last digit, ( p r i n t f is capable of displaying numbers in base 8, as w e’ll
                              see in Chapter 7, so there’s actually an easier way to write this program.)

                         5.   Rewrite the u p c . c program of Section 4.1 so that the user enters 11 digits at one time,
                              instead of entering one digit, then five digits, and then another five digits.
                              E n te r th e f i r s t     11 d i g i t s   o f a UPC:       01380015173
                              C heck d i g i t : 5

                         6.   European countries use a 13-digit code, known as a European Article Number (EAN)
                              instead of the 12-digil Universal Product Code (UPC) found in North America. Each EAN
                              ends with a check digil, just as a UPC does. The technique for calculating the check digit is
                              also similar:
                                    Add the second, fourth, sixth,’ eigohth,’ tenth,w and twelfth digcits.
                                    Add the first, third, fifth, seventh, ninth, and eleventh digits.
                                    Multiply the first sum by 3 and add it to the second sum.
7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 4     E x p re s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             Subtract 1 from the total.
                                             C om pute the rem ainder when the adjusted total is divided by 10.
                                             Subtract the rem ainder from 9.
                                       F o rex am p le, consider GiiIliioglu Turkish Delight Pistachio & C oconut, which has an EAN
                                       o f 8691484260008. The first sum is 6 4- 1 4- 8 + 2 + 0 4- 0 = 17. and the second sum is 8 4- 9 4-
                                       4 4- 4 4- 6 4- 0 = 3 1. M ultiplying the first sum by 3 and adding the second yields 82. Subtract­
                                       ing 1 gives 81. The rem ainder upon dividing by 10 is I. W hen the rem ainder is subtracted
                                       from 9, the result is 8, which m atches the last digit o f th e original code. Y o u rjo b is to m od­
                                       ify the u p c . c program o f Section 4.1 so that it calculates the check digit for an EAN. The
                                       user will enter the first 12 diog its o f the EAN as a singo le num ber:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       Enter the first 12 digits of an EAN: 869148426000
                                       Check digit: 8
              5           S e le c t io n S ta te m e n t s                                                          ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                 P ro g ra m m e rs a re n o t to b e m e a s u re d b y th e ir in g e n u ity a n d
                                                                    th e ir lo g ic b u t b y th e c o m p le te n e s s o f th e ir c a s e a n a ly s is .




                                                 Although C has many operators, it has relatively few statements. We’ve encoun-
  r e t u r n s t a t e m e n t BA   > 2 .2      teredjust two so far: the r e t u r n statement and the expression statement. Most of
                                                 C 's remaining statements fall into three categories, depending on how they affect
e x p r e s s io n s t a t e m e n t > 4 .5onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 the order in which statements are executed:cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             ■ Selection statem ents. The i f and s w i t c h statements allow a program to
                               select a particular execution path from a set of alternatives.
                             ■ Iteration statem ents. The w h i l e . d o, and f o r statements support iteration
                               (looping).
                             ■ J u m p statem ents. The b r e a k . c o n t i n u e , and g o t o statements cause an
                               unconditional jum p to some other place in the program. (The r e t u r n state­
                               ment belongs in this category, as well.)

                          The only other statements in C are the compound statement, which groups several
                          statements into a single statement, and the null statement, which performs no
                          action.
                               This chapter discusses the selection statements and the compound statement.
                          (Chapter 6 covers the iteration statements, thejum p statements, and the null state­
                          ment.) Before we can write i f statements, we’ll need logical expressions: condi­
                          tions that i f statements can test. Section 5.1 explains how logical expressions are
                          built from the relational operators (<. <=, >. and >=). the equality operators (==
                          and ’ =), and the logical operators (&&, | | , and !). Section 5.2 covers the i f state­
                          ment and compound statement, as well as introducing the conditional operator
                          (? :). which can test a condition within an expression. Section 5.3 describes the
                          s w i t c h statement.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                                                                       73
74ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 5   S e le c tio n S ta te m e n ts aZYXWVUTSRQPONMLKJIHGFEDCBA




                        5.1       L o g ic a l E x p r e s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  Several of C ’s statements, including the i f statement, must test the value of an
                                  expression to see ifit is “true" or ‘'false." Forexam ple, an i f statement might need
                                  to test the expression i < j ; a true value would indicate that i is less than j . In
                                  many programming languages, an expression such as i < j would have a special
                                  “Boolean” or “logical” type. Such a type would have only two values, fa           ls e and
                                                                                                                cbaZYXWVUTSRQPONMLKJI

                                  true. In C, however, a comparison such as i < j yields an integer: either 0 (false)
                                  or 1 (true). With this in mind, let’s look at the operators that are used to build logi­
                                  cal expressions.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  R e la tio n a l O p e r a to r s

                                  C ’s rela tio n a l operators (Table 5.1) correspond to the <, >, <, and > operators of
                                  mathematics, except that they produce 0 (false) or I (true) when used in expres­
                                  sions. For example, the value o f 10 < 11 is I ; the value o f 11 < 10 is 0.

                   T a b le 5.1                                    Sym bol               M e a n in g
      Relational Operators RQPONMLKJIHGFEDCBA                          <       less than
                                                                       >       awrealer than
                                                                      <=       less than or equal to
                                                                      >=       greater than or equal to


                                      The relational operators can be used lo compare integers and floating-point
                                  numbers, with operands of mixed types allowed. Thus, 1 < 2 . 5 has the value 1,
                                  while 5 . 6 < 4 has the value 0.
                                      The precedence of the relational operators is lower than that of the arithmetic
                                  operators; forexam ple, i + j < k - 1 means ( i + j ) < (k - 1 ) . The relational
                                  operators are left associative.


                                  The expression
                                  i < j < k

                                  is legal in C. but doesn’t have the meaning that you might expect. Since the < oper­
                                  ator is left associative, this expression is equivalent to

                                  (i < j ) < k

                                  In other words, the expression first tests whether i is less than j ; the 1 or 0 pro­
                                  duced by this comparison is then compared to k. The expression does not test
                                  whether j lies between i and k. (W e’ll see later in this section that the correct
                                  expression would be i < j && j < k.)
                                                                                      5 .1                                                   7 5 dcbaZYXWVUTSRQPO
                                                                                                 L o g ic a l E x p r e s s io n s hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                         E q u a lity O p e r a to r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         Although the relational operators are denoted by the same sym bols as in many
                                                              equality operators have a unique appearance
                         other programming languages, the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         (Table 5.2). The “equal to” operator is two adjacent = characters, not one, since a
                         single = character represents the assignm ent operator. The “not equal to” operator
                         is also two characters: ! and =.

        T a b le 5 .2                                             Sym bol         M e a n in g
Equality Operators                                                   ==         equal to
                                                                     !=         not equal to

                             Like the relational operators, the equality operators are left associative and
                         produce either 0 (false) or l (true) as their result. However, the equality operators
                         have low er precedence than the relational operators. For example, the expression kjihgfedcbaZYXWVUTSRQ
                         i < j == j < k

                         is equivalent to
                         (i < j) ==          (j < k)

                         which is true if i < j and j < k are both true or both false.
                              Clever programmers som etim es exploit the fact that the relational and equality
                         operators return integer values. For exam ple, the value of the expression ( i >= j )
                         + ( i == j ) is either 0, 1. or 2, depending on whether i is less than, greater than,
                         or equal to j , respectively. Tricky coding like this generally isn’t a good idea, how­
                         ever; it makes programs hard to understand.


                         L o g ic a l O p e r a to r s
                         M ore complicated logical expressions can be built from sim pler ones by using the
                         lo gical operators: and, or, and n o t (Table 5.3). The ! operator is unary, while &&
                         and | | are binary.

         T a b le 5 .3                                          Sym bol           M e a n in g
 Logical Operators                                                  i         logical negation
                                                                   &&         logical a n d
                                                                   II         logical or

                              The logical operators produce either 0 or 1 as their result. Often, the operands
                         will have values of 0 or 1, but this isn’t a requirement; the logical operators treat
                         any nonzero operand as a true value and any zero operand as a false value.
                              The logical operators behave as follows:
                           ■ ! expr has the value 1 if ex p r has the value 0.
                           ■ e x p rl && expr2 has the value 1 if the values of e x p rl and expr2 are both non­
                             zero.
           C h a p te r 5    S e le c tio n S ta te m e n ts cbaZYXWVUTSRQPONMLKJIHGFEDCBA
7 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                          e x p rl | | expr2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                              has the value 1 ifeith er e x p r l or expr2 (or both) has a nonzero
                                          value.
                                    In all other cases, these operators produce the value 0.
                                         Both && and | | perform “short-circuit” evaluation of their operands. That is,
                                    these operators first evaluate the left operand, then the right operand. I'fthe value of
                                    the expression can be deduced from the value of the left operand alone, then the
                                    right operand isn 't evaluated. Consider the following expression:kjihgfedcbaZYXWVUTSRQPONMLKJIHG

                                     (i != 0) && (j / i > 0)

                                    To find the value o f this expression, we must first evaluate ( i ! = 0 ) . If i isn’t
                                    equal to 0, then w e’ll need to evaluate ( j / i > 0) to determ ine w hether the entire
                                    expression is true or false. However, if i is equal to 0, then the entire expression
                                    must be false, so there’s no need to evaluate ( j / i > 0 ) . The advantage of short-
                                    circuit evaluation is apparent— without it. evaluating the expression would have
                                    caused a division by zero.


                                    Be wary o fsid e effects in logical expressions. Thanks to the short-circuit nature of
                         A          the && and | | operators, side effects in operands may not always occur. Consider
                                    the following expression:
                                    i > 0 && ++j > 0

                                    Although j is apparently increm ented as a side effect ofevaluating the expression,
                                    that isn’t always the case. If i > 0 is false, then + + j > 0 is not evaluated, so j isn’t
                                    increm ented. The problem can be fixed by changing the condition to + + j > 0 &&
                                    i > 0 or, even better, by incrementing j separately.


                                         The ! operator has the same precedence as the unary plus and m inus opera­
                                    tors. The precedence of && and | | is lower than that of the relational and equality
                                    operators; for example, i < j && k == m means ( i < j ) && (k == m ). The !
                                    operator is right associative; && and | | are left associative.aZYXWVUTSRQPONMLKJIHGFEDCBA




                         5 .2       T h e i f S ta te m e n t

                                    The i f statem ent allows a program to choose between two alternatives by testing
                                    the value of an expression. In its sim plest form, the i f statem ent has the form


             i f s ta te m e n t                                      if    ( expression     ) statem ent


                                    Notice that the parentheses around the expression are mandatory; they’re part of
                                    the i f statement, not part of the expression. Also note that the word t h e n doesn’t
                                    come after the parentheses, as it would in som e program m ing languages.
                                                                                    5.2    The i f S ta te m e n t       77 onmlkjihgfedcbaZYXWV

                                   When an i f statem ent is executed, the expression in the parentheses is evalu­
                              ated; if the value of the expression is nonzero— which C interprets as true— the
                              statement after the parentheses is executed. H ere’s an example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              if    (line_num == MAX_LINES)
                                   line_num = 0;

                              The statem ent l i n e _ n u m = 0 ; is executed if the condition l i n e _ n u m ==
                              MAX_LINES is true (has a nonzero value).


                              D on’t confuse == (equality) with = (assignm ent). The statement

                              if    (i == 0) ...

                              tests whether i is equal to 0. However, the statem ent

                              if    (i = 0) ...aZYXWVUTSRQPONMLKJIHGFEDCBA

                              assigns 0 to i . then tests whether the result is nonzero. In this case, the test always
                              fails.
                                    Confusing == with = is perhaps the most com m on C program m ing error,
                              probably because = means “is equal to” in m athem atics (and in certain program ­
                              ming languages). Some compilers issue a warning ifth ey notice = where == would
                    Q&A       norm ally appear.


                                  Often the expression in an i f statem ent will test w hether a variable falls
                              within a range of values. To test whether 0 < i < n , for exam ple, w e’d write

                   id io m    if    (0 <= i && i < n) ...

                              To test the opposite condition ( i is outside the range), w e’d write

                   id io m    if    (i < o | | i >= n) ...

                              Note the use of the | | operator instead of the && operator.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                              C o m p o u n d S ta te m e n ts

                              In our i f statement template, notice that sta tem en t is singular, not plural:

                              if    ( expression ) statement

                              W hat ifw e want an i f statement to control fnw or more statem ents? T hat’s where
                              the c o m p o u n d sta te m e n t comes in. A com pound statem ent has the form


com p ou nd s ta te m e n t                                         { statem ents    }


                              By putting braces around a group ofstatem ents, we can force the com piler to treat
                              it as a single statement.
78        C h a p te r 5   S e le c tio n S ta te m e n ts hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
  ZYXWVUTSRQPONMLKJIHGFEDCBA




                                      Here's an example o fa compound statement:

                                { line_num = 0; page_num++; }

                                For clarity, FI1 usually put a compound statement on several lines, with one state­
                                ment per line:


                                   line_num = 0;
                                   page_num+ + ;


                                Notice that each inner statement still ends with a semicolon, but the compound
                                statement itselfdoes not.
                                     Here’s what a compound statement would look like when used inside an i f
                                statement:

                                if (line_num == MAX_LINES)                       {
                                  line_num = 0;
                                  page_num++;
                                }

                                Compound statements are also common in loops and other places where the syntax
                                o fC requires a single statement; but wc want more than one.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                T h e else C la u s e

                                An i f statement may have an e l s e clause:


     i f s ta te m e n t w ith                                    ( expression ) statem ent e l s e
                                                           i f cbaZYXWVUTSRQPONMLKJIHGFEDCBA          statem ent
            e l s e c la u s e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                The statement that follows the word e l s e is executed ifth e expression in paren­
                                theses has the value 0.
                                     Here’s an example o fan i f statement with an e l s e clause:

                                if (i > j)
                                  max = i ;
                                else
                                  max = j ;

                                Notice that both “in n er 1 statements end with a semicolon.
                                      When an i f statement contains an e l s e clause, a layout issue arises: where
                                should the e l s e be placed? Many C programmers align it with the i f at the
                                beginning of the statement; as in the previous example. The inner statements are
                                usually indented, but if theyTe short they can be put on the same line as the i f and
                                e ls e :

                                if (i > j) max = i;
                                else max = j ;
                                                       5 .2                                           79
                                                              T h e i f S t a t e m e n t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


     There are no restrictions on what kind of statements can appear inside an i f
statement. In fact, it's not unusual for i f statements to be nested inside other i f
statements. Consider the following i f statement, which fmds the largest of the
numbers stored in i , j , and k and stores that value in max:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

if (i > j)
  if (i > k)
     max = i ;
  else
     max = k ;
else
  if (j > k)
     max = j ;
  else
     max = k ;

i f statements can be nested to any depth. Notice how aligning each e l s e with the
matching i f makes the nesting easier to see. If you still find the nesting confusing,
don’t hesitate to add braces:
if (i > j) {
  if (i > k)
    max = i ;
  else
    max = k;
} else {
  if (j > k)
    max = j ;
  else
    max = k;


Adding braces to statements— even when they’re not necessary— is like using
parentheses in expressions: both techniques help make a program more readable
while at the same time avoiding the possibility that the compiler won’t understand
the program the way we thought it did.
     Some programmers use as many braces as possible inside i f statements (and
iteration statements as well). A programmer who adopts this convention would
include a pair of braces for every i f clause and every e l s e clause:
if (i > j) {
  if (i > k) {
    max = i ;
  } else {
    max = k ;

} else {
  if (j > k) {
    max = j ;
  } else {
    max = k;
80 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 5     S e le c tio n S ta te m e n ts


                                   Using braces even when they’re not required has two advantages. First, the pro­
                                   gram becom es easier to modify, because more statements can easily be added to
                                   any i f or e l s e clause. Second, it helps avoid errors that can result from forget­
                                   ting to use braces when adding statements to an i f or e l s e clause.dcbaZYXWVUTSRQPONMLKJIHGF


                                   C a s c a d e d i f S ta te m e n ts

                                   W e’ll often need to test a series of conditions, stopping as soon as one of them is
                                   true. A *'cascaded” i f statement is often the best way to write such a series of
                                   tests. For example, the following cascaded i f statement tests whether n is less
                                   than 0, equal to 0, or greater than 0:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   if (n < 0)
                                     printf("n is less than 0\n");
                                   else
                                     if (n == 0)
                                        printf("n is equal to 0\n");
                                     else
                                        printf("n is greater than 0\n");

                                   Although the second i f statement is nested inside the first, C program m ers don’t
                                   usually indent it. Instead, they align each e l s e with the original i f :

                                   if (n < 0)
                                     printf("n is less than 0\n");
                                   else if (n == 0)
                                     printf("n is equal to 0\n");
                                   else
                                     printf("n is greater than 0\n");

                                   This arrangement gives the cascaded i f a distinctive appearance:

                                       ( expression )
                                   if PONMLKJIHGFEDCBA
                                     statement
                                   else if ( expression )
                                     statement

                                   else if ( expression )
                                     statement
                                   else
                                     statement

                                   The last two lines ( e l s e statement) aren't always present, of course. This way of
                                   indenting the cascaded i f statement avoids the problem ofexcessive indentation
                                   when the num ber of tests is larO ge. Moreover,1 it assures the reader that the statement
                                   is nothingo more than a series of tests,
                                         Keep in mind that a cascaded i f statement isn’t some new kind ofstatem eni:
                                   it’sju s t an ordinary i f statem ent that happens to have another i f statement as its
                                   e l s e clause (and that i f statement has another i f statement as its e l s e clause,
                                   ad infinitum).
                                                                           5.2      The i f StatementhgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                               81 dcbaZYXWVUTSR


PROGRAM      C a lc u la t in g a B r o k e r ’s C o m m is s io n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
             When slocks ai'e sokl or purchased through a broker, the broker’s com m ission is
             often computed using a sliding scale that depends upon the value o f the stocks
             traded. L et’s say that a broker charges the am ounts shown in the following table:cbaZYXWVUTSRQPONM
                  Transaction size              Com m ission rate
                  Under $2,500                  $30 + 1.7%
                  $2,500-$6,250                $56 + 0.66%
                  $6,250-$20,000               $76 + 0.34%
                  $20,000-$50,000              $ 100 + 0.22%
                  $50,000-$500,000             $ 155 + 0.11 %
                  Over $500,000                $255 + 0.09%
             The minim um charge is $39. Our next program asks the user to enter the am ount of
             the trade, then displays the amount of the com mission:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

             Enter value of trade: 30000
             Commission: $166.00

             The heart of the program is a cascaded i f statem ent that determ ines which range
             the trade falls into.
  broker.c   /* Calculates a broker’s commission */

             #include <stdio.h>

             int main(void)

                float commission, value;

                printf("Enter value of trade: ”);
                scanf("%f", &value);

                if (value < 2500.00f)
                  commission = 30.00f + .017f * value;
                else if (value < 6250.00f)
                  commission = 56.00f + .0066f * value;
                else if (value < 20000.00f)
                  commission = 76.00f + .0034f * value;
                else if (value < 50000.00f)
                  commission = 100.00f + .0022f * value;
                else if (value < 500000.00f)
                  commission = 155.00f + .0011f * value;
                else
                  commission = 255.00f + .0009f * value;

                if (commission < 39.00f)
                  commission = 39.00f;

                printf("Commission: $%.2f\n”, commission);

                return 0;
8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 5     S e le c tio n S ta te m e n ts onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         The cascaded i f statement could have been written this way instead (the
                                     changes are indicated in dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                              b o ld ): kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      if (value < 2500.00f)
                                        commission = 30.00f + .017f * value;
                                      else if (value >- 2500.00f && value < 6250.00f)
                                        commission = 56.00f + .0066f * value;
                                      else if (value >= 6250.00f && value < 20000.00f)
                                        commission = 76.00f + .0034f * value;


                                     Although the program will still work, the added conditions aren’t necessary. For
                                     example, the first i f clause tests w h e th e r v a l u e is less than 2500 and, ifso . com ­
                                     putes the com m ission. When we reach the second i f test ( v a l u e >= 2 5 0 0 . 0 0 f
                                     && v a l u e < 6 2 5 0 . 0 0 f ) , we know that v a l u e can’t be less than 2500 and
                                     therefore must be greater than or equal to 2500. The condition v a l u e >=
                                     2 50 0 . 0 0 f will always be true, so there's no point in checking it.


                                     T h e “ D a n g lin g e l s e ” P r o b le m
                                     When i f statem ents are nested,*w e’ve ^2/0t 10 wCa^atchK
                                                                                              rf*out for the notorious “dangling
                                     e l s e ” problem. Consider the following example:

                                      if (y != 0)
                                        if (x != 0)
                                           result = x / y;
                                      else
                                        printf("Error: y is equal to 0\n");

                                     To which i f statement does the e l s e clause belon O                          gO
                                                                                              g ? The indentation su wgests
                                     that it belongs to the outer i f statement. However, C follows the rule that an e l s e
                                     clause belongs to the nearest i f statem ent that hasn’t already been paired with an
                                     e l s e . In this example, the e l s e clause actually belongs to the inner i f state­
                                     ment, so a correctly indented version would look like this:

                                      if (y 1= 0)
                                        if (x != 0)
                                          result = x / y;
                                        else
                                          printf("Error: y is equal to 0\n");

                                     To make the e l s e clause part of the outer i f statem ent, we can enclose the inner
                                     i f statem ent in braces:

                                      if (y != 0) {
                                        if (x 1= 0)
                                          result = x / y;
                                      } else
                                          printf("Error: y is equal to 0\n");

                                     This exam ple illustrates the value o fb races; if w e’d used them in the original i f
                                     statement, we w ouldn’t have gotten into this situation in the first place.
                                                                                        5 .2                                         8 3 dcbaZYXWVUTSRQPO
                                                                                                 T h e i f S ta te m e n t hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                      C o n d itio n a l E x p r e s s io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      C ’s i f statement allows a program to perform one of two actions depending on the
                                                                      operator that allows an expression to pro­
                      value of a condition. C also provides an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                      duce one of two values depending on the value of a condition.
                            The c o n d itio n a l operator consists o f two symbols (? and :), which must be
                      used together in the following way.aZYXWVUTSRQPONMLKJIHGFEDCBA


c o n d it io n a l                                          e x p ri   ? expr2       : expr3
e x p r e s s io n

                      exprJ, expr2, and expr3 can be expressions of any type. The resulting expression is
                      said to be a co n d itio n a l exp ressio n . The conditional operator is unique am ong C
                      operators in that it requires three operands instead o fo n e or two. For this reason, it
                      is often referred to as a ternary operator.
                            The conditional expression e x p r l ? expr2 : expr3 should be read “if e x p rl
                      then expr2 else e x p r3 " The expression is evaluated in stages: e x p rl is evaluated
                      first; if its value isn’t zero, then expr2 is evaluated, and its value is the value of the
                      entire conditional expression. Lf the value of e x p rl is zero, then the value of expr3
                      is the value of the conditional.
                            The following example illustrates the conditional operator:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      int i , j , k ;

                      i = 1;
                      j = 2,-
                      k = i > j ? i : j;                                   /* k is now 2 */
                      k = (i >= 0 ? i : 0) + j;                            /* k is now 3 */

                      The conditional expression i > j ? i : j in the first assignment to k returns the
                      value of either i or j , depending on which one is larger. Since i has the value I
                      and j has the value 2, the i > j com parison fails, and the value o f the conditional
                      is 2, which is assigned to k. In the second assignment to k, the i >= 0 com parison
                      succeeds; the conditional expression ( i >= 0 ? i : 0) has the value I, which is
                      then added to j lo produce 3. The parentheses are necessary, by the way; the prece­
                      dence of the conditional operator is less than that of the other operators w e’ve dis­
                      cussed so far, with the exception o fth e assignment operators.
                            Conditional expressions tend to make programs shorter but harder to under­
                      stand, so it’s probably best to avoid them. There are, however, a few places in
                      which they’re tempting; one is the r e t u r n statement. Instead of writing

                      if (i > j)
                        return i ;
                      else
                        return j ;

                      many programmers would write

                      return i > j ? i : j ;
8 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 5    S e le c t io n S t a t e m e n t s


                                              Calls o f p r i n t f can som etim es benefit from condition expressions. Instead ofkjihgfedcbaZ

                                              if (i > j)
                                                printf("%d\n", i);
                                              else
                                                printf("%d\n"/ j);

                                              we could simply write
                                              printf("%d\n", i > j ? i : j);aZYXWVUTSRQPONMLKJIHGFEDCBA

          m a c r o d e fin itio n s > /< 3   Conditional expressions are also common in certain kinds o fm acro definitions.dcbaZYXWVUT


                                              B o o le a n V a lu e s in C 8 9

                                              For many years, the C language lacked a proper Boolean type, and there is none
                                              defined in the C89 standard. This omission is a minor annoyance, since many pro­
                                              grams need variables that can store either/tf/se or tru e . One way to work around
                                              this limitation o fC 8 9 is to declare an i n t variable and then assign it either 0 or 1:
                                              int flag;

                                              flag = 0;
                                              • ••
                                              flag = 1;

                                              Although this schem e works, it doesn’t contribute much to program readability.
                                              It’s not obvious that f l a g is to be assigned only Boolean values and that 0 and 1
                                              represent false and true.
                                                   To make programs m ore understandable, C89 programmers often define mac­
                                              ros with names such as TRUE and FALSE:
                                              # define TRUE 1
                                              # define FALSE 0

                                              Assignments to f l a g now have a more natural appearance:
                                              flag = FALSE;

                                              flag = TRUE;

                                                   To test whether f l a g is true, we can write
                                              if (flag == TRUE) ...

                                              o rju st

                                              if (flag) ...

                                              The latter form is better, not only because it’s more concise, but also because it will
                                              still work correctly if f l a g has a value other than 0 or 1.
                                                    To test whether f l a g is false, we can write
                                              if (flag == FALSE) ...
                                                                                                    5.2     The i f State me nthgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                                         85 onmlkjihgfedcbaZYXW


                                                 or kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 if (1 flag) ...

                                                     Carrying this idea one step further, we might even define a macro that can be
                                                 used as a type:

                                                 #define BOOL int

                                                 BOOL can take the place of i n t when declaring Boolean variables:

                                                 BOOL flag;

                                                 It's now clear that f l a g isn’t an ordinary integer variable, but instead represents a
                                                 Boolean condition. (The compiler still treats f l a g as an i n t variable, of course.)
             t y p e d e fin it io n s > 7 . 5   In later chapters, w e’ll discover better ways to set up a Boolean type in C89 by
             e n u m e r a t io n s > 7 6 . 5    using type definitions and enumerations.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                 <%p>            B o o l e a n V a lu e s in RQPONMLKJIHGFEDCBA
                                                                             C 99

                                                 The longstanding lack of a Boolean type has been remedied in C99, which pro­
                                  Q&A            vides the _ B o o l type. In this version o fC , a Boolean variable can be declared by
                                                 writine^

                                                 _Bool flag;

   u n s ig n e d in te g e r ty p e s > 7 j                                                              unsig ned integer type), so a
                                                      _ B o o l is an integer type (more precisely, an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 _ B o o l variable is really just an integer variable in disguise. Unlike an ordinary
                                                 integer variable, however, a _ B o o l variable can only be assigned 0 or 1. In gen­
                                                 eral. attempting to store a nonzero value into a _ B o o l variable will cause the vari­
                                                 able to be assigned 1:

                                                 flag = 5;              /* flag is assigned 1 */

                                                 l f s legal (although not advisable) to perform arithmetic on _ B o o l variables; it’s
                                                 also legal to print a _ B o o l variable (either 0 or 1 will be displayed). And. of
                                                 course, a _ B o o l variable can be tested in an i f statement:

                                                 if (flag)              /* tests whether flag is 1 */


                                                       In addition to defining the _ B o o l type, C99 also provides a new header,
< s td b o o i.h > h e a d e r > 2 t5            < s t d b o o l . h > . that makes it easier to work with Boolean values. This header
                                                 provides a macro, b o o l , that stands for _ B o o l. If < s t d b o o l .h > is included,
                                                 we can write

                                                 bool flag;               /★    same as _Bool flag; */

                                                 The < s t d b o o l . h > header also supplies macros named t r u e and f a l s e ,
                                                 which stand for 1 and 0, respectively, making it possible to write
            C h a p te r 5
8 6 ZYXWVUTSRQPONMLKJIHGFEDCBA S e le c tio n S ta te m e n ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          flag = false;

                                          flag = true;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                          Because the < s t d b o o l . h> header is so handy, I’ll use it in subsequent programs
                                          whenever Boolean variables are needed.aZYXWVUTSRQPONMLKJIHGFEDCBA



                              5 .3        T h e s w i t c h S ta te m e n t
                                           ln everyday programming, w e’ll often need to com pare an expression against a
                                          series of values to see which one it currently matches. We saw in Section 5.2 that a
                                          cascaded i f statement can be used for this purpose. For exam ple, the following
                                          cascaded i f statement prints the English word that corresponds to a numerical
                                          ograde:
                                          if (grade == 4)
                                            printf (’’Excellent") ;
                                          else if (grade == 3)
                                            printf("Good");
                                          else if (grade == 2)
                                            printf("Average");
                                          else if (grade == 1)
                                            printf("Poor");
                                          else if (grade == 0)
                                            printf("Failing");
                                          else
                                            printf("Illegal grade");

                                          As an alternative to this kind of cascaded i f statem ent, C provides the s w i t c h
                                          statement. The following s w i t c h is equivalent to our cascaded i f :

                                          switch (grade) {
                                            case 4: printf("Excellent");
                                                     break;
                                            case 3: printf("Good");
                                                     break;
                                            case 2: printf("Average");
                                                     break;
                                            case 1: printf("Poor");
                                                     break;
                                            case 0: printf("Failing");
                                                     break;
                                            default: printf("Illegal grade");
                                                     break;


                                          When this statem ent is executed, the value o fth e variable g r a d e is tested against
                                          4, 3, 2, 1, and 0. If it matches 4, for example, the m essage E x c e l l e n t is printed,
          b re a k s ta te m e n t> & 4   then the b r e a k statement transfers control to the statem ent following the
                                          s w i t c h . If the value of g r a d e doesn’t match any of the choices listed, the
                                          d e f a u l t case applies, and the message I l l e g a l g r a d e is printed.
                                                                                        5 .3                                                   87 aZYXWVUTSRQPONML
                                                                                                 T h e s w i t c h S ta te m e n t onmlkjihgfedcbaZYXWVUTSRQPONMLKJ

                                          A s w i t c h statement is often easier to read than a cascaded i t statement.
                                       Moreover, s w i t c h statements are often faster than i f statements, especially
                                       when there are more than a handful ofcases.
                         Q&A              In its most common form, the s w i t c h statement has the form


s w i t c h s ta te m e n t                               s w i t c h ( expression ) {
                                                                         constant-expression
                                                             c a s e cbaZYXWVUTSRQPONMLKJIHGFEDCBA      statem ents

                                                              c a s e constant-expression            : statem ents
                                                              d e f a u l t : statem ents



                                       The s w i t c h statement is fairly complex; let’s look at its com ponents one by one:

                                        ■ C o n tro llin g expressio n. The word s w i t c h must be followed by an integer
            c h a ra c te rs > 7 . 3      expression in parentheses. Characters are treated as integers in C and thus can
                                          be tested in s w i t c h statements. Floating-point numbers and strings don’t
                                          qualify, however.
                                        ■ Case labels. Each case begins with a label of the form kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                constant-expression :
                                           case PONMLKJIHGFEDCBA

                                           A c o n sta n t expression is much like an ordinary expression except that it can’t
                                           contain variables or function calls. Thus, 5 is a constant expression, and 5 +
                                           10 is a constant expression, but n + 10 isn't a constant expression (unless n is
                                           a macro that represents a constant). The constant expression in a case label
                                           must evaluate to an integer (characters are also acceptable).
                                        ■ S ta tem en ts. After each case label comes any num ber of statements. No braces
                                          are required around the statements. (Enjoy it— this is one of the few places in
                                          C where braces aren’t required.) The last statement in each group is normally
                                          b re a k .

                                       Duplicate case labels aren’t allowed. The order o fth e cases doesn’t matter; in par­
                                       ticular, the d e f a u l t case doesn’t need lo com e last.
                                            Only one constant expression may follow the word c a s e ; however, several
                                       case labels may precede the same group of statements:

                                       switch (grade) {
                                         case 4:
                                         case 3:
                                         case 2:
                                         case 1: printf("Passing");
                                                  break;
                                         case 0: printf("Failing");
                                                  break;
                                         default; printf("Illegal grade");
                                                  break;
88 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 5     S e le c tio n S ta te m e n ts


                                   To save space, programmers som etim es pul several case labels on the same line:kjihgfedc

                                   switch (grade) {
                                     case 4: case 3: case 2: case 1:
                                              printf("Passing");
                                              break;
                                     case     printf("Failing");
                                              break;
                                     default: printf("Illegal grade");
                                              break;


                                   Unfortunately, there’s no way to write a case label that specifies a range o f values,
                                   as there is in some programming languages.
                                        A s w i t c h statement isn’t required to have a d e f a u l t case, l f d e f a u l t is
                                   missing and the value of the controlling expression doesn’t match any o f the case
                                   labels, control simply passes to the next statement after the s w i t c h .dcbaZYXWVUTSRQPONMLKJIH


                                   T h e R o le o f th e b r e a k S ta te m e n t

                                   Now, let’s take a closer look at the m ysterious b r e a k statem ent. As w e’ve seen,
                                   executing a b r e a k statement causes the program to “break” out of the s w i t c h
                                   statement; execution continues at the next statem ent after the s w i t c h .
                                        The reason that we need b r e a k has to do with the fact that the s w i t c h state­
                                   ment is really a form of “computed jum p.” When the controlling expression is
                                   evaluated, control jum ps to the case label matching the value of the s w i t c h
                                   expression. A case label is nothing morc than a marker indicating a position within
                                   the s w i t c h . When the last statement in the case has been executed, control “ falls
                                   through” to the first statement in the following case: the case label for the next case GFEDCB
                                          K^'                                        ^^


                                   is ignored. Without b r e a k (o rso m e oth erju n ip statem ent), control will flow from
                                   one case into the next. Consider the following s w i t c h statement:
                                                                                     ^




                                   switch (grade) {
                                     case 4: printf("Excellent");
                                     case 3: printf("Good");
                                     case 2: printf("Average");
                                     case 1: printf("Poor");
                                     case 0: printf("Failing");
                                     default: printf("Illegal grade");


                                   If the value of g r a d e is 3, the message printed is

                                   GoodAveragePoorFailingIllegal grade


                                   Forgetting to use b r e a k is a com m on error. Although om itting b r e a k is some­

                        A          times done intentionally to allow several cases to share code, it’s usually just an
                                   oversight.
                                            k»»
                                                                      5 .3   The s w i t c h S ta te m e n t hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                       8 9 onmlkjihgfedcbaZYXW


                      Since deliberately falling through from one casc into the next is rare, it?s a
                  good idea to point out any deliberate omission o f b r e a k :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                  switch (grade) {
                    case 4: case 3: case 2: case 1:
                             num_passing++;
                             /* FALL THROUGH */
                    case 0: total_grades++;
                             break;


                  Without the comment, someone might later fix the “error” by adding an unwanted
                  b r e a k statement.
                        Although the last case in a s w i t c h statement never needs a b r e a k state­
                  ment, it’s common practice to put one there anyway to guard against a “missing
                  b r e a k ” problem ifcases should later be added.


                   P r i n tin g a D a t e in L e g a l F o r m
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  Contracts and other legal documents are often dated in the following way:cbaZYXWVUTSRQPONMLKJIHGFEDCB

                  D ated th is                day o               f      ,2 0 .

                  Let’s write a program that displays dates in this form. We'll have the user enter the
                  date in month/day/year form, then we'll display the date in “legal" form:
                  Enter date (mm/dd/yy): 7/19/14
                  Dated this 19th day of July, 2014.
                  We can get p r i n t f to do most of the formatting. However, w e’re left with two
                  problems: how to add “th” (or “st” or “nd” or “rd") to the day. and how to print the
                  month as a word instead o f a number. Fortunately, the s w i t c h statement is ideal
                  for both situations; w e’ll have one s w i t c h print the day suffix and another print
                  the month name.BA
       date.C     /* Prints a date in legal form */

                  #include <stdio.h>

                  int main(void)

                     int month, day, year;

                     printf("Enter date (mm/dd/yy): ”);
                     scanf("%d /%d /%d", &month, &day, &year);

                     printf("Dated this %d”, day);
                     switch (day) {
                       case 1: case 21: case 31:
                         printf("st”); break;
                       case 2: case 22:
                         printf("nd"); break;
90 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 5     S e le c tio n S ta te m e n ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            case 3: case 23:
                                              p r i n t f ("rd”) ; break;
                                            default: printf("th"); break;

                                         printf(" day of ") ;

                                          switch      (month) {
                                            case      1 : printf (’’January”) ;                       break;
                                            case      2 : printf (’’February”) ;                      break;
                                            case      3 : p r i n t f ("March");                      break;
                                            case      a • p r i n t f ("April");                      break;
                                            case      5: p r i n t f ("May”);                         break;
                                            case      6: p r i n t f ("June”) ;                       break;
                                            case      7 : p r i n t f ("July”);                       break;
                                            case      8 : printf (’’August ”) ;                       break;
                                            case      9: p r i n t f ("September”);                   break;
                                            case      10 : printf (’’October”) ;                      break;
                                            case      11: p r i n t f ("November");                   break;
                                            case      12 : printf <"December");                       break;


                                          printf(”, 20%.2d.\n",                   year);
                                          return 0;


                                          Note the use of %. 2 d to display the last two digits of the year. If we had used
                                     %d instead, single-digit years would be displayed incorrectly (2005 would be
                                     printed as 2 05).aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      M y c o m p ile r d o e s n ’t g iv e a w a r n in g w h e n I u s e = in s te a d o f = = . I s th e r e so m e
                                     w a y to fo r c e th e c o m p ile r to n o tic e th e p r o b le m ? [p . 7 7 ]
                             A:      Here’s a trick that some programmers use: instead of writing
                                     if     (i == 0) ...

                                     they habitually write
                                     if     (0 == i) ...

                                     Now suppose that the == operator is accidentally written as =:
                                     if     (0 = i) ...

                                     The compiler will produce an error message, since it’s not possible to assign a
                                     value to 0 . 1 d o n \ use this trick, because I think it makes programs look unnatural.
                                     Also, it can be used only when one of the operands in the test condition isn’t an
                                     lvalue.
                                          Fortunately, many compilers are capable of checking for suspect uses of the =
                                     operator in i f conditions. The GCC compiler, for example, will perform this
                                                                                                                       91
                                                                                                   Q & A onmlkjihgfedcbaZYXWVUTSRQPONM


     check if the - W p a r e n t h e s e s option is used or if - W a ll (all warnings) is
     selected. GCC allows the programmer to suppress the warning in a particular case
     by enclosing the i f condition in a second set of parentheses:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
     if ((i = j)) ...dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q:   C b o o k s s e e m to u se s e v e r a l d iffe r e n t s ty le s o f in d e n ta tio n a n d b r a c e p la c e ­
     m e n t fo r c o m p o u n d s ta te m e n ts . W h ic h s ty le is b e st?
A:                 The New H acker’s D ictionary (Cambridge, Mass.: MIT Press, 1996),
     According to cbaZYXWVUTSRQPONMLKJIHGFEDCBA
     there are four common styles of indentation and brace placement:
               ■       The K&R style, used in Kemighan and Ritchie’s The C Program m ing L a n ­
                       guage, is the one I’ve chosen for the programs in this book. In the K&R style,
                       the left brace appears at the end of a line:
                       if (line_num == MAX_LINES)             {
                         line_num = 0;
                         page_num++;


                       The K&R style keeps programs compact by not putting the left brace on a line
                       by itself. A disadvantage: the left brace can be hard to find. (I don’t consider
                       this a problem, since the indentation of the inner statements makes it clear
                       where the left brace should be.) The K&R style is the one most often used in
                       Java, by the way.
                   ■   The Allm an style, named after Eric Allman (the author of s e n d m a i l and
                       other UNIX utilities), puts the left brace on a separate line:
                       if (line_num == MAX_LINES)

                         line_num = 0;
                         page_num++;


                       This style makes it easy to check that braces come in matching pairs.
       ■               The W hitesmiths style, popularized by the Whitesmiths C compiler, dictates
                       that braces be indented:
                       if (line_num == MAX_LINES)

                         1ine_num = 0;
                         page_num++;


           ■           The G NU style, used in software developed by the GNU Project, indents the
                       braces, then further indents the inner statements:
                       if (line_num == MAX_LINES)

                            line_num = 0;
                            page_num++;
92 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 5     S e le c tio n S ta te m e n ts onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          W hich style you use is mainly a m atter of taste: there’s no proof that one style
                                     is clearly better than the others. In any event, choosing the right style is less im por­
                                     tant than applying it consistently.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      I f i is an i n t v a r ia b le a n d f is a f l o a t v a r ia b le , w h a t is th e ty p e o f th e c o n ­
                                     d itio n a l e x p r e ss io n ( i > 0 ? i     : f )?
                             A:      When i n t and f l o a t values are mixed in a conditional expression, as they are
                                     here, the expression has type f l o a t . If i > 0 is true, the value o fth e expression
                                     will be the value of i after conversion to f l o a t type.

                             Q:      W h y d o e s n ’t C 9 9 h a v e a b e tte r n a m e fo r its B o o le a n ty p e ? [p . 8 5 ]
                             A:      _ B o o l isn’t a very elegant name, is it? M ore com m on names, such as b o o l or
                                     b o o l e a n , w eren’t chosen because existing C program s m ight already define
                         <ffi>       these names, causing older code not to compile.

                             Q:      O K , so w h y w o u ld n ’t th e n a m e        B o o l b r e a k o ld e r p r o g r a m s a s w e ll?
                             A:      The C89 standard specifies that names beginning with an underscore followed by
                                     an uppercase letter are reserved for future use and should not be used by program ­
                                     mers.

                           *Q :      T h e te m p la te g iv e n fo r th e s w i t c h s ta te m e n t d e s c r ib e d it a s th e “ m o s t c o m ­
                                     m o n fo r m .” A r e th e r e o th e r fo r m s ? [p. 8 7 ]
                             A:      The s w i t c h statem ent is a bit more general than described in this chapter,
                                     although the description given here is general enough for virtually all programs.
                      iabeis>&4      For exam ple, a s w i t c h statem ent can contain labels that aren ’t preceded by the
                                     word c a s e , which leads to an am using (?) trap. Suppose that we accidentally mis­
                                     spell the word d e f a u l t :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     switch (...) {
                                       •••
                                       defualt: ...


                                     The com piler may not detect the error, since it assum es that d e f u a l t is an ordi­
                                     nary label.

                             Q:      I ’v e se e n s e v e r a l m e th o d s o f in d e n tin g th e s w i t c h s ta te m e n t. W h ic h w a y is
                                     b e st?
                             A:      There are at least two com m on methods. One is to put the statem ents in each case cbaZYXWV
                                     a f te r the case label:

                                     switch (coin) {
                                       case 1: printf("Cent");
                                                break;
                                       case 5: printf("Nickel");
                                                break;
                                       case 10: printf("Dime");
                                                break;
                                                                                             E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                       9 3 onmlkjihgfedcbaZYX


                            c ase 25: p r in tf ( " Q u a r te r " ) ;
                                      b re a k ;


                         If each case consists of a single action (a call of p r i n t f , in this exam ple), the
                         b r e a k statem ent could even go on the same line as the action:

                         s w itc h (c o in ) {
                            c a se 1:    p r in tf ( " C e n t" ) ; b re a k ;
                            c a s e 5:   p r in tf ( " N ic k e l" ) ; b re a k ;
                            c a s e 10: p r in tf ( " D im e " ) ; b re a k ;
                            c a se 25: p r in tf ( " Q u a r te r " ) ; b re a k ;


                                                                         u n d er the case label, indenting the
                              The other method is to put the statements cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         statements to make the case label stand out:

                         s w itc h (c o in ) {
                            c a s e 1:
                                p r i n t f ( ”C e n t” ) ;
                                b re a k ;
                            c a s e 5:
                                p r i n t f ( " N ic k e l” );
                                b re a k ;
                            c a s e 10:
                                p r i n t f ( " D im e " ) ;
                                b re a k ;
                            c a se 25:
                                p r i n t f ( " Q u a rte r" );
                                b re a k ;


                         In one variation of this schem e, each case label is ali ^gwned under the word s w i t c h ,
                              The first method is fine when the statem ents in each case are short and there
                         are relatively few of them. The second method is better for large s w i t c h state­
                         ments in which the statem ents in each case are complex and/or numerous.aZYXWVUTSRQPONMLKJIHGFED




                         E x e r c is e s

S e c t io n 5 .1   l.   The following program fragments illustrate the relational and equality operators. Show the
                         output produced by each, assuming that i . j . and k are i n t variables.
                         (a) i = 2 ; j = 3 ;
                             k = i * j == 6 ;
                             p r i n t f ( "% d ", k ) ;
                         (b) i = 5 ; j = 1 0 ; k = 1 ;
                             p rin tf(" % d " , k > i < j ) ;
                         (C) i = 3 ; j = 2 ; k = 1 ;
                             p r i n t f ( " % d " , i < j == j < k ) ;
                         (d) i = 3 ; j - 4 ; k = 5 ;
                             p r i n t f ( " % d " , i % j 4- i < k ) ;
94 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r5     S e le c tio n S ta te m e n ts aZYXWVUTSRQPONMLKJIHGFEDCBA


                      ©     2.    The following program fragments illustrate the logical operators. Show the output produced
                                  by each, assuming that i , j ? and k are i n t variables.
                                   (a) i = 1 0 ; j = 5 ;
                                       p rin tf(" % d " , !i < j ) ;
                                   (b) i = 2 ; j = 1 ;
                                       p rin tf(" % d " , l ! i + ! j ) ;
                                   (c) i = 5 ; j = 0 ; k = - 5 ;
                                       p r i n t f ( " % d " , i && j | | k ) ;
                                   (d) i = 1 ; j = 2 ; k = 3 ;
                                       p rin tf(" % d " , i < j || k );

                           *3.    The following program fragments illustrate the short-circuit behavior of logical expressions.
                                  Show the output produced by each, assuming that i , j . and k are i n t variables.
                                   (a) i = 3 ; j =          4; k = 5;
                                       p rin tf(" % d       ” , i < j | | ++j < k) ;
                                       p rin tf(" % d       %d % d", i , j , k ) ;
                                   (b) i = 7 ; j =          8; k = 9;
                                       p rin tf(" % d       ” , i - 7 && j+ + < k ) ;
                                       p rin tf(" % d       %d % d", i , j , k ) ;
                                   (C) i = 7 ; j =          8; k = 9;
                                       p rin tf(" % d       ", ( i = j) | | (j = k ) ) ;
                                       p rin tf(" % d       %d % d", i , j , k ) ;
                                   (d) i = 1 ; j =          1; k = 1;
                                       p rin tf(" % d       " , + + i | | + + j && +4-k) ;
                                       p rin tf(" % d       %d % d", i , j , k ) ;

                       © *4.       Write a single expression whose value is e ith e r-1 , 0, or + 1, depending on whether i is less
                                   than, equal to, or greater than j , respectively.

S e c t io n 5 .2          *5.     Ts the following i f statement legal?
                                   if     (n >= 1 < = 10)
                                        p r i n t f ( " n i s b e tw e e n 1 a n d 1 0 \ n " ) ;
                                   Tf so. what does it do when n is equal to 0?

                       © *6.       is Lhe following i f statement legal?
                                   if     (n == 1 - 1 0 )
                                        p rin tf(" n is       b e tw e e n 1 a n d 1 0 \ n " ) ;
                                   lfs o , what does il do when n is equal to 5?

                             7.    W hat does the following statement print if i has the value 17? Whal does it print if i has lhe
                                   value -1 7 ?
                                   p rin tf(" % d \n " ,      i   >= 0 ? i       : -i);

                             8.    The following i f statement is unnecessarily complicated. Simplify it as much as possible.cbaZYXW
                                   (Hini: The entire statement can be replaced by a single assignment.)
                                   if      ( a g e >= 1 3 )
                                        i f ( a g e <= 19 )
                                             te e n a g e r = tr u e ;
                                       e ls e
                                             te e n a g e r = f a ls e ;
                                   e l s e i f ( a g e < 13)
                                        te e n a g e r = f a ls e ;
                                                                                                                                    95 onmlkjihgfedcbaZYXWVU
                                                                                        P ro g r a m m in g P r o je c ts hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                       9.   Are the following i f statements equivalent? If not, why not? kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                            if (score >= 90)                      if (score < 60)
                              printf(”A") ;                         printf(”F");
                            else if (score >= 80)                 else if (score < 70
                              printf("B") ;                         printf("D”);
                            else if (score >= 70)                 else if (score < 80
                              printf("C") ;                         printf("C");
                            else if (score >= 60)                 else if (score < 90
                              printf("D") ;                         printf("B”);
                            else                                  else
                              printf("F");                          printf("A");aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 5 .3   © *10.   What output does the following program fragment produce? (Assume that i is an integer
                            variable.)
                            i = 1;
                            switch (i % 3) {
                              case 0: printf("zero");
                              case 1: printf("one”);
                              case 2: printf("two");
                            }

                      11.   The following table shows telephone area codes in the state of Georgia along with the larg­
                            est city in each area;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                            Area code      M ajor city
                               229         Albany
                               404         Atlanta
                               470         Atlanta
                               478         Macon
                               678         Atlanta
                               706         Columbus
                               762         Columbus
                               770         Atlanta
                               912         Savannah

                            Write a s w i t c h statement whose controlling expression is the variable a r e a _ c o d e . Ifth e
                            value of a r e a _ c o d e is in the table, the s w i t c h statement will print the corresponding
                            city name. Otherwise, the s w i t c h statement will display the message " A r e a c o d e n o t
                            r e c o g n i z e d ” . Use the techniques discussed in Section 5.3 to make the s w i t c h state­
                            ment as simple as possible.




                            P r o g ra m m in g P r o je c ts

                       1.   Write a program that calculates how many digits a number contains:
                            Enter a number: 374
                            The number 374 has 3 digits
                            You may assume that the number has no more than four digits. Hint: Use i f statements to
                            test the number. For example, if the number is between 0 and 9, it has one digit. If the num­
                            ber is between 10 and 99, it has two digits.
96 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r5      S e le c tio n S ta te m e n ts cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                        tfi)   2.   W rite a program that asks lhc user for a 24-hour lime, then displays the time in 12-hour
                                    form:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    Enter a 24-hour time: 21:11
                                    Equivalent 12-hour time: 9:11 PM
                                     Be careful not to display 12:00 as 0:00.

                               3.   M odify the b r o k e r . c program o f Section 5.2 by making both of the following changes:
                                     (a) Ask (he user lo enter the number o fsh ares and the price per share, instead of the value
                                         o f the trade.
                                     (b) Add statem ents that compute the commission charged by a rival broker (533 plus 3tf per
                                         share for fewer than 2000 shares: $33 plus 2$j per share for 2000 shares or more). Dis­
                                         play the rival's commission as well as the commission charged by the original broker.hgfedcbaZY

                        LWJ          Here’s a simplified version of the Beaufort scale, which is used to estim ate wind force:
                                                            D escription
                                                            Calm
                                                            Li^a'hl air
                                                            Breeze
                                                            Galc
                                     48^53                  Storm
                                     Above 63               Hurricanc
                                     W rite a program that asks the user to enter a wind speed (in knots), then displays the corre­
                                     sponding description.

                               5.    In one state, single residents are subject to the following income tax:
                                    Incom e                  A m o u n t ofta.x
                                    Not over $750            I % of income
                                    $750-52.250              57.50         plus 2% of amount over $750
                                    $2,250-53.750            537.50        plus 3% of amount over $2,250
                                    $3,750-55.250            $82.50        plus 4% o f am ount over 53.750
                                    $5,250-57,000            5142.50 plus 5% of am ount over 55.250
                                    Over $7,000              $230.00 plus 6% o f amount over $7,000
                                     W rite a program that asks the user to enter the amount of taxable income, then displays the
                                     tax due.

                        ©      6.    Modify the u p c . c program of Section 4 . 1 so that il checks whether a UPC is valid. After
                                     the user enters a UPC, the program will display cither VALID or NOT VALID.

                               7.    W rite a program that finds the largest and smallest o ffo u r integers entered by the user:
                                     Enter four integers: 21 43 10 35
                                     Largest: 43
                                     Smallest: 10
                                     Use as few i f statem ents as possible. H int: Four i f statem ents are sufficient.

                               8.    The following table shows the daily flights from one city to another:
                                     D epartu re tim e       A rrival time
                                        8:00 a.m.             10:16 a.m.
                                        9:43 a.m.             11:52 a.m.
                                       ll:1 9 a .m .            1:31 p.m.
                                       12:47 p.m.               3:00 p.m.
                                                                                                                  97
                                                                      P ro g ra m m in g P ro je c ts onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


             2:00 p.m.            4:08 p.m.
             3:45 p.m.            5:55 p.m.
             7:00 p.m.            9:20 p.m.
             9:45 p.m.           11:58 p.m.
          W rite a program that asks user to enter a tim e (expressed in hours and minutes, using the 24-
          hour clock). The program then displays the departure and arrival times for the Hight whose
          departure lime is closest to that entered by the user:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          Enter a 24-hour time: 13:15
          Closest departure time is 12:47 p.m., arriving at 3:00 p.m.cbaZYXWVUTSRQPONMLKJIHGF
          H int: Convert the input into a lime expressed in minuies since midnighl. and com pare it to
          the departure tim es, also expressed in minutes since midnighl. For example. 13:15 is 13 X
          6 0 + 15 = 795 minutes since midnight, which is closer to 12:47 p.m. (767 m inutes since
          midnight) than to any o f the other departure limes.

     9.   W rite a program that prompts the user lo enter iwo dates and then indicates which dale
          comes earlier on the calendar:
          Enter first date (mm/dd/yy): 3/6/08
          Enter second date (mm/dd/yy): 5/17/07
          5/17/07 is earlier than 3/6/08

©   10.   Using the s w i t c h statement, write a program that converts a numerical grade into a letter
          grade:
          Enter numerical grade: 84
          Letter grade: B
          Use the following grading scale: A = 90-100, B = 80-89, C = 7 0 -7 9 . D = 60-69, F = 0 -59.
          Print an error messag*^e if the W            g^-er than 100 or less than«*.’0. H int: Break the grade
                                          g*rade is lar<
          into iwo digits, then use a s w i t c h statem ent to test the ten’s digit.

    11.   Write a program that asks the user for a two-digit number, ihen prints the English word for
          ihe number:
          Enter a two-digit number: 45
          You entered the number forty-five.
          H int: Break the num ber into two digits. Use one s w i t c h statem ent to print the word for the
          first digit (“tw enty:’ “thirty,” and so forth). Use a second s w i t c h statem ent to print the
          word for the sccond digit. D on’t forget that lhc num bers betw een 11 and 19 require special
          treatment.
6 Loops                  ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                       A p ro g ra m w ith o u t a lo o p a n d a s tru c tu re d
                                                                            v a ria b le is n 't w o rth w ritin g . onmlkjihgfedcbaZYX




      Chapter 5 covered C ’s selection statements, i f and s w i t c h . This chapter intro­
      duces C 's iteration statements, which allow us to set up loops.
            A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
              loop is a statement w hosejob is to repeatedly execute some other statement
      (the loop body). In C, every loop has a co n tro llin g expressio n. Each time the loop
      body is executed (an iteration of the loop), the controlling expression is evaluated;
      if the expression is true— has a value that’s not zero— the loop continues to exe­
      cute.
           C provides three iteration statements: w h i l e , d o , and f o r , which are cov­
      ered in Sections 6.1, 6.2, and 6.3, respectively. The w h i l e statement is used for
      loops whose controlling expression is tested before the loop body is executed. The
      d o statement is used ifth e expression is tested after the loop body is executed. The
      f o r statement is convenient for loops that increment or decrement a counting vari­
      able. Section 6.3 also introduces the comma operator, which is used primarily in
      f o r statements.
           The last two sections of this chapter are devoted to C features that are used in
      conjunction with loops. Section 6.4 describes the b r e a k , c o n t i n u e , and g o t o
      statements, b r e a k jum ps out of a loop and transfers control to the next statement
      after the loop, c o n t i n u e skips the rest of a loop iteration, and g o t o jum ps to
      any statement within a function. Section 6.5 covers the nulJ statement, which can
      be used to create loops with empty bodies.aZYXWVUTSRQPONMLKJIHGFEDCBA




6.1   T h e w h ile S ta te m e n t

      O f all the ways to set up loops in C. the w h i l e statement is Che simplest and most
      fundamental. The w h i l e statement has the form



                                                                                                                99
100 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 6    L o o p s aZYXWVUTSRQPONMLKJIHGFEDCBA



      w h i l e s ta te m e n t                                                        ( expression ) sta tem en t
                                                                          w h i l e cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                The expression inside the parentheses is the controlling expression; the statement
                                                after the parentheses is the loop body. Here’s an example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                while (i < n)            /* controlling expression */
                                                  i = i * 2;             /* loop body */

                                                Note that the parentheses are mandatory and that nothing goes between the right
                                                parenthesis and the loop body. (Some languages require the word do.)
                                                      When a w h i l e statement is executed, the controlling expression is evaluated
                                                first. If its value is nonzero (true), the loop body is executed and the expression is
                                                tested again. The process continues in this fashion— first testing the controlling
                                                expression, then executing the loop body— until the controlling expression eventu­
                                                ally has the value zero.
                                                      The following example uses a w h i l e statement to compute the smallest
                                                power of 2 that is greater than or equal to a number n:

                                                i = 1;
                                                while (i < n)
                                                  i = i * 2;

                                                Suppose that n has the value 10. The following trace shows what happens when
                                                the w h i l e statement is executed:

                                                i = 1;          i is now 1.
                                                ls i < n?       Yes; continue.
                                                i = i * 2;      i is now 2.
                                                Is i < n?       Yes; continue.
                                                i = i * 2;      i is now 4.
                                                Is i < n ?      Yes; continue.
                                                i = i * 2;      i is now 8.
                                                Is i < n ?      Yes; continue.
                                                i = i * 2;      i is now 16.
                                                Is i < n?       No; exit from loop.

                                                Notice how the loop keeps going as long as the controlling expression ( i < n) is
                                                true. When the expression is false, the loop terminates, and i is greater than or
                                                equal to n, as desired.
                                                      Although the loop body must be a single statement, that’s merely a technical­
                                                ity. If we want more than one statement, we can just use braces to create a single
      c o m p o u n d s ta te m e n ts > 5 .2   COmpOUnd Statement:

                                                while (i > 0) {
                                                  printf(”T minus %d and counting\n", i);
                                                            6.1                                              101onmlkjihgfedcbaZYXWV
                                                                    T h e w h i l e S t a t e m e n t kjihgfedcbaZYXWVUTSRQPONMLKJIHG


          Some programmers always use braces, even when they’re not strictly necessary:

          while (i < n) {             /* braces allowed, but not required */
            i = i * 2;


              As a second example, let’s trace the execution of the foUowing statements,
          which display a series o f “countdown” messages:dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

          i = 10;
          while (i > 0) {
            printf("T minus %d and counting\n", i);
            i-- ;


          Before the w h i l e statement is executed, the variable i is assigned the value 10.
          Since 10 is greater than 0, the loop body is executed, causing the message T
          m i n u s 10 a n d c o u n t i n g to be printed and i to be decrem ented. The condition
          i > 0 is then tested again. Since 9 is greater than 0, the loop body is executed once
          more. This process continues until the message T m in u s 1 a n d c o u n t i n g is
          printed and i becomes 0. The test i > 0 then fails, causing the loop to terminate.
               The countdown example leads us to make several observations about the
          w h i l e statement:

            ■ The c ontrolling expression is false when a w h i l e loop terminates. Thus,
               when a loop controlled by the expression i > 0 terminates, i must be less than
               or equal to 0. (Otherwise, w e’d still be executing the loop!)
            ■ The body of a w h i l e loop may not be executed at all. Since the controlling
                                     before lhe loop body is executed, it’s possible that the
               expression is tested cbaZYXWVUTSRQPONMLKJIHGFEDCBA
               body isn’t executed even once. If i has a negative or zero value when the
               countdown loop is first entered, the loop will do nothing.
            ■ A w h i l e sta tement can often be written in a variety of ways. For example, we
               could make the countdown loop more concise by decrem enting i inside the
               call o f p r i n t f :

 Q&A           while (i > 0)
                 printf("T minus %d and counting\n", i--);aZYXWVUTSRQPONMLKJIHGFEDCBA


          h if in it e L o o p s

          A w h i l e statement w on’t terminate if the controlling expression always has a
          nonzero value. In fact, C programmers sometimes deliberately create an in fin ite
          loop by using a nonzero constant as the controlling expression:

id io m   while (1) ...

          A w h i l e statement of this form will execute forever unless its body contains a
          statem ent that transfers control out of the loop ( b r e a k , g o t o , r e t u r n ) or calls a
          function that causes the program to terminate.
            C h a p te r 6 L o o p s
1 0 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                               P r i n ti n g a T a b le o f S q u a r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
             P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   Let’s write a program that prints a table of squares. The program will first prompt
                                   the user to enter a number nRQPONMLKJIHGFEDCBA
                                                                . It will then print n lines ofoutput, with each line con­
                                   taining a number between l and n together with its square:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   This program prints a table of squares.
                                   Enter number of entries in table: 5
                                            1         1
                                            2         4
                                            3         9
                                            4        16
                                            5        25

                                       Let’s have the program store the desired number of squares in a variable
                                   named n. We’ll need a loop that repeatedly prints a number i and its square, start­
                                   ing with i equal to 1. The loop will repeat as long as i is less than or equal to n.
                                   We’ll have to make sure to add 1 to i each time through the loop.
                                       We’ll write the loop as a w h i l e statement. (Frankly, we haven’t got much
                                   choice, since the w h i l e statement is the only kind of loop we’ve covered so far.)
                                   Here’s the finished program:

                  s q u a r e ,c   /* Prints a table of squares using a while statement */

                                   #include <stdio.h>

                                   int main(void)

                                       int i, n;

                                       printf("This program prints a table of squares.\n");
                                       printf("Enter number of entries in table: ”);
                                       scanf("%d", &n);

                                       i = 1;
                                       while (i <= n) {
                                         printf("%10d%10d\n",                 i z i * i);



                                       return 0;


                                         Note how s q u a r e . c displays numbers in neatly aligned columns. The trick
                                   is to use a conversion specification like %10d instead of just %d, taking advantage
                                   of the fact that p r i n t f right-justifies numbers when a field width is specified.


             PROGRAM               S u m m in g a S e r ie s o f N u m b e r s

                                   As a second example of the w h i l e statement, let’s write a program that sums a
                                   series of integers entered by the user. Here’s what the user will see:
                                                                           6 .2                                          103 kjihgfedcbaZYXWVU
                                                                                   T h e d o S t a t e m e n t onmlkjihgfedcbaZYXWVUTSRQPONMLK


                      This program sums a series of integers.
                      Enter integers (0 to terminate): 8 23 71 5 0
                      The sum is: 107

                      Clearly w e’ll need a loop that uses s c a n f to read a number and then adds the
                      number to a runningc> total,
                          Letting n represent the num berjust read and sum the total o fa ll numbers pre­
                      viously read, we end up with the following program:BA

          sum .c      /* Sums a series of numbers */

                      #include <stdio.h>

                      int main(void)

                         int n, sum = 0;

                        printf("This program sums a series of integers.\n");
                        printf("Enter integers (0 to terminate): ");

                         scanf("%d", &n);
                         while (n != 0) {
                           sum += n;
                           scanf(”%d", &n);

                        printf("The sum is: %d\n", sum);

                         return 0;


                      Notice that the condition n ! = 0 is testedjust after a number is read, allowing the
                      loop to terminate as soon as possible. Also note that there are two identical calls of
                      s c a n f , which is often hard to avoid when using w h i l e loops.aZYXWVUTSRQPONMLKJIHGFEDCBA




            6 .2      T h e d o S ta te m e n t

                      The d o statement is closely related to the w h i l e statement; in fact, the d o state­
                      ment is essentiallyjust a w h i l e statement whose controlling expression is tested cbaZYXWVUTSRQPONM
                      after each execution of the loop body. The d o statement has the form


d o s ta te m e n t                        d o statem ent    w h ile    ( expression       )   ;


                      As with the w h i l e statement, the body of a d o statement must be one statement
                      (possibly compound, of course) and the controlling expression must be enclosed
                      within parentheses.
                            When a d o statement is executed, the loop body is executed first, then the con­
                      trolling expression is evaluated. If the value of the expression is nonzero, the loop
1 04 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 6     Loops


                                body is executed again and then the expression is evaluated once more. Execution
                                o f the d o statem ent term inates when the controlling expression has the value 0 cbaZYX
                                a fte r the loop body has been executed.
                                       L et’s rewrite the countdown exam ple o f Section 6.1, using a d o statement this
                                time:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                i = 10;
                                do {
                                  printf("T minus %d and counting\n", i);
                                  --i;
                                } while (i > 0) ;

                                W hen the d o statem ent is executed, the loop body is first executed, causing the
                                message T m i n u s 10 a n d c o u n t i n g to be printed and i to be decremented.
                                The condition i > 0 is now tested. Since 9 is greater than 0, the loop body is exe­
                                cuted a second time. This process continues until the m essage T m i n u s 1 and
                                c o u n t i n g is printed and i becom es 0. The test i > 0 now fails, causing the loop
                                to term inate. As this exam ple shows, the d o statem ent is often indistinguishable
                                from the w h i l e statem ent. The difference between the two is that the body of a
                                d o statem ent is always executed at least once; the body of a w h i l e statement is
                                skipped entirely if the controlling expression is 0 initially.
                                     Incidentally, it’s a good idea to use braces in all d o statem ents, whether or not
                                they’re needed, because a d o statem ent without braces can easily be mistaken fora
                                w h i l e statement:

                                do
                                  printf("T minus %d and counting\n", i--);
                                while (i > 0) ;

                                A careless reader m ight think that the word w h i l e was the beginning of a w h ile
                                statement.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


             PROGRAM            C a l c u la tin g th e N u m b e r o f D ig its in a n I n te g e r

                                Although the w h i l e statem ent appears in C program s much more often than lhe
                                d o statem ent, the latter is handy for loops that m ust execute at least once. To illus­
                                trate this point, let’s write a program that calculates the num ber o f digits in an inte­
                                ger entered by the user:

                                Enter a nonnegative integer: 60
                                The number has 2 digit(s).

                                     O ur strategy will be to divide the user’s input by 10 repeatedly until it
                                becom es 0; the num ber of divisions perform ed is the num ber of digits. Clearly
                                w e’ll need some kind o flo o p , since we d o n ’t know how many divisions it will take
                                to reach 0. But should we use a w h i l e statem ent or a d o statem ent? The d o state­
                                ment turns out to be more attractive, because every integer— even 0— has at least
                                one digit. H ere’s the program:
                                                                               6 .3                                          105 BA
                                                                                      T h e f o r S t a t e m e n t hgfedcbaZYXWVUTSRQPONMLKJIHGF


    numdigits.c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                    /* Calculates the number of digits in an integer */

                        #include <stdio.h>

                        int main(void)

                           int digits = 0, n;

                          printf("Enter a nonnegative integer:                        ");
                          scanf("%d", &n);

                          do {
                            n /= 10;
                            digits++;
                          } while (n > 0);

                          printf("The number has %d digit(s).\n", digits);

                          return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                            To see why the d o statement is the right choice, let’s see what would happen if
                        we were to replace the d o loop by a similar w h i l e loop:
                        while (n > 0) {
                          n /= 10;
                          digits++;


                        I f n is 0 initially, this loop won’t execute at all, and the program would print
                        The number has 0 digit(s).aZYXWVUTSRQPONMLKJIHGFEDCBA




              6 .3      T h e f o r S ta te m e n t

                        We now come to the last o f C ’s loops: the f o r statement. D on’t be discouraged by
                        the f o r statement’s apparent complexity; it’s actually the best way to write many
                        loops. The f o r statement is ideal for loops that have a "counting” variable, but it’s
                        versatile enough to be used for other kinds of loops as well.
                             The f o r statement has the form


f o r s ta te m e n t                       for cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 ( exprJ ; expr2 ; expr3               ) statem ent


                        where ex p rl, expr2, and expr3 are expressions. Here’s an example:
                        for (i = 10; i > 0; i--)
                          printf("T minus %d and counting\n", i);

                        When this f o r statement is executed, the variable i is initialized to 10, then i is
                        tested to see if it’s greater than 0. Since il is, the message T m in u s 10 a n d
                                                ^**                     ^ r
106 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 6    Loops


                               c o u n t i n g is printed, then i is decremented. The condition i > 0 is then tested
                               again. The loop body will be executed 10 times in all, with i varying from 10
                               down to 1.
                                    The f o r statement is closely related to the w h i l e statement. In fact, except
                      Q&A      in a few rare cases, a f o r loop can always be replaced by an equivalent w h i l e
                               loop:PONMLKJIHGFEDCBA

                               exprl;kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                               while ( expr2 ) {
                                 statementdcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                               As this pattem shows, exprl is an initialization step that’s performed only once,
                               before the loop begins to execute, expr2 controls loop termination (the loop contin­
                               ues executing as long as the value of expr2 is nonzero), and expr3 is an operation
                               to be performed at the end ofeach loop iteration. Applying this pattern to our pre­
                               vious f o r loop example, we arrive at the following:

                               i = 10;
                               while (i > 0) {
                                 printf("T minus %d and counting\n",                 i);GFEDCBA
                                     1--;



                                    Studying the equivalent w h i l e statement can help us understand the fine
                               points o f a f o r statement. For example, suppose that we replace i - - by - - i in
                               our f o r loop example:

                               for (i = 10; i > 0; --i)
                                 printf("T minus %d and counting\n", i);

                               How does this change affect the loop? Looking at the equivalent w h i l e loop, we
                               see that it has no effect:

                               i = 10;
                               while (i > 0) {
                                 printf("T minus %d and counting\n",                 i);
                               } " ” 1 '*

                               Since the first and third expressions in a f o r statement are executed as statements,
                               their values are irrelevant— they’re useful only for their side effects. Consequently,
                               these two expressions are usually assignments or increment/decrement expres­
                               sions.


                               f o r S ta te m e n t I d io m s

                               The f o r statement is usually the best choice for loops that “count up” (increment
                               a variable) or “count down” (decrement a variable). A f o r statement that counts
                               up or down a total of n times will usually have one of the following forms:
                                                                                   6 .3                                           107 RQPONMLKJIHGFEDCBA
                                                                                          T h e f o r S t a t e m e n t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHG


          ■                                        0 to n - 1 :
                    C o u n t i n g u p f r o n i dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  for (i = 0; i < n,- i++) ...
id io m kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

              ■ C     o u n t i n g u p f r o m 1 to n :

id iom          for (i = 1; i <= n,- i++) ...

          ■ C         o u n t i n g d o w n f r o m n - 1 to 0;

id iom          for (i = n - 1; i >= 0; i--) ...

              ■ C     o u n t i n g d o w n f r o m n to 1;

id iom          for (i = n; i > 0; i--) ...
             Imitating these patterns will help you avoid some of the following errors,
         which beginning C programmers often make:

          ■ U sing < instead of > (or vice versa) in the controlling expression. Notice that
             “counting up” loops use the < or <= operator, while “counting down” loops
             rely on > or >=.
              ■ U sing == in the controlling expression instead of <, <=, >, or >=. A contfol-
                 ling expression needs to be true al the beginning o flh e loop, then later become
                 false so that the loop can terminate. A test such as i == n doesn’t make much
                 sense, because it w on’t be true initially.
              ■ “O ff-by-one” errors such as writing the controlling expression as i <= n
                 instead of i < n.


         O m ittin g E x p r e s s io n s in a f o r S ta t e m e n t

         The f o r statement is even more flexible than w e’ve seen so far. Som e f o r loops
         may not need all three of the expressions that normally control the loop, so C
         allows us to omit any or all of the expressions.
              If they7r.sv expression is omitted, no initialization is performed before the loop
         is executed:

         i = 10;
         for (; i > 0; --i)
           printf("T minus %d and counting\n", i);

         In this example, i has been initialized by a separate assignment, so w e’ve omitted
         the first expression in the f o r statement. (Notice that the semicolon between the
         first and second expressions remains. The two semicolons must always be present,
         even when w e’ve omitted some of the expressions.)
               If we omit the t h ir d expression in a f o r statement, the loop body is responsi­
         ble for ensuring that the value of the second expression eventually becomes false.
         Our f o r statement example could be written like this:

         for (i = 10; i > 0;)
           printf("T minus %d and counting\n", i--);
108 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 6     L o o p s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   To com pensate for omitting the third expression, w e’ve arranged for i to be decre­
                                   mented inside the loop body.
                                                  fir s t and third expressions are both omitted, the resulting loop is
                                       W hen the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   nothing more than a w h i l e statement in disguise. F orexam ple, the loop kjihgfedcbaZYXWVUTSRQPO

                                    for (; i > 0;)
                                      printf("T minus %d and counting\n", i--);

                                    is the same as

                                   while (i > 0)
                                     printf("T minus %d and counting\n", i--);

                                   The w h i l e version is clearer and therefore preferable.
                                        If the se co n d expression is missing, il defaults to a true value, so the f o r
                                   statem ent doesn’t term inate (unless stopped in some other fashion). For exam ple,
                         Q&A       some program m ers use the following f o r statem ent to establish an infinite loop:

                       id io m      for (;;) ...


                        <*ffi>      f o r S t a te m e n ts in C 9 9

                                   Tn C99, the first expression in a f o r statement can be replaced by a declaration.
                                   This feature allows the programmer to declare a variable for use by the loop:

                                    for (int i = 0; i < n; i++)


                                   The variable i need not have been declared prior to this statem ent, (ln fact, if a
                                   declaration of i already exists, this statem ent creates a new version of i that will
                                   be used solely within the loop.)
                                        A variable declared by a f o r statem ent can ’t be accessed outside the body of
                                   the loop (we say that it’s not visible outside the loop):

                                    for (int i = 0; i < n; i++) {
                                      •••
                                      printf("%d", i);   /* legal; i is visible inside loop */
                                      • ••

                                   printf("%d", i);                     /*** WRONG ***/

                                        Having a f o r statement declare its own control variable is usually a good
                                   idea: it’s convenient and it can make program s easier to understand. However, if
                                   the program needs to access the variable after loop term ination, it’s necessary to
                                   use the older form o f the f o r statement.
                                        Incidentally, a f o r statement may declare more than one variable, provided
                                   that all variables have the same type:

                                    for (int i = 0, j = 0; i < n; i++)
                                                                                                          6 .3   T h e f o r S t a t e m e n t hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                                                        109 dcbaZYXWVUTSRQPO


                                           T h e C o m m a O p e r a to r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           On occasion, we might like to write a f o r statement with two (or more) initializa­
                                           tion expressions or one that increments several variables each time through the
                                           loop. We can do this by using a co m m a exp ressio n as the first or third expression
                                           in the f o r statement.
                                                A com m a expression has the form aZYXWVUTSRQPONMLKJIHGFEDCBA


c o m m a e x p r e s s io n                                                             e x p rl   , expr2


                                           where e x p rl and expr2 are any two expressions. A com m a expression is evaluated
                                           in two steps: First, e x p rl is evaluated and its value discarded. Second, expr2 is
                                           evaluated; its value is the value of the entire expression. Evaluating e x p r l should
                                           always have a side effect; if it doesn’t, then e x p rl serves no purpose.
                                                 For example, suppose that i and j have the values l and 5, respectively. When
                                           thc com m a expression 4-4-i, i + j is evaluated, i is first incremented, then i 4- j
                                           is evaluated, so lhe value of the expression is 7. (And, of course, i now has the
                                           value 2.) The precedence of the comma operator is less than that o fa ll other opera­
                                           tors, by the way, so there\s no need to put parentheses around 4-4-i and i 4- j .
                                                 Occasionally, w e’ll need to chain together a series o fco m m a expressions,just
                                           as we sometimes chain assignments together. The com m a operator is left associa­
                                           tive, so the com piler interprets

                                           i    = 1,   j   = 2,       k = i     4- j

                                           as

                                           ( (i   = 1) f    (j       = 2) ) ,   (k =      (i   4- j ) )

                                           Since the left operand in a comma expression is evaluated before the right operand,
                                           thc assignments i = 1, j = 2, and k - i 4- j will be perform ed from left to right.
                                                The comma operator is provided for situations where C requires a single
                                           expression, but w e’d like to have two or more expressions. In other words, the
                                           comma operator allows us to “glue” two expressions together to form a single
                                           expression. (Note the similarity to the compound statement, which allows us to
                                           treat a group of statements as a single statement.)
                                                The need to glue expressions together doesn’t arise that often. Certain macro
     m a c r o d e fin i1 io n s > 7 < 3   definitions can benefit from the com m a operator, as w e’H see in a later chapter.
                                           The f o r statement is the only otherplace where the com m a operator is Hkely to be
                                           found. For example, suppose that we want to initialize two variables when entering
                                           a f o r statement. Instead ofwi*iting

                                           sum = 0 ;
                                           fo i' ( i = 1;        i    <= N ;    i4-4-)
                                              su m 4-= i ;

                                           we can write
            C h a p te r 6     L o o p s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
1 1 0 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                       for (sum = 0, i = 1; i <= N; i + +)
                                         sum += i;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      The expression sum = 0 1 i = 1 first assigns 0 to sum , then assigns 1 to i . With
                                      additional commas, the f o r statement could initialize more than two variables.


                                   P r in tin g a T a b le o f S q u a r e s (R e v is ite d )
                P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      The s q u a r e . c program (Section 6.1) can be improved by converting its w h i l e
                                      loop to a f o r loop:BA

                   square2.c           /* Prints a table of squares using a for statement */

                                       #include <stdio.h>

                                       int main(void)

                                           int i , n ;

                                          printf("This program prints a table of squares.\n");
                                          printf("Enter number of entries in table: ”);
                                          scanf(”%d", &n);

                                           for (i = 1; i <= n; i++)
                                             printf("%10d%10d\n", i, i * i);

                                          return 0;


                                           We can use this program to illustrate an important point about the f o r state­
                                      ment: C places no restrictions on the three expressions that control its behavior.
                                      Although these expressions usually initialize, test, and update the same variable,
                                      there\s no requirement that they be related in any way. Consider the following ver­
                                      sion of the same program:

                   square3.c           /* Prints a table of squares using an odd method */

                                      #include <stdio.h>

                                       int main(void)

                                          int i, n, odd, square;

                                          printf("This program prints a table of squares.\n");
                                          printf("Enter number of entries in table: ”);
                                          scanf(”%d", &n);

                                          i = 1;
                                          odd = 3;
                                          for (square = 1; i <= n; odd += 2) {
                                            printf( ,'%10d%10d\n”, i, square);
                                            ++i;
                                                                                   6 .4                                     111
                                                                                          E x itin g fro m a L o o p kjihgfedcbaZYXWVUTSRQPONMLKJ


                                 square += odd;


                              return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                           The f o r statement in this program initializes one variable ( s q u a r e ) , tests
                           another ( i) , and increments a third (odd), i is the number to be squared, s q u a r e
                           is the square of i , and o d d is the odd number that must be added to the current
                           square to get the next square (allowing the program to compute consecutive
                           squares without performing any multiplications).
                                 The tremendous flexibility of the f o r statement can sometimes be useful;hgfedcbaZYXWVU
iin k e d iis ts > /7 .5   we’ll find it to be a great help when working with linked lists. The f o r statement
                           can easily be misused, though, so don’t go overboard. The f o r loop in
                           s q u a r e 3 . c would be a lot clearer if we rearranged its pieces so that the loop is
                           clearly controlled by i .aZYXWVUTSRQPONMLKJIHGFEDCBA




              6 .4         E x itin g fr o m a L o o p

                           We’ve seen how to write loops that have an exit point before the loop body (using
                           w h i l e and f o r statements) or after it (using d o statements). Occasionally, how­
                           ever, we’ll need a loop with an exit point in the middle. We may even want a loop
                           to have more than one exit point. The b r e a k statement makes it possible to write
                           either kind of loop.
                                After we’ve examined the b r e a k statement, we'll look at a couple of related
                           statements: c o n t i n u e and g o t o . The c o n t i n u e statement makes it possible to
                           skip part of a loop iteration w ithoutjum ping out of the loop. The g o t o statement
                           allows a program tojum p from one statement to another. Thanks to the availability
                           ofstatem ents such as b r e a k and c o n t i n u e , the g o t o statement is rarely used.dcbaZYXWVUTSRQ


                           T h e b r e a k S ta te m e n t
                           We’ve already discussed how a b r e a k statement can transfer control out of a
                           s w i t c h statement. The b r e a k statement can also be used to jum p out of a
                           w h i l e , d o , or f o r loop.
                                Suppose that we’re writing a program that checks whether a number n is
                           prime. Our plan is to write a f o r statement that divides n by the numbers between
                           2 and n - 1. We should break out of the loop as soon as any divisor is found;
                           there’s no need to try the remaining possibilities. After the loop has terminated, we
                           can use an i f statement to determine whether termination was premature (hence n
                           isn’t prime) or normal (n is prime):

                           for (d = 2; d < n; d++)
                             if (n % d == 0)
                               break;
112 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 6    L o o p s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     if (d < n)
                                       printf("%d is divisible by %d\n", n, d);
                                     else
                                       printf("%d is prime\n", n);

                                         The b r e a k statement is particularly useful for writing loops in which the exit
                                     point is in the middle of the body rather than at the beginning or end. Loops that
                                     read user input, terminating when a particular value is entered, often fall into this
                                     category:

                                     for (;;) {
                                       printf("Enter a number (enter 0 to stop): ");
                                       scanf (”%d", &n) ;
                                       if (n == 0)
                                         break;
                                       printf("%d cubed is %d\n”, n, n * n * n);


                                                                                               innerm ost enclosingG* w h i l e ,
                                          A b r e a k statement transfers control out of the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    d o , f o r , or s w i t c h statement. Thus, when these statements are nested, the
                                    b r e a k statement can escape only one level of nesting. Consider the case of a
                                    s w i t c h statement nested inside a w h i l e statement:

                                    while (...) {
                                      switch (...) {
                                        •••
                                        break;




                                    The b r e a k statement transfers control out of the s w i t c h statement, but not out
                                    of the w h i l e loop. I'll return to this point later.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    T h e c o n t i n u e S ta te m e n t

                                    The c o n t i n u e statement doesn’t really belong here, because it doesn’t exit from
                                    a loop. It's similar to b r e a k . though, so its inclusion in this section isn’t com­
                                    pletely arbitrary, b r e a k transfers control just past the end of a loop, while
                                    c o n t i n u e transfers control to a point just before the end of the loop body. With
                                    b r e a k , control leaves the loop: with c o n t i n u e , control remains inside the loop.
                                    There's another difference between b r e a k and c o n t i n u e : b r e a k can be used
                                    in s w i t c h statements and loops ( w h i l e , d o , and f o r ) , whereas c o n t i n u e is
                                    limited to loops.
                                          The following example, which reads a series of numbers and computes their
                                    sum, illustrates a simple use o f c o n t i n u e . The loop terminates when 10 nonzero
                                    numbers have been read. Whenever the number 0 is read, the c o n t i n u e state­
                                    ment is executed, skipping the rest of the loop body (the statements sum 4-= i ;
                                    and n + + ;) but remaining inside the loop.
                                                                                                        6 .4                                       113
                                                                                                                E x it in g fro m a L o o p kjihgfedcbaZYXWVUTSRQPONMLKJI


                                                  n = 0;
                                                  sum = 0;
                                                  while (n < 10) {
                                                    s c a n f ("%d", & i ) ;
                                                    if (i == 0)
                                                       continue;
                                                    sum += i ;
                                                    n++ ;
                                                    /* continue jumps to here */onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                  If c o n t i n u e were not available, we could have written the exam ple as follows:

                                                  n = 0;
                                                  sum = 0;
                                                  while (n < 10) {
                                                    scanf (•'% d ” , & i ) ;
                                                    if (i != 0) {
                                                      sum += i;
                                                      n++ ;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                  T h e g o t o S ta te m e n t

                                                  b r e a k and c o n t i n u e a re ju m p statements that transfer control from one point
                                                  in the program to another. Both are restricted: the target of a b r e a k is a po in tju stcbaZYXWVUTSRQPON
                                                  beyond the end of the enclosing loop, while the target of a c o n t i n u e is a point
                                                  just before the end of the loop. The g o t o statement, on the other hand, is capable
                                                  ofjum ping to any statement in a function, provided that the statement has a label,
                                                  (C99 places an additional restriction on the g o t o statement: il can’t be used to
 v a r ia b le - le n g t h a r r a y s > 3 . 3   bypass the declaration o f a variable-length array.)
                                                        A label is just an identifier placed at the beginning of a statement:


la b e le d s t a t e m e n t                                                      id entifier    : statem ent


                                                  A statement may have more than one label. The g o t o statement itselfhas the form


   g o t o s t a t e m e n t ZYXWVUTSRQPONMLKJIHGFEDCBA                              g o to      identifier ;


                                                  Executing the statement g o t o L ; transfers control to the statement that follows
                                                  the label L, which must be in the same function as the g o t o statement itself.
                                                       If C didn’t have a b r e a k statement, here’.s how we might use a g o t o state­
                                                  ment to exit prematurely from a loop:

                                                  for (d = 2; d < n; d++)
                                                    if (n % d == 0)
                                                      goto d o n e ;
114 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 6    L o o p s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  done:
                                  if (d < n)
                                    printf("%d is divisible by %d\n", n, d);
                                  else
                                    printf("%d is prime\n", n);

                                                 The g o t o statement, a staple of older programming languages, is rarely
                                           needed in everyday C programming. The b r e a k , c o n t i n u e , and r e t u r n state- hgfedcbaZYX
                                 Q&A kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
             e x it f u n c t io n > 9 . 5 ments— which are essentially restricted g o t o statements— and the e x i t function
                                           are sufficient to handle most situations that might require a g o t o in other lan­
                                           guages.
                                                 Nonetheless, the g o t o statement can be helpful once in a while. Consider the
                                           problem of exiting a loop from within a s w i t c h statement. As we saw earlier, the
                                           b r e a k statement doesn’t quite have the desired effect: it exits from the s w i t c h ,
                                           but not from the loop. A g o t o statement solves the problem:
                                  while (...) {
                                    switch (...) {
                                         •«•
                                         goto loop_done;               /* break w o n ’t work here ★ /



                                  loop_done: ...

                                  The g o t o statement is also useful for exiting from nested loops.


              PROGRAM             B a la n cin g a C h eck b o o k
                                  Many simple interactive programs are menu-based: they present the user with a list
                                  ofcom m ands to choose from. Once the userhas selected a command, the program
                                  performs the desired action, then prompts the user for another command. This pro­
                                  cess continues until the user selects an “exit” or “quit” command.
                                       The heart of such a program will obviously be a loop. Inside the loop will be
                                  statements that prompt the user for a command, read the command, then decide
                                  what action to take:
                                  for (;;) {PONMLKJIHGFEDCBA
                                    prompt user to enter command*,
                                    read command;
                                    execute command;


                                  Executing the command will require a s w i t c h statement (or cascaded i f state­
                                  ment):
                                  for (;;) {
                                    prompt user to enter command;
                                    read command;
                                    switch (command) {
                                       case command\-. performoperation^; break;
                                                              6 .4                                     115
                                                                     E x itin g fro m a L o o p kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


                    case PONMLKJIHGFEDCBA
                         com.mandz' performoperatioih; break;

                    case commandn ' . performoperationn ; break;
                    defaul t : print e.rrormessage; break;
             }   }onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                   To illustrate this arrangement, let’s develop a program that maintains a check­
             book balance. The program will offer the user a menu of choices: clear the account
             balance, credit money to the account, debit money from the account, display the
             current balance, and exit the program. The choices are represented by the integers
             0, 1, 2, 3, and 4, respectively. Here’s whal a session with the program will look
             like:

             *** ACME checkbook-balancing program ***
             Commands: 0=clear, l=credit, 2=debit, 3=balance, 4=exit

             Enter command: 1
             Enter amount of credit: 1042.56
             Enter command: 2
             Enter amount of debit: 133.79
             Enter command: 1
             Enter amount of credit: 1754.32
             Enter command: 2
             Enter amount of debit: 1400
             Enter command: 2
             Enter amount of debit: 68
             Enter command: 2
             Enter amount of debit: 50
             Enter command: 3_
             Current balance: $1145.09
             Enter command: 4

                  When the user enters the command 4 (exit), the program needs to exit from the
             s w i t c h statement cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    and the surrounding loop. The b r e a k statement w on’t help,
             and we’d prefer not to use a g o t o statement. Instead, w e’ll have the program exe­
             cute a r e t u r n statement, which will cause the m a in function to return to the
             operating system.BA

checking.c   /* Balances a checkbook */

             #include <stdio.h>

             int main(void)

                 int cmd;
                 float balance = 0.0f, credit, debit;

                 printf(”*** ACME checkbook-balancing program ***\n");
                 printf("Commands: 0=clear, l=credit, 2=debit, ");
                 printf(”3=balance, 4=exit\n\n");
116 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 6    L o o p s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       for (;;) {
                                         printf("Enter command; ");
                                         s c a n f ("%d", & c m d ) ;
                                         switch (cmd) {
                                            case 0:
                                                balance - 0.0f;
                                                break;
                                            case 1:
                                                printf("Enter amount of credit: ”);
                                                scanf("%f", &credit);
                                                balance += credit;
                                                break;
                                            case 2:
                                                printf("Enter amount of debit: ");
                                                s c a n f ("%f”, &debit);
                                                balance -= debit;
                                                break;
                                            case 3:
                                                printf("Current balance: $%.2f\n’, / balance);
                                                break;
                                            case 4:
                                                return 0;
                                            default:
                                                printf("Commands: O=clear, l=credit, 2=debit,                     ");
                                                printf("3=balance, 4=exit\n\n");
                                                break;
                                         }
                                       }


                                    Note that the r e t u r n statement is not followed by a b r e a k statement. A b r e a k
                                    immediately following a r e t u r n can never be executed, and many compilers will
                                    issue a warningo messagC?e,aZYXWVUTSRQPONMLKJIHGFEDCBA




                         6 .5       T h e N u ll S t a t e m e n t

                                    A statement can be n u l l — devoid of symbols except for the semicolon at the end.
                                    Here’s an example:

                                    i = 0;       ; j = 1;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    This line contains three statements: an assi<g_'nment to i . a null statement, and an
                                    assignment to j .
                         Q&A             The null statement is primarily good for one thing: writing loops whose bodies
                                    are empty. As an example, recall the prime-finding loop ofSection 6.4:

                                    for (d = 2; d < n; d+ + )
                                      if (n % d == 0)
                                        break;
                                                                                              6 .5                                             117
                                                                                                     T h e N u l l S t a t e m e n t onmlkjihgfedcbaZYXWVUTSRQPONMLK


                                        If we move the n % d == 0 condition into the loop’s controlling expression, the
                                        body o fth e loop becomes empty:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        for (d = 2; d < n && n % d != 0; d++)
                                          /* empty loop body */ ;

                                        Each time through the loop, the condition d < n is tested first; if it’s false, the loop
                                        terminates. Otherwise, the condition n % d ’ = 0 is tested, and if that’s false, the
                                        loop terminates. (In the lattercase. n % d == 0 must be true: in other words, w e’ve
                                        found a divisor o fn .)
                                            Note how w e’ve put the null statement on a line by itself, instead ofw ritin g

                                        for (d = 2; d < n && n % d != 0; d++);

                          Q&A           C programmers customarily put the null statement on a line by itself. Otherwise,
                                        someone reading the program might get confused about whether the statement
                                        after the f o r was actually its body:

                                        for (d = 2; d < n && n % d ’= 0; d++);
                                        if (d < n)
                                          printf("%d is divisible by %d\n", n, d);

                                             Converting an ordinary loop into one with an empty body doesn’t buy much:
                                        the new loop is often more concise but usually no more efficient. In a few cases,
                                        though, a loop with an empty body is clearly superior to the alternatives. For exam- aZYXWVUTSRQPONM
re a d in g c h a r a c te r s > z .3   ple. w e’Il find these loops to be handy for reading character data.


                                        Accidentally putting a semicolon after the parentheses in an i f , w h i l e , or f o r
                         A              statement creates a null statement, thus ending the i f , w h i l e . or f o r prem a­
                                        turely.
                                             ■   In an i f statement, putting a semicolon after the parentheses creates an i f
                                                 statement that apparently performs the same action regardless of the value of
                                                 its controlling expression:

                                                 if (d == 0);                                                   /*** WRONG ***/
                                                   printf("Error: Division by zero\n");

                                                 The call o f p r i n t f isn’t inside the i f statement, so it’s performed regardless
                                                 of whether d is equal to 0.

                                         ■       In a w h i l e statement, putting a semicolon after the parentheses may create
                                                 an infinite loop:

                                                 i = 10;
                                                 while (i > 0) ;                           /*** WRONG ***/
                                                 {
                                                   printf("T minus %d and counting\n", i);
118 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 6    Loops


                                     A nother possibility is that the loop term inates, but the statem ent that should be
                                     the loop body is executed only once, after the loop has terminated:kjihgfedcbaZYXWVUTSRQPONMLK
                                     i = 11;
                                     while (--i > 0);                          /*** WRONG ***/
                                       printf("T minus %d and counting\n", i);

                                     This exam ple prints the m essage

                                     T minus 0 and counting

                                ■ I n a f o r statement, putting a semicolon after the parentheses causes the state­
                                    ment that should be the loop body to be executed only once:
                                     for (i = 10; i > 0; i--);                 /*** WRONG ***/
                                       printf("T minus %d and counting\n", i);

                                     This exam ple also prints the message

                                     T minus 0 and countingaZYXWVUTSRQPONMLKJIHGFEDCBA




                              Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                       Q:     T h e fo ll o w in g lo o p a p p e a r s in S e c ti o n 6 .1 :

                              while (i > 0)
                                printf("T minus %d and counting\n", i--);

                              W h y n o t s h o r te n th e lo o p e v e n m o r e b y r e m o v in g th e “ > 0 ” te s t ?

                              while (i)
                                printf("T minus %d and counting\n", i--);

                              T h is v e r s io n w ill s t o p w h e n i r e a c h e s 0 , s o it s h o u ld b e j u s t a s g o o d a s th e
                              o r ig in a l , [p . 1 0 1 ]
                        A:    The new version is certainly more concise, and many C program m ers would write
                              the loop in just this way. It does have drawbacks, though.
                                   First, the new loop is not as easy to read as the original. It’s clear that the loop
                              will term inate when i reaches 0, but it’s not obvious w hether w e’re counting up or
                              down. In the original loop, that inform ation can be deduced from the controlling
                              expression, i > 0.
                                   Second, the new loop behaves differently than the original if i should happen
                              to have a negative value when the loop begins to execute. The original loop term i­
                              nates immediately, but the new loop doesn’t.

                       Q:     S e c ti o n 6 .3 s a y s th a t, e x c e p t in r a r e c a s e s , f o r lo o p s c a n b e c o n v e r te d to
                              w h i l e lo o p s u s in g a s t a n d a r d p a t te r n . C a n y o u g iv e a n e x a m p le o f s u c h a
                              c a s e ? [p . 1 0 6 ]
                                                                                                                 119onmlkjihgfedcbaZYXWV
                                                                                                   Q & A kjihgfedcbaZYXWVUTSRQPONMLKJIHG


A:   When the body of a f o r loop contains a c o n t i n u e statement, the w h i l e pat­
     tern shown in Section 6.3 is no longer valid. Consider the following exam ple from
     Section 6.4:

     n = 0;
     sum = 0;
     while (n < 10) {
       scanf("%d", &i);
       if (i == 0)
         continue;
       sum += i ;
       n++;
     }

     At first glance, it looks as though we could convert the w h i l e loop into a f o r
     loop:

     sum = 0;
     for (n = 0; n < 10; n++)                         {
       scanf("%d", &i);
       if (i == 0)
         continue;
       sum += i;


     Unfortunately, this loop isn’t equivalent to the original. W hen i is equal to 0. the
     original loop doesn’t increm ent n . but the new loop does.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q:   W h ic h fo r m o f in fi n it e lo o p is p r e f e r a b le , w h i l e   (1 ) or f o r   ( ; ; ) ? [p . 1 0 8 ]
A:   C programmers have traditionally preferred f o r ( ; ; ) for reasons of efficiency;
     older com pilers would often force programs to test the 1 condition each time
     through the w h i l e loop. With m odern com pilers, however, there should be no dif­
     ference in performance.

Q:   I ’v e h e a r d th a t p r o g r a m m e r s s h o u ld n e v e r u s e th e c o n t i n u e s t a t e m e n t . Is
     th is tr u e ?
A:   It’s true that c o n t i n u e statem ents are rare. Still, c o n t i n u e is handy once in a
     while. Suppose w e’re writing a loop that reads some input data, checks that it’s
     valid, and, if so, processes the input in som e way. If there are a num ber of validity
     tests, or if they’re complex, c o n t i n u e can be helpful. The loop would look
     som ething like this:

     for (;;) {PONMLKJIHGFEDCBA
       read data;
       if (datafailsfirst test)
          continue;
       if (datafails second test)
          continue;
120 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 6    L o o p s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             (datafailslasiiesf)
                                        if PONMLKJIHGFEDCBA
                                           continue;
                                        process data;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                             Q:     W h a t’s so b a d a b o u t th e g o t o s ta te m e n t? [p. 114] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                             A:     The g o t o statement isn't inherently evil; it’sju st that we usually have better alter­
                                    natives. Programs that use more than a few g o t o statements can quickly degener­
                                    ate into “spaghetti code,” with control blithely jumping from here to there.
                                    Spaghetti code is hard to understand and hard to modify.
                                         g o t o statements make programs hard to read because they can jum p either
                                    forward or backward. (In contrast, b r e a k and c o n t i n u e onlyjum p forward.) A
                                    program that contains g o t o statements often requires the reader tojum p back and
                                    forth in an attempt to follow the flow of control.
                                         g o t o statements can make programs hard to modify, since they make it possi­
                                    ble for a section ofcode to serve more than one purpose. For example, a statement
                                    that is preceded by a label might be reachable either by “falling through” from the
                                    previous statement or by executing one of several g o t o statements.

                             Q:      D o e s th e n u ll s ta te m e n t h a v e a n y u se s b e sid e s in d ic a tin g th a t th e b o d y o f a
                                     lo o p is e m p ty ? [p . 116^|
                             A:     Very few. Since the null statement can appear wherever a statement is allowed,
                                    there are many potential uses for the null statement. In practice, however, there’s
                                    only one other use of the null statement, and it’s rare.
                                         Suppose that we need to put a label at the end of a compound statement. A
                                    label can’t stand alone: it must always be followed by a statement. Putting a null
                                    statement after the label solves the problem:



                                        goto end_of_stmt;
                                        •••
                                        end_of_stmt: ;


                             Q:     A r e th e r e a n y o th e r w a y s to m a k e an e m p ty lo o p b o d y s ta n d o u t b e s id e s p u t­
                                     tin g th e n u ll s ta te m e n t on a lin e by itse lf? [p . 117]
                             A:      Some programmers use a dummy c o n t i n u e statement:

                                     for (d = 2; d < n && n % d >= 0; d++)
                                       continue;

                                     Others use an empty compound statement:

                                     for (d = 2; d < n && n % d 1= 0; d++)
                                         {}
                                                                                                                                          121
                                                                                                                  E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIHG




                                   E x e r c is e s

S e c t io n 6 .1                  What output does the following program fragment produce? kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   while (i <= 128) {
                                     printf("%d ", i);
                                     i *= 2;


S e c tio n 6 .2                   What output does thefo!lowing program fragment produce?
                                   i = 9384;
                                   do {
                                     printf("%d ”, i);
                                     i /= 10;
                                   } while (i > 0);

                                    *3.    W hat output docs the following f o r statement produce?
S e c t i o n 6 .3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   for (i = 5, j = i - 1; i > 0, j > 0; --i, j = i - 1)
                                     printf("%d ", i);

                       ©     4.    Which one of the following statements is not equivalent to lhc other two (assuming that the
                                   loop bodies arc the same)?
                                   (a) for (i = 0; i < 10; i+ + ) ...
                                   (b) for (i = 0; i < 10; + + i) ...
                                   (c) for (i = 0; i+ + < 10; ) ...

                             5.    Which one of the following statements is not equivalent to the other two (assuming that the
                                   loop bodies are the same)?
                                   (a) while (i < 10) {...}
                                   (b) for (; i < 10;) {...}
                                   (c) do {...} while (i < 10) ;

                             6.   Translate the program fragment of Exercise I into a single f o r statement.

                             7.   Translate the program fragment ofExercise 2 into a single f o r statement.

                           *8.     What output does the following f o r statement produce?
                                   for (i = 10; i >= 1; i /= 2)
                                     printf("%d ", i++);

                             9.    Translate the f o r statement of Exercise 8 into an equivalent w h i l e statement. You will
                                   need one statement in addition to the w h i l e loop itself.

                           © 10.       Show how to replace a c o n t i n u e
S e c t i o n 6 . 4 ZYXWVUTSRQPONMLKJIHGFEDCBA                                 statement by an equivalent g o t o statement.

                                   What output does the following program fragment produce?
1 2 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 6    L o o p s aZYXWVUTSRQPONMLKJIHGFEDCBA


                                   sum = 0;
                                   for (i = 0; i < 10; i++)                 {
                                     if (i % 2)
                                       continue;
                                     sum += i ;
                                    }
                                   printf("%d\n", sum);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                       ©    12.    The following “prim e-testing” loop appeared in Section 6.4 as an example:
                                   for (d = 2; d < n; d++)
                                     if (n % d == 0)
                                       break;
                                   This loop isn^t very efficient. I f s not necessary to divide n by all numbers between 2 and
                                   n - 1 to determ ine whether it’s prime. In fact, we need only check divisors up to the square
                                                                                                  H int: D on’t try to com pute the
                                   root of n. Modify the loop to take advantage of this fact. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   square root of n; instead, com pare d * d with n.

                              :|: 13.   Rewrite the following loop so that its body is empty:
S e c t io n 6 .5 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   for (n = 0; m > 0; n++)
                                     m /= 2 ;

                       © *14.      Find the error in the following program fragment and fix it.
                                   if (n % 2 == 0) ;
                                     printf("n is even\n");




                                    P r o g r a m m in g P r o je c t s

                             1.    Write a program that finds the largest in a series o f numbers entered by the user. The pro­
                                   gram must prompt the user to enter numbers one by one. When the user enters 0 or a nega­
                                   tive number, the program must display the largest nonnegative num ber entered:
                                   Enter a number: 60
                                   Enter a number: 38.3
                                   Enter a number: 4.89
                                   Enter a number: 100.62
                                   Enter a number: 75.2295
                                   Enter a number: 0
                                   The largest number entered was 100.62
                                   Notice that the numbers aren’t necessarily integers.

                       ©     2.    W rite a program that asks the user to enter two integers, then calculates and displays their
                                   greatest common divisor (GCD):
                                   Enter two integers: 12 28
                                   Greatest common divisor: 4
                                   H int: The classic algorithm for computing the GCD, known as Euclid’s algorithm, goes as
                                   follows: Let m and n be variables containing the two numbers. If n is 0, then stop: m con­
                                   tains the GCD. Otherwise, com pute the rem ainder when m is divided by n. Copy n into m
                                   and copy the rem ainder into n. Then repeat the process, starting with testing w hether n is 0.
                                                                                                            123onmlkjihgfedcbaZ
                                                                    P ro g ra m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLK

    3.   Write a program that asks the user to enter a fraction, then reduces the fraction to lowest
         terms:
         Enter a fraction: 6/12
         In lowest terms: 1/2cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         H int: To reduce a fraction to lowest terms, first compute the GCD of the numerator and
         denominator. Then divide both the numerator and denominator by the GCD.

©   4.   Add a loop to the b r o k e r . c program of Section 5.2 so that the user can enter more than
         one trade and the program will calculate the commission on each. The program should ter­
         minate when the user enters 0 as the trade value:
         Enter value of trade: 30000
         Commission: $166.00
         Enter value of trade: 20000
         Commission: $144.00
         Enter value of trade: 0

    5.   Programming Project 1 in Chapter 4 asked you to write a program that displays a two-digit
         number with its digits reversed. Generalize the program so that the number can have one.
         two, lhrce, or more digits. H int: Use a d o loop that repeatedly divides the num ber by 10.
         stopping when it reaches 0.

©   6.   Write a program that prompts the user to enter a number /?. then prints all even squares
         between 1 and n. For example, if the user enters 100, the program should print the follow­
         ing:
         4
         16
         36
         64
         100

    7.   Rearrange the s q u a r e 3 . c program so that the f o r loop initializes i , tests i , and incre­
         ments i . D on't rewrite the program; in particular, don*t use any multiplications.

©   8.   Write a program that prints a one-month calendar. The user specifies the number of days in
         the month and the day of the week on which the month begins:
         Enter number of days in month: 3JL
         Enter starting day of the week (l=Sun, 7=Sat): 2
                   1 2 3 4 5
          6     7 8 9 10 11 12
         13    14 15 16 17 18 19
         20    21 22 23 24 25 26
         27    28 29 30 31
         Hint: This program isn’t as hard as it looks. The most important part is a f o r statement that
         uses a variable i to count from 1 to n, whcrc n is the number o fd a y s in the month, printing
         each value of i . Inside the loop, an i f statement tests whether i is the last day in a week; if
         so. it prints a new-line character.

    9.   Programming Project 8 in Chapter 2 asked you to write a program that calculates the
         remaining balance on a loan afier the first, second, and third monthly payments. Modify the
         program so that it also asks the user to enter the number of payments and then displays the
         balance remaining after each ofthese payments.
1 2 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 6     L o o p s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                               10.     Programming Project 9 in Chapter 5 asked you to write a program that determ ines which of
                                       two dates comes earlier on the calendar. Generalize the program so that the user may enter
                                       any number of dates. The user will enter 0/0/0 to indicate that no more dates will be entered:kjihgfedcb
                                       Enter a date(mm/dd/yy): 3/6/08
                                       Enter a date(mm/dd/yy): 5/17/07
                                       Enter a date(mm/dd/yy): 6/3/07
                                       Enter a date(mm/dd/yy): 0/0/0
                                       5/17/07 is the earliest date

                               11.                                            e can be expressed as an infinite series:
                                       The value of the mathematical constant cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       e = 1 4- 1/11+ 1/2! 4- 1/3! 4-...
                                       Write a program that approximates e by computing the value of
                                       1 4- 1/114- 1/2! 4- 1/3! 4- ... + l/n!
                                       where n is an integer entered by the user.

                               12.     Modify Programming Project 11 so that the program continues adding terms until the cur­
                                       rent term becomes less than E. where e is a small (Hoating-point) number entered by the
                                       user.
7     B a s ic T y p e s                                    ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                        M a k e n o m is ta k e a b o u t it: C o m p u te r s p r o c e s s n u m b e r s —
                                                                              W e m e a s u r e o u r u n d e r s ta n d in g ( a n d c o n tro l)
                                                       n o t s y m b o ls . hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                b y th e e x te n t to w h ic h w e c a n a r ith m e tiz e a n a c tiv ity . onmlkjihgfedcbaZY




                                            basic (built-in) types: i n t and f l o a t . (We've
      So far. we’ve used only two o fC 's cbaZYXWVUTSRQPONMLKJIHGFEDCBA
      also seen _ B o o l. which is a basic type in C99.) This chapter describes the rest of
      lhe basic types and discusses important issues about types in general. Section 7.1
      reveals the full range of integer types, which include long integers, short integers,
      and unsigned integers. Section 7.2 introduces the d o u b l e and l o n g d o u b l e
      types, which provide a larger range of values and greater precision than f l o a t .
      Section 7.3 covers the c h a r type, which we’ll need in order to work with charac­
      ter data. Section 7.4 tackles the thorny topic ofconverting a value o fo n e type to an
      equivalent value of another. Section 7.5 shows how to use t y p e d e f to define new
      type names. Finally, Section 7.6 describes the s i z e o f operator, which measures
      the amount ofstorage required for a type.




7.1   In t e g e r T y p e s

      C supports two fundamentally different kinds of numeric types: integer types and
      floating types. Values of an integer type are whole numbers, while values of a
      floating type can have a fractional part as well. The integer types, in turn, are
      divided into two categories: signed and unsigned.RQPONMLKJIHGFEDCBA



                                         S ig n e d a n d U n s ig n e d I n te g e r s

                                     signed in te g e r (k n o w n a s th e sign bit) is 0 if th e n u m b e r is
      T h e le ftm o s t b it o f a BA
      p o s itiv e o r z e ro , 1 if it’s n e g a tiv e . T h u s , th e la rg e s t 1 6 - b it in te g e r h a s th e b in a r y r e p ­
      re s e n ta tio n




                                                                                                                                          125
1 26 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 7    B a s ic T y p e s


                                   0111111111111111

                                   w h ic h h a s th e v a lu e 3 2 ,7 6 7 (2 1 5 - 1). T h e la rg e s t 3 2 -b it in te g e r is

                                   01111111111111111111111111111111

                                   w h ic h h a s th e v a lu e 2 ,1 4 7 ,4 8 3 ,6 4 7 (2 31 - 1). A n in te g e r w ith n o s ig n b it (th e le ft­
                                                                                                                                      unsigned. T h e
                                   m o s t b it is c o n s id e re d p a rt o f th e n u m b e r's m a g n itu d e ) is s a id to b e BA
                                   la rg e s t 1 6 -b it u n s ig n e d in te g e r is 6 5 ,5 3 5 (2 1 6 - 1), a n d th e la rg e s t 3 2 -b it u n s ig n e d
                                   in te g e r is 4 ,2 9 4 ,9 6 7 ,2 9 5 (2 3 2 - 1).
                                          B y d e fa u lt, in te g e r v a ria b le s a re s ig n e d in C — th e le ftm o s t b it is re s e rv e d fo r th e
                                   s ig n . To te ll th e c o m p ile r th a t a v a ria b le h a s no s ig n bit, w e d e c la re it to b e
                                   u n s ig n e d . U n s ig n e d n u m b e rs a re p rim a rily u s e fu l fo r s y s te m s p ro g ra m m in g a n d
                                   lo w -le v e l, m a c h in e -d e p e n d e n t a p p lic a tio n s . W e ’ll d is c u s s ty p ic a l a p p lic a tio n s fo r
                                   u n s ig n e d n u m b e rs in C h a p te r 2 0 ; u n til th e n , w e ’ll g e n e ra lly a v o id th e m . onmlkjihgfedcbaZYXWVUTSRQPO




                                        C ’s integer types come in different sizes. The i n t type is usually 32 bits, but
                                   may be 16 bits on older CPUs. Since some program s require numbers that are too
                                   large to store in i n t form, C also provides lo        n g integers. At times, we may need to
                                                                                       cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   conserve memory by instructing the compiler to store a number in less space than
                                   normal; such a number is called a sh o rt integer.
                                        To construct an integer type that exactly meets our needs, we can specify that
                                   a variable is l o n g or s h o r t , s i g n e d or u n s i g n e d . We can even com bine
                                   specifiers (e.g., l o n g u n s i g n e d i n t ) . However, only the following six com bi­
                                   nations actually produce different types:

                                          sh o rt in t
                                          u n s ig n e d s h o r t i n t

                                          in t
                                          u n s ig n e d i n t

                                          lo n g i n t
                                          u n s ig n e d lo n g i n t

                                   Other combinations are synonyms for one ofth ese six types. (For example, l o n g
                                   s i g n e d i n t is the same as l o n g i n t , since integers arc always signed unless
                                   otherwise specified.) Incidentally, the order of the specifiers doesn’t matter;
                                   u n s i g n e d s h o r t i n t is the same as s h o r t u n s i g n e d i n t .
                                          C allows us to abbreviate the names of integer types by dropping the word
                                   i n t . For example, u n s i g n e d s h o r t i n t may be abbreviated to u n s i g n e d
                                   s h o r t , and l o n g i n t may be abbreviated to just l o n g . Omitting i n t is a
                                   widespread practice among C programmers, and some newer C-based languages
                                   (including Java) actually require the programmer to write s h o r t or l o n g rather
                                   than s h o r t i n t or l o n g i n t . For these reasons, I’ll often omit the word i n t
                                   when it’s not strictly necessary.
                                                                                                                    7 .1                                         127
                                                                                                                               I n t e g e r T y p e s onmlkjihgfedcbaZYXWVUTSRQ


                                               The range of values represented by each o f the six integer types varies from
                                          one machine to another. However, there are a couple o f rules that all compilers
                                          must obey. First, the C standard requires that s h o r t i n t , i n t , and l o n g i n t
                                          each cover a certain minim um range o f values (see Section 23.2 for details). Sec­
                                          ond, the standard requires that i n t not be shorter than s h o r t i n t , and l o n g
                                          i n t not be shorter than i n t . However, it’s possible that s h o r t i n t represents
                                          the same range of values as i n t : also, i n t may have the same range as l o n g
                                          in t.
                                               Table 7.1 shows the usual range of values for the integer types on a 16-bit
                                          machine; note that s h o r t i n t and i n t have identical ran g es.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                                ^^




                      T a b le 7 .1                    __________ T ype__________        S m a lle s t V a lu e            L a r g e s t V a l u e kjihgfedcbaZYXWVUTSRQPONMLKJIH
       Integer Types on a                                short int                 -32,768                                        32,767
           l6-bit Machine                                unsigned short int              0                                        65,535
                                                         int                       -32,768                                        32,767
                                                         unsigned int                    0                                        65,535
                                                         long int           -2,147.483,648                                 2.147,483.647
                                                         unsigned long int _____________ 0                                 4.294.967,295

                                          Table 7.2 shows the usual ranges on a 32-bit machine; here i n t and l o n g i n t
                                          have identical rang©es.RQPONMLKJIHGFEDCBA

                      T a b le 7 .2                    __________ Type__________         S m a l l e s t V a lu e          L a r g e s t V a lu e
       Integer Types on a                                short int                 -32,768                                        32,767
          32-bit Machine                                 unsigned short int              0                                        65.535
                                                         int                -2.147.483,648                                 2,147,483.647
                                                         unsigned int                    0                                 4.294.967,295
                                                         long int           -2,147,483,648                                 2,147,483,647
                                                         unsigned long int _____________ 0                                 4,294,967,295

                                          In recent years, 64-bit CPUs have becom e more common. Table 7.3 shows typical
                                          ranges for the integer types on a 64-bit machine (especially under UNDQ.

                      T a b le 7 .3       _________ T ype__________            S m a lle s t V a lu e                                L a r g e s t V a lu e
       Integer Types on a                  short int                             -32.768                                                       32,767
          64-bit Machine                   unsigned short int                          0                                                       65,535
                                           int                            -2.147.483.648                                                2,147.483,647
                                           unsigned int                                0                                                4.294.967,295
                                           long int           -9.223,372,036,854.775.808                                    9,223,372,036,854,775,807
                                           unsigned long int ________________________0                                     18.446.744,073.709.551.615 hgfedcbaZYXW

                                               Once more, let me em phasize that the ranges shown in Tables 7.1, 7.2, and 7.3
                                          aren’t mandated by the C standard and may vary from one com piler to another.
                                          One way to determ ine the ranges of the integer types for a particular im plementa­
< l i m i t s . h > h e a d e r> 2 3 .2   tion is to check the < l i m i t s .h > header, which is part o f the standard library.
                                          This header defines macros that represent the sm allest and largest values of each
                                          integer type.
128 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   I n te g e r T y p e s in C 9 9

                                                 C99 provides two additional standard integer types, l o n g l o n g i n t and
                                                 u n s i g n e d l o n g l o n g i n t . These types were added because of the growing
                                                 need for very large integers and the ability of newer processors to support 64-bit
                                                 arithmetic. Both l o n g l o n g types are required to be at least 64 bits wide, so the
                                                 range of l o n g l o n g i n t values is typically - 2 f u (-9.223,372,036,854.775,808)
                                                 to 2 63 - l (9.223,372.036.854,775.807). and range of u n s i g n e d l o n g l o n g
                                                 i n t values is usually 0 to 2 64 - 1 (18.446.744,073,709.551,615).
                                                       The s h o r t i n t , i n t . l o n g i n t . and l o n g l o n g i n t types (along with
        s i g n e d c h a r ty p e > 7 . 3                                                      sta n d a rd sig n e d in teg er types in C99. The
                                                 the s i g n e d c h a r type) are called cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 u n s i g n e d s h o r t i n t . u n s i g n e d i n t , u n s i g n e d l o n g i n t , and
    u n s i g n e d c h a r ty p e > 7 . 3       u n s i g n e d l o n g l o n g i n t types (along with the u n s i g n e d c h a r type and
                                                 the _ B o o l type) are called sta n d a rd u n sig n e d in te g er types.
                   _ B o o l ty p e > 5 . 2 dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                       In addition to the standard integer types, the C99 standard allows im plem enta­
                                                 tion-defined e x te n d e d in te g e r types, both signed and unsigned. For example, a
                                                 com piler might provide signed and unsigned 128-bit integer types.


                                   I n te g e r C o n s ta n ts

                                   Let's turn our attention to c o n sta n ts— numbers that appear in the text of a pro­
                                   gram, not numbers that are read, written, or computed. C allows integer constants
                                   to be written in decimal (base 10), octal (base 8), or hexadecimal (base 16).



                                                                 Octal and H exadecim al Num bers
                                   A n o c ta l n u m b e r is w ritte n u s in g o n ly th e d ig its 0 th ro u g h 7. E a ch p o s itio n in a n
                                   o c ta l n u m b e r re p re s e n ts a p o w e r o f 8 Qust a s e a c h p o s itio n in a d e c im a l n u m b e r
                                   re p re s e n ts a p o w e r o f 10). T h u s , th e o c ta l n u m b e r 2 3 7 re p r e s e n ts th e d e c im a l n u m ­
                                   b e r 2 x 8 2 + 3 x 8 1 + 7 x 8 ° = 1 2 8 + 2 4 + 7 = 159.
                                         A h e x a d e c im a l (o r h e x) n u m b e r is w ritte n u s in g th e d ig its 0 th ro u g h 9 p lu s th e
                                   le tte rs A th ro u g h F, w h ic h s ta n d fo r 10 th ro u g h 15, re s p e c tiv e ly . E a ch p o s itio n in a
                                   h e x n u m b e r re p re s e n ts a p o w e r o f 16; th e h e x n u m b e r 1 A F h a s th e d e c im a l v a lu e
                                   1 x 1 6 2 + 1 0 x 1 6 1 + 1 5 x 1 6 ° = 2 5 6 + 1 6 0 4 -1 5 = 4 3 1 .




                                      ■ D e c im a l constants contain di<ojits bectrween 0 and 9. but must not besin with a
                                        zero:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         15      255       32767

                                      ■ O ctal constants contain only digits between 0 and 7. and m u st begin with a
                                        zero:

                                         017       0377         077777
                                                                         7.1                                  129cbaZYXWVUTSRQP
                                                                                I n t e g e r T y p e s kjihgfedcbaZYXWVUTSRQPONML


         ■ H exa d e cim a l onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                              constants contain digits between 0 and 9 and letters between a
           and f , and always begin with Ox:

             0xf     0xff      0x7fff

             The letters in a hexadecimal constant may be either upper or lower case:

             0xff     0xfF      0xFf      0xFF      0Xff      0XfF      0XFf      0XFF

             Keep in mind that octal and hexadecimal are nothing more than an alternative
       way of writing numbers; they have no effect on how the num bers are actually
       stored. (Integers are always stored in binary, regardless of what notation w e’ve
       used to express them.) We can switch from one notation to another at any time, and
       even mix them: 10 + 0 1 5 + 0 x 2 0 has the value 55 (decimal). Octal and hex are
       most convenient for writing low-level programs; we w on’t use these notations
       much until Chapter 20.
             The type of a decim al integer constant is normally i n t . However, if the value
       of the constant is too large to store as an i n t , the constant has type l o n g i n t
       instead. In the unlikely case that the constant is too large to store as a l o n g i n t ,
       the com piler will try u n s i g n e d l o n g i n t as a last resort. The rules for deter­
       mining the type o fa n octal or hexadecim al constant are slightly different: the com­
       piler will go through the types i n t , u n s i g n e d i n t , l o n g i n t , and u n s i g n e d
       l o n g i n t until it finds one capable of representing the constant.
             To force the com piler to treat a constant as a long integer, just follow it with
       the letter L (or 1):

       15L     0377L       0x7fffL

       To indicate that a constant is unsigned. put the letter U (or u ) after it:

       15U     0377U       0x7fffU

       L and U may be used in com bination to show that a constant is both long a nd
       unsigned: 0 x f f f f f f f f U L . (The order of the L and U doesn’t matter, nor does
       their case.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


<%p)   I n te g e r C o n sta n ts in C 9 9

       In C99, integer constants that end with either LL or 11 (the case of the two letters
       must match) have type l o n g l o n g i n t . Adding the letter U (or u) before or after
       the LL or 11 denotes a constant o fty p e u n s i g n e d l o n g l o n g i n t .
             C99's general rules for determining the type of an integer constant are a bit
       different from those in C89. The type of a decimal constant with no suffix (U, u, L,
       1. LL, or 11) is the “smallest” of the types i n t , l o n g i n t , or l o n g l o n g i n t
       that can represent the value of that constant. For an octal or hexadecim al constant,
       however, the list of possible types is i n t , u n s i g n e d i n t , l o n g i n t ,
       u n s i g n e d l o n g i n t , l o n g l o n g i n t , and u n s i g n e d l o n g l o n g i n t , in
       that order. Any suffix at the end of a constant changes the list o f possible types. For
           C h a p te r 7 B a s ic T y p e s
130 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                exam ple, a constant that ends with U (or u ) m ust have one o f the types u n s i g n e d
                                i n t , u n s i g n e d l o n g i n t , or u n s i g n e d l o n g l o n g i n t . A decim al con­
                                stant that ends with L (or 1) must have one of the types l o n g i n t or l o n g l o n g
                                i n t . T here’s also a provision for a constant to have an extended integer type if it's
                                too large to represent using one of the standard integer types.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                I n te g e r O v e r flo w

                                W hen arithm etic operations are perform ed on integers, it’s possible that the result
                                will be too large to represent. For exam ple, when an arithm etic operation is per­
                                form ed on two i n t values, the result must be able to be represented as an i n t . If
                                the result can ’t be represented as an i n t (because it requires too many bits), we
                                say that overflow has occurred.
                                     The behavior when integer overflow occurs depends on w hether the operands
                                were signed or unsigned. W hen overflow occurs during an operation on sig n e d
                                integers, the program ’s behavior is undefined. Recall from Section 4.4 that the con­
                                sequences of undefined behavior may vary. M ost likely the result of the operation
                                will sim ply be wrong, but the program could crash or exhibit other undesirable
                                behavior.
                                     W hen overflow occurs during an operation on u n sig n ed integers, though, the
                                result is defined: we get the correct answ er modulo 2", w here n is the num ber of
                                bits used to store the result. For exam ple, if we add 1 to the unsigned 16-bit num ­
                                ber 65,535, the result is guaranteed to be 0.


                                R e a d in g a n d W r itin g I n te g e r s

                                Suppose that a program isn’t working because one of its i n t variables is over­
                                flowing. O ur first thought is to change the type of the variable from i n t to l o n q
                                i n t . But w e’re not done yet; we need to see how the change will affect the rest of
                                the program . In particular, we must check w hether the variable is used in a call of
                                p r i n t f or s c a n f . U" so, the form at string in the call will need to be changed,
                                since the %d conversion works only for the i n t type.
                                       R eading and writing unsigned, short, and long integers requires several new
                                conversion specifiers:aZYXWVUTSRQPONMLKJIHGFEDCBA

                       Q&A         ■ W he n reading or writing an u n sig n ed integer, use the letter u , o , or x instead
                                      of d in the conversion specification. If the u specifier is present, the num ber is
                                      read (or written) in decimal notation; o indicates octal notation, and x indi­
                                      cates hexadecim al notation.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      unsigned int u;

                                      s c a n f ("%u", & u ) ;          reads      u   in   base 10 *
                                      printf("%u", u);                  writes     u   in   base 10 *
                                      scanf("%o", &u);                  reads      u   in   base  8 *
                                      p r i n t f ("%o", u ) ;          writes     u   in   base 8 *
                                                                                    1 In te g e r T y p e s
                                                                                 7 .cbaZYXWVUTSRQPONMLKJIHGFEDCBA   131 kjihgfedcbaZYXW

                            scanf("%x", &u);           /* reads u in base 16 */
                            printf("%x", u);           /* writes u in base 16 */

                          ■ W hen reading or writing a short integer, pul the letter h in front of d, o, u, or
                             x:

                            short s ;

                            scanf("%hd", &s);
                            printf("%hd", s);

                          ■ Wh en reading or writing a long integer, put the letter 1 (“e l l/ not “one”) in
                             front of d, o, u, or x:

                            long 1;

                            scanf("%ld", &1);
                            printf("%ld", 1);

        <^£>          ■     When reading or writing a long long integer (C99 only), put the letters 11 in
                            front of d, o, u, or x:

                            long long 11;

                            scanf("%lld", £11);
                            printf("%lld", 11);hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                  S u m m in g a S e r ie s o f N u m b e r s
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA                     (R e v is ite d )

                 In Section 6.1, we wrote a program that sums a series of integers entered by the
                 user. One problem with this program is that the sum (or one of the input numbers)
                 might exceed the largest value allowed for an i n t variable. Here’s what might
                 happen ifthe program is run on a machine whose integers are 16 bits long:
                 This program sums a series of integers.
                 Enter integers (0 to terminate): 10000 20000 30000 0
                 The sum is: -5536

                 The sum was 60,000, which wouldn’t fit in an i n t variable, so overflow occurred.
                 When overflow occurs with sigoned numbers, the outcome is undefined. In this
                 case, we got an apparently meaningless number. To improve the program, let’s
                 switch to l o n g variables.

     su m 2 .c   /★         Sums a series of numbers (using long variables) */

                 #include <stdio.h>

                 int main(void)

                          long n, sum = 0;

                          printf("This program sums a series of integers.\n");
           C h a p te r 7 B a s ic T y p e s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
132 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       printf("Enter integers (0 to terminate): ");

                                       scanf("%ld", &n);
                                       while (n != 0) {
                                         sum += n;
                                         scanf(”%ld", &n);

                                       printf("The sum is: %ld\n", sum);

                                       return 0;


                                   The change was fairly simple: we declared n and sum to be l o n g variables
                                   instead of i n t variables, then we changed the conversion specifications in s c a n f
                                   and p r i n t f to % ld instead of %d.aZYXWVUTSRQPONMLKJIHGFEDCBA




                         7 .2       F lo a t in g T y p e s

                                   The integer types aren’t suitable for all applications. Sometimes w e’ll need vari­
                                   ables that can store numbers with digits after the decimal point; or numbers that are
                                   exceedingly large or small. Numbers like these are stored in floating-point form at
                                   (so called because the decimal point “floats”). C provides three flo a tin g types, cor­
                                   responding to different floating-point formats:

                                          flo a t                      Single-precision floating-point
                                          d o u b le                   Double-precision floating-point
                                          lo n g d o u b le            Extended-precision floating-point

                                   f l o a t is suitable when the am ount ofprecision isn’t critical (calculating tem pera­
                                   tures to one decimal point, for example), d o u b l e provides greater precision—
                                   enough for most programs, l o n g d o u b l e , which supplies the ultim ate in preci­
                                   sion, is rarely used.
                                         The C standard doesn’t state how much precision the f l o a t , d o u b l e . and
                                   l o n g d o u b l e types provide, since different computers may store floating-point
                                   numbers in diflbrent ways. M ost modern com puters follow the specifications in
                                   lEEE Standard 754 (also known as IEC 60559). so w e’ll use it as an example.RQPONMLKJIHGF



                                                                T h e J .E E E F l o a t i n g - P o i n t S t a n d a r d hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB

                                    lE E E S ta n d a rd 7 5 4 , d e v e lo p e d by th e In s titu te o f E le c tric a l a n d E le c tro n ic s E n g i­
                                   n e e rs , p ro v id e s tw o p rim a ry fo rm a ts fo r flo a tin g -p o in t n u m b e rs : s in g le p r e c is io n (3 2
                                   b its) a n d d o u b le p re c is io n (6 4 b its ). N u m b e rs a re s to re d in a fo rm o f s c ie n tific n o ta ­
                                                                                                                  exponent, a n d a
                                   tio n , w ith e a c h n u m b e r h a v in g th re e p a rts : a s /g n , a n BA                               fraction.
                                   T h e n u m b e r o f b its re s e rv e d fo r th e e x p o n e n t d e te rm in e s h o w la rg e (o r s m a ll) n u m ­
                                   b e rs c a n be, w h ile th e n u m b e r o f b its in th e fra c tio n d e te rm in e s th e p re c is io n . In
                                   s in g le -p re c is io n fo rm a t, th e e x p o n e n t is 8 b its lo n g , w h ile th e fra c tio n o c c u p ie s 2 3
                                                                                                                          7 .2                                    133hgfedcbaZ
                                                                                                                                     F lo a tin g T y p e s kjihgfedcbaZYXWVUTSRQ


                                           bits. A s a re su lt, a s in g le -p re c is io n n u m b e r h a s a m a x im u m v a lu e o f a p p ro x im a te ly
                                           3 .4 0 x 10 3 8 , w ith a p re c is io n o f a b o u t 6 d e c im a l d ig its .
                                                 T h e IE E E s ta n d a rd a ls o d e s c rib e s tw o o th e r fo rm a ts , s in g le e x te n d e d p re c isio n
                                           a n d d o u b le e x te n d e d p re c is io n . T h e s ta n d a rd d o e s n ’t s p e c ify th e n u m b e r o f b its in
                                           th e s e fo rm a ts , a lth o u g h it re q u ire s th a t th e s in g le e x te n d e d ty p e o c c u p y a t le a st 4 3
                                           b its a n d th e d o u b le e x te n d e d typ e a t le a s t 7 9 bits. F o r m o re in fo rm a tio n a b o u t the
                                           IE E E s ta n d a rd a n d flo a tin g -p o in t a rith m e tic in g e n e ra l, s e e ''W h a t e v e ry c o m p u te r
                                                                                                                                                         (ACM
                                           s c ie n tis t s h o u ld k n o w a b o u t flo a tin g -p o in t a rith m e tic ” by D a v id G o ld b e rg cbaZYXWVUTSRQPONM
                                           Computing Surveys, vo l. 2 3 , no. 1 (M a rch 1 9 9 1 ): 5 ^ 4 8 ). aZYXWVUTSRQPONMLKJIHGFEDCBA



                                                    Table 7.4 shows the characteristics of the floating types when implemented
                                               according to the IEEE standard. (The table shows the smallest positive norm alized
                                               values. Subnormal numbers can be smaller.) The l o n g d o u b l e type isn’t shown
                                  > 2 3 .4dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
  s u b n o r m a l n u m b e r s BA

                                               in the table, since its length varies from one machine to another, with 80 bits and
                                                128 bits being the most common sizes.RQPONMLKJIHGFEDCBA

                     T a b le 7 .4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                      T ype          S m a l l e s t P o s it iv e V a lu e         L a r g e s t V a lu e         P r e c is io n
           Floating Type                                                     i . l 7 5 4 9 x l 0 ^ 38              3 .4 0 2 8 2 x lO38
                                                   float                                                                                              6 dig
                                                                                                                                                          <^its
          Characteristics                          double                   2.22507 x l O-308                      1.79769 x 1030S                   15 digo its
        (IEEE Standard)

                                                  On computers that don't follow the LEEE standard, Table 7.4 w on’t be valid.
                                           In fact, on some machines, f l o a t may have the same set of values as d o u b l e , or
                                           d o u b l e may have the same values as l o n g d o u b l e . Macros that define the
< f l o a t . h > h e a d e r > 2 3 .1     characteristics oftlie floating types can be found in the < f l o a t . h> header.
                                                  In C99. the floating types are divided into two categories. The f l o a t , d o u ­
                                           b l e , and l o n g d o u b l e types fall into one category, called the real flo a tin g
         c o m p le x i y p e s > 2 7 .3   types. Floating types also include the com plex types ( f l o a t _ C o m p le x , d o u ­
                                           b l e C o m p le x , and l o n g d o u b l e _ C o m p le x ). which are new in C99.


                                           F lo a ti n g C o n s ta n t s

                                           Floating constants can be written in a variety ofw ays. The following constants, for
                                           example, are all valid ways of writing the number 57.0:

                                           57.0        57.       57.0e0            57E0          5.7el        5.7e+l          .57e2          570.e-l

                                           A floating constant must contain a decimal point and/or an exponent; the exponent
                                           indicates the power of 10 by which the number is to be scaled. If an exponent is
                                           present, it must be preceded by the letter E (or e). An optional + or - sign may
                                           appear after the E (or e).
                                                By default, floating constants are stored as double-precision numbers. In other
                                           words, when a C compiler finds the constant 57.0 in a program, it arranges for the
                             Q&A           number to be stored in memory in the same format as a d o u b l e variable. This
                                           rule generally causes no problems, since d o u b l e values are converted automati­
                                           cally to f l o a t when necessary.
134 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             On occasion, it may be necessary to force the compiler to store a floating con­
                                       stant in f l o a t or l o n g d o u b l e formal. To indicate that only single precision is
                                       desired, pul the letter F (or f ) at the end of the constant (for example, 57 . OF). To
                                        indicate that a constant should be stored in l o n g d o u b l e format, put the letter L
                                       (or 1) at the end ( 5 7 . 0L).
                               g|            C99 has a provision for writing floating constants in hexadecimal. Such a con­
                                   aZYXWVUTSRQPONMLKJIHGFEDCBA

                                       stant begins with Ox or OX (like a hexadecimal integer constant). This feature is
                               Q&A     rarely used.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             R e a d in g a n d W r itin g F lo a tin g -P o in t N u m b e r s

                                             As we’ve discussed, the conversion specifications %e, %f, and %g are used for
                                             reading and writing single-precision floating-point numbers. Values of types d o u ­
                                             b l e and l o n g d o u b l e require slightly different conversions:

                                                ■         reading a value of type d o u b l e , put the letter 1 in front of e, f , or g:kjihgfedc
                                                     When cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     double d;

                                                     scanf(”%lf”, &d);

                               Q&A                   Note: Use 1 only in a s c a n f format string, not a p r i n t f string. In a
                                                     p r i n t f format string, the e, f , and g conversions can be used to write either
                                                     f l o a t or d o u b l e values. (C99 legalizes the use of % le, % lf, and % lg in
                                                     calls o f p r i n t f , although the 1 has no effect.)
                                                ■ W hen reading or writing a value of type l o n g d o u b l e , put the letter L in
                                                   front of e, f , or g:

                                                     long double ld;

                                                     scanf("%Lf", &ld);
                                                     printf("%Lf", ld);




                                7 .3         C h a ra c te r T y p e s

                               Q&A           The only remaining basic type is c h a r , the character type. The values of type
                                             c h a r can vary from one computer lo another, because different machines may
                                             have different underlying character sets.



                                                                                           C h a r a c te r S e ts

                                             T o d a y 's m o s t p o p u la r c h a ra c te r s e t is ASCII (A m e ric a n S ta n d a rd C o d e fo r In fo rm a ­
                                   >Appendix ERQPONMLKJIHGFEDCBA
 A S C I I c h a r a c t e r s e t BA

                                             tio n In te rc h a n g e ), a 7 -b it c o d e c a p a b le o f re p re s e n tin g 128 c h a ra c te rs . In A S C II,
                                             th e d ig its 0 to 9 a re re p re s e n te d by the c o d e s 0 1 1 0 0 0 0 -0 1 1 1 0 0 1 , a n d th e u p p e r­
                                             c a s e le tte rs A to Z a re re p re s e n te d by 1 0 0 0 0 0 1 - 1 0 1 1 0 1 0 . A S C II is o fte n e x te n d e d
                                                                         7 .3                                          135
                                                                                  C h a r a c t e r T y p e s hgfedcbaZYXWVUTSRQPONMLK


to a 2 5 6 -c h a ra c te r c o d e kn o w n as L a tin - 1 th a t p ro v id e s th e c h a ra c te rs n e c e s s a ry
for W e s te rn E u ro p e a n a n d m a n y A fric a n la n g u a g e s . onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



      A variable oftype c h a r can be assigned any single character:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB

char ch;

ch     = ’a ’;          /* lower-case               a */
ch     = ’A ’;          /* upper-case               A */
ch     = ’0 ’;          /* zero                       */
ch     = ' ';           /* space                      */

Notice that character constants are enclosed in single quotes, not double quotes.dcbaZYXWVUTSRQP


O p e r a tio n s o n C h a r a c te r s

                                                                  C treats characters as
Working with characters in C is simple, because o fo n e fact: cbaZYXWVUTSRQPONMLKJIHGFEDCBA
sm all integers. After all, characters are encoded in binary, and it doesn’t take much
imagination to view these binary codes as integers. In ASCII, for example, charac­
ter codes range from 0000000 to 111 1111, which we can think of as the integers
from 0 to 127. The character ’ a ' has the value 97, 'A ' has the value 65, ' 0 1 has
the value 48, and ’ ’ has the value 32. The connection between characters and
*integers in C is so strong that character constants actually have i n t type rather
than c h a r type (an interesting fact, but not one that will often matter to us).
     When a character appears in a computation, C simply uses its integer value.
Consider the following examples, which assume the ASCH character set:

char ch;
int i ;

i = ’a ’;                     /*   i is now 97
ch = 65;                      /*   ch is now ’A ’ */
ch = ch + 1;                  /*   ch is now ’B ’
ch+ + ;                       /*   ch is now 'C' */

    Characters can be com pared,just as numbers can. The following i f statement
checks whether c h contains a lower-case letter; if so, it converts c h to upper case.

if ('a' <= ch && ch <= 'z')
  ch = ch - 'a ' + ’A ’;

Comparisons such as ' a ' <= c h are done using the integer values of the charac­
ters involved. These values depend on the character set in use, so programs that use
<, <=, >, and >= to compare characters may not be portable.
     The fact that characters have the same properties as numbers has some advan­
tages. For example, we can easily write a f o r statement whose control variable
steps through all the upper-case letters:

for (ch = ’A'; ch <= 'Z'; ch+ + ) ...
136 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s aZYXWVUTSRQPONMLKJIHGFEDCBA


                                    On the other hand, treating characters as numbers can lead to various program m ing
                                    errors that w on't be caught by the compiler, and lets us write m eaningless expres­
                                    sions such as ’ a 1 * ’ b 1 / ’ c 1 . It can also ham per portability, since our pro­
                                    gram s may be based on assum ptions about the underlying character set. (Our f o r
                                    loop, for example, assum es that the letters from A to Z have consecutive codes.) dcbaZYXWVU


                                    S ig n e d a n d U n s ig n e d C h a r a c te r s

                                      Since C allows characters to be used as integers, it shouldn't be surprising that the
                                       c h a r type— like the integer types— exists in both signed and unsigned versions.
                                      Signed characters norm ally have values between -1 2 8 and 127, while unsigned
                                      characters have values between 0 and 255.
                                               The C standard d o esn 't specify whether ordinary c h a r is a signed or an
                                      unsigned type; some com pilers treat it as a signed type, while others treat it as an
                                      unsigned type. (Some even allow the program m er to select, via a com piler option,
                                      whether c h a r should be signed or unsigned.)
                                               Most of the time, we don’t really care whether c h a r is signed or unsigned.
                                      Once in a while, though, we do, especially if w e're using a character variable to
                                      store a small integer. For this reason. C allows the use of the words s i g n e d and
                          Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      u n s i g n e d to modify c h a r :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    signed char sch;
                                    unsigned char uch;

            p o r t a b ility tip        D on 't assum e that c h a r is eith er sig n ed o r un signed by default, l f i l m a t­
                                         ters, use s i g n e d c h a r o r u n s i g n e d c h a r instead o f c h a r .

                                                          In light of the close relationship between characters and integers, C89 uses the
                                         16.5
         e n u m e r a t e d t y p e s > BA        term in teg ra l types to refer to both the integer types and the character types. Enu­
                                                    merated types are also integral types.
                                                          C99 doesn't use the term ‘Integral types.” Instead, it expands the m eaning of
                                                   “integer types” to include the character types and the enum erated types. C 99 ?s
                                                   _ B o o l type is considered to be an unsigned integer type.
                      B o o l t y p e > 5 . 2 cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                    A r ith m e tic T y p e s

                                    The integer types and floating types are collectively known as a rith m e tic types.
                                    Here's a summary o fth e arithm etic types in C89, divided into categories and sub­
                                    categories:

                                      ■ Integ ral types
                                         • char
                                         • Signed integer types ( s i g n e d c h a r , s h o r t i n t , i n t , l o n g i n t )
                                         • Unsigned integer types ( u n s i g n e d c h a r , u n s i g n e d s h o r t             in t.
                                           u n s ig n e d i n t , u n s ig n e d lo n g i n t )
                                                                                          7 .3                                         137onmlkjihgfedcbaZYXW
                                                                                                    C h a r a c t e r T y p e s kjihgfedcbaZYXWVUTSRQPONMLKJI


                                 • Enumerated types
                              ■ Floati ng types ( f l o a t , d o u b l e , l o n g d o u b l e )
              <^E>       C99 has a more complicated hierarchy for its arithmetic types:

                          ■      Integer types
                                 • char
                                 • Signed integer types, both standard ( s i g n e d c h a r , s h o r t i n t , i n t ,
                                   l o n g i n t , l o n g l o n g i n t ) and extended
                                 • Unsigned integer types, both standard ( u n s i g n e d c h a r , u n s i g n e d
                                   s h o r t i n t , u n s ig n e d i n t , u n s ig n e d lo n g i n t . u n s ig n e d
                                   l o n g l o n g i n t , _ B o o l) and extended
                                 • Enumerated types
                          ■ Floating t ypes
                                 • Real floating types ( f l o a t , d o u b l e , l o n g d o u b l e )
                                 • Com plex types ( f l o a t _ C o m p le x , d o u b l e _ C o m p le x , l o n g d o u ­
                                   b l e _ C o m p le x ) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                         E sca pe S eq u ences

                         A character constant is usually one character enclosed in single quotes, as w e’ve
                         seen in previous examples. However, certain special characters— including the
                         new-line character— can’t be written in this way. because they’re invisible (non­
                         printing) or because they can't be entered from the keyboard. So that programs can
                         deal with every character in the underlying character set, C provides a special nota­
                                   escape seq u en ce.
                         tion, the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                              There are two kinds of escape sequences: ch a ra cter escapes and n u m e ric
                         escapes. We saw a partial list of character escapes in Section 3 .l: Table 7.5 gives
                         the complete set.

         T a b le 7 .5                                         N am e          E sca p e S e qu en ce
Character Escapes RQPONMLKJIHGFEDCBA                      Alcrt (bell)                  \a
                                                          Backspace                     \b
                                                          Form feed                     \f
                                                          New line                      \n
                                                          CarriagV
                                                                 —>e return             \r
                                                          Horizontal tab                \t
                                                          Vertical tab                  \v
                                                          Backslash                     \\
                                                          Question inark                \?
                                                          Single quote                  \'
                                                          Double quote                  \ 11

                             The \ a , \ b , \ f , \ r , \ t , and \ v escapes represent common ASC11 controlaZYXWVUTSRQPON
              Q&A        characters. The \ n escape represents the ASCII line-feed character. The \ \ escape
                         allows a character constant or string to contain the \ character. The \ ’ escape
138 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 7    B a s ic T y p e s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   allows a character constant to contain the ' character, while the \ " escape allows a
                         Q&A       string to contain the ” character. The \ ? escape is rarely used.
                                        Character escapes are handy, but they have a problem: the list of character
                                   escapes doesn't include all (he nonprinting ASCII characters, just the most com ­
                                   mon. Character escapes are also useless for representing characters beyond the
                                   basic l28 ASCH characters. Numeric escapes, which can represent cbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                          any character,
                                   are the solution to this problem.
                                        To write a numeric escape for a particular character, first look up the charac­
                                   ter’s octal or hexadecimal value in a table like the one in Appendix E. For example,
                                   the ASCII escape character (decimal value: 27) has the value 33 in octal and IB in
                                   hex. Either of these codes can be used to write an escape sequence:
                                     ■ An octa l escape seq u en ce consists of the \ character followed by an octal
                                        number with at most three digits. (This number must be representable as an
                                        unsigned character, so its maximum value is normally 377 octal.) For exam ­
                                        ple, the escape character could be written \ 3 3 or \ 0 3 3 . Octal numbers in
                                        escape sequences— unlike octal constants— don’t have to begin with 0.
                                     ■   A h exa d ecim a l escape seq u en ce consists of \ x followed by a hexadecimal
                                         number. Although C places no limit on the number of digits in the hexadeci­
                                         mal number, it must be representable as an unsigned character (hence it can’t
                                         exceed FF if characters are eight bits long). Using this notation, the escape
                                         character would be written \ x l b or \ x l B . The x must be in lower case, but
                                         the hex digits (such as b) can be upper or lower case.
                                        When used as a character constant, an escape sequence must be enclosed in
                                   single quotes. For example, a constant representing the escape character would be
                                   written ’ \ 3 3 ' (or ' \ x l b * ) . Escape sequences tend to get a bit cryptic, so it’s
                                   often a good idea to give them names using # d e f i n e :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   #define ESC '\33'                /* ASCII escape character */
                                   Escape sequences can be embedded in strings as well, as we saw in Section 3.1.
                                         Escape sequences aren't the only special notations for representing charac­
        trigraph sequences >25.3   ters. Trigraph sequences provide a way to represent the characters #. [. \ , ] , ^, {,
                                    |, }, and ~, which may not be available on keyboards in some countries. C99
 universal character names >25.4   adds universal character names, which resemble escape sequences. Unlike escape
                                   sequences, however, universal character names are allowed in identifiers.


                                   C h a r a c te r -H a n d lin g F u n c t io n s

                                   Earlier in this section, we saw how to write an i f statement that converts a lower­
                                   case letter to upper-case:
                                   if ('a' <= ch && ch <= *z')
                                     ch = ch - 'a ’ + 1A ’;

                                   This isn’t the best method, though. A faster— and more portable— way to convert
                                   case is to call C ’s t o u p p e r library function:
                                                       7 .3                                       139
                                                              C h a r a c t e r T y p e s kjihgfedcbaZYXWVUTSRQPONMLKJIH


ch = toupper(ch);             /* converts ch to upper case */onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDC

When it’s called, t o u p p e r checks whether its argument (c h in this case) is a
lower-case letter. If so, it returns the corresponding upper-case letter. Otherwise,
t o u p p e r returns the value of the argument. In our example, we’ve used the
assignment operator to store the return value of t o u p p e r back into the c h vari­
able, although we could just as easily have done something else with it— stored it
in another variable, say, or tested it in an i f statement:

if (toupper(ch) == 'A') ...

     Programs that call t o u p p e r need to have the following # i n c l u d e directive
at the top:

#include <ctype.h>

t o u p p e r isn’t the only useful character-handling function in the C library. Sec­
tion 23.5 describes them all and gives examples of their use.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


R e a d in g a n d W r itin g C h a r a c te r s u s in g s c a n f a n d p r i n t f

The %c conversion specification allows s c a n f and p r i n t f to read and write sin­
gle characters:

char ch;

scanf("%c", &ch);             /* reads a single character */
printf("%c", ch);             /* writes a single character */

     s c a n f doesn’t skip white-space characters before reading a character. If the
next unread character is a space, then the variable c h in the previous example will
contain a space after s c a n f returns. To force s c a n f to skip white space before
reading a character, put a space in its format slringjust before %c:

scanf(” %c”, &ch);             /* skips white space, then reads ch */

Recall from Section 3.2 that a blank in a s c a n f format string means “skip zero or
more white-space characters.”
     Since s c a n f doesn’t normally skip white space, it’s easy to detect the end of
an input line: check to see if the characterjust read is the new-line character. For
example, the following loop will read and ignore all remaining characters in the
current input line:

do {
  scanf(”%c”, &ch);
} while (ch != ’\n');

When s c a n f is called the next time, it will read the first character on the next
input line.
140 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7     B a s ic T y p e s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   R e a d in g a n d W r it in g C h a r a c te r s u s in g g e t c h a r a n d p u t c h a r onmlkjihgf

                                   C provides other ways to read and write single characters. In particular, we can use
                         Q&A       the g e t c h a r and p u t c h a r functions instead of calling s c a n f and p r i n t f .
                                   p u t c h a r writes a single character:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   putchar(ch);

                                   Each time g e t c h a r is called, it reads one character, which it returns. In order to
                                   save this character, we m ust use assiucnm ent to store it in a variable:

                                   ch = getchar();                /* reads a character and stores it in ch */

                                   g e t c h a r actually returns an i n t value rather than a c h a r value (the reason will
                                   be discussed in later chapters). As a result, it’s not unusual for a variable to have
                                   type i n t rather than c h a r if il will be used to store a character read by g e t c h a r .
                                   Like s c a n f , g e t c h a r doesn’t skip white-space characters as it reads.
                                         Using g e t c h a r and p u t c h a r (rather than s c a n f and p r i n t f ) saves lime
                                   when the program is executed, g e t c h a r and p u t c h a r are fast for two reasons.
                                   First, they’re much simpler than s c a n f and p r i n t f , which are designed to read
                                   and write many kinds of data in a variety of formats. Second, g e t c h a r and
                  macros > 14.3    p u t c h a r are usually im plemented as macros for additional speed.
                                         g e t c h a r has another advantage over s c a n f : because it returns the charac­
                                   ter that it reads, g e t c h a r lends itself lo various C idioms, including loops that
                                   search for a character or skip over all occurrences of a character. Consider the
                                   s c a n f loop that we used to skip the rest o fa n input line:

                                   do {
                                     scanf("%c", &ch);
                                   } while (ch != ’\n’);

                                   Rewriting this loop using g e t c h a r gives us the following:

                                   do {
                                     ch = getchar();
                                   } while (ch != '\n');

                                   Moving the call o f g e t c h a r into the controlling expression allows us to condense
                                   the loop:

                                   while ((ch = getchar())                       ’= '\n')
                                     /•

                                   This loop reads a character, stores it into the variable c h . then tests if c h is not
                                   equal to the new-line character. If(he test succeeds, the loop body (which is em pty)
                                   is executed, then the loop test is performed once more, causing a new character to
                                   be read. Actually, we don’t even need the c h variable; we can just com pare the
                                   return value of g e t c h a r with the new-line character:
                                                                                 7 .3   C h a r a c te r T y p e s hgfedcbaZYXWVUTSRQPONM
                                                                                                                            141 aZYXWVUTS


       id io m       while (getchar()
                 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA      != '\n')     /* skips rest of line */
                          •
                         t   onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                     The resulting loop is a well-known C idiom that’s cryptic but worth learning.
                          g e t c h a r is useful in loops that skip characters as well as loops that search
                     for characters. Consider the following statement, which uses g e t c h a r to skip an
                     indefinite number o fblank characters:

       id io m       while ((ch = getchar()) == ' ')                           /* skips blanks */
                         t




                     When the loop terminates, c h will contain the first nonblank character that
                     g e t c h a r encountered.


                     Be careful if you mix g e t c h a r and s c a n f in the same program, s c a n f has a
        A            tendency to leave behind characters that it has “peeked” at but not read, including
                     the new-line character. Consider what happens ifw e try to read a number first, then
                     a character:

                     printf("Enter an integer: ");
                     scanf("%d", &i);
                     printf("Enter a command: ");
                     command = getchar();

                     The call of s c a n f will leave behind any characters that w eren’t consumed during
                     the reading of i , including (but not limited to) the new-line character, g e t c h a r
                     will fetch the first leftover character, which wasn’t what we had in mind.




                   D e te r m in in g th e L e n g th o f a M e ss a g e
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                     To illustrate how characters are read, let’s write a program that calculates the
                     length of a message. After the user enters the message, the program displays the
                     lengCth:

                     Enter a message: Brevity is the soul of wit.
                     Your message was 27 character(s) long.

                     The length includes spaces and punctuation, but not the new-line character at the
                     end of the messag^ve,
                           We’ll need a loop whose body reads a character and increments a counter. The
                     loop will terminate as soon as a new-line character turns up. We could use either
                     s c a n f or g e t c h a r to read characters; most C programmers would choose
                     g e t c h a r . Using a straightforward w h i l e loop, we might end up with the follow­
                     ing program.
142 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 7 B a s ic T ypes BA

                 length.ckjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                              /* Determines the length of a message */

                               #include <stdio.h>

                               int main(void)

                                  char ch;
                                  int len = 0;

                                  printf("Enter a message:               '•);
                                  ch = getc ha r ();
                                  while (ch != •\ n ') {



                                  printf("Your message was %d character(s)                   long.\n",      len);

                                  return 0;


                                    Recalling our discussion of idioms involving w h i l e loops and g e t c h a r , \ve
                               realize that the program can be shortened:

                length2.c      /* Determines the length of a message */

                               #include <stdio.h>

                               int main(void)

                                  int len = 0;

                                  printf("Enter a message: ");
                                  while (getchar() != *\n‘)
                                    len++;
                                  printf(”Your message was %d character(s)                   long.\n",      len);

                                  return 0;aZYXWVUTSRQPONMLKJIHGFEDCBA




                      7 .4     T y p e C o n v e r s io n

                               Com puters tend to be more restrictive than C when it com es to arithm etic. For a
                               com puter to perform an arithmetic operation, the operands must usually be of the
                               same size (the same number of bits) and be stored in the sam e way. A com puter
                               may be able to add two 16-bit integers directly, but not a 16-bit integer and a 32-bit
                               integer or a 32-bit integer and a 32-bit floating-point number.
                                    C, on the other hand, allows the basic types to be mixed in expressions. We
                               can com bine integers, floating-point numbers, and even characters in a single
                               expression. The C com piler may then have to generate instructions that convert
                                                                          7 .4                                         143 onmlkjihgfedc
                                                                                   T y p e C o n v e r s io n hgfedcbaZYXWVUTSRQPONML


      some operands to different types so that the hardware will be able to evaluate the
      expression. If we add a 16-bit s h o r t and a 32-bit i n t , for example, the compiler
      will arrange for the s h o r t value to be converted to 32 bits. If we add an i n t and
      a f l o a t , the com piler will arrange for the i n t to be converted to f l o a t format.
      This conversion is a little more com plicated, since i n t and f l o a t values are
      stored in different ways.
            Because the com piler handles these conversions automatically, without the
      program m er’s involvement, they’re known as RQPONMLKJIHGFEDCBA
                                                                    i m p l i c i t c o n v e r s i o n s . C also allows
      the program m er to perform e x p l i c i t c o n v e r s i o n s , using the cast operator. I’ll dis­
      cuss implicit conversions first, postponing explicit conversions until later in the
      section. Unfortunately, the rules for perform ing im plicit conversions are somewhat
      complex, primarily because C has so many different arithmetic types.
            Im plicit conversions are perform ed in the following situations:

        ■     When the operands in an arithm etic or logical expression don’t have the same
              type. (C performs what are known as the u s u a l a r i t h m e t i c c o n v e r s i o n s . )
            ■ W hen the type of the expression on the right side of an assignment doesn't
               match the type of the variable on the left side.
            ■ W hen the type of an argument in a function call doesn’t match the type of the
               corresponding parameter.
        ■ Whe n the type of the expression in a r e t u r n statem ent doesn’t match the
           function’s return type.
      W e’ll discuss the first two cases now and save the others for C hapter 9.dcbaZYXWVUTSRQPONMLKJIHGF


      T h e U su a l A r ith m e tic C o n v e r s io n s

      The usual arithmetic conversions are applied to the operands o f most binary opera­
      tors, including the arithmetic, relational, and equality operators. For example, let’s
      say that f has type f l o a t and i has type i n t . The usual arithmetic conversions
      will be applied to the operands in the expression f + i , because their types aren’t
      the same. Clearly it’s safer to convert i to type f l o a t (m atching f ’s type) rather
      than convert f to type i n t (m atching i ’s type). An integer can always be con­
      verted to f l o a t ; the worst that can happen is a minor loss o f precision. Convert­
      ing a floating-point number to i n t , on the other hand, would cost us the fractional
      part of the number. W orse still, w e’d get a com pletely meaningless result if the
      original number were larger than the largest possible integer or sm aller than the
      smallest integer.
           The strategy behind the usual arithmetic conversions is to convert operands to
      the “narrowest” type that will safely accom m odate both values. (Roughly speak­
      ing, one type is narrower than another if it requires fewer bytes to store.) The types
      of the operands can often be made to match by converting the operand of the nar­
      rower type to the type of the other operand (this act is known as p r o m o t i o n ) .
      Among the most common promotions are the i n t e g r a l p r o m o t i o n s , which convert
Q&A   a character or short integer to type i n t (or to u n s i g n e d i n t in some cases).
144 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7     B a s ic T y p e s


                                       We can divide the rules for performing the usual arithm etic conversions into
                                   two cases:RQPONMLKJIHGFEDCBA

                                     ■       T h e ty p e o f e i th e r o p e r a n d is a f l o a t i n g ty p e .   Use the following diagram to
                                             promote the operand whose type is narrower:

                                                                                           lo n g d o u b le

                                                                                                 d o u b le

                                                                                                   flo a t

                                             That is, if one operand has type l o n g d o u b l e , then convert the other oper­
                                             and to type l o n g d o u b l e . Otherwise, ifo n e operand has type d o u b l e , con­
                                             vert the other operand to type d o u b l e . Otherwise, if one operand has type
                                             f l o a t , convert the other operand to type f l o a t . Note that these rules cover
                                             mixtures of integer and floating types: ifo n e operand has type l o n g i n t , for
                                             example, and the other has type d o u b l e , the l o n g i n t operand is converted
                                             to d o u b l e .
                                         ■                                            First perform integral promotion on
                                             N e i t h e r o p e r a n d t y p e is a f l o a t i n g t y p e .
                                             both operands (guaranteeing that neither operand will be a character or short
                                             integer). Then use the following diagram to promote the operand whose type
                                             is narrower:

                                                                                   u n s ig n e d         lo n g   in t

                                                                                              lo n g i n t
                                                                                                    ?
                                                                                          u n s ig n e d i n t
                                                                                                    ?


                                   T here’s one special case, but it occurs only when l o n g i n t and u n s i g n e d i n t
                                   have the same length (32 bits, say). Under these circum stances, ifo n e operand has
                                   type l o n g i n t and the other has type u n s i g n e d i n t , both are converted lo
                                   u n s i g n e d l o n g i n t .kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   When a signed operand is combined with an unsigned operand, the signed operand

                        A          is converted to an unsigtw*ned value. vT^1he conversion^* involves adding or subtracting a
                                   multiple o f n + 1, where n is the largest representable value of the unsigned type.
                                   This rule can cause obscure programming errors.
                                         Suppose that the i n t variable i has the value -1 0 and the u n s i g n e d i n t
                                   variable u has the value 10. If we compare i and u using the < operator, we might
                                   expect to get the result 1 (true). Before the comparison, however, i is converted to
                                   u n s i g n e d i n t . Since a negative number can’t be represented as an unsigned
                                   integer, the converted value w on’t be -1 0 . Instead, the value 4,294,967,296 is
                                   added (assuming that 4,294,967.295 is the largest u n s i g n e d i n t value), giving
                                                     7.4    T y p e C o n v e r s io n onmlkjihgfedcbaZYXWVUTSRQPONMLK
                                                                                                  145

a converted value of 4,294,967,286. The comparison i < u will therefore produce
0. Some compilers produce a warning message such as “com parison betw een
sig n ed and unsig ned” when a program attempts to compare a signed num ber with
an unsigned number.
      Because of traps like this one, it's best to use unsigned integers as little as pos­
sible and, especially, never mix them with signed integers.


     The following example shows the usual arithmetic conversions in action:kjihgfedcbaZYXWVUTSRQPON

char c ;
short int s ;
int i ;
unsigned int u;
long int 1;
unsigned long int ul;
float f;
double d;
long double ld;

i = i+ c;                /* c   is converted to int                */
i = i+ s;                /* s   is converted to int                */
u = u+ i;                /* i   is converted to unsigned int       */
1 = 1+ u;                /* u   is converted to long int           */
ul = ul + 1;             /* 1   is converted to unsignedlong int */
f = f + ul;              /*ul   is converted to float              */
d = d 4- f;              /* f   is converted to double             */
ld = ld 4- d;            /* d   is converted to long double        */dcbaZYXWVUTSRQPONMLKJIH


C o n v e r sio n D u r in g A s s ig n m e n t

The usual arithmetic conversions don’t apply to assignment. Instead, C follows the
simple rule that the expression on the right side of the assignm ent is converted to
the type of the variable on the left side. If the variable’s type is at least as “wide” as
the expression’s, this will work without a snag. For example:

char c;
int i;
float f;
double d;

i = c;        /* c is converted to int   */
f = i;        /* i is converted to float */
d = f;        /* f is converted to double */

     Other cases are problematic. Assigning a floating-point num ber to an integer
variable drops the fractional part o fth e number:

int i ;

i = 842.97;             /* i is now 842 */
i = -842.97;            /* i is now -842 */
146 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  Moreover, assigning a value to a variable of a narrower type will give a meaning­
                                  less result (or worse) if the value is outside the range of the variable’s type:kjihgfedcbaZYXWVUTSR
                        Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   C = 10000;              /*** WRONG
                                   i = 1.0e20;             /*** WRONG
                                   f = 1.0el00;            /*** WRONG

                                   A “narrowing” assignment may elicit a warning from the compiler or from tools
                                   such as l i n t .
                                        It’s a good idea to append the f suffix to a floating-point constant if it will be
                                   assigned to a f l o a t variable, as w e’ve been doing since Chapter 2:

                                   f = 3.14159f;

                                  Without the suffix, the constant 3 .1 4 1 5 9 would have type d o u b l e , possibly
                                  causing a warning message.


                        <^)        I m p li c it C o n v e r s io n s in C 9 9

                                  The rules for implicit conversions in C99 are somewhat different from the rules in
                Booitype>s.2      C89, primarily because C99 has additional types (_ B o o l, l o n g l o n g types,
                                  extended integer types, and complex types).
                                       For the purpose of defining conversion rules, C99 gives each integer type an
                                  “integer conversion rank.” Here are the ranks from highest to lowest:

                                        1. l o n g l o n g i n t , u n s i g n e d l o n g l o n g i n t
                                        2. l o n g i n t , u n s i g n e d l o n g i n t
                                        3. i n t , u n s i g n e d i n t
                                        4. s h o r t i n t , u n s i g n e d s h o r t i n t
                                        5. c h a r , s i g n e d c h a r , u n s i g n e d c h a r
                                        6. _ B o o l

                                  For simplicity, I'm ignoring extended integer types and enumerated types.
                                        In place of C89’s integral promotions. C99 has “integer promotions,” which
                                  involve converting any type whose rank is less than i n t and u n s i g n e d i n t to
                                  i n t (provided that all values of the type can be represented using i n t ) or else to
                                  u n s ig n e d in t .
                                        As in C89, the C99 rules for performing the usual arithmetic conversions can
                                  be divided into two cases:cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     ■ The type o f either operand is a flo a tin g type. As long as neither operand has a
                                       complex type, the rules are the same as before. (The conversion rules for com ­
                                       plex types will be discussed in Section 27.3.)
                                     ■ N eith er operand type is a flo a tin g type. First perform integer promotion on
                                       both operands. If the types of the two operands are now the same, the process
                                       ends. Otherwise, use the following rules, stopping at the first one that applies:
                                        • If both operands have signed types or both have unsigned types, convert the
                                                                                       7 .4    T y p e C o n v e r s io n aZYXWVUTSRQPONMLKJIHGFEDCB
                                                                                                                                 1 4 7 onmlkjihgfedcbaZYXW


                                     operand whose type has lesser integer conversion rank to the type of the
                                     operand with greater rank.
                                  • If the unsigned operand has rank greater or equal to the rank o f the type of
                                    the signed operand, convert the signed operand to the type of the unsigned
                                    operand.
                                  ♦ If the type of the signed operand can represent a ll of the values of the type
                                       of the unsigned operand, convert the unsigned operand to the type of the
                                       signed operand.
                                  • Otherwise, convert both operands to the unsigned type corresponding to the
                                    type of the signed operand.
                                   Incidentally, all arithmetic types can be converted to _ B o o l type. The result
                             o fth e conversion is 0 ifth e orig<C3inal value is 0;7 otherwise,* the result is 1.dcbaZYXWVUTSRQPONMLKJIHGFED


                             C a s tin g

                             Although C ’s implicit conversions are convenient, we sometimes need a greater
                             degree of control over type conversion. For this reason, C provides cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                 casts. A cast
                             expression has the form


c a s t e x p r e s s io n                                    ( type-nam e ) expression


                             type-nam e specifies the type to which the expression should be converted.
                                  The following example shows how to use a cast expression to compute the
                             fractional part o fa f l o a t value:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             float f, frac_part;

                             frac_part = f - (int) f;

                             The cast expression ( i n t ) f represents the result of converting the value of f to
                             type i n t . C ’s usual arithmetic conversions then require that ( i n t ) f be con­
                             verted back to type f l o a t before the subtraction can be performed. The differ­
                             ence between f and ( i n t ) f is the fractional part of f , which was dropped
                             duringo the cast,
                                  Cast expressions enable us to document type conversions that would take
                             place anyway:

                             i = (int) f;            /* f is converted to int */

                             They also enable us to overrule the com piler and force it to do conversions that we
                             want. Consider the following example:

                             float quotient;
                             int dividend, divisor;

                             quotient = dividend / divisor;
148 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s


                                  As il’s now written, the result of the division— an intcue>er— will be converted lo
                                  f l o a t form before being stored in q u o t i e n t . We probably want d i v i d e n d
                                                                            before the division, though, so that we get a
                                  and d i v i s o r converted to f l o a t cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  more exact answer. A cast expression will do the trick:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  quotient = (float) dividend / divisor;

                                  d i v i s o r doesn’t need a cast, since casting d i v i d e n d to f l o a t forces the
                                  compiler to convert d i v i s o r to f l o a t also.
                                        Incidentally, C regards ( type-nam e ) as a unary operator. Unary operators
                                  have higher precedence than binary operators, so the compiler interprets

                                   (float) dividend / divisor

                                  as

                                   ((float) dividend) / divisor

                                  If you find this confusing, note that there are other ways to accomplish the same
                                  effect:

                                  quotient = dividend / (float) divisor;

                                  or

                                  quotient = (float) dividend / (float) divisor;

                                      Casts are sometimes necessary to avoid overflow. Consider the following
                                  example:

                                  long i;
                                  int j = 1000;

                                  i = J * j;         /* overflow may occur */

                                  At first glance, this statement looks fine. The value o f j * j is 1.000,000, and i is
                                  a l o n g , so it can easily store values of this size, right? The problem is that when
                                  two i n t values are multiplied, the result will have i n t type. But j * j is too
                                  large to represent as an i n t on some machines, causing an overflow. Fortunately,
                                  using a cast avoids the problem:

                                  i = (long) j * j;

                                  Since the cast operator takes precedence over *. the first j is converted to l o n g
                                  type, forcing the second j to be converted as well. Note that the statement

                                  i = (long)      (j * j);         /*** WRONG ***/

                                  wouldn’t work, since the overflow would already have occurred by the time of the
                                  cast.
                                                                         7 .5                                    149aZYXWVUTSRQP
                                                                                T y p e D e fin itio n s kjihgfedcbaZYXWVUTSRQPONMLKJ




7 .5   T y p e D e f i n it io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

       In Section 5.2, we used the # d e f i n e directive to create a macro that could be
       used as a Boolean type:

       #define BOOL int

Q&A    T here’s a better way to set up a Boolean type, though, using a feature known as a RQPONMLKJIHG
       ty p e d e fin itio n :

       typedef int Bool;

                                                                last. Note also that T’ve capi­
       Notice that the name of the type being defined comes cbaZYXWVUTSRQPONMLKJIHGFEDCBA
       talized the word B o o l. Capitalizing the first letter of a type name isn’t required;
       it’sju st a convention that some C programm ers employ.
            Using t y p e d e f to define B o o l causes the com piler to add B o o l to the list
       of type names that it recognizes. B o o l can now be used in the same way as the
       built-in type names— in variable declarations, cast expressions, and elsewhere. For
       exam ple, we might use B o o l to declare variables:

       Bool flag;                /* same as int flag; */

       The com piler treats B o o l as a synonym for i n t ; thus, f l a g is really nothing
       more than an ordinary i n t variable.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


       A d v a n ta g e s o f T y p e D e f in it io n s

       Type definitions can make a program more understandable (assum ing that the pro­
       gram m er has been careful to choose meaningful type names). For example, sup­
       pose that the variables c a s h _ i n and c a s h _ o u t will be used to store dollar
       amounts. Declaring D o l l a r s as

       typedef float Dollars;

       and then writing<x

       Dollars cash_in, cash_out;

       is more informative thanjust writing

       float cash_in, cash_out;

            Type definitions can also make a program easier to modify. U’ we later decide
       that D o l l a r s should really be defined as d o u b l e , all we need do is change the
       type definition:

       typedef double Dollars;
1 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 7    B a s ic T yp e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      The declarations of D o l l a r s variables need not be changed. Without the type
                                      definition, we would need to locate all f l o a t variables that store dollar amounts
                                      (not necessarily an easy task) and change their declarations.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      T y p e D e fin itio n s a n d P o r ta b ility

                                      Type definitions are an important tool for writing portable programs. One of the
                                      problems with moving a program from one com puter to another is that types may
                                      have different ranges on different machines. If i is an i n t variable, an assignment
                                      like kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      i = 100000;

                                      is fine on a machine with 32-bit integers, but will fail on a machine with J6-bit
                                      integ^*ers.aZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 F orgreaterportabiU ty, consider using typedef to define new n a n ie sfo r
             p o r t a b ili t y t ip cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            integer types.

                                          Suppose that w e’re writing a program that needs variables capable of storing
                                     product quantities in the range 0-50,000. We could use l o n g variables for this
                                     purpose (since they’re guaranteed to be able to hold numbers up to at least
                                     2,147,483,647), but we’d rather use i n t variables, since arithmetic on i n t values
                                     may be faster than operations on l o n g values; also, i n t variables may take up
                                     less space.
                                          Instead ofusing the i n t type to declare quantity variables, we can define our
                                     own “quantity” type:

                                      typedef int Quantity;

                                      and use this type to declare variables:

                                     Quantity q;

                                     When we transport the program to a machine with shorter integers, w e’ll change
                                     the definition o f Q u a n t i t y :

                                      typedef long Quantity;

                                     This technique doesn’t solve all our problems, unfortunately, since changing the
                                     definition o f Q u a n t i t y may affect the way Q u a n t i t y variables are used. At the
                                     very least, calls o f p r i n t f and s c a n f that use Q u a n t i t y variables will need to
                                     be changed, with %d conversion specifications replaced by % ld.
                                           The C library itself uses t y p e d e f to create names for types that can vary
                                     from one C implementation to another; these types often have names that end with
                                     _ t , such as p t r d i f f _ t , s i z e _ t , and w c h a r _ t . The exact definitions o fth ese
                                     types will vary, but here are some typical examples:
                                                                                    7 .6                                              151
                                                                                             T h e s i z e o f O p e r a t o r kjihgfedcbaZYXWVUTSRQP

                                typedef long int ptrdiff__t;
                                typedef unsigned long int size_t;
                                typedef int wchar_t;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                In C99, the < s t d i n t . h > header uses t y p e d e f to define names for integer
                                           types with a particular num ber o fb its. For example, i n t 3 2 _ t is a signed integer
 < s t d i n t . h > h e a d e r ZYXWVUTSRQPONMLKJIHGFEDCBA
                                 > 2 7 .1

                                           type with exactly 32 bits. Using these types is an effective way to make programs
                                           more portable.aZYXWVUTSRQPONMLKJIHGFEDCBA




                      7 .6      T h e s i z e o f O p e ra to r

                                The s i z e o f operator allows a program to determ ine how much memory is
                                required to store values of a particular type. The value o f the expression


s i z e o f e x p re s s io n                                   s iz e o f         type-nam e )
                                                                              ( cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                is an unsigned integer representing the num ber of bytes required to store a value
                                belonging lo type-nam e, s i z e o f ( c h a r ) is always 1, but the sizes o f th e other
                                types may vary. On a 32-bit machine, s i z e o f ( i n t ) is normally 4. Note thal
                                s i z e o f is a rather unusual operator, since the com piler itselfcan usually deter­
                      Q&A       mine the value o f a s i z e o f expression.
                                      The s i z e o f operator can also be applied to constants, variables, and expres­
                                sions in general. If i and j are i n t variables, then s i z e o f ( i ) is 4 on a 32-bit
                                machine, as is s i z e o f ( i + j ). When applied to an expression— as opposed to a
                                type— s i z e o f doesn’t require parentheses; we could write s i z e o f i instead of
                                s i z e o f ( i ) . However, parentheses may bc needed anyway because of operator
                                precedence. The com piler would interpret s i z e o f i + j as ( s i z e o f i ) + j ,
                                because s i z e o f — a unary operator— takes precedence over the binary + opera­
                                tor. To avoid problems, I always use parentheses in s i z e o f expressions.
                                      Printing a s i z e o f value requires care, because the type of a s i z e o f expres­
                                sion is an im plem entation-defined type named s i z e _ t . In C89, if s best to con­
                                vert the value of the expression to a known type before printing it. s i z e _ t is
                                guaranteed to be an unsigned integer type, so it’s safest to cast a s i z e o f expres­
                                sion to u n s i g n e d l o n g (the largest of C 89’s unsigned types) and then print it
                                usingo the % lu conversion:

                                printf("Size of int: %lu\n",                   (unsigned long) sizeof(int));

                                      In C99, the s i z e _ t type can be larger than u n s i g n e d l o n g . However, the
                                p r i n t f function in C99 is capable ofdisplaying s i z e _ t values directly, without
                                needing a cast. The trick is to use the letter z in the conversion specification, fol­
                                lowed by one o fth e usual integer codes (typically u):

                                printf(*'Size of int: %zu\n", sizeof(int));                                     /* C99 only */
152 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                           Q:     S e c tio n 7.1 s a y s th a t %o a n d %x a r e u se d to w r ite u n s ig n e d in te g e r s in o c ta l
                                   a n d h e x n o ta tio n . H o w d o I w r ite o r d in a r y (s ig n e d ) in te g e r s in o c ta l o r h e x ?
                                   [p . 1 3 0 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                           A:     You can use %o and %x to print a signed integer as long as its value isn’t negative.
                                  These conversions cause p r i n t f to treat a signed integer as though it were
                                  unsigned; in other words, p r i n t f will assume that the sign bit is part of the num­
                                  ber’s magnitude. As long as the sign bit is 0, there’s no problem. If the sign bit is 1,
                                  p r i n t f will print an unexpectedly large number.

                           Q:     B u t w h a t if th e n u m b e r z\ n e g a tiv e ? H o w c a n 1 w r ite it in o c ta l o r h e x ?
                           A:     There’s no direct way to print a negative number in octal or hex. Fortunately, the
                                  need to do so is pretty rare. You can, ofcourse. test whether the number is negative
                                  and print a minus sign yourself:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   if (i < 0)
                                     printf("-%x”, -i);
                                   else
                                     printf (”%x*', i) ;

                           Q:      W h y a r e flo a tin g c o n s ta n ts s to r e d in d o u b l e fo r m r a th e r th a n f l o a t fo r m ?
                                   [p . 1 3 3 ]
                           A:     For historical reasons. C gives preference to the d o u b l e type: f l o a t is treated
                                  as a second-class citizen. Consider, for instance, the discussion of f l o a t in Ker-
                                                          The C Programming Language: “The main reason for using
                                  nighan and Ritchie’s cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  f l o a t is to save storage in large arrays, or. less often, to save time on machines
                                  where double-precision arithmetic is particularly expensive.” C originally man­
                                  dated that all floating-point arithmetic be done in double precision. (C89 and C99
                                  have no such requirement.)

                         *Q :     W h a t d o h e x a d e c im a l flo a tin g c o n s ta n ts lo o k lik e , a n d w h a t a r e th e y g o o d
                                   fo r? [p . 1 34]
                           A:     A hexadecimal floating constant begins with 0 x or 0X and must contain an expo­
                                  nent, which is preceded by the letter P (or p). The exponent may have a sign, and
                                  the constant may end with f , F, 1, or L. The exponent is expressed in decimal, but
                                  represents a power o f2 , not a power of 10. For example. 0 x 1 . Bp3 represents the
                                  number 1.6875 x 2 3 = 13.5. The he,x digit B corresponds to the bit pattern 1011.
                                  The B occurs to the right of the period, so each I bit represents a negative power of
                                  2. Summing these powers o f 2 (2~1 + 2~3 4- 2^4 ) yields .6875.
                                       Hexadecimal floating constants are primarily useful for specifying constants
                                  that require great precision (including mathematical constants such as e and K).
                                  Hex numbers have a precise binary representation, whereas a constant written in
                                  decimal may be subject to a tiny rounding error when converted to binary. Hexa-
                                                                                                                                                              153onmlkjihgfedcbaZYX
                                                                                                                                                Q & A kjihgfedcbaZYXWVUTSRQPONMLKJI


                                                  decimal numbers are also useful for defining constants with extreme values, such
                                                  as the values of the macros in the < f l o a t . h> header. These constants are easy to
                                                  write in hex but difficult to write in decimal.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      *Q :        W h y d o w e u se % lf to r e a d a d o u b l e v a lu e b u t %f to p r in t it? [p . 1 34]
                                         A:       This is a tough question to answer. First, notice that s c a n f and p r i n t f are
                                                  unusual functions in that they aren’t restricted to a fixed number ofargum ents. We hgfedcbaZYXWVUT
v a r ia b ie - ie n g th a r g u m e n tiis ts   say that s c a n f and p r i n t f have variable-length argument lists. When functions RQPONMLKJIHGFE
                                     ^ 26 1
                                                  with variable-length argument lists are called, the compiler arranges for f l o a t
                                                  arguments to be converted automatically to type d o u b l e . As a result, p r i n t f
                                                  can’t distinguish between f l o a t and d o u b l e arguments. This explains why %f
                                                  works for both f l o a t and d o u b l e arguments in calls o f p r i n t f .
                                                       s c a n f . on the other hand, is passed a pointer     to a variable, %f tells s c a n f to
                                                                                                  cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                  store a f l o a t value at the address passed to it. while % lf tells s c a n f to store a
                                                  d o u b l e value at that address. The distinction between f l o a t and d o u b l e is
                                                  crucial here. If given the wrong conversion specification, s c a n f will likely store
                                                  the wrong number ofbytes (not to mention the fact that the bit pattern for a f l o a t
                                                  isn’t the same as that for a d o u b l e ) .

                                         Q:       W h a t’s th e p r o p e r w a y to p r o n o u n c e c h a r ? [p , 1 3 4 ]
                                         A:       There’s no universally accepted pronunciation. Some people pronounce c h a r in
                                                  the same way as the first syllable of “character.” Others say “char.” as in
                                                  char b ro ile d ;
                                         Q:       W h e n d o e s it m a tte r w h e th e r a c h a r a c te r v a r ia b le is s ig n e d o r u n s ig n e d ? [p.
                                                  136]
                                         A:       Ifw e store only 7-bit characters in the variable, it doesn’t matter, since the sign bit
                                                  will be zero, lfw e plan to store 8-bit characters, however, w e’ll probably want the
                                                  variable to have u n s i g n e d c h a r type. Consider the following example:
                                                  ch = ’ \ x d b ' ;
                                                  I f c h has been declared to have type c h a r , the compiler may choose to treat it as a
                                                  signed character (many compilers do). As long as c h is used only as a character,
                                                  there won’t be any problem. But if c h is ever used in a context that requires the
                                                  compiler to convert its value to an integer, w e’re likely to have trouble: the result­
                                                  ingO inO teger will be nOegativ7e, since c h ’s vs-ign bit is 1.
                                                         Here’s another situation: In some kinds of programs, it’s customary to use
                                                  c h a r variables to store one-byte integers. 11' w e’re writing such a program, w e’ll
                                                  have to decide whether each variable should be s i g n e d c h a r or u n s i g n e d
                                                  c h a r .ju s t as we must decide whether ordinary integer variables should have type
                                                  i n t o ru n s ig n e d in t.

                                         Q:       I d o n ’t u n d e r s ta n d h o w th e n e w -lin e c h a r a c te r c a n b e th e A S C II lin e -fe e d
                                                  c h a r a c te r . W h e n a u s e r e n te r s in p u t a n d p r e s se s th e E n te r k e y , d o e s n ’t th e
                                                  p r o g r a m rea d th is a s a c a r r ia g e -r e tu r n c h a r a c te r o r a c a r r ia g e r e tu r n p lu s a
                                                  lin e fe e d ? [p . 137]
154 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 7    B a s ic T y p e s


                                            A:       Nope. As part of C ’s UNIX heritage, it always regards the end of a line as being
                                                     marked by a single line-feed character. (In UNIX text files, a single line-feed char­
                                                     acter— but no carriage return— appears at the end ofcach line.) The C library takes
                                                     care of translating the user’s keypress into a line-feed character. When a program
                                                     reads from afile, the I/O library translates the file’s end-of-line marker (whatever it
                                                     may be) into a single line-feed character. The same transformations occur— in
                                                     reverse— when output is written to the screen or to a file. (See Section 22.l for
                                                     details.)
                                                          Although these translations may seem confusing, they serve an important pur­
                                                     pose: insulating programs from details that may vary from one operating system to
                                                     another.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         *Q :        W h a t ’s th e p u r p o s e o f th e \ ? e s c a p e s e q u e n c e ? [p . 138]
                                            A:       The \ ? escape is related to lrigraph sequences, which begin with ? ? . Ifyou should hgfedcbaZY
        t r ig r a p h s e q u e n c e s > 2 5 . 3   put ? ? in a string, there’s a possibility that the compiler will mistake it for the
                                                     beginning o fa trigraph. Replacing the second ? by \ ? fixes the problem.

                                            Q:       I f g e t c h a r is fa ste r , w h y w o u ld w e e v e r w a n t to u se s c a n f to r e a d in d iv id ­
                                                     u a l c h a r a c te r s ? [p. 1 4 0 ]
                                            A:       Although it’s not as fast as g e t c h a r , the s c a n f function is more flexible. As we
                                                     saw previously, the "%c" format string causes s c a n f to read the next input char­
                                                     acter; “ %c" causes it to read the next non-white-space character. Also, s c a n f is
                                                     good at reading characters that are mixed in with other kinds of data. L efs say that
                                                     our input data consists of an integer, then a single nonnumeric character, then
                                                     another integer. By using the format string " %d%c%d", we can get s c a n f to read
                                                     all three items.

                                        *Q :         U n d e r w h a t c ir c u m s ta n c e s d o th e in te g r a l p r o m o tio n s c o n v e r t a c h a r a c te r o r
                                                     s h o r t in te g e r to u n s i g n e d i n t ? [p. 1 4 3 ]
                                            A:       The integral promotions yield an u n s i g n e d i n t if the i n t type isn’t large
                                                     enough to include aIJ possible values of the original type. Since characters are usu­
                                                     ally eight bits long, they are almost always converted to i n t , which is guaranteed
                                                     to be at least 16 bits long. Signed short integers can always be converted to i n t as
                                                     well. Unsigned short integers are problematic. If short integers have the same
                                                     length as ordinary integers (as they do on a I6-bit machine), then unsigned short
                                                     integers will have to be converted to u n s i g n e d i n t . since the largest unsigned
                                                     short integer (65,535 on a 16-bit machine) is larger than the largest i n t (32,767).

                                           Q:        E x a c tly w h a t h a p p e n s if I a ss ig n a v a lu e to a v a r ia b le t h a t ’s n o t la r g e e n o u g h
                                                     to h o ld it? [p . 146]
                                            A:       Roughly speaking, if the value is of an integral type and the variable is of an
                                                     unsigned type, the extra bits are thrown away; if the variable has a signed type, the
                                                     result is implementation-defined. Assigning a floating-point number to a vari­
                                                     able— integer or floating— thafs too small to hold it produces undefined behavior:
                                                     anything can happen, including program termination.
                                                                                                                                                                           155 dcbaZYXWVUTSRQP
                                                                                                                                                E x e r c is e s onmlkjihgfedcbaZYXWVUTSRQPONML


                                          ••:Q:        \V h y d o e s C b o th e r to p r o v id e ty p e d e f in it io n s ? k n ’t d e f in in g a BOOL m a c r o
                                                       j u s t a s g o o d a s d e fin in g a B o o l ty p e u s in g t y p e d e f ? [p . 1 4 9 ]

                                              A:       There are two important differences between type definitions and macro defini­
                                                       tions. First, type definitions are more powerful than macro definitions. In particu­
                                                       lar. array and pointer types can’t be defined as macros. Suppose that we try to use a
                                                       macro to define a “pointer to integer” type:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                       #define PTR_TO_INT int *

                                                       The declaration

                                                       PTR_TO_INT p, q, r;

                                                       will become

                                                       int * p, q, r;

                                                       after preprocessing. Unfortunately, only p is a pointer; q and r are ordinary integer
                                                       variables. Type definitions don’t have this problem.
                                                             Second, t y p e d e f names are subject to the same scope rules as variables: a
                                                       t y p e d e f name defined inside a function body w ouldn’t be recognized outside the
                                                       function. Macro names, on the other hand, are replaced by the preprocessor wher­
                                                       ever they appear.

                                          *Q :         Y o u s a id th a t c o m p ile r s “ c a n u s u a lly d e te r m in e th e v a lu e o f a s i z e o f e x p r e s ­
                                                       s io n .” C a n ’t a c o m p ile r RQPONMLKJIHGFEDCBA
                                                                                          a l w a y s d e t e r m in e th e v a lu e o f a s i z e o f e x p r e s s io n ?
                                                       [p . 1 5 1 ]
                                              A:       In C89, yes. In C99. however, there’s one exception. The com piler can’t determ ine hgfedcbaZYXWVUTS
        v a r ia b ie - ie n g ih a r r a y s > 8 .3   the size of a variable-length array, because the number of elements in the array
                                                       may change during the execution of the program.




                                                       E x e rc is e s

S e c ti o n 7.1                                 l.    Give the decimal value of each of the following integer constants.
                                                       (a) 077
                                                       (b) 0 x 7 7
                                                       (c) 0XABC

S e c ti o n 7 .2                               2.     Which of the following are not legal constants in C? Classify.each legal constant as either
                                                       integer or floating-point.
                                                       (a)   010E2
                                                       (b)   3 2 .1 E + 5
                                                       (c)   0790
                                                       (d)   100_000
                                                       (e)   3 .9 7 8 e - 2
            C h a p te r 7 B a s ic T ype s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
1 5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                       ©     3.     W hich of lhc following are not legal types in C?
                                    (a)   s h o r t u n s ig n e d i n t
                                    (b)   sh o rt flo a t
                                    (c)   lo n g d o u b le
                                    (d)   u n s i g n e d l o n g aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 7 .3       ©     4.     If c is a variable of type c h a r , which one o f the following statem ents is illegal?
                                    (a)   i += c ; / * i h a s            ty p e   in t   */
                                    (b)   c = 2 * c - 1;
                                    (c)   p u t c h a r (c ) ;
                                    (d)   p r i n t f (c ) ;

                             5.     W hich one of the following is not a legal way to write the number 65? (Assum e that thc
                                    character set is ASCII.)
                                    (a)   ’A ’
                                    (b)   0 b l0 0 0 0 0 1
                                    (C)   0101
                                    (d)   0x41

                             6.     For each o fth e following items of data, specify which one of the types c h a r , s h o r t , i n t ,
                                    or l o n g is the sm allest one guaranteed to be large enough lo store the item.
                                    (a)   Days in a month
                                    (b)   D a y s in a y e a r
                                    (c)   M inutes in a day
                                    (d)   Seconds in a day

                             7.     For each o f the following character escapes, give the equivalent octal escape. (A ssum e that
                                    the character set is ASCII.) You may wish to consult Appendix E, which lists the num erical
                                    codes for ASCII characters.
                                    (a)   \b
                                    (b)   \n
                                    (c)   \r
                                    (d)   \t

                             8.     Repeat Exercise 7, but give the equivalent hexadecim al escape.

S e c tio n 7 .4             9.     Suppose that i and j arc variables o f type i n t . W hat is the type o f thc expression i / j +
                                    ’a ’?

                       ©    10.     Suppose that i is a variable o f type i n t . j is a variable o fty p e l o n g , and k is a variable of
                                    type u n s i g n e d i n t . W hat is the type o fth e expression i + ( i n t ) j * k ?

                            11.     Suppose that i is a variable of type i n t . f is a variable o f type f l o a t . and d is a variable
                                    of type d o u b l e . W hat is the type o f the expression i * f / d?

                       ©    12.     Suppose that i is a variable of type i n t , f is a variable o fty p e f l o a t , and d is a variable
                                    o fty p e d o u b l e . Explain what conversions take place during the execution o f the following
                                    statement:
                                                                                                                                             157hgfedcbaZ
                                                                                                     P ro g ra m m in g P r o je c ts kjihgfedcbaZYXWVUTSRQP


                           l3.    Assume that a program contains the following declarations:
                                  c h a r c = ' \ 1 ';
                                  s h o r t s = 2;
                                  i n t i = -3 ;
                                  lo n g m = 5;
                                  f l o a t f = 6 .5 f ;
                                  d o u b le d = 7 .5 ;
                                   Give the value and the type of each expression listed below.
                                   (a) c * i             (c) f / c                 (e) f - d
                                   (b) s + m             (d) d / s                 (f) ( i n t ) f

                      ©    l4.     Does the following statement always compute lhc fractional part of f correctly (assuming
                                   that f and f r a c _ p a r t are f l o a t variables)?
                                   fra c _ p a rt = f      -     (in t)   f;
                                   Ifnot, what’s the problem?

                                  l5.    Use t y p e d e f to create types named I n t 8 , I n t l 6 . and I n t 3 2 . Define the types so that
S e c tio n 7.5 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   they represent 8-bit. l6-bit. and 32-bit integers on your machine.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   P r o g r a m m in g P r o je c t s

                      ©      l.   The s q u a r e 2 . c program of Section 6.3 will fail (usually by printing strange answers) if
                                  i * i exceeds the maximum i n t value. Run the program and determine the smallest value
                                  of n that causes failure. Try changing the type of i to s h o r t and running the program
                                  again. (Don’t forget to update the conversion specifications in the call o f p r i n t f ! ) Then
                                  try l o n g . From these experiments, what can you conclude about the number ofbits used to
                                  store integer types on your machine?

                       ©    2.     Modify the s q u a r e 2 . c program of Section 6.3 so that il pauses after every 24 squares and
                                   displays the following message:
                                   P re s s E n te r to        c o n tin u e ...
                                   After displaying the message, (he program should use g e t c h a r to read a character,
                                   g e t c h a r won’t allow the program to continue until the user presses the Enter key.

                            3.    Modify the sum 2 . c program of Section 7 .1 to sum a series of d o u b l e values.

                            4.    Write a program that translates an alphabetic phone number into numeric form:
                                   E n t e r p h o n e n u m b e r : CALLATT
                                   2255288
                                   (In case you don’t have a telephone nearby, here are the letters on the keys: 2=ABC, 3=DEF,
                                   4=GHI, 5=JKL. 6=M N 0, 7=PRS, 8=TUV. 9=WXY.) Ifth e original phone numbercontains
                                   nonalphabetic characters (digits or punctuation, for example), leave them unchanged:
                                   E n t e r p h o n e num be r : l-8 0 0 -C Q L -L E C T
                                   1 -8 0 0 -2 6 5 -5 3 2 8
                                   You may assume that any letters entered by thc user are upper case.
158 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 7    B a s ic T y p e s


                      ©    5.    In lhe SC R A B B LE Crossw ord Game, players form words using small tiles, each containing
                                 a letter and a face value. The face value varies from one letter to another, based on the let­
                                 ter’s rarity. (Here are the face values: l : A EILN O RSTU . 2: DG. 3: BCMP, 4: FHVWY. 5: K.
                                 8: JX, l0: QZ.) W rite a program that com putes the value o f a word by sum m ing the values
                                 o f its letters:
                                 E n t e r a w o rd : p i t f a l l
                                 S c r a b b l e v a l u e : 12
                                 Your program should allow any mixture o f lower-case and upper-case letters in the word.cbaZYXW
                                 H int: Use the t o u p p e r library function.

                      ©    6.    W rite a program that prints the values o f s i z e o f ( i n t ) . s i z e o f ( s h o r t ) .
                                 s i z e o f ( l o n g ) , s i z e o f ( f l o a t ) , s i z e o f ( d o u b l e ) and s i z e o f ( l o n g d o u ­
                                 b le ) .

                            7.   M odify Program m ing Project 6 from C hapter 3 so that the user may add, subtract, multiply,
                                 or divide two fractions (by entering either +, - . *. or / between the fractions).

                            8.   M odify Program m ing Project 8 from C hapter 5 so that the user enters a tim e using the 12-
                                 hour clock. The input will have the form h o u rx :m iiiu ie x followed by eith erA , P, AM, or PM
                                 (either lower-case or upper-case). W hite space is allowed (but not required) between the
                                 num erical tim e and the AM^PM indicator. Exam ples o f valid input:
                                  1 :1 5 P
                                  l:1 5 P M
                                  l:1 5 p
                                  1 : 15pm
                                  1 :1 5 P
                                  1 : 1 5 PM
                                  1 :1 5 p
                                  1 : 1 5 pm
                                  You may assum e that the input has one o f these form s; there is no need lo test for errors.

                            9.   W rite a program that asks the user for a l2-hour time, then displays the time in 24-hour
                                 form:
                                 E n t e r a 1 2 - h o u r t i m e : 9 : 1 1 PM
                                 E q u iv a le n t 2 4 - h o u r tim e : 2 1 :1 1
                                 See Program m ing Project 8 for a description o fth e input format.

                           10.   W rite a program that counts the num ber o f vowels (a, e, i, o. and u) in a sentence:
                                  E n t e r a s e n t e n c e : A nd t h a t ’ s t h e         w ay i t     is .
                                  Y our s e n te n c e c o n t a i n s 6 v o w e ls .

                           11.   W rite a program that takes a first name and last nam e entered by the user and displays the
                                 last name, a com m a, and the first initial, followed by a period:
                                  E n te r a f i r s t     and     la s t   nam e:     L lo y d    F o s d ic k
                                  F o s d ic k , L.
                                 The user’s input may contain extra spaces before the first name, betw een the first and last
                                 names, and after the last name.

                           12.   W rite a program that evaluates an expression:
                                 E n te r an e x p re s s io n :        1 + 2 .5 * 3
                                 V a lu e o f e x p r e s s i o n :     1 0 .5
                                                                                                             159
                                                                  P ro g ra m m in g P ro je c ts onmlkjihgfedcbaZYXWVUTSRQ

      The operands in the expression are floating-point numbers; the operators are +, -, *, and / .
      The expression is evaluated from left to right (no operator takes precedence over any other
      operator).

l3.   Write a program that calculates the average word length for a sentence:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
      Enter a sentence: It was deja vu all over again.
      Average word length: 3.4
      For simplicity, your program should consider a punctuation mark to be part of the word lo
      which it is attached. Display the average word length to one decimal place.

l4.   Write a program that uses Newton’s method to com pute the square root of a positive float­
      ing-point number:
      Enter a positive number: 3
      Square root: 1.73205
      Let .v be the number entered by the user. N ewton’s method requires an initial guess cbaZYXWVUTSRQPONMLKJ
                                                                                           y for the
      square root of.Y (w e’ll use y = 1). Successive guesses are found by computing the average of
      y and x!y. The following table shows how the square root of 3 would be found:

                                                                  Average of hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   •\
                                            y           x!y        y and x/y
                                  ~     i            3            ~i
                                   3    2            1.5            1.75
                                   3    1.75         i.7 l4 2 9     1.73214
                                   3    1.73214      1.73196        1.73205
                                   3    1.73205      1.73205        1.73205
      Note that the values of y get progressively closer to the true square root of .v. For greater
      accuracy, your program should use variables o fty p e d o u b l e rather than f l o a t . Have the
      program terminate when the absolute value o fth e difference between the old value o fy and
      the new value o fy is less than the product of .00001 and y. H int: Call the f a b s function to
      find the absolute value of a d o u b l e . (You’ll need to include the < m a t h . h> header at the
      beginning of your program in order to use f a b s . )

15.   Write a program that computes the factorial of a positive integer:
      Enter a positive integer: 6
      Factorial of 6: 720

      (a) Use a s h o r t variable to store the value of the factorial. W hat is the largest value o fn
          for which the program correctly prints the factorial of /??
      (b) Repeat part (a), using an i n t variable instead.
      (c) Repeal part (a), using a l o n g variable instead.
      (d) Repeat part (a), using a l o n g l o n g variable instead (if your com piler supports the
          l o n g l o n g type).
      (e) Repeat part (a), using a f l o a t variable instead.
      (1) Repeat part (a), using a d o u b l e variable instead.
      (g) Repeat part (a), using a l o n g d o u b l e variable instead.

      In cases (e)-(g), the program will display a close approxim ation o fth e factorial, not neces­
      sarily the exact value.
8     A rra y s               ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                           l f a p ro g ra m m a n ip u la te s a la rg e a m o u n t o f data,
                                                                           it d o e s s o in a s m a ll n u m b e r o f ways. onmlkjihgfedc




                                                 scalar: capable of holding a single data
      So far. lhe only variables w e’ve seen are cbaZYXWVUTSRQPONMLKJIHGFEDCBA
      item. C also supports aggregate variables, which can store collections of values.
      There are two kinds ofaggregates in C: arrays and structures. This chapter shows
      how to declare and use arrays, both one-dim ensional (Section 8.1) and multidi­
      mensional (Section 8.2). Section 8.3 covers C 99’s variable-length arrays. The
      focus of the chapter is on one-dim ensional arrays, which play a much bigger role
      in C than do multidim ensional arrays. Later chapters (Chapter 12 in particular)
      provide additional inform ation about arrays; Chapter 16 covers structures.




8.1   O n e - D im e n s io n a l A r r a y s

      An array is a data structure containing a number of data values, all of which have
      the same type. These values, known as elem en ts, can be individually selected by
      their position within the array.
           The sim plest kind of array has just one dim ension. The elem ents of a one­
      dimensional array are conceptually arranged one after another in a single row (or
      column, if you prefer). H ere's how we might visualize a one-dim ensional array
      named a:

                          a


          To declare an array, we must specify the type of the array’s elements and the
      num ber of elements. For example, lo declare that the array a has 10 elements of
      type i n t , we would write

      in t   a [1 0 ] ;



                                                                                                                          161
1 62 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 8    A r ra y s


                                                      The elements of an array may be of any type; the length of the array can be speci­
                                                      fied by any (integer) constant expression. Since array lengths may need to be
       c o n s ta n t e x p re s s io n s > 5 . 3 aZYXWVUTSRQPONMLKJIHGFEDCBA

                                                      adjusted when the program is later changed, using a macro to define the length of
                                                      an array is an excellent practice:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           #define N 10

                                           int a [N];dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           A r r a y S u b sc r ip tin g

                                         To access a particular element of an array, we write the array name followed by an
                                                                                                    subscripting or in d e xin g the
                                         integer value in square brackets (this is referred to as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         array). Array elements are always numbered starting from 0, so the elements o fa n
                            Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         array of length n are indexed from 0 lo n - 1. For example, if a is an array with 10
                                         elements, they’re designated by a [ 0 ] , a [ 1 ] , .... a [ 9 ] , as the following figure
                                         shows:



                                                                 a [0 ]   a [l]   a [2 ]   a [3 ]   a [4 ]   a [5 ]   a [6 ]   a (7 ]   a (8 ]   a [9 1



                    iv a i u e s > 4 . 2   Expressions o fth e form a [ i ] are lvalues, so they can be used in the same way as
                                           ordinary variables:

                                           a[0] = 1;
                                           printf("%d\n", a[5]);
                                           ++a [i] ;

                                           In general, ifan array contains elements of type T. then each element of the array is
                                           treated as if it were a variable of type T. In this example, the elements a [ 0 ] .
                                           a [ 5 ] , and a [ i ] behave like i n t variables.
                                                 Arrays and f o r loops go hand-in-hand. Many programs contain f o r loops
                                           whose job is to perform some operation on every element in an array. Here are a
                                           few examples oftypical operations on an array a of length N:

                          id io m          for (i = 0; i < N; i+ + )
                                             a[i] = 0;                                          /* clears a */

                          id io m          for (i = 0; i < N; i+ + )
                                              scanf("%d", &a[i]);                               /* reads data into a */

                          id io m          for (i = 0; i < N; i++)
                                              sum += a[i];                                      /* sums the elements of a */

                                           Notice that we must use the & symbol when calling s c a n f to read an array ele-
                                           m ent,just as we would with an ordinary variable.
                                               8 .1                                                      163 kjihgfedcb
                                                      O n e - D im e n s io n a l A r r a y s onmlkjihgfedcbaZYXWVUTSRQP




    C doesn’t require that subscript bounds be checked; if a subscript goes out of
A   range, the program’s behavior is undefined. One cause of a subscript going out of
    bounds: forgetting that an array with n elements is indexed from 0 to n — 1, not 1 to
    n. (As one of my professors liked to say, “In this business, you’re always off by
    one.” He was right, of course.) The following example illustrates a bizarre effect
    that can be caused by this common blunder:
    int a [10], i ;

    for (i = 1; i <= 10; i++)
      a[i] = 0;

    With some compilers, this innocent-looking f o r statement causes an infinite loop!
    When i reaches 10, the program stores 0 into a [ 1 0 ] . But a [1 0 ] doesn’t exist,
    so 0 goes into memory immediately after a [ 9 ] . If the variable i happens to fol­
    low a [9] in memory— as might be the case— then i will be reset to 0, causing the
    loop to start over.


        An array subscript may be any integer expression:

    a[i+j*10] = 0;

    The expression can even have side effects:

    i = 0;
    while (i < N)
      a[i++] = 0;

    L et’s trace this code. After i is set to 0, the w h i l e statement checks whether i is
    less than N. If it is, 0 is assigned to a [ 0 ] , i is incremented, and the loop repeats.
    Note that a [+ + i] wouldn’t be right, because 0 would be assigned to a [1] during
    the first loop iteration.


    Be careful when an array subscript has a side effect. For example, the following
A   loop— which is supposed to copy the elements of the array b into the array a —
    may not work properly:
    i = 0;
    while (i < N)
      a [i] = b[i++J ;

    The expression a [ i ] = b [i+ + ] accesses the value of i and also modifies i else­
    where in the expression, which— as we saw in Section 4.4— causes undefined
    behavior. Of course, we can easily avoid the problem by removing the increment
    from the subscript:
    for (i = 0; i < N; i++)
      a [i] = b [i] ;
           C h a p te r 8 A rra ys
164 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

            PRO G RA M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                            R e v e r s in g a S e r ie s o f N u m b e r s

                                   Our first array program prompts the user to enter a series of numbers, then writes
                                   the numbers in reverse order:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
                                   In reverse order: 31 50 11 23 94 7 102 49 82 34

                                   Our strategy will be to store the numbers in an array as they’re read, then go
                                   through the array backwards, printing the elements one by one. In other words, we
                                   w on’t actually reverse the elements in the array, but w e’ll make the user think we
                                   did.

                r e v e r s e .c   /* Reverses a series of numbers */

                                   #include <stdio.h>

                                   #define N 10

                                   int main(void)

                                      int a [N], i ;

                                      printf("Enter %d numbers:           ”, N);
                                      for (i = 0; i < N; i++)
                                        scanf(”%d”, &a [i]);

                                      printf('*In reverse order:”);
                                      for (i = N - 1; i >= 0; i--)
                                        printf(" %d", a[i]);
                                      printf(”\n”);

                                      return 0;


                                         This program shows just how useful macros can be in conjunction with arrays.
                                   The macro N is used four times in the program: in the declaration of a , in the
                                   p r i n t f that displays a prompt, and in both f o r loops. Should we later decide to
                                   change the size of the array, we need only edit the definition of N and recompile
                                   the program. Nothing else will need to be altered; even the prompt will still be cor­
                                   rect.


                                   A r r a y I n itia liz a tio n

                                   An array, like any other variable, can be given an initial value at the time it's
                                   declared. The rules are somewhat tricky, though, so w e'll cover some of them now
              iniiiaiizers>rs.5    and save others until later.
                                       The most common form of array initializer is a list o f constant expressions
                                   enclosed in braces and separated by commas:

                                   int a[10]       = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
                                                    8 .1                                                     165 aZYXWVUTSRQPON
                                                             O n e - D im e n s io n a l A rra y s onmlkjihgfedcbaZYXWVUTSRQPONML


                            shorter than the array, the remaining elements of the array are
      lf the initializer is cbaZYXWVUTSRQPONMLKJIHGFEDCBA
      given the value 0:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      int a[10] = {1, PONMLKJIHGFEDCBA
                       2, 3, 4, 5, 6};
        /* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */

      Using this feature, we can easily initialize an array to all zeros:
      int a [10] = {0};
        /* initial value of a is {0, Q, 0, Q, 0, 0, 0, 0, 0, 0} */

      It’s illegal for an initializer to be completely empty, so w e’ve put a single 0 inside
      the braces. It’s also illegal for an initializer to be longer than the array it initial­
      izes.
            lfan initializer is present, the length o fth e array may be omitted:

      int a[] = {lz 2, 3, 4, S, 6, t, 8, 9, 10};

      The compiler uses the length of the initializer to determine how long the array is.
      The array still has a fixed number of elements (10, in this example), just as if we
      had specified the length explicitly.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


C99   D e s ig n a te d I n itia liz e r s

      lfs often the case that relatively few elements of an array need to be initialized
      explicitly; the other elements can be given default values. Consider the following
      example:

      int a[15] = {0, 0, 29, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 48};

      We want element 2 of the arrav^ to be 29,'element 9 to be 7. and element 14 to be
      48, but the other values arejust zero. For a large array, writing an initializer in this
      fashion is tedious and error-prone (what ifthere were 200 zeros between two of the
      nonzero values?).
           C99’s designated initializers can be used to solve this problem. H ere’s how
      we could redo the previous example using a designated initializer:

      int a[15] = {[2] = 29,                 [9] = 7,      [14] = 48};

      Each number in brackets is said to be a designator.
           Besides being shorter and easier to read (at least for some arrays), designated
      initializers have another advanta s^e: the order in which the elements are listed no
      longer matters. Thus, our previous example could also be written in the following
      way:
      int a[15] = {[14] = 48,                 [9] = 7,      [2] = 29};

           Designators must be integer constant expressions. Ifthe array being initialized
      has leng<^th /?, eac<Jh designator must be between 0 and n - I. Ho'wever, if ^the length
      of the array is omitted, a designator can be any nonnegative integer. In the latter
      case, the compiler will deduce the length of the array from the largest designator.
            C h a p te r 8    A rr a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
1 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                      In the following example, the fact that 23 appears as a designator will force the
                                      array to have length 24:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       int b[] = {[5] = 10,                     [23] = 13,     [11] = 36,    [15] = 29};

                                          An initializer may use botb the older (element-by-element) technique and the
                                       newer (designated) technique:

                                       int c[10] = {5, 1, 9,                         [4] = 3, 7, 2,    [8] = 6};

                                      This initializer specifies that the array’s first three elements will be 5, 1, and 9. Ele­
                                      ment 4 will have the value 3. The two elements after element 4 will be 7 and 2.
                                      Finally, element 8 will have the value 6. All elements for which no value is speci­
                                      fied will default to zero.


                                  C h e c k in g a N u m b e r fo r R e p e a te d
               P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                    D ig it s

                                      Our next program checks whether any of the digits in a number appear more than
                                      once. After the user enters a number, the program prints either R e p e a t e d d i g i t
                                      or No r e p e a t e d d i g i t :

                                      Enter a number: 28212
                                      Repeated digit

                                      The number 28212 has a repeated digit (2); a number like 9357 doesn’t.
                                             The program uses an array of Boolean values to keep track of which digits
                                      appear in a number. The array, named d i g i t _ s e e n , is indexed from 0 to 9 to
                                      correspond to the 10 possible digits. Initially, every elem ent of the array is false.
                                      (The initializer for d i g i t _ s e e n is {f a l s e }, which only initializes the first ele­
                                      ment of the array. However, the com piler will automatically make the remaining
                                      elements zero, which is equivalent to false.)
                                             When given a number n , the program examines n ’s digits one at a time, stor­
                                      ing each into the d i g i t variable and then using it as an index into d i g i t _ s e e n .
                                      l f d i g i t _ s e e n [ d i g i t ] is true, then d i g i t appears at least twice in n. On the
                                      other hand, if d i g i t _ s e e n [ d i g i t ] is false, then d i g i t has not been seen
                                      before, so the program sets d i g i t _ s e e n [ d i g i t ] to t r u e and keeps going.BA

                   rep d ig it.c      /* Checks numbers for repeated digits */

                                      #include <stdbool.h>                           /* C99 only */
                                      #include <stdio.h>

                                      int main(void)

                                          bool digit_seen[10]                    = {false};
                                          int digit;
                                          long n;

                                          printf(*'Enter a number:                      ");
                                          scanf("%ld", &n);
                                                                                    8 .1                                                   167 hgfedcbaZYXWVUTSR
                                                                                            O n e -D im e n s io n a l A rra y s onmlkjihgfedcbaZYXWVUTSRQPONMLK

                                   while (n > 0) {
                                     digit = n % 10;
                                     if (digit_seen[digit])
                                       break;
                                     digit_seen[digit] = true;
                                     n /= 10;
                                   }
                                   if (n > 0)
                                     printf("Repeated digit\n");
                                   else
                                     printf("No repeated digit\n");

                                   return 0;


                                                       This program uses the names b o o l , t r u e , and f a l s e , which are defined in
                                                 C99’s < s t d b o o l . h> header. If your compiler doesn’t support this header, you'll
< s t d b o o l . h > h e a d e r > 2 1 . 5 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 need to define these names yourself. One way to do so is to pul the following lines
                                                 above the m a in function:

                               #define true 1
                               #define false 0
                               typedef int bool;

                                   Notice that n has type l o n g , allowing the user to enter numbers up to
                               2,147.483.647 (or more, on some machines).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                               U s in g th e s i z e o f O p e r a to r w ith A r r a y s

                               The s i z e o f operator can determine the size ofan array (in bytes). I f a is an array
                               of 10 integers, then s i z e o f ( a ) is typically 40 (assuming that each integer
                               requires four bytes).
                                     We can also use s i z e o f to measure the size of an array element, such as
                               a [ 0 ] . Dividing the array size by the element size gives the length o fth e array:

                               sizeof(a) / sizeof(a[0])

                               Some programmers use this expression when the length of the array is needed. To
                               clear the array a. forexample. we could write

                               for (i = 0; i < sizeof(a)                     / sizeof(a[0]); i+4-)
                                 a[i] = 0;

                               With this technique, the loop doesn’t have to be modified ifthe array length should
                               change at a later date. Using a macro to represent the array length has the same-
                               advantage, ofcourse, but the s i z e o f technique is slightly better, since there’s no
                               macro name to remember (and possibly gel wrong).
                                   One minor annoyance is that some compilers produce a warning message for
                               theexpression i < s i z e o f (a ) / s i z e o f (a [0] ). The variable i probably has
168 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 8    A rra y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 lype i n t (a signed type), whereas s i z e o f produces a value of type s i z e _ t (an
                                                 unsigned type). We know from Section 7.4 that comparing a signed integer with an
                                                 unsigOned Ointeger is a Cd angeroi us practice, altohough in this case it’s safe because
                                                 both i and s i z e o f (a ) / s i z e o f (a [0] ) have nonnegative values. To avoid a
                                                 waming, we can add a cast that converts s i z e o f (a ) / s i z e o f ( a [0] ) to a
                                                 sigc^ned intoeger:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 for (i = 0; i < (int)                (sizeof(a) / sizeof(a[0])); i++)
                                                   a[i] = 0;

                                                      Writing ( i n t ) ( s i z e o f ( a ) / s i z e o f ( a [ 0 ] ) ) isa b itu n w ie ld y ;d e fin -
                                                 ing a macro that represents it is often helpful:

                                                 #define SIZE ((int)               (sizeof(a) / sizeof(a[0])))

                                                 for (i = 0; i < SIZE; i++)
                                                   a[i] = 0;

                                                 If w e f re back to using a macro, though, w hat’s the advantage of s i z e o f ? We’ll
                                                 answer that question in a later chapter (the trick is to add a parameter to the
     p a ra m e te riz e d m a c ro s > 1 4 .3   macro).


                                     C o m p u ti n g I n te r e s t
                   P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 Our next program prints a table showing the value of S l00 invested at different
                                                 rates of interest over a period of years. The user will enter an interest rate and the
                                                 number of years the money will be invested. The table will show the value of the
                                                 money at one-year intervals— at that interest rate and the next four higher rates—
                                                 assuming that interest is compounded once a year. Here’s what a session with the
                                                 program will look like:

                                                 Enter interest rate: 6
                                                 Enter number of years: 5

                                                 Years          6%          7%          8%          9%        10%
                                                   1          106.00      107.00      108.00      109.00     110.00
                                                   2          112.36      114.49      116.64      118.81     121.00
                                                   3          119.10      122.50      125.97      129.50     133.10
                                                   4          126.25      131.08      136.05      141.16     146.41
                                                   5          133.82      140.26      146.93      153.86     161.05

                                                       Clearly, we can use a f o r statement to print the first row. The second row is a
                                                 little trickier, since its values depend on the numbers in the first row. Our solution
                                                 is to store the first row in an array as it’s computed, then use the values in Lhe array
                                                 to compute the second row. Of course, this process can be repeated for the third
                                                 and later rows. We’ll end up with two f o r statements, one nested inside the other.
                                                 The outer loop will count from 1 to the number ofyears requested by the user. The
                                                 inner loop will increment the interest rate from its lowest value to its highest value.
                                                                     8 .2                                                169BA
                                                                            M u ltid im e n s io n a l A rra y s kjihgfedcbaZYXWVUTSRQPONML

interest.c   /* Prints a table of compound interest */

             #include <stdio.h>

             #define NUM_RATES ((int) (sizeof(value) / sizeof(value[0])))
             #define INITIAL_BALANCE 100.00

             int main(void)

                int i, low_rate, num_years, year;
                double value[5];

               printf("Enter interest rate: ");
               scanf("%d", &low_rate);
               printf("Enter number of years: ");
               scanf("%d", &num_years);

                printf("\nYears");
                for (i = 0; i < NUM_RATES; i++) {
                  printf("%6d%%", low_rate + i);
                  value[i] = INITIAL_BALANCE;

                printf("\n");

                for (year = 1; year <= num_years; year++) {
                  printf("%3d     ", year);
                  for (i = 0; i < NUM_RATES; i++) {
                    value[i] += (low_rate + i) / 100.0 * value[i];
                    printf("%7.2f", value[i]);

                   printf("\n");


                return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                 Note the use o f NUM_RATES to control two o f the f o r loops. If we later
             change the size o fth e v a l u e array, the loops will adjust automatically.aZYXWVUTSRQPONMLKJIHGFEDCB




     8 .2    M u ltid im e n s io n a l A r ra y s

             An array may have any num ber of dim ensions. For example, the follow ing declara­
                                                       m atrix, in mathematical term inology):
             tion creates a tw o-dim ensional array (a cbaZYXWVUTSRQPONMLKJIHGFEDCBA

             int m [5] [9] ;

             The array m has 5 rows and 9 columns. Both rows and colum ns are indexed from 0,
             as the following figure shows:
170 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 8    A rra y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                   To access the element ofm in row i , column j . we must write m [ i ] [ j ] . The
                                              expression m [ i ] designates row i of m. and m [ i ] [ j ] then selects elem ent j in
                                              this row.


                                              Resist the temptation to write m [ i t j ] instead of m [ i ] [ j ]. C treats the comma
                                              as an operator in this context, so m [ i , j ] is the same as m [ j ].
            c o m m a o p e ra to r > 6 . 3



                                                  Although we visualize two-dimensional arrays as tables, that's not the way
                                              they’re actually stored in computer memory. C stores arrays in row   -m ajo rorder, with
                                                                                                             cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              row 0 first, then row l , and so forth. For example, here’s how the m array is stored:
                                                                            ro w 0                            ro w 1                           ro w 4

                                                                                                                                                        ------ ^"
                                                                       0s                      *^        sr                   «^               <?> • • •       0?
                                                                   < *'
                                                                             • •   •       ^Q '                • •   •                       .v
                                                                                                                                   • • • kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                                                           .U *
                                                                  <>                   e            <^                   ^*                <>x           ^


                                              We’ll usually ignore this detail, but sometimes it will affect our code.
                                                   Just as f o r loops go hand-in-hand with one-dimensional arrays, nested f o r
                                              loops are ideal for processing multidimensional arrays. Consider, for example, the
                                              problem of initializing an array for use as an identity matrix. (In mathematics, an
                                              identity m atrix has l ’s on the main diagonal, where the row and column index are
                                              the same, and O's everywhere else.) We'll need to visit each element in the array in
                                              some systematic fashion. A pair of nested f o r loops— one that steps through every
                                              row index and one that steps through each column index— is perfect for thejob:
                                              #define N 10

                                              double ident[N][N];
                                              int row, col;

                                              for (row = 0; row < N; row++)
                                                for (col = 0; col < N; CO1+--+)
                                                  if (row == col)
                                                    ident[row][col] = 1.0;
                                                  else
                                                    ident[row][col] = 0.0;

                                                  Multidimensional arrays play a lesser role in C than in many other program­
                                              ming languages, primarily because C provides a more flexible way to store multi­
          a rra y s o f p o in te rs > 13.7   dimensional data: arrays o f pointers.
                                                               8 .2                                                        171 dcbaZYXWVUTSRQ
                                                                           M u ltid im e n s io n a l A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONM


    I n itia liz in g a M u l tid i m e n s i o n a l A r r a y

    We can create an initializer for a two-dimensional array by nesting one-dimen- KJIHGFEDCBA
    sional initializers:

    in t   m [5 ] [9 ]    = {> ,        i,   i,    1,    1,    0,     1,      1,    r hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                        1,
                              0,        1,   0,    i,    o,    i,     o,      i,    o; 9
                              0,        1,   0,    1,    1,    0,     0,      1,    0 9
                             > ,        1,   0,    1,    0,    0,     0,      1,    0 9
                             [I,        I,   0,    1,    0,    0,     1,      1,    1 i} ;

    Each inner initializer provides values for one row of the matrix. Initializers for
    higher-dimensional arrays are constructed in a similar fashion.
         C provides a variety of ways to abbreviate initializers for multidimensional
    arrays:
      ■ Ifan initializer isn’t large enough to fi.ll a mu ltidimensional array, the remain­
          ing elements are given the value 0. For example, the following initializer fills
          only the first three rows ofm: the last two rows will contain zeros:

           in t   m [5 ] [9 ]   = { [1 ,      1,    1,    1,    1,     0,      1,    1,    1]       /


                                    [0 ,      1,    o,    1,    0,     1,      0,    1,    0]   >
                                                                                                    /
                                                                                                    }   *
                                    [0 ,      1,    o,    1,    1,     0,      0,    1,    0]

      ■ If an inner list isn’t lon ^s enougOh to fill a row,1 the remainin^s elements in the
          row are initialized to 0:

           in t   m [5 ] [9 ]   = { .1 ,      1,    1,    1,    1,     0,      1 , 1 , 1 }<
                                    (
                                     0,       1,    0,    1,    0,     1,      0 , 1] ■ ,
                                    ;o ,      i,    o,    i,    i,     o,      0, 1 9
                                    > ,       1,    0,    1,    0,     0,             1' 9
                                                                               0 ,cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     1,       1,    0,    1,    0,     0,      1, 1, i}} ;

      ■ We can even omit the inner braces:
           in t   m [5 ] [9 ]   = {1 ,       1,    1,    1,    1,     0,     1,     1,    1,
                                   0,        1,    0,    1,    0,     1,     0,     1,    0,
                                   0,        1,    0,    1,    1,     0,     0,     1,    0,
                                   1,        1,    0,    1,    0,     0,     0,     1,    0,
                                   1,        1,    0,    1,    0,     0,     1,     1,    1}

           Once the compiler has seen enough values to fill one row. it begins filling the
           next.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


    Oinitting the inner braces in a multidimensional array initializer can be risky, since
A   an extra element (or even worse, a missing element) will affect the rest of the ini­
    tializer. Leaving out the braces causes some compilers to produce a warning mes­
    sage such as “m issing braces around initializer.”


        C99's designated initializers work with multidimensional arrays. For example,
    we could create a 2 x 2 identity matrix as follows:
1 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 8    A rr a y s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                     double ident[2][2] = {[0][0] = 1.0,                 [1][1] = 1.0};onmlkjihgfedcbaZYXWVUTSRQPONMLK
                                                     As usual, all elements for which no value is specified will default to zero.dcbaZYXWVUTSRQPONM


                                                     C o n s ta n t A r r a y s
                                                     Any array, whether one-dimensional or multidimensional, can be made “constant”
                                                     by starting its declaration with the word c o n s t :
                                                     const char hex_chars[] =
                                                       { '0 ', '1 ’, '2 ', '3 ', '4 ', '5 ', ’6 ’, '7 ', ’8 ’, '9 ',
                                                         ’A ', ’B ’, 'C ’, ’D ’, 'E ’, ’F '} ;aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                     An array that’s been declared c o n s t should not be modified by the program; the
                                                     compiler will detect direct attempts to modify an element.
                                                          Declaring an array to be c o n s t has a couple of primary advantages. It docu­
                                                     ments that the program w on’t change the array, which can be valuable information
                                                     for someone reading the code later. It also helps the com piler catch errors, by
                                                     informing it that we don't intend to modify the array.
                                          18.3
       c o n s t t y p e q u a lif ie r > BA              c o n s t isn’t limited to arrays; it works with any variable, as w e’ll see later.
                                                     However, c o n s t is particularly useful in array declarations, because arrays may
                                                     contain reference information that won’t change during program execution.


                    PROGRAM                          D e a lin g a H a n d o f C a r d s
                                                     Our next program illustrates both two-dimensional arrays and constant arrays. The
                                                     program deals a random hand from a standard deck of playing cards, (ln case you
                                                                                                                                  suit—
                                                     haven't had time to play games recently, each card in a standard deck has a cbaZYXWVUTSRQPO
                                                     clubs, diamonds, hearts, or spades— and a rank— two, three, four, five, six, seven,
                                                     eight, nine, len,jack, queen, king, or ace.) We'll have the user specify how many
                                                     cards should be in the hand:
                                                     Enter number of cards in hand: 5
                                                     Your hand: 7c 2s 5d as 2h
                                                     lt’s not immediately obvious how w e’d write such a program. How do we pick
                                                     cards randomly from the deck? And how do we avoid picking the same card twice?
                                                     Let’s tackle these problems separately.
                 t i m e f u n c t io n   > 2 6 .3         To pick cards randomly, we'll use several C library functions. The t i m e func­
                                                     tion (from < t i m e . h > ) returns the current time, encoded in a single number. The
               s r a n d lu n c l io n    > 2 6 .2   s r a n d function (from < s t d l i b . h > ) initializes C ’s random number generator.
                                                     Passing the return value of t i m e to s r a n d prevents the program from deaUng the
                 r a n d f u n c t io n > 2 6 .2     same cards every time we run it. The r a n d function (also from < s t d l i b . h > )
                                                     produces an apparently random number each time it’s called. By using the % oper­
                                                     ator. we can scale the return value from r a n d so that it falls between 0 and 3 (for
                                                     suits) or between 0 and 12 (for ranks).
                                                           To avoid picking the same card twice, w e’ll need to keep track ofw hich cards
                                                     have already been chosen. For that purpose, w e’ll use an array named i n _ h a n d
                                                          8 ,2                                                          173
                                                                 M u l t i d i m e n s i o n a l A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLK


          that has four rows (one for each suit) and 13 columns (one for each rank). In other
          words, each element in the array corresponds to one of the 52 cards in the deck. All
          elem ents of the array will be false lo start with. Each time we pick a card at ran­
          dom, w e’ll check whether the elem ent of i n _ h a n d corresponding to that card is
          true or false. If it’s true, w e’ll have to pick another card. If it’s false, w e’ll store
          t r u e in that card's array elem ent to remind us later that this card has already been
          picked.
                Once w e’ve verified that a card is “new”— not already selected— w e'll need to
          translate its numerical rank and suit into characters and then display the card. To
          translate the rank and suit to character form, w e'll set up two arrays of charac­
          ters— one for the rank and one for the suit— and then use the numbers to subscript
          the arrays. These arrays w on't change during program execution, so we may as
          well declare them to be c o n s t .

               / ★ Deals a random hand of
d e a l. c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA     cards */

          #include      < s t d b o o l .h       /* C99 only */
          #include      < s t d i o .h>
          #include      < s t d l i b .h>
          #include      < t i m e .h>

          #define NUM_SUITS 4
          #define NUM_RANKS 13

          int main(void)

             bool in_hand[NUM_SUITS] [NUM_RANKS] = {false};
             int num_cards, rank, suit;
             const char r a n k _ c o d e [] = { ’2 ’, ’3 ’, ’4 ’, ’5 ’, ’6 ’, ’7 ’, ’8 ’,
                                                 '9 ', 1 1 ', 'j ' , 'q ', 'k ' , 'a '} ;
             const char suit_code[] = {'c','d','h','s'};

             sr*and( (unsigned)              time (NULL) ) ;

             printf("Enter number of cards in hand:                           ");
             scanf (“%d ”, &num__cards) ;

             p r i n t f ("Your h a n d : ”);
             while (num_cards > 0) {
                 suit = rand() % NUM_SUITS;                  /* picks a random suit */
                 rank = rand() % NUM_RANKS;                  /* picks a random rank */
                 if (!in_hand[suit][rank]) {
                    i n _ h a n d [ s u i t ] [rank] = true;
                    num_cards--;
                    p r i n t f ( ” % c % c ” , rank_code[rank], suit_code[suit]);


             p r i n t f (”\ n ”);

             return 0;
           C h a p te r 8 A rrays
174 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     Notice the initializer for the in _ _ h a n d array:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                bool in_hand[NUM_SUITS][NUM_RANKS]                         = {false};

                                Even though in _ _ h a n d is a two-dimensional array, we can use a single pair of
                                braces (at the risk ofpossibly incurring a warning from the compiler). Also, we’ve
                                supplied only one value in the initializer, knowing that the compiler will fill in 0
                                (false) for the other elements.aZYXWVUTSRQPONMLKJIHGFEDCBA




                      8 .3      V a ria b le -L e n g th A r ra y s (C 9 9 )

                                Section 8.l stated that the length o fa n array variable must be specified by a con­
                                stant expression. In C99. however, it’s sometimes possible to use an expression
                                that’s noi constant. The following modification o fth e r e v e r s e . c program (Sec­
                                tion 8 .l) illustrates this ability:

              re v e rse 2 .c   /* Reverses a series of numbers using a variable-length
                                   array - C99 only */

                                #include <stdio.h>

                                int main(void)

                                    int i z n;

                                  printf("How many numbers do you want to reverse? ");
                                  scanf("%d", &n);

                                    int a[n];          /* C99 only - length of array depends on n */

                                  printf("Enter %d numbers:                    ”, n);
                                  for (i = 0; i < n; i+4-)
                                    scanf("%d", &a[i]);

                                  printf("In reverse order:");
                                  for (i = n - 1; i >= 0; i--)
                                    printf(" %d", a[i]);
                                  printf("\n");

                                  return 0;


                                The array a in this program is an example of a variable-length array (or VLA for
                                short). The length of a VLA is computed when the program is executed, not when
                                the program is compiled. The chief advantage of a VLA is that the programmer
                                doesn’t have to pick an arbitrary length when declaring an array; instead, the pro­
                                gram itself can calculate exactly how many elements are needed. If the program­
                                mer makes the choice, it’s likely that the array will be too long (wasting memory)
                                or too short (causing the program to fail). In the r e v e r s e 2 . c program, the num-
                                                                                                                            Q & A hgfedcbaZYXWVUTSRQPONMLK
                                                                                                                                           1 7 5 onmlkjihgfedcba


                                 ber entered by the user determines the length o f a ; the program m er doesn’t have to
                                 choose a fixed length, unlike in the original version of the program .
                                      The length o f a VLA doesn’t have to be specified by a single variable. Arbi­
                                 trary expressions, possibly containing operators, are also legal. Forexam ple:kjihgfedcbaZYXWVUTSRQ

                                  int a [3*i+5];
                                  int b [j+k] ;

                                 Like other arrays. VLAs can be multidimensional:

                                  int c [m] [n] ;

static storage duration > 18.2          The primary restriction on VLAs is that they can't have static storage duration.
                                  (We haven’t yet seen any arrays with this property.) A nother restriction is that a
                                  VLA may not have an initializer.
                                         Variable-length arrays are most often seen in functions other than m a in . One
                                  big*^ advanct?a ge o f a VLA that beloV>
                                                                         ngs to a function f is that it can have a different
                                  length each time f is called. W e’ll explore this feature in Section 9.3.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                  Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                         Q:       W h y d o a r r a y s u b s c r i p t s s ta r t a t 0 in s te a d o f 1 ? [p . 1 6 2 ]
                          A:      Having subscripts begin at 0 simplifies the com piler a bit. Also, il can make array
                                  subscripting marginally faster.

                         Q:      W h a t i f I w a n t a n a r r a y w ith s u b s c r ip t s th a t g o fr o m 1 t o 10 in s te a d o f 0 to 9?
                          A:     H ere’s a common trick: declare the array to have 11 elem ents instead of 10. The
                                 subscripts will go from 0 to 10. but you can just ignore elem ent 0.

                         Q:      I s it p o s s ib le to u se a c h a r a c te r a s a n a r r a y s u b s c r i p t ?
                          A:     Yes. because C treats characters as integers. You’ll probably need to “scale" the
                                 character before you use il as a subscript, though. Let's say that we want the
                                  l e t t e r _ c o u n t array to keep track of a count for each letter in the alphabet. The
                                 array will need 26 elements, so w e’d declare it in the following way:

                                  int let t e r _ c o u n t [26];

                                  However, we can’t use letters to subscript l e t t e r _ c o u n t directly, because their
                                  integer values do n 't fall between 0 and 25. To scale a lower-case letter to the
                                  proper range, we can simply subtract ’ a '; to scale an upper-case letter, w e’ll sub­
                                  tract ' A '. For example, if c h contains a lower-case letter, w c'd write

                                  letter_count[ch-'a'J                      = 0;

                                  to clear the count that corresponds to c h . A minor caveat: this technique isn’t com­
                                  pletely portable, because it assumes that letters have consecutive codes. However,
                                  il works with most character sets, including ASCII.
176 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 8    A rr a y s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     Q:      It s e e m s iik e a d e s ig n a te d in it ia liz e r c o u ld e n d u p in it ia liz in g a n a r r a y e le m e n t
                                             m o r e th a n o n c e . C o n s id e r th e fo llo w in g a r r a y d e c la r a t io n : kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                             int a[] = {4, 9, 1, 8,                        [0] = 5, 7};

                                             Is th is d e c la r a t io n le g a l, a n d i f s o , w h a t is th e le n g th o f t h e a r r a y ? [p . 1 6 6 ]
                                     A:      Yes, the declaration is legal. H ere’s how it works: as it processes an initializer list,
                                             the com piler keeps track ofw hich array element is to be initialized next. Normally,
                                             the next element is the one followin ^g* the element that was last initialized. How-
                                             ever, when a designator appears in the list, it forces the next element be the one
                                                                             even ifth a t elem ent has already been initialized.
                                             represented by the designator, cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  H ere's a step-by-step look at how the compiler will process the initializer for
                                             the array a:

                                                   The 4 initializes element 0;the next element to be initialized is element 1.
                                                   The 9 initializes element 1;the next element to be initialized is element 2.
                                                   The 1 initializes element 2;the next element to be initialized is element 3.
                                                   The 8 initializes element 3;the next element to be initialized is element 4.
                                                   The [0] designator causes the next element to become 0, so the 5 initializes
                                                       element 0 (replacing the 4 previously stored there). The next clement to
                                                       be initialized is element 1.
                                                   The 7 initializes elem ent 1 (replacing the 9 previously stored there). The next
                                                       element to be initialized is element 2 (which is irrelevant since w e're at
                                                       the end of the list).

                                             The net effect is the same as if we had written

                                             int a[] = {5, 7, 1, 8},-

                                             Thus, the length of this array is four.

                                     Q:      T h e c o m p i le r g iv e s m e a n e r r o r m e s s a g e i f I tr y to c o p y o n e a r r a y in to a n o th e r
                                             b y u s in g th e a s s ig n m e n t o p e r a to r . W h a t ’s w r o n g ?
                                     A:      Although it looks quite plausible, the assignment

                                             a = b;            /* a and b are arrays */

                                             is indeed illegal. The reason for its illegality isn't obvious; it has to do with the
                                             peculiar relationship between arrays and pointers in C, a topic w e’ll explore in
                                             Chapter 12.
                                                  The simplest way to copy one array into another is to use a loop that copies the
                                             elements, one by one:

                                             for (i = 0; i < N; i++)
                                               a[i] = b[i] ;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         m e m c p y fu n c tio n > 2 s .6   Another possibility is to use the m em cpy (“memory copy”) function from the
                                             < s t r i n g . h > header, m em cpy is a low-level function that simply copies bytes
                                             from one place to another. To copy the array b into the array a. use m em cpy as
                                             follows:
                                                                                                                                                         177
                                                                                                                              E x e r c is e s onmlkjihgfedcbaZYXWVUTSRQP


                               m e m c p y (a ,   b,    s iz e o f(a ));

                               Many programmers prefer m em cpy, especially for large arrays, because it’s poten­
                               tially faster than an ordinary loop.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                        *Q :   S e c t io n 6 .4 m e n tio n e d th a t C 9 9 d o e s n ’t a llo w a g o t o s t a t e m e n t to b y p a s s th e
                               d e c la r a tio n o f a v a r ia b le -le n g t h a r r a y . W h a t ’s th e r e a s o n fo r th is r e str ic tio n ?
                         A:    The memory used to store a variable-length array is usually allocated when the
                               declaration of the array is reached during program execution. Bypassing the decla­
                               ration using a g o t o statement could result in a program accessing the elements of
                               an array that was never allocated.




                               E x e r c is e s

S e c tio n 8.1     ©     I.   W e d is c u s s e d u s in g th e e x p r e s s io n s iz e o f ( a ) / s i z e o f ( a [ 0 ] ) to calcu lateth en u m -
                                                                                                                                           t is the type
                               ber of elements in an array. The expression s i z e o f (a ) / s i z e o f ( r ) , where cbaZYXWVUTSRQPONMLKJIHGFE
                               of a ’s elements, would also work, but it’s considered an inferior technique. Why?

                    ©     2.   The Q&A section shows how to use a letter as an array subscript. Describe how to use a
                               digit (in character form) as a subscript.

                          3.   Write a declaration of an array named w e e k e n d containing seven b o o l values. Include an
                               initializer that makes the first and last values t r u e ; all other values should be f a l s e .

                          4.   (C99) Repeat Exercise 3, but this time use a designated initializer. Make the initializer as
                               short as possible.

                          5.   The Fibonacci numbers are 0. I. I. 2. 3. 5. 8, l3, ..., where each number is the sum of the
                               two preceding numbers. Write a program fragment that declares an array named
                               f i b _ n u m b e r s of length 40 and fills the array with the first 40 Fibonacci numbers. Hint:
                               Fill in the first two numbers individually, then use a loop to compute the remaining num­
                               bers.

                                6.    Calculators, watches, and other electronic devices often rely on seven-segment displays for
S e c t io n 8 .2 aZYXWVUTSRQPONMLKJIHGFEDCBA
                               numerical output. To form a digit, such devices “turn on” some o fth e seven segments while
                               leaving others “o f f ’:




                               Suppose that we want to set up an array that remembers which segments should be “on” for
                               each dig*^it. Let’s numbert* the segments as follows:
                                  0




                               Here’s what the array might look like, with each row representing one digit:
                               co n st in t        s e g m e n t s [ 1 0 ] [7]     = {{1,        1,    1,    1,    1,    1,      0},     ...};
                               I’ve given you the first row of the initializer; fill in the rest.
1 78 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 8    A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                         ©      7.     Using the shortcuts described in Section 8.2. shrink the initializer for the s e g m e n t s array
                                       (Excrcise 6) as much as you can.

                                8.    W rite a declaration for a two-dimensional array named t e m p e r a t u r e _ r e a d i n g s that
                                      stores one month of hourly temperature readings. (For simplicity, assume that a month has
                                      30 days.) The rows o fth e array should represent days of the month; the columns should rep­
                                      resent hours of the day.

                                9.    Using the array of Exercise 8. write a program fragment that computes the average tempera­
                                      ture for a month (averaged over all days of the month and all hours of the day).

                              10.     Write a declaration for an 8 x 8 c h a r array named c h e s s _ b o a r d . Include an initializer
                                      that puts the following data into the array (one character per array clement):kjihgfedcbaZYXWVUTSRQPONMLKJIH




                                       P P P P P P P P
                                       R N B Q K B N R

                               11.    Write a program fragment that declares an 8 x 8 c h a r array named c h e c k e r _ b o a r d and
                                      then uses a loop to store the following data into the array (one character per array element):
                                       B R B R B R B R
                                       R B R B R B R B
                                       B R B R B R B R
                                       R B R B R B R B
                                       B R B R B R B R
                                       R B R B R B R B
                                       B R B R B R B R
                                       R B R B R B R BcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       Hint: The element in row /\ column J. should be the letter B if i 4- j is an even number.aZYXWVUTSRQPONM




                                       P r o g r a m m in g P r o je c t s

                                1.     Modify the r e p d i g i t . c program ofS ection 8.1 so that it shows which digits (if any)
                                       were repeated:
                                       Enter a number: 939577
                                       Repeated digit(s): 7 9

                         ©      2.     Modify the r e p d i g i t . c program of Section 8.1 so that it prints a table showing how
                                       many limes each digil appears in the number:
                                       Enter a number: 41271092
                                       Digit:        0 1 2 3                         4 56       7    8    9
                                       Occurrences: 1 2 2 0                          10 0       1    0    1

                                3.     Modify the r e p d i g i t . c program of Section8.1 so that the user can enter more than one
                                       number to be tested for repeated digits. The program should terminate when the user enters
                                       a number that’s less than or equal to ().
                                                                                                             179
                                                                   P ro g ra m m in g P ro je c ts onmlkjihgfedcbaZYXWVUTSRQPO

    4.   Modify the r e v e r s e . c program of Section 8.l lo use the expression ( i n t )
         ( s i z e o f (a ) / s i z e o f (a [0] ) ) (o ra macro with this value) for the array length.

©   5.                                                                                        m onthly
         Modify the i n t e r e s t . c program of Section 8.l so that it compounds interest cbaZYXWVUTSRQPONMLKJIHG
         instead of annually. The form of the output shouldn’t change: the balance should still be
         shown at annual intervals.

    6.   The prototypical Intemet newbie is a fellow named BIFF, who has a unique way of writing
         messages. H ere's a typical B 1FF communique:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
         H3Y DUD3,       C 15 RlLLY C 0 0 L l 1!!!i!!!!
         W rite a “B lF F fille r that reads a message entered by the user and translates it into BlFF-
         speak:
         Enter message:          Hey dude,       C is rilly cool
         In BlFF-speak:          H3Y DUD3,       C 15 RlLLY C 0 0 L ! !!!!!!!!!
         Your program should convert the message to upper-case letters, substitute digits for certain
         letters ( A ^ 4 . B ^ 8 . E -> 3 ,1 -> 1 ,0 ^ 0 . S~>5). and (hen append 10or so exclamation marks.
         H int: Store the original message in an array ofcharacters, then go back through the array,
         translating and printing characters one by one.

    7.   W rite a program that reads a 5 x 5 array o f integers and then prints the row sums and the
         column sums:
         Enter    row    1: 8 3 9 0 10
         Enter    row    2 : 3 5 17 1 1
         Enter    row    3 : 2 8 6 23 1
         Enter    row    4 : 15 7 3 2 9
         Enter    row    5: 6 14 2 6 0

         Row totalS: 30 27 40 36 28
         Column totals: 34 37 37 32 21

©   8.   Modify Programming Project 7 so that it prompts for five quiz grades for each of five stu­
         dents. then computes the total score and average score for each student, and the average
         score, high score, and low score for each quiz..

    9.   W rite a program that generates a “random walk" across a 10 x 10 array. The array will con­
         tain characters (all ’ . ’ initially). The program must randomly “walk” from element to ele­
         ment; always going up, down. left, or right by one element. The elements visited by thc
         program will be labeled with the letters A through Z, in the order visited. H ere's an example
         o flh e desired output:



         . F E ..............
         H G ................
         I ..................
         J ............... Z .
         K . . R S T U V Y .
         L M P Q . . . W X .
         . N O ..............


         H int: Use the s r a n d and r a n d functions (see d e a l . c ) to generate random numbers.
         After generating a number, look at its remainder when divided by 4. There are four possible
         values for the remainder— 0. 1 .2 , and 3— indicating the direction of the next move. Before
         perform ing a move, check that (a) il w on’t go outside the array, and (b) it doesn’t take us to
180 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 8    A rra y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    an elem ent that already has a letter assigned. If either condition is violated, try m oving in
                                    another direction. If all four directions are blocked, the program must term inate. H ere’s an
                                    exam ple o f prem ature term ination:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    A BG H I ..
                                    . CF . JK .
                                    . DE . M L .
                                    . . . . N 0 .
                                    . .W X Y P Q
                                    . .V U T S R




                                    Y is blocked on all four sides, so there’s no place lo put Z.

                            10.     M odify Program m ing Project 8 from C hapter 5 so that the departure tim es are stored in an
                                    array and the arrival tim es are stored in a second array. (The tim es are integers, representing
                                    the num ber of minutes since m idnight.) The program will use a loop to search the array o f
                                    departure times for the one closest to the time entered by the uscr.

                            11.     M odify Program m ing Project 4 from C hapter 7 so that the program labels its output:
                                    Enter phone number : l-800-CQL-LECT
                                    In numeric form: 1-800-265-5328
                                   The program will need to store lhc phone num ber (cither in its original form or in its
                                   num eric form) in an array of characters until it can be printed. You may assum e that the
                                   phone num ber is no morc than 15 characters long.

                            12.     M odify Program m ing Project 5 from Chapter 7 so that the SC R A B B LE values of lhe letters
                                    are stored in an array. T he array will have 26 elem ents, corresponding to the 26 letters o fth e
                                    alphabet. For exam ple, elem ent 0 of the array will store 1 (because the SC R A B B LE value o f
                                    the letter A is 1), elem ent 1 of the array will store 3 (because the SC R A B B LE value o f the
                                    letter B is 3), and so forth. As each character o f the input word is read, the program will use
                                    lhc array to determ ine the SC R A B B LE value o f that character. Use an array initializer to set
                                    up the array.

                            13.    M odify Program m ing Projcci 11 from C hapter 7 so that the program labels its output:
                                   Enter a first and last name: Lloyd Fosdick
                                   You entered the name: Fosdick, L.
                                   Thc program will need lo siore the last nam e (bul not the first name) in an array o fch araclers
                                   unlil il can be printed. You may assum e ihat lhe last name is no more than 20 characiers long.

                            14.     W riie a program lhal reverses lhc words in a sentence:
                                   Enter a sentence: you can cage a swallow can't you?
                                   Reversal of sentence: you can't swallow a cage can you?cbaZYXWVUTSRQPONMLKJI
                                   H int: Usc a loop lo read lhe characters one by one and siore them in a one-dim ensional
                                   c h a r array. Have the loop slop al a period, queslion mark, orexclam ation point (the “term i­
                                   nating character*), which is saved in a separate c h a r variable. Then use a second loop lo
                                   scarch backward lhrough the array for the beginning o f lhe last word. Prinl the last word,
                                   lhen search backward for the nexi-(o-last word. Repeal until lhe beginning o f the array is
                                   reached. Finally, print lhe term inating character.

                            15.    O nc o f the oldesi known encryption techniques is lhe C aesar cipher, attributed to Julius C ae­
                                   sar. Il involves replacing each letter in a m essage with another letter lhai is a fixed num ber of
                                                                                                        181 onmlkjihgfedcbaZ
                                                               P ro g ra m m in g P ro je c ts hgfedcbaZYXWVUTSRQPONMLK


      positions later in the alphabet. (If the replacement would go past lhc letter Z. the cipher
      ‘‘wraps around” to lhe beginning o fth e alphabet. For example, ifeac h letter is replaced by
                                                   Y would be replaced by A, and Z would be replaced by
      the letter two positions after it. then cbaZYXWVUTSRQPONMLKJIHGFEDCBA
      B.) Write a program that encrypts a message using a Caesar cipher. The user will enter the
      message to be encrypted and the shift amount (the num ber of positions by which letters
      should be shifted):kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
      Enter message to be encrypted: Go ahead, make my day.
      Enter shift amount (1-25): 2
      Encrypted message: Jr dkhdg, pdnh pb gdb.
      Notice that the program can decrypt a message if the user enters 26 minus the original key:
      Enter message to be encrypted: Jr dkhdg, pdnh pb gdb.
      Enter shift amount (1-25): 23
      Encrypted message: Go ahead, make my day.
      You may assume that the message does not exceed 80 characters. Characters other than let­
      ters should be left unchanged. Lower-case letters remain lowcr-casc when encrypted, and
      upper-case letters remain upper-case. Hint: To handle the wrap-around problem, use the
      expression ( ( c h - ’A ’ ) + n ) % 2 6 + ‘A ’ to calculate the encrypted version ofan upper­
      case letter, where c h stores the letter and n stores the shift amount. (You’ll need a similar
      expression for lower-case letters.)

16.   Write a program that tests whether two words are anagrams (permutations of the same let­
      ters):
      Enter first word: smartest
      Enter second word: mattress
      The words are anagrams .

      Enter first word: dumbest
      Enter second word: stumble
      The words are not anag rams.
      Write a loop that reads the first word, character by character, using an array o f2 6 integers lo
      keep track of how many times each letter has been seen. (For example, afier (he word sm art­
      est has been read, the array should contain the values 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 2 2 0
      0 0 0 0 0. reflecting the fact that sm artest contains one a, one e. one ni, one i\ two .fs and
      two r’s.) Use another loop to read the second word, except this time decrementing the corre­
      sponding array element as each letter is read. Both loops should ignore any characters that
      aren’t letters, and both should treat upper-case letters in the same way as lower-case letters.
      After the second word has been read, use a third loop to check whether all the elements in
      the array are zero. If so. the words are anagrams. Hint: You may wish to use functions from
      <ctype .h>, such as isalpha and tolower.

17.   Write a program that prints an n x n magic square (a square arrangement of the numbers
      1. 2........ / r in which the sums of the rows, columns, and diagonals are all the same). The
      user will specify the value ofn :
      This program creates a magic square of a specified size.
      The size must be an odd number between 1 and 99.
      Enter size of magic s q u a r e : 5_
         17   24    1    8     15
         23    5    7   14     16
          4    6   13   20     22
         10   12   19   21       3
         11   18   25    2       9
            C h a p te r 8    A rra y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
1 8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                      Store the magic square in a two-dimensional array. Start by placing the num ber 1 in the m id­
                                                                                                         i r by moving up one row and
                                      dle of row 0. Place each o f the remaining numbers 2, 3, .... cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      over one column. Any attempt to go outside the bounds o f the array should “wrap around”
                                      to the opposite side o fth e array. For exam ple, instead o f storing the next num ber in row - 1 ,
                                      we would store i( in row n - 1 (the last row). Instead o fsto rin g the next num ber in colum n n,
                                      we would store it in column 0. If a particular array elem ent is already occupied, put the
                                      num ber directly below the previously stored number. If your com piler supports variable­
                                      length arrays, declare the array to have n rows and n columns. If not, declare the array to
                                      have 99 rows and 99 columns.
9     F u n c t io n s              ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                         l f y o u h a v e a p r o c e d u r e w ith te n
                                                            p a ra m e te r s , y o u p r o b a b ly m is s e d s o m e . onmlkjihgfedcba




      We saw in Chapter 2 that a Function is simply a series o f statem ents that have been
      grouped together and given a name. Although the term “ function” comes from
      mathematics. C functions don’t always resem ble math functions. In C, a function
      doesn't necessarily have arguments, nor does it necessarily com pute a value, (fri
      som e program m ing languages, a “function” returns a value, whereas a "procedure"’
      doesn’t. C lacks this distinction.)
            Functions are the building blocks o fC program s. Each function is essentially a
      small program , with its own declarations and statem ents. Using functions, we can
      divide a program into small pieces that are easier for us— and others— to under­
      stand and modify. Functions can take som e o f the tedium out of program m ing by
      allowing us to avoid duplicating code that’s used more than once. Moreover, func­
      tions are reusable: wc can take a function that was originally part of one program
      and use it in others.
            Our program s so far have consisted o fju s t the m a i n function. In this chapter,
      w e'll see how to write functions other than m a in , and w e’ll learn more about
      m a i n itself. Section 9.1 shows how to define and call functions. Section 9.2 then
      discusses function declarations and how they differ from function definitions.
      Next, Section 9.3 exam ines how argum ents are passed to functions. The remainder
      of the chapter covers the r e t u r n statem ent (Section 9.4), the related issue of pro­
      gram term ination (Section 9.5), and recursion (Section 9.6).




9.1   D e fin in g a n d C a llin g F u n c t io n s

      Before we go over the formal rules for defining a function, let’s look at three sim ­
      ple programs that define functions.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                                                                                    183
           C h a p te r 9 F u n c tio n s
184 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             C o m p u t in g A v e r a g e s
             PRO G RA M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                 Suppose we often need to compute the average of two d o u b l e values. The C
                                 library doesn't have an “average" function, but we can easily define our own.
                                 H ere’s what il would look like:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                 double average(double a, double b)

                                    return (a + b) / 2;


                                 The word d o u b l e at the beginning is a v e r a g e ’s re tu rn type: the type o f data
                                 that the function returns each time it’s called. The identifiers a and b (the func­
                       Q&A       tion’s p a ra m eters) represent the two numbers that will be supplied when a v e r ­
                                 a g e is called. Each parameter must have a type ^usi like every variable has a
                                 type); in this example, both a and b have type d o u b l e . (It may look odd. but the
                                 word d o u b l e must appear twice, once for a and once for b.) A function param e­
                                 ter is essentially a variable whose initial value will be supplied later, when the
                                 function is called.
                                      Every function has an executable part, called the body, which is enclosed in
                                 braces. The body of a v e r a g e consists o f a single r e t u r n statement. Executing
                                 this statement causes the function to “return" to the place from which it was called:
                                 the value of (a + b ) / 2 will be the value returned by the function.
                                      To call a function, we write the function name, followed by a list of a rg u ­
                                 m en ts. For example, a v e r a g e ( x , y ) is a call of the a v e r a g e function. Argu­
                                 ments are used to supply information to a function; in this case, a v e r a g e needs
                                 to know which two numbers to average. The effect of the call a v e r a g e ( x , y ) is
                                 to copy the values of x and y into the parameters a and b . and then execute the
                                 body of a v e r a g e . An argument doesn’t have to be a variable; any expression of a
                                 com patible type will do, allowing us to write a v e r a g e ( 5 . 1 , 8 . 9 ) or a v e r ­
                                 age (x /2 , y /3 ) .
                                      W e'll put the call of a v e r a g e in the place where we need to use the return
                                 value. For example, we could write

                                printf("Average: %g\n", average(x, y));

                                 to compute the average o f x and y and then print it. This statement has the follow­
                                 ing effect:

                                      I. The a v e r a g e function is called with x and y as arguments.
                                      2. x and y are copied into a and b.
                                      3. a v e r a g e executes its r e t u r n statement, returning the average of a and b.
                                      4. p r i n t f prints the value that a v e r a g e returns. (The return value of
                                         a v e r a g e becomes one o f p r i n t f ’s argum ents.)
                                Note that the return value of a v e r a g e isn’t saved anywhere; the program prints il
                                and then discards it. If we had needed the return value later in the program, we
                                could have captured il in a variable:
                                                          9 .1                                                                 185 kjihgfedcb
                                                                 D e f in in g a n d C a l l i n g F u n c t i o n s onmlkjihgfedcbaZYXWVUTSRQ


                    avg = average(x, y);

                    This statement calls a v e r a g e , then saves its return value in the variable a v g .
                        Now, let’s use the a v e r a g e function in a complete program. The following
                    program reads three numbers and computes their averages, one pair at a time:

                         Enter three numbers: 3.5 9.6 10.2
                         Average of 3.5 and 9.6: 6.55
                         Average of 9.6 and 10.2: 9.9
                         Average of 3.5 and 10.2: 6.85

                    Among other things, this program shows that a function can be called as often as
                    we need.BA

  a v e ra g e .c   /★    Computes pairwise averages of three numbers */

                    #include <stdio.h>

                    double average(double a, double b)

                         return (a + b) / 2;


                    int main(void)

                         double x, y, z;

                         printf("Enter three numbers: ”);
                         scanf("%lf%lf%lf", &x, &y, &z);
                         printf("Average of %g and %g: %g\n", x, y, average(x, y));
                         printf("Average of %g and %g: %g\n", y, z, average(y, z));
                         printf("Average of %g and %g: %g\n", x, z, average(x, z));

                         return 0;


                    Notice that I’ve put the definition of a v e r a g e before m a in . We’ll see in Section
                    9.2 that putting a v e r a g e after m a in causes problems.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                  P r in tin g a C o u n td o w n
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                    Not every function returns a value. For example, a function whose job is to pro­
                    duce output may not need to return anything. To indicate that a function has no
                    return value, we specify that its return type is v o i d , ( v o i d is a type with no val­
                    ues.) Consider the following function, which prints the message T m in u s n a n d
                    c o u n t i n g , where n is supplied when the function is called:

                    void print_count(int n)

                         printf("T minus %d and counting\n", n);
186 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 9   F u n c t io n s


                                  p r i n t _ c o u n t has one parameter, n, of type i n t . It returns nothing, so I’ve
                                  specified v o i d as the return type and omitted the r e t u r n statement. Since
                                  p r i n t _ c o u n t doesn’t return a value, we can’t call it in the same way we call
                                  a v e r a g e . Instead, a call of p r i n t _ c o u n t must appear in a statem ent by itself:kjihgfedcb
                                  print_count(i);

                                         H ere’s a program that calls p r i n t _ c o u n t 10 times inside a loop:BA
             countdown.c           /★    Prints a countdown */

                                  #include <stdio.h>

                                  void print_count(int n)

                                        printf("T minus %d and counting\n", n);


                                   int main(void)

                                        int i;

                                        for (i = 10; i > 0; --i)
                                          print_count(i);

                                        return 0;


                                       Initially, i has the value 10. When p r i n t _ c o u n t is called for the first time,
                                  i is copied into n. so that n takes on the value 10 as well. As a result, the first call
                                  of p r i n t _ c o u n t will print
                                  T minus 10 and counting

                                  p r i n t _ c o u n t then returns to the point at which it was called, which happens to
                                  be the body of a f o r statement. The f o r statement resumes where it left off, dec­
                                  rementing i to 9 and testing whether it’s greater than 0. It is, so p r i n t _ c o u n t is
                                  called again, this time printing
                                  T minus 9 and counting

                                  Each time p r i n t _ c o u n t is called, i is different, so p r i n t _ c o u n t will print
                                  10 different messagc^es,


                             P r in tin g a P u n (R e v is ite d )
              PRO G RA M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  Some functions have no parameters at all. Consider p r i n t _ p u n . which prints a
                                  bad pun each time it’s called:
                                  void print_pun(void)

                                        printf("To C, or not to C: that is the question.\n");
                                                                                  9.1    D e fin in g a n d C alling F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLK
                                                                                                                                               187

                                   The word v o i d in parentheses indicates that p r i n t _ p u n has no arguments.
                                   (This time, we’re using v o i d as a placeholder that means “nothing goes here.”)
                                       To call a function with no arguments, we write the function’s name, followed
                                   by parentheses:

                                   p rin t_ p u n ();

                                   The parentheses m ust be present, even though there are no arguments.
                                       Here’s a tiny program that tests the p r i n t _ p u n function:

                    p u n 2 .c     /* P r i n t s a b a d p u n * /

                                   # i n c l u d e < s t d i o .h >

                                   v o id p rin t_ p u n (v o id )

                                               p r i n t f ( " T o C, o r n o t t o C: t h a t i s     th e q u e s t i o n . \ n " ) ;
                                   }

                                   i n t m a in ( v o id )
                                   {
                                       p rin t_ p u n ();
                                       r e t u r n 0;
                                   }
                                        The execution o fth is program begins with the first statement in m a in , which
                                   happens to be a call o f p r i n t _ p u n . When p r i n t _ p u n begins to execute, it in
                                   turn calls p r i n t f to display a string. When p r i n t f returns, p r i n t _ p u n re­
                                   turns to m a in .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   F u n c t io n D e fin it io n s

                                   Now that w e’ve seen several examples, let’s look at the general form of ^ fu n c tio n
                                   d efin itio n : aZYXWVUTSRQPONMLKJIHGFEDCBA


f u n c t io n d e f i n it io n                                return-type fu n ctio n -n a m e   ( pa ra m eters )

                                                                    declarations
                                                                    statem ents



                                        The return type o fa function is the type ofv alu e that the function returns. The
                                   following rules govem the return type:

                                       ■         Functions may not return arrays, but there are no other restrictions on the
                                                 return type.
                                           ■     Specifying that the return type is v o i d indicates that the function doesn't
                                                 return a value.
188 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 9    F u n c tio n s


                                     ■ If the r eturn type is omitted in C89, the function is presumed to return a value
                                         of type i n t . In C99, it’s illegal to omit the return type of a function.
                                     As a matter ofstyle, some programmers put the return type cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                               above the function
                                  name:dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  double
                                  average(double a, double b)

                                      return (a + b) / 2;


                                 Putting the return type on a separate line is especially useful if the return type is
                                 lengthy, like u n s i g n e d l o n g i n t .
                                       After the function name comes a list of parameters. Each parameter is pre­
                                 ceded by a specification of its type; parameters are separated by commas. If the
                        Q&A kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 function has no parameters, the word v o i d should appear between the parenthe­
                                 ses. Note: A separate type must be specified for each parameter, even when several
                                 parameters have the same type:

                                  double average(double a, b)                /*** WRONG ***/

                                      return (a + b) / 2;


                                      The body of a function may include both declarations and statements. For
                                  example, the a v e r a g e function could be written

                                  double average(double a, double b)

                                      double sum;             /* declaration */

                                      sum = a + b;            /* statement */
                                      return sum / 2;         /* statement */


                                  Variables declared in the body of a function belong exclusively to that function;
                                  they can't be examined or modified by other functions. In C89, variable declara-
                       <@ 1       tions must come first, before all statements in the body of a function. In C99, vari­
                                  able declarations and statements can be mixed, as long as each variable is declared
                                  prior to the first statement that uses the variable. (Some pre-C99 compilers also
                                  allow mixingC5 ofdeclarations and statements.)^
                                       The body of a function whose return type is v o i d (which Tll call a *‘v o i d
                                  function”) can be empty:

                                  void print_pun(void)



                                  Leaving the body empty may make sense during program development: we can
                                  leave room for the function without taking the time to complete it, then come back
                                  later and write the body.
                                                                         9.1                                                           189dcbaZYXWV
                                                                                  D e fin in g a n d C a llin g F u n c tio n s kjihgfedcbaZYXWVUTSRQPON


                           F u n c t io n C a lls onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                           A function call consists of a function name followed by a list of arguments,
                           enclosed in parentheses:
                           average(x, y)
                           print_count(i)
                           print_pun()


                           If the parentheses are missing, the function won’t get called:
                           print_pun;              /*** WRONG ***/

                           The result is a legal (albeit meaningless) expression statement that looks correct,
                 Q&A                                                                      “statem ent with no
                           but has no effect. Some compilers issue a warning such as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                           effect.”


                                A call of a v o i d function is always followed by a semicolon to turn it into a
                           statement:

                           print_count(i);
                           print_pun();

                           A call of a n o n -v o id function, on the other hand, produces a value that can be
                           stored in a variable, tested, printed, or used in some other way:

                           avg = average(x, y);
                           if (average(x, y) > 0)
                             printf(“Average is positive\n");
                           printf("The average is %g\n", average(x, y));

                               The value returned by a n o n -v o id function can always be discarded if it’s not
                           needed:

                           average(x, y);                  /* discards return value */

expressionstatements>4.5   This call of a v e r a g e is an example of an expression statement: a statement that
                           evaluates an expression but then discards the result.
                               Ignoring the return value of a v e r a g e is an odd thing to do. but for some
                           functions it makes sense. Thc p r i n t f function, for example, returns the number
                           of characters that it prints. After the following call, n u m _ c h a r s will have the
                           value 9:

                           num_chars = printf("Hi, Mom!\n 11);

                           Since weTe probably not interested in the number of characters printed, weTI nor­
                           mally discard p r i n t f ’s return value:

                           printf("Hi, Mom!\n");                        /* discards return value */

                                 To make it clear that we’re deliberately discarding the return value of a func-
                           tio n ,C a llo w su sto p u t ( v o id ) beforethccall:
190 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 9    F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            (void) printf("Hi, Mom!\n");hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                     c a s t in g > 7 . 4   What we’re doing is casting (converting) the return value of p r i n t f to type
                                            v o i d . Gn C, “casting t o v o i d ” is a polite way ofsaying “throwing away?) Using
                                             ( v o i d ) makes it clear to others that you deliberately discarded rhe rerurn value,
                                            n o tju st forgot that there was one. Unfortunately, there are a great many functions
                                            in the C library whose values are routinely ignored; using ( v o i d ) when calling
                                            them all can get tiresome, so I haven’t done so in this book.


               PROGRAM                      T e stin g W h e th e r a N u m b e r I s P r im e
                                            To sce how functions can make programs easier to understand, let's write a pro­
                                            gram that tests whether a number is prime. The program will prompt the user to
                                            enter a number, then respond with a message indicating whether or not the number
                                            is prime:
                                            Enter a number: 34
                                            Not prime

                                            Instead of putting the prime-testing details in m a in , we'll define a separate func­
                                            tion that returns t r u e if its parameter is a prime number and f a l s e if it isn’t.
                                            When given a number n, the i s _ p r i m e function will divide n by each of the
                                            numbers between 2 and the square root of n; if the remainder is ever 0, we know
                                            that n isn’t prime.
                                       / ★ Tests whether a number is prime */
                      p r im e .c dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            #include <stdbool.h>                 /* C99 only */
                                            #include <stdio.h>

                                            bool is_prime(int n)
                                            {
                                              int divisor;

                                              if (n <= 1)
                                                return false;
                                              for (divisor = 2; divisor * divisor <= n; divisor++)
                                                if (n % divisor == 0)
                                                  return false;
                                              return true;


                                            int main(void)

                                               int n ;

                                              printf("Enter a number: ");
                                              scanf("%d", &n);
                                              if (is_prime(n))
                                                printf("Prime\n");
                                              else
                                                printf("Not prime\n");
                                                               9 .2                                               191 kjihgfedcbaZYXWVUT
                                                                      F u n c tio n D e c la r a tio n s hgfedcbaZYXWVUTSRQPONMLKJIHGF

          return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


            Notice that m a in contains a variable named n even though i s _ j p r i m e 's
       param eter is also named n. In general, a function may declare a variable with the
       same name as a variable in another function. The two variables represent different
       locations in memory, so assigning a new value to one variable doesn’t change the
       other. (This property extends to param eters as well.) Section lO.I discusses this
       point in more detail.
            As i s _ p r i m e dem onstrates, a function may have more than one r e t u r n
       statement. However, we can execute just one of these statem ents during a given
       call of the function, because reaching a r e t u r n statement causes the function to
       return to where it was called. We’ll learn more about the r e t u r n statem ent in
       Section 9.4.aZYXWVUTSRQPONMLKJIHGFEDCBA




9 .2   F u n c t io n D e c la r a t io n s

       In the programs in Section 9 .l, the definition o fe a c h function was always placed cbaZYXWVUTSRQPONM
       above the point at which it was called. In fact, C doesn’t require that the definition
       of a function precede its calls. Suppose that we rearrange the a v e r a g e . c pro­
       gram by putting the definition o f a v e r a g e a fter the definition o f m a in :

       #include <stdio.h>

       int main(void)

         double x, y, z;

         printf("Enter three numbers:
         scanf("%lf%lf%lf", &x, &y, &z);
         printf("Average of %g and %g: %g\n", x, y, average(x, y));
         printf("Average of %g and %g: %g\n", y, z, average(y, z));
         printf("Average of %g and %g: %g\n", x, z, average(x, z));

          return 0;


       double average(double a, double b)

          return (a + b) / 2;


       When the com piler encounters the first call o f a v e r a g e in m a in , it has no
       information about a v e r a g e : it doesn’t know how many paraineters a v e r a g e
       has, what the types of these param eters are, or what kind o f value a v e r a g e
       returns. Instead ofproducing an error message, though, the com piler assum es that
       a v e r a g e returns an i n t value (recall from Section 9.l that the return type of a
192 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 9    F u n c tio n s


                                                                                                                   im p lic itd e c -
                                        function is i n t by default). We say that the compiler has created an cbaZYXWVUTSRQPONMLKJIHGF
                                       laration of the function. The compiler is unable to check that we’re passing
                                        a v e r a g e the right number of arguments and that the arguments have the proper
                                        type. Instead, it performs the default argument promotions and hopes for the best.
default argument promotions > 9.3onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        When it encounters the definition of a v e r a g e later in the program, the compiler
                                        notices that the function’s return type is actually d o u b l e , not i n t , and so we
                                       ^g^*et an error messag^^e.
                                                One way to avoid the problem of caII-before-definition is to arrange the pro­
                                       gram so that the definition o feach function precedes all its calls. Unfortunately,
                                       such an arrangement doesn’t always exist; and even when it does, it may make the
                                       program harder to understand by putting its function definitions in an unnatural
                                       order.
                                                Fortunately. C offers a better solution: declare each function before calling it.
                                        A fu n c tio n declaration provides the compiler with a brief glimpse at a function
                                        whose full definition will appear later. A function declaration resembles the first
                                        line o fa function definition with a semicolon added at the end:


  fu n c tio n d e c la ra tio n                    return-type function-nam e        ( param eters )        ; dcbaZYXWVUTSRQPONMLKJIHGFED


                                   Needless to say. the declaration o fa function must be consistent with the function's
                         Q&A       definition.
                                        Here's how our program would look with a declaration o f a v e r a g e added:kjihgfedc

                                   #include <stdio.h>

                                   double average(double a, double b);                       /* DECLARATION */

                                   int main(void)

                                      double x, y, z;

                                      printf("Enter three numbers: ");
                                      scanf("%lf%lf%lf", &x, &y, &z);
                                      printf("Average of   %gand %g: %g\n",                    x, y, average(x, y ) );
                                      printf("Average of   %gand %g: %g\n”,                    y, z, average(y, z));
                                      printf("Average of   %gand %g: %g\n",                    x, z, average(x, z));

                                      return 0;


                                   double average(double a, double b)                        /* DEFINITION */

                                      return (a + b) / 2;


                                        Function declarations of the kind we've been discussing are known as/wzic-
                                   tion prototypes to distinguish them from an older style of function declaration in
                         Q&A       which the parentheses are left empty. A prototype provides a complete description
                                                                   9 .3                             193 onmlkjihgfedcba
                                                                          A r g u m e n ts hgfedcbaZYXWVUTSRQPONMLK


       of how to call a function: how many argum ents to supply, what their types should
       be, and what type of result will be returned.
                                                                                       nam es of the
            Incidentally, a function prototype doesn’t have to specify the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
       function’s param eters, as long as their types are present:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

       double average(double, double);aZYXWVUTSRQPONMLKJIHGFEDCBA

       Tt’s usually best not to omit param eter names, since they help docum ent the pur­
       pose o f each param eter and remind the program m er o f the order in which argu­
Q&A    ments must appear when the function is caJled. However, there are legitimate
^ B    reasons for om itting param eter names, and some program m ers prefer to do so.
            C99 has adopted the rule that either a declaration or a definition of a function
       must be present prior to any call of the function. Calling a function for which the
       com piler has not yet seen a declaration or definition is an error.




9 .3   A r g u m e n ts

       L et’s review the difference between a param eter and an argum ent. Param eters
       appear in function definitio ns; they’re dummy names that represent values to be
       supplied when the function is called. A rg u m en ts are expressions that appear in
       function calls. When the distinction between argum ent and p a ra m e te r isn’t impor­
       tant; I’ll som etim es use argum ent to mean either.
             In C, arguments are p a sse d by value: when a function is called, each argument
       is evaluated and its value assigned to the corresponding parameter. Since the
       param eter contains a copy of the argum ent's value_. any changes made to the
       param eter during the execution of the function d o n 't affect the argum ent. In effect,
       each param eter behaves like a variable that’s been initialized to the value of the
       matching argument.
            The fact that arguments are passed by value has both advantages and disad­
       vantages. Since a param eter can be modified without affecting the corresponding
       argument, we can use parameters as variables within the function, thereby reduc­
       ing the num ber of genuine variables needed. C onsider the following function,
       which raises a number x to a p o w ern :

       int power(int x, int n)

          int i, result = 1;

          for (i = 1; i <= n; i++)
            result = result * x;

          return result;


       Since n is a copy of the original exponent, we can modify it inside the function,
       thus removing^" the need for i :
194 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 9    F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     int power(int x, int n)

                                         int result = 1;

                                         while (n-- > 0)
                                           result = result * x;

                                         return result;


                                          Unfortunately, C ’s requirement that arguments be passed by value makes it
                                     difficult to write certain kinds of functions. For example, suppose that we need a
                                     function that will decompose a d o u b l e value into an integer part and a fractional
                                     part. Since a function can’t RQPONMLKJIHGFEDCBA
                                                                    r e tu r n two numbers, we might try passing a pair of
                                     variables to the function and having it modify them:

                                     void decompose(double x, long int_part, double frac_part)

                                         int_part = (long) x;   /* drops the fractional part of x */
                                         frac_part = x - int_part;


                                     Suppose that we call the function in the following way:

                                     decompose(3.14159,                    i, d);

                                     At the beginning of the call, 3.14159 is copied into x, i\s value is copied into
                                     i n t _ j p a r t . and d ’s value is copied into f r a c _ p a r t . The statements inside
                                     d e c o m p o s e then assign 3 to i n t _ p a r t and .14159 to f r a c _ p a r t , and the
                                     function returns. Unfortunately, i and d w eren't affected by the assignments to
                                     i n t _ p a r t and f r a c _ p a r t , so they have the same values after the call as they
                                     did before the call. With a little extra effort, d e c o m p o s e can be made to work, as
                                     w e’ll see in Section 11.4. However, w e’ll need to cover more o f C ’s features first.dcbaZYXW


                                     A r g u m e n t C o n v e r s io n s

                                     C allows function calls in which the types o fth e arguments don’t match the types
                                     o fth e parameters. The rules governing how the arguments are converted depend on
                                     whether or not the com piler has seen a prototype for the function (or the function's
                                     full definition) prior to the call:
                                                                                                             The value of
                                        ■ T h e c o m p il e r h a s e n c o u n te r e d a p r o to t y p e p r i o r to     th e c a ll.
                                            each argument is implicitly converted to the type of the corresponding param­
                                            eter as ifby assignment. For example, ifan i n t argument is passed to a func­
                                            tion that was expecting a d o u b l e , the argument is converted to d o u b l e
                                            automatically.
                                        ■ T h e c o m p i l e r h a s n o t e n c o u n t e r e d a p r o t o t y p e p r i o r t o t h e c a l l . The compiler
                                            performs the d e f a u l t a r g u m e n t p r o m o t i o n s : (1) f l o a t arguments are con­
                                            verted to d o u b l e . (2) The integral promotions are performed, causing c h a r
                                                                  9 .3   A r g u m e n ts hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                   1 9 5 onmlkjihgfedcbaZYXW


             and s h o r t arguments to be converted to i n t . (In C99, the integer promo- dcbaZYXWVUTSRQ
£99"         tions are performed.) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


        Relying on the default argument promotions is dangerous. Consider the following
A       program:
        #include <stdio.h>

        int main(void)

           double x = 3.0;
           printf("Square: %d\n", square(x));

           return 0;


        int square(int n)

           return n * n;


        At the time s q u a r e is called, the compiler hasn’t seen a prototype yet, so it
        doesn’t know that s q u a r e expects an argument of type i n t . Instead, the com­
        piler performs the default argument promotions on x, with no effect. Since it’s
        expecting an argument of type i n t but has been given a d o u b l e value instead,
        the effect of calling s q u a r e is undefined. The problem can be fixed by casting
        s q u a r e ’s argument to the proper type:
        printf("Square: %d\n", square((int) x));

 _   Of course, a much better solution is to provide a prototype for s q u a r e before
<@ > calling it. In C99, calling s q u a r e without first providing a declaration or defini­
      tion of the function is an error.




        A r r a y A r g u m e n ts aZYXWVUTSRQPONMLKJIHGFEDCBA

        Arrays are often used as arguments. When a function parameter is a one-dim en­
Q&A     sional array, the length o fth e array can be (and is normally) left unspecified:

        int f(int a[])               /* no length specified */




        The argument can be any one-dimensional array whose elements are o fth e proper
        type. There’sju st one problem: how will f know how long the array is? Unfortu­
        nately, C doesn’t provide any easy way for a function to determine the length o fan
        array passed to il. Instead, we’ll have to supply the length— if the function needs
        it— as an additional arogument,
             C h a p te r 9
1 9 6 ZYXWVUTSRQPONMLKJIHGFEDCBAF u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                       Although we can use the s i z e o f operator to help determine the length of an
                           A                 variable, it doesn’t give the correct answer for an array param eter:
                                       array cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       int f (int a [] )

                                           int len = sizeof(a) / sizeof(a[0]);
                                               /*** WRONG: not the number of elements in a ***/
                                           •••


                                       Section 12.3 explains why.


                                            The following function illustrates the use ofone-dim ensional array arguments.
                                       When given an array a of i n t values, s u m _ a r r a y returns the sum of the ele­
                                       ments in a. Since s u m _ a r r a y needs to know the length of a, we must supply it
                                       as a second argument.

                                       int sum_array(int a[], int n)

                                           int i , sum = 0;

                                           for (i = 0; i < n; i++)
                                             sum += a [i];

                                           return sum;


                                       The prototype for s u m _ a r r a y has the following appearance:

                                       int sum_array(int a[], int n);

                                       As usual, we can omit the parameter names if we wish:

                                       int sum_array(int                      [], int);

                                           When s u m _ a r r a y is called, the first argument will be the name of an array,
                                       and the second will be its length. For example:

                                       #define LEN 100

                                       int main(void)

                                           int b[LEN], total;
                                           •••
                                           total - sum_array(b, LEN);
                                           •••


                                       Notice that we don’t put brackets after an array name when passing it to a function:

                                       total = sum_array(b[], LEN);                       /*** WRONG ***/
                                                                   9 .3                           197onmlkjihgfedcbaZYXWVU
                                                                          A rg u m e n ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE


           An important point, about array arguments: A function has no way to check
      that w e’ve passed it the correct array length. We can exploit this fact by telling the
      function that the array is smaller than il really is. Suppose that w e’ve only stored
      50 numbers in the b array, even though it can hold l00. We can sum ju st the first
      50 elem ents by writing

      total = sum_array(b, 50);                 /* sums first 50 elements */

      s u m _ a r r a y will ignore the other 50 elements. (Indeed, it won"t know that they
      even exist!)


      Be careful not to tell a function that an array argument is cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                  larger than it really is:

      total = sum_array(b, 150);                 /*** WRONG ***/

      In this example, s u m _ a r r a y will go past the end of the array, causing undefined
      behavior.


           Another important thing to know is that a function is allowed to change the
      elements of an array parameter, and the change is reflected in the corresponding
      argument. For example, the following function modifies an array by storing zero
      into each of its elements:

      void store_zeros(int a[], int n)

         int i ;

         for (i = 0; i < n; i++)
           a[i] = 0;


      The call

      store_zeros(b, 100);

      will store zero into the first 100 elem ents of the array b. This ability to modify the
      elements of an array argument may seem to contradict the fact that C passes argu­
      ments by value. In fact, there’s no contradiction, but I w on’t be able to explain why
      until Section 12.3.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
           If a parameter is a multidimensional array, only the length o f th e first dim en­
Q&A   sion may be omitted when the parameter is declared. For example, if we revise the
      s u m _ a r r a y function so that a is a two-dimensional array, we must specify the
      number ofcolum ns in a, although we don’t have to indicate the num ber of rows:

      #define LEN 10

      int sum_two_dimensional_array(int a[][LEN], int n)

         int i , j , sum = 0;
198 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 9    F u n c tio n s


                                                        f o r ( i = 0 ; i < n ; i+ + )
                                                            f o r ( j = 0 ; j < LEN; j+ + )
                                                                sum += a [ i ] [j ] ;

                                                        re tu rn       sum ;


                                                     Not being able to pass multidimensional arrays with an arbitrary number o fc o l-
                                                     umns can be a nuisance. Fortunately, we can often work around this difficulty by aZYXWVU
           a r r a y s o fp o in te r s > /3 .7      using arrays ofpointers. C99's variable-length array parameters provide an even
                                                     better solution to the problem.

                                                   V a r ia b le -L e n g th
                                       C 9 9 dcbaZYXWVUTSRQPONMLKJIHGFEDCBA        A rray P aram eters
                                                     C99 adds several new twists to array arguments. The first has to do with variable-
       v a r ia b ie -ie n g th a r r a y s > 8 .3   length arrays (VLAs), a feature of C99 that allows the length of an array to be
                                                     specified using a non-constant expression. Variable-length arrays can also be
                                                     parameters, as it turns out.
                                                          Consider the s u m _ a r r a y function discussed earlier in this section. H ere’s
                                                     the definition of s u m _ a r r a y , with the body omitted:
                                                     in t      s u m _ a rra y (in t a [ ] ,   i n t n) hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                        • ••




                                                     As it stands now, there’s no direct link between n and the length of the array a.
                                                     Although the function body treats n as a ’s length, the actual length of the array
                                                     could in fact be larger than n (or smaller, in which case the function w on’t work
                                                     correctly).
                                                           Using a variable-length array parameter, we can explicitly state that a ’s length
                                                     is n:
                                                     in t      s u m _ a rra y (in t n z i n t a [n ])

                                                        •••


                                                     The value of the first parameter (n) specifies the length of the second parameter
                                                     (a). Note that the order of the parameters has been switched: order is important
                                                     when variable-length array parameters are used.


                                                     The following version of s u m _ a r r a y is illegal:
                                                     i n t s u m _ a rra y (in t a [ n ] ,      i n t n)         / * * * WRONG * * * /




                                                     The com pilerw illissueanerror message at i n t a [n] .b ec au seith asn ’ty et seen n.
                                                            9 .3                             199
                                                                   A rg u m e n ts onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


     There arc several ways to write the prototype for our new version of
s u m _ a r r a y . One possibility is to make it look exactly like the function defini­
tion:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

int sum_array(int n, int a(n]);                   /* Version 1 */

Another possibility is to replace the array length by an asterisk (*):

int sum_array(int n, int a[*]);                   /* Version 2a */

The reason for using the * notation is that param eter nam es are optional in func­
tion declarations. Ifth e name o fth e first param eter is om itted, it w ouldn’t be possi­
ble to specify that the length of the array is n . but the * provides a clue that the
length of the array is related to parameters that com e earlier in the list:

int sum_array(int,          int   [*]);           /* Version 2b */

It’s also legal to leave the brackets empty, as we normally do when declaring an
array parameter:

int sum_array(int n, int a[] ) ;                  /* Version 3a */
int sum array(int, int []);                       /* Version 3b */

Leaving the brackets em pty isnT a good choice, because il doesn’t expose the rela­
tionship between n and a.
     In general, the length of a variable-length array param eter can be any expres­
sion. For example, suppose that we were to write a function that concatenates two
arrays a and b by copying the elem ents of a , followed by the elem ents o f b , into a
third array named c:

int concatenate(int m, int n, int a[m],                    int b[n],        int c[m+n])




The length of c is the sum of the lengths of a and b. The expression used to spec­
ify the length of c involves two other param eters, but in general it could refer to
variables outside the function or even call other functions.
     Variable-length array param eters with a single dim ension— as in all our exam ­
ples so far— have limited usefulness. They make a function declaration or defini­
tion more descriptive by stating the desired length o fa n array argument. However,
no additional error-checking is performed: it’s still possible for an array argum ent
lo be loo long or too short.
             *^

     It lums out that variable-length array param eters are most useful for m ultidi­
mensional arrays. Earlier in this section, we tried to write a function that sums the
elem ents in a tw o-dim ensional array. O ur original function was lim ited to arrays
with a fixed num ber o f columns. If we use a variable-length array parameter, we
can generalize the function to any number ofcolum ns:
2 0 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 9    F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      int sum_two_dimensional_array(int n, int m, int a[n] [m])

                                          int i ।       j।   sum = 0;

                                          for (i = 0; i < n; i++)
                                            for (j = 0; j < m; j++)
                                              sum += a [i] [j] ;

                                          return sum;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      Prototypes for this function include the following:

                                      int     sum_two_dimensional_array(int                      n, int   m,    int a[n][m]);
                                      int     sum_two_dimensional_array(int                      n, int   m,    int a[*][*]);
                                      int     sum_two_dimensional_array(int                      n, int   m,    int a[] [m]);
                                      int     sum_two_dimensional_array(int                      n, int   in,   int a[] [*]);dcbaZYXWVUTSRQPO


                          <^j>        U s in g s t a t i c in A r r a y P a r a m e te r D e c la r a tio n s

                                      C99 allows the use of the keyword s t a t i c in the declaration o f array parameters.
                                      (The keyword itself existed before C99. Section 18.2 discusses its traditional uses.)
                                           In the following example, putting s t a t i c in front o fth e number 3 indicates
                                      that the length of a is guaranteed to be al least 3:

                                      int sum_array(int a[static 3], int n)




                                      Using s t a t i c in this way has no effect on the behavior of the program. The pres­
                                      ence of s t a t i c is merely a “hint” that may allow a C com piler to generate faster
                                      instructions for accessing the array, (lf the com piler knows that an array will
                                      always have a certain minimum length, it can arrange to “prefetch” these elem ents
                                      from memory when the function is called, before the elem ents are actually needed
                                      by statements within the function.)
                                           One last note about s t a t i c : If an array param eter has more than one dim en­
                                      sion, s t a t i c can be used only in the first dimension (forexam ple, when specify­
                                      ing the number of rows in a two-dimensional array).


                          <%£>        C o m p o u n d L ite r a ls

                                      Let’s return to the original s u m _ a r r a y function, one last time. When
                                      s u m _ a r r a y is called, the first argument is usually the name of an array (the one
                                      whose elements are to be summed). For example, we might call s u m _ a r r a y in
                                      the following way:

                                      int b [] = {3, 0, 3, 4, 1};
                                      total = sum_array(b, 5);
                                                                                           9.4    T h e r e tu r n S ta te m e n t hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                                           201 onmlkjihgfedcbaZYXWV


                                               The only problem with this arrangement is that b must be declared as a variable
                                               and then initialized prior to the call, I f b isn't needed for any other purpose, it can
                                               be mildly annoying to create it solely for the purpose of calling s u m _ a r r a y .
                                                      In C99, we can avoid this annoyance by using a c o m p o u n d literal: an
                                               unnamed array that’s created “on the fly” by simply specifying which elements it
                                               contains. The following call of su m _ a x ^ ra y has a compound literal (shown in dcbaZYXWVUTSRQP
                                               b o ld ) as its first argument:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                               total = sum_array((int []){3, 0, 3, 4 ,                  1}, 5);aZYXWVUTSRQPONMLKJIHGFEDCBA

                                               In this example, the compound literal creates an array containing the five integers
                                               3, 0, 3, 4, and I. We didn’t specify the length o fth e array, so it’s determined by the
                                               number of elements in the literal. We also have the option of specifying a length
                                               explicitly: ( i n t [4] ) { 1 , 9 , 2 , 1} isequivalentto ( i n t [] ) { 1 , 9 , 2 , 1}.
                                                    In general, a compound literal consists of a type name within parentheses, fol­
                                               lowed by a set of values enclosed by braces. A compound literal resembles a cast
                                               applied to an initializer. In fact, compound literals and initializers obey the same
                                               rules. A compound literal may contain designators, just like a designated initial­
                                       >d. 1
  d e s ig n a t e d in itia liz e r s BA      izer, and it may fail to provide full initialization (in which case any uninitialized
                                               elements default to zero). For example, the literal ( i n t [1 0 ] ) { 8 , 6} has 10
                                               elements: the first two have the values 8 and 6, and the remainin^s, elements have
                                               the value 0.
                                                    Compound literals created inside a function may contain arbitrary expres­
                                               sions, notjust constants. For example, we could write

                                               total = sum__array((int          []){2 * i, i + j, j * k}, 3);

                                               where i , j , and k are variables. This aspect ofcom pound literals greatly enhances
                                               their usefulness.
                        iv a iu e s > 4 .2           A compound literal is an lvalue, so the values of its elements can be changed,
                                               lfdesired, a compound literal can be made “read-only” by adding the word c o n s t
                                               to its ty p e ,a s in ( c o n s t i n t [ ] ) { 5 , 4}.




                                9 .4           T h e r e t u r n S ta te m e n t

                                               A n o n -v o id function must use the r e t u r n statement to specify what value it will
                                               return. The r e t u r n statement has the form


r e t u r n s t a te m e n t                                                  re tu rn   expression     ;


                                               The expression is often just a constant or variable:

                                               return 0;
                                               return status;
            C h a p te r 9    F u n c tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA
2 0 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                                   More complex expressions are possible. For example, it's not unusual to see the
         c o n d itio n a io p e r a to r > 5 .2   conditional operator used in a return expression:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                   return n >= 0 ? n : 0;

                                                   When this statement is executed, the expression n >= 0 ? n : 0 is evaluated first.
                                                   Thc statement returns the value o f n ifit's not negative; otherwise, it returns 0.
                                                        If the type of the expression in a r e t u r n statement doesn’t match the func­
                                                   tion's return type, the expression will be implicitly convened to the return type. For
                                                   example, if a function is declared to return an i n t , but the r e t u r n statement
                                                   contains a d o u b l e expression, the value o fth e expression is converted to i n t .
                                                        r e t u r n statements may appear in functions whose return type is v o i d , pro­
                                                   vided that no expression is given:
                                                   return;        /* return in a void function */

                                                  Putting an expression in such a r e t u r n statement will get you a compile-time
                                                  error. In thc following example, the r e t u r n statement causes the function to
                                     Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  return immediately when given a negative argument:
                                                   void print_int(int i)

                                                     if (i < 0)
                                                       return;
                                                     printf("%d", i);


                                                   If i is less than 0, p r i n t _ i n t will return without calling p r i n t f .
                                                        A r e t u r n statement may appear at the end of a v o i d function:
                                                   void print__pun(void)

                                                                C, or not to C: that is the question.\n");
                                                     printf(”To cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                     return;   /* OK, but not needed */


                                                   Using r e t u r n is unnecessary, though, since the function will return automatically
                                                   after its last statement has been executed.
                                                         If a n o n -v o id function reaches the end of its body— that is, it fails to execute
                                                   a r e t u r n statement— the behavior of the program is undefined if it attempts to
                                                   use the value returned by the function. Some compilers will issue a warning such
                                                   as “control reaches end o f non-void fun ctio n ” if they detect the possibility of a
                                                   n o n -v o id function “falling off” the end of its body.




                                     9 .5          P r o g r a m T e r m i n a t io n

                                                   Since m a in is a function, it must have a return type. Normally, the return type of
                                                   m a in is i n t . which is why the programs we’ve seen so far have defined m a in in
                                                   the following way:
                                                                                          9 .5   P r o g r a m T e rm in a tio n hgfedcbaZYXWVUTSRQPON
                                                                                                                                         2 0 3 kjihgfedcb


                                      int main(void)

                                         •••onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      Older C programs often omit m a i n ’s return type, taking advantage of the fact that
                                      it traditionally defaults to i n t :

                                      main()GFEDCBA




                                   Omitting the return type of a function isn’t legal in C99, so it’s best to avoid this
                          .C99.aZYXWVUTSRQPONMLKJIHGFEDCBA
                                      practice. Omitting the word v o i d in m a i n ’s parameter list remains legal, but— as
                                      a matter of style— it’s best to be explicit about the fact that m a in has no parame­
                                      ters. (W e’ll see later that m a in sometimes cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                        does have two parameters, usually
      a rg c a n d a rg v > f& 7      named a r g c and a r g v .)
                                           The value returned by m a in is a status code that— in some operating sys­
                          Q&A         tems— can be tested when the program terminates, m a in should return 0 if the
                                      program terminates normally; to indicate abnormal termination, m a in should
                                      return a value other than 0. (Actually, there’s no rule to prevent us from using the
                                      return value for other purposes.) It’s good practice to make sure that every C pro­
                                      gram returns a status code, even if there are no plans to use it, since someone run­
                                      ning the program later may decide to test it.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      T h e e x i t F u n c tio n
                                      Executing a r e t u r n statement in m a in is one way to terminate a program.
< s td iib .h > h e a d e r > 2 a 2   Another is calling^v* the e x i t function,f which belong^^s to < s t d l i b . h>. The ar^g**u-
                                      ment passed to e x i t has the same meaning as m a i n ’s return value: both indicate
                                      the program ’s status at termination. To indicate normal termination, w e’d pass 0:

                                      exit(0);                                  /* normal termination */

                                      Since 0 is a bit cryptic, C allows us to pass EXIT_SUCCESS instead (the effect is
                                      the same):

                                      exit(EXIT_SUCCESS);                       /* normal termination */

                                      Passing EX IT_FAILURE indicates abnormal termination:

                                      exit (EXIT__FAILURE) ;                    /* abnormal termination */

                                      EXIT_SUCCESS and EX IT_FAILURE are macros defined in < s t d l i b . h > .
                                      The values of EXIT_SUCCESS and EX IT_FA ILU R E are implementation-
                                      defined; typical values are 0 and 1, respectively.
                                           As methods of terminating a program, r e t u r n and e x i t are closely related.
                                      In fact, the statement

                                      return PONMLKJIHGFEDCBA
                                             expression;
            C h a p te r 9    F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
2 0 4 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                       in m a in is equivalent to

                                               (expression) ;
                                       e x i t cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      The difference between r e t u r n and e x i t is that e x i t causes program term ina­
                                      tion regardless of which function calls it. The r e t u r n statement causes program
                                      termination only when it appears in the m a in function. Some programmers use
                                      e x i t exclusively to make it easier to locate all exit points in a program.aZYXWVUTSRQPONMLKJIHG




                           9 .6        R e c u r s io n

                                      A function is recursive if it calls itself. For example, the following function com ­
                                      putes n\ recursively, using the formula //! = ii x (ii - 1)!:

                                       i n t f a c t ( i n t n)

                                           if   (n <= 1)
                                             r e t u r n 1;
                                          e ls e
                                             re tu rn n * fa c t(n                - 1 );


                                      Some programming languages rely heavily on recursion, while others don’t even
                                      allow it. C falls somewhere in the middle: it allows recursion, but most C program ­
                                      mers don't use it that often.
                                           To see how recursion works, let's trace the execution o fth e statement

                                       i = f a c t (3) ;

                                       Here’s what happens:
                                             f a c t (3) finds that 3 is not less than or equal to 1. so it calls
                                                 f a c t (2 ), which finds that 2 is not less than or equal to 1, so il calls
                                                     f a c t (1 ), which finds that 1 is less than orequal to 1, so it returns 1. causing
                                                 f a c t (2) to return 2 x 1 = 2. causing
                                             f a c t (3) to return 3 x 2 = 6.
                                      Notice how the unfinished calls of f a c t “pile up” until f a c t is finally passed 1.
                                      At that point, the old calls of f a c t begin to “unwind” one by one, until the origi­
                                      nal call— f a c t (3 ) — finalJy returns with the answer, 6.
                                           H ere’s another example of recursion: a function that computes AJ l , using the
                                      formula xJt = .v x .v"- 1 .

                                       i n t p o v /e r(in t x,         i n t n)

                                           if   (n == 0)
                                             r e t u r n 1;
                                          e ls e
                                             r e t u r n x * p o w e r(x , n - 1 ) ;
                                                                      9 .6    R e c u r s io n hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                       2 0 5 onmlkjihgfedcbaZYXW


The call p o w e r (5 z 3) would be executed as follows:
     p o w e r ( 5 , 3) finds that 3 is not equal to 0, so it calls
         p o w e r ( 5 , 2 ) , which finds that 2 is not equal to 0, so i( calls
             p o w e r ( 5 , 1 ) , which finds that 1 is not equal to 0. so il calls
                                                          is equal io 0, so it retum s 1. causing
                 p o w e r (5 z 0 ) , which finds that 0 cbaZYXWVUTSRQPONMLKJIHGFEDCBA
             p o w e r ( 5 , 1) to retum 5 x 1 = 5, causing
         p o w e r (5 z 2 ) to return 5 x 5 = 25. causing
     p o w e r (5 z 3) to return 5 x 25 = 125.
Incidentally, we can condense the p o w e r function a bit by putting a conditional
expression in the r e t u r n statement:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

int power(int x z int n)

   return n == 0 ? 1 : x * power(x, n - 1);


      Both f a c t and p o w e r arecareful to test a “term ination condition" as soon as
they’re called. When f a c t is called, it im m ediately checks w hether its param eter
is less than or equal lo 1. W hen p o w e r is called, it first checks w hether its second
param eter is equal to 0. All recursive functions need som e kind of term ination con­
dition in order to prevent infinite recursion.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


T h e Q u ic k s o r t A lg o r ith m

At this point, you may w onder why w e’re bothering with recursion: after all, nei­
ther f a c t nor p o w e r really needs it. Well, yo u ’ve got a point. Neither function
makes much of a case for recursion, because each calls itself just once. Recursion
is much more helpful for sophisticated algorithm s that require a function to call
itself two or more times.
      In practice, recursion often arises naturally as a result of an algorithm design
technique known as d ivid e-a n d -co n q u e r. in which a large problem is divided into
sm aller pieces that are then tackled by the same algorithm . A classic exam ple of
the divide-and-conquer strategy can be found in the popular sorting algorithm
known as Q u ickso rt. The Quicksort algorithm goes as follows (for simplicity,
w e’ll assum e that the array being sorted is indexed from 1 to /?):

     1. Choose an array element e (the “partitioning elem ent’’), then rearrange the
        array so that elem ents I. .... i - I are less than or equal to e, elem ent i con­
        tains e, and elem ents i + 1, ..., n are greater than or equal to e.
     2. Sort elem ents 1, .... i - 1 by using Q uicksort recursively.
     3. Sort elem ents i + 1, ..., n by using Quicksort recursively.

After step 1, the elem ent e is in its proper location. Since the elem ents to the left of
e are all less than or equal to it, they’ll be in their proper places once they’ve been
sorted in step 2; sim ilar reasoning applies to the elem ents to the right o fe .
     Step 1 of the Quicksort algorithm is obviously critical. T here are various
m ethods to partition an array, some much better than others. W e’ll use a technique
2 0 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 9    F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      that’s easy to understand but not particularly efficient. 1'11 first describe the parti­
                                      tioning aIgoriUim informally; later, we’ll translate it into C code.
                                            The algorithm relies on two “markers” named l o w and h ig h , which keep track
                                      of positions within the array. Initially, l o w points to the first element of the array
                                      and h ig h points to the last element. We start by copying the first element (the parti­
                                      tioning element) into a temporary location elsewhere, leaving a “hole” in the array.
                                      Next, we move h ig h across the array from right to left until it points to an element
                                      that’s smaller than the partitioning element. We then copy the element into the hole
                                      that l o w points to, which creates a new hole (pointed to by h ig h ) . We now move
                                      l o w from left to right, looking for an element that’s larger than the partitioning ele­
                                      ment. When we find one, we copy it into the hole that h i g h points to. The process
                                      repeats, with l o w and h i g h taking turns, until they meet somewhere in the middle
                                      of the array. At that time, both will point to a hole; all we need do is copy the parti­
                                      tioning element into the hole. The following diagrams illustrate how Quicksort
                                      would sort an array of integers:

                                      Let’s start with an array containing seven
                                      elements, cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 low points to the first element;         12      3      6     18     7    15          «1
                                      high points to the last one.
                                                                                          lo w                                     h ig h


                                      The first element, 12. is the partitioning                  3      6     18     7    15          10 J 12 dcbaZYX
                                      element. Copying it somewhere else leaves
                                      a hole at the beginning of the array.KJIHGFEDCBA     A                                           A

                                                                                           I                                            I
                                                                                          lo w                                      h ig h


                                      We now compare the element pointed to by
                                                                                          10      3      6     18     7    15                       I 12
                                      high with 12. Since 10 is smaller than 12.
                                      it's on the wrong side of the array, so we                                                       A


                                      move it to the hole and shift low to the                                                          I
                                                                                                 lo w                              h ig h
                                      rigoht,

                                      low points to the number 3. which is less                                                    _        J        1   2


                                                                                          10      3      6     18     7    15
                                      than 12 and therefore doesn’t need to be
                                      moved. Wc shift low to the right instead.                          A
                                                                                                         I
                                                                                                                                       A




                                                                                                        lo w                       h ig h


                                      Since 6 is also less than 12, we shift low                                                   _            ]    1   2



                                                                                          10      3      6     18     7    15
                                      again.
                                                                                                                                   ^^^■^
                                                                                                                                      ■ ^^^M
                                                                                                                A                        A
                                                                                                                                         I
                                                                                                                 I
                                                                                                               lo w                h ig h


                                      low now points to 18, which is larger than                                                       18 J 12
                                                                                          10      3      6            7    15
                                      12 and therefore out of position. After
                                      moving 18 lo the hole, we shift high to the                               A           A


                                      left.
                                                                                                               lo w       h ig h
                                                                             9 ,6                                  2 0 7 cbaZYXWVUTSRQPON
                                                                                         R e c u r s io n hgfedcbaZYXWVUTSRQPONMLKJIHGF


                  high onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         points to 15, which is greater than 12                                            1 B
                                                                                                                 I dcbaZYXWVUTSRQPONML
                                                                   10   3    6                7     15
                  and thus doesn’t need to be moved. We
                  shift high to the left and continue.                               A        A
                                                                                              I
                                                                                              I

                                                                                    low high
                                                                                                                 *
                  high points to 7, which is out o f position.
                                                                   10    3   6      7               15     18
                  After moving^* 7 to the hole, we shift lo w to
                  the right.
                                                                                         low, high


                  low and high are now equal, so we move
                  the partitioning elem ent to the hole.



                  At this point, we’ve accomplished our objective: all elements to the left of the par­
                  titioning element are less than or equal to 12. and all elements to the right are
                  greater than or equal to 12. Now that the array has been partitioned, we can use
                  Quicksort recursively to sort the first four elements of the array (10, 3. 6, and 7)
                  and the last two (15 and 18).


P R O G R A M BA Q u ic k s o r t

                  Let’s develop a recursive function named q u i c k s o r t that uses the Quicksort
                  algorithm to sort an array of integers. To test the function, we’Il have m a in read 10
                  numbers into an array, call q u i c k s o r t to sort the array, then print the elements
                  in the array:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  Enter 10 numbers to be sorted: 9 16 47 82 4 66 12 3 25 51
                  In sorted order: 3 4 9 12 16 25 47 51 66 82

                  Since the code for partitioning the array is a bit lengthy, I’ll put il in a separate
                  function named s p l i t .

      qsort.c     /* Sorts an array of integers u s i ng Qu ic k s o r t a l g o r i t h m */

                  #include < s t d i o .h>

                  #define N 10

                  void qui cksort(int a [] , int low, int high) ;
                  int split (int a [] , int low, int h i g h ) ;

                  int main(void)

                     int a [N] ,

                     p r i n t f ( " E n t e r %d numbers to be sorted:      ", N);
                     for (i = 0; i < N; i++)
                         s c a n f ("% d " , &a [i]);
2 0 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 9    F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            quicksort(a, 0, N - 1);

                                            printf("In sorted order: ");
                                            for (i = 0; i < N; i++)
                                              printf("%-d ", a[i]);
                                            printf("\n");

                                            return 0;


                                      void quicksort(int a[], int low, int high)

                                            int middle;

                                            if (low >= high) return;
                                            middle = split(a, low, high);
                                            quicksort(a, low, middle - 1);
                                            quicksort(a, middle + 1, high);


                                      int split(int a[], int low, int high)

                                            int part_element = a[low];

                                            for (;;) {
                                              while (low < high && part_element <= a[high])
                                                high--;
                                              if (low >= high) break;
                                              a[low++] = a[high];

                                               while (low < high && a[low] <= part_element)
                                                 low++;
                                               if (low >= high) break;
                                               a[high--] = a[low];


                                            a[high] = part_element;
                                            return high;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          Although this version of Quicksort works, it’s not the best. There are num er­
                                      ous ways to improve the program ’s performance, including:RQPONMLKJIHGFEDCBA
                                        ■                                                 Our method isn‘1 the most efficient.
                                              I m p r o v in g th e p a r titio n in g a lg o r ith m .
                                              Instead of choosing the first element in the array as the partitioning element,
                                              it’s better to take the median of the first element, the middle element, and the
                                              last element. The partitioning process itselfcan also be sped up. In particular,
                                              it’s possible to avoid the lo w < h i g h tests in the two w h i l e loops.
                                                                                                 Instead of using Quicksort
                                        ■ U s in g a d if f e r e n t m e th o d to s o r t s m a l l a r r a y s .
                                              recursively all the way down to arrays with one element, it’s better to use a
                                              sim pler method for small arrays (those with fewer than, say, 25 elements).
                                                                                                                                      A         209cbaZYXWVUTSRQPONM
                                                                                                                                 Q &PONMLKJIHGFEDCBA

                                  ■ M a kin g Q uicksort nonreciirsive. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                          Although Quicksort is a recursive algorithm
                                    by nature— and is easiest to understand in recursive form— it’s actually more
                                    efficient if the recursion is removed.
                                For details about improving Quicksort, consul( a book on algorithm design, such as
                                Roberi Sedgewick’s A lg orithm s in C, Parts /^ 4 : Fundam entals. D ata Structures.
                                Sorting, Searching, Third Edition (Boston. Mass.: Addison-Wesley, 1998).aZYXWVUTSRQPONMLKJIHGFEDC




                                Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                         Q:     S o m e C b o o k s a p p e a r to u s e te r m s o th e r th a n p a ra m e te r a n d a rg u m e n t. Is
                                th e r e a n y s ta n d a r d te r m in o lo g y 1? [p . 1 8 4 ]
                         A:     As with many other aspects o f C. there’s no general agreem ent on terminology,
                                although the C89 and C99 standards use param eter and argum ent. The following
                                table should help you translate:

                                      This book:            O ther books:
                                      parameter             formal argument, formal parameter
                                      argument              actual argument, actual parameter

                                Keep in mind that— when no confusion would result— I sometimes deliberately
                                blur the distinction between the two terms, using argum ent to mean either.

                         Q:     I ’v e s e e n p r o g r a m s in w h ic h p a r a m e te r ty p e s a r e s p e c ifie d in s e p a r a t e d e c la ­
                                r a t io n s a ft e r th e p a r a m e te r lis t, a s in th e fo llo w in g e x a m p le :

                                double average(a, b)
                                double a, b;

                                    return (a + b) / 2;


                                Is th is p r a c t ic e le g a l? [p . 1 8 8 ]
                         A:                           This method ofdefining functions comes from K&R C, so you may encounter it in
                                                      older books and programs. C89 and C99 support this style so that older programs
                                                      will still compile. Fd avoid using it in new programs, however, for a couple o frea-
                                                      sons.
                                                           First, functions that are defined in the older way aren’t subject to the same
                                                      degree of error-checking. When a function is defined in the older way— and no
                                                      prototype is present— the compiler won’t check that the function is called with the
                                                      right number of arguments, nor will it check that the arguments have the proper hgfedcbaZYXWVUTSR
                                                      types. Instead, it will perform the default argument promotions.
d e fa u lt a r g u m e n t p r o m o tio n s ZYXWVUTSRQPONMLKJIHGFEDCBA
                                              > 9 .3

                                                           Second, the C standard says that the older style is “obsolescent,” meaning that
                                                      its use is discouraged and that it may be dropped from C eventually.
210 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 9     F u n c tio n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               Q:      S o m e p r o g r a m m in g ia n g u a g e s a llo w p r o c e d u r e s a n d f u n c t io n s to b e n e s te d
                                                       w ith in e a c h o th e r . D o e s C a llo w fu n c tio n d e fi n i tio n s t o b e n e s te d ? onmlkjihgfedcbaZYXWVUTSRQPONMLK
                                               A:      No. C does not permit the definition of one function to appear in the body of
                                                       another. Among other things, this restriction simplifies the compiler.

                                          *Q :         W h y d o e s th e c o m p ile r a llo w th e u s e o f fu n c tio n n a m e s th a t a r e n ’t fo llo w e d b y
                                                       p a r e n th e s e s ? [p . 1 8 9 ]
                                               A:      We’ll see in a later chapter that the com piler treats a function name not followed byhgfedcbaZYX
       p o in te r s io ( u n c tio n s > /z . 7                           o in ter to the function. Pointers to functions have legitimate uses,
                                                       parentheses as a pcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                       so the com piler can’t automatically assume that a function name without parenthe­
                                                       ses is an error. The statement

                                                       print_pun;

                                                       is legal because the com piler treats p r i n t _ p u n as a pointer and therefore an
      e x p r e s s io n s t a t e m e n t s > 4 . 5   expression. making this a valid (although pointless) expression statement.

                                          !h
                                               Q:      l n th e fu n c tio n c a ll f ( a ,          b ) , h o w d o e s th e c o m p ile r k n o w w h e th e r th e
                                                       c o m m a is p u n c tu a tio n o r w h e t h e r i t ’s a n o p e r a t o r ?
                                               A:      It turns out that the arguments in a function call can’t be arbitrary expressions.
                                                       Instead, they must be “assignment expressions,” which can ’t contain com m as used
                                                       as operators unless they’re enclosed in parentheses. In other words, in the call
                                                       f ( a , b ) the comma is punctuation; in the call f ( ( a , b ) ) it’s an operator.

                                             Q:        D o th e n a m e s o f p a r a m e t e r s in a fu n c tio n p r o t o t y p e h a v e to m a tc h th e n a m e s
                                                       g iv e n la te r in th e f u n c t io n ’s d e fin itio n ? [p . 1 9 2 ]
                                               A:      No. Some programmers take advantage o f this fact by giving long names to param ­
                                                       eters in the prototype, then using shorter names in the actual definition. Or a
                                                       French-speaking program m er might use English names in prototypes, then switch
                                                       lo more familiar French names in function definitions.

                                             Q:        I s till d o n ’t u n d e r s ta n d w h y w e b o th e r w ith fu n c tio n p r o to ty p e s . I f w e j u s t p u t
                                                       d e fin i tio n s o f a ll th e fu n c tio n s b c f o r e m a i n ,7 w e ’r e c o v e r e d ,?r i o
                                                                                                                                                          g h t?
                                               A:      Wrong. First, you’re assuming that only m a in calls the other functions, which is
                                                       unrealistic. In practice, some of the functions will call each other. If we put all
                                                       function definitions above m a in , w e’ll have to watch their order carefully. Calling
                                                       a function that hasn’t been defined yet can lead to big problems.
                                                            But that’s not all. Suppose that two functions call each other (which isn’t as
                                                       far-fetched as it may sound). No matter which function we define first, it will end
                                                       up calling a function (hat hasn’t been defined yet.
                                                            But there\s still more! Once programs reach a certain size, it w on’t be feasible
                                                       to put aII the functions in one file anymore. When we reach that point, w e’lI need
                                                       prototypes to tell the compiler about functions in other files.

                                             Q:        I ’v e s e e n fu n c tio n d e c la r a tio n s th a t o m it a ll in f o n n a t io n a b o u t p a r a m e te r s :
                                                                                                      Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                                     211 kjihgfedcbaZYXWVUTSR


     double average();dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

     Is th is p r a c tic e leg a l? [p. 192] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
A:   Yes. This declaration informs the compiler that a v e r a g e returns a d o u b l e value
     but provides no information about the number and types of its parameters. (Leav­
     ing the parentheses empty doesn’t necessarily mean that a v e r a g e has no param­
     eters.)
          In K&R C, this form of function declaration is the only one allowed: the form
     that we’ve been using— the function prototype, in which parameter information cbaZYXWVUTSRQPONMLKJIH
                                                                                             is
     included— was introduced in C89. The older kind of function declaration is now
     obsolescent, although still allowed.

Q:   W h y w o u ld a p r o g r a m m e r d e lib e r a te ly o m it p a r a m e te r n a m e s in a fu n c tio n
     p r o to ty p e ? I s n ’t it e a s ie r t o j u s t le a v e th e n a m e s? [p. 1 9 3 ]
A:   Omitting parameter names in prototypes is typically done for defensive purposes,
     lf a macro happens to have the same name as a parameter, the parameter name will
     be replaced during preprocessing, thereby damaging the prototype in which it
     appears. This isn't likely to be a problem in a small program written by one person
     but can occur in large applications written by many people.

Q:   Is it leg a l to p u t a fu n c tio n d e c la r a tio n in s id e th e b o d y o f a n o th e r fu n c tio n ?
A:   Yes. Here’s an example:
     int main(void)

        double average(double a ( double b);
        •••


     This declaration of a v e r a g e is valid only for the body of m a in : if other func­
     tions need to call a v e r a g e , they’ll each have to declare it.
           The advantage of this practice is that it’s clearer to the reader which functions
     call which other functions, (ln this example, we see that m a in will be calling
     a v e r a g e .) On the other hand, it can be a nuisance if several functions need to call
     the same function. Even worse, trying to add and remove declarations during pro­
     gram maintenance can be a real pain. For these reasons, 1'11 always put function
     declarations outside function bodies.

Q:   I f s e v e r a l fu n c tio n s h a v e th e sa m e r e tu r n ty p e , c a n th e ir d e c la r a tio n s b e c o m ­
     b in e d ? F o r e x a m p le , s in c e b o th p r i n t _ p u n a n d p r i n t           c o u n t have v o i d
     a s th e ir r e tu r n ty p e , is th e fo llo w in g d e c la r a tio n le g a l?

     void print_pun(void), print_count(int n ) ;

A:   Yes. In fact, C even allows us to combine function declarations with variable decla­
     rations:

     double x, y, average(double a, double b);
2 1 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 9     F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       Combining declarations in this way usually isn't a good idea, though; it can easily
                                       cause confusion.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Q:       W lia t h a p p e n s i f I s p e c ify a le n g th fo r a o n e - d im e n s io n a l a r r a y p a r a m e te r ?
                                       Ip. 1 9 5 ]
                               A:      The compiler ignores it. Consider the following example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       double inner__product(double v[3],                               double w[3]);

                                       Other than documenting that i n n e r _ p r o d u c t ’s arguments are supposed to be
                                       arrays of length 3. specifying a length doesn’t buy us much. The com piler w on’t
                                       check that the arguments actually have length 3. so there’s no added security. In
                                       fact; the practice is misleading in that it suggests that i n n e r _ p r o d u c t can only
                                       be passed arrays oflength 3. when in fact we can pass arrays ofarbitrary length.

                             *Q :      W h y c a n th e fir st d im e n s io n in a n a r r a y p a r a m e te r b e le ft u n s p e c if ie d , b u t n o t
                                       th e o t h e r d im e n s io n s ? [p . 1 9 7 ]
                               A:      First; we need to discuss how arrays are passed in C. As Section 12.3 explains,
                                                                                                         o in ter to the first ele­
                                       when an array is passed to a function, the function is given a pcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       ment in the array.
                                            Next, we need to know how the subscripting operator works. Suppose that a is
                                       a one-dimensional array passed to a function. When we write

                                       a[i]      = 0;

                                       the compiler generates instructions that compute the address of a [ i ] by multiply­
                                       ing i by the size of an array element and adding the result to the address that a rep­
                                       resents (the pointer passed to the function). This calculation doesn't depend on thc
                                       length o f a , which explains why we can omit it when defining the function.
                                            What about multidimensional arrays? Recall that C stores arrays in row-major
                                       order, with the elements in row 0 stored first, then the elements in row 1, and so
                                       forth. Suppose that a is a two-dimensional array param eter and we write

                                       a [i] [j ] = 0 ;

                                      The compiler generates instructions to do the following: (1) multiply i by the size
                                      of a single row o f a ; (2) add this result to the address that a represents; (3) multiply
                                      j by the size of an array element; and (4) add this result to the address computed in
                                      step 2. To generate these instructions, the compiler must know the size of a row in
                                      the array, which is determined by the number ofcoItim ns. The bottom line: the pro­
                                      grammer must declare the number ofcolum ns in a.

                              Q:       W h y d o s o m e p r o g r a m m e r s p u t p a r e n th e s e s a r o u n d th e e x p r e s s io n in a
                                       r e t u r n s ta te m e n t?
                               A:     The examples in the first edition of Kernighan and Ritchie's The C Program m ing
                                      Language always have parentheses in r e t u r n statements, even though they
                                      aren’t required. Programmers (and authors of subsequent books) picked up the
                                      habit from K&R. 1 don’t use these parentheses, since they’re unnecessary and
                                                                                                                 2 1 3 onmlkjihgfedcbaZYXWV
                                                                                                  Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFE


contribute nothing to readability. (Kernighan and Ritchie apparently agree: the
r e t u r n statements in the second edition of RQPONMLKJIHGFEDCBA
                                                T h e C P r o g r a m m i n g L a n g u a g e lack
parentheses.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

W h a t h a p p e n s i f a n o n - v o i d fu n c ti o n a t t e m p ts to e x e c u t e a r e t u r n s t a t e ­
m e n t th a t h a s n o e x p r e s s io n ? [p . 2 0 2 ]
That depends on the version o fC . ln C89, executing a r e t u r n statem ent w ithout
an expression in a n o n - v o id function causes undefined behavior (but only if the
program attempts to use the value returned by the function). In C99. such a state­
ment is illegal and should be detected as an error by the compiler.

H o w c a n I te s t m a i n ’s r e tu r n v a l u e to s e e i f a p r o g r a m h a s te r m in a t e d n o r ­
m a lly ? Lp. 2 0 3 ]
That depends on your operating system . Many operating system s allow this value
to be tested within a “batch file" or “shell script" that contains com m ands to run
several programs. For example, the line kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

if errorlevel 1 PONMLKJIHGFEDCBA
                command

in a Windows batch file will execute c o m m a n d if the last program term inated with
a status code greater than or equal to 1.
     In UNIX, each shell has its own method for testing the status code. In the
Bourne shell, the variable $ ? contains the status of the last program run. The C
shell has a sim ilar variable, but its name is $ s t a t u s .

W h y d o e s m y c o m p ile r p r o d u c e a “ c o n t r o l r e a c h e s e n d o f n o n - v o i d f u n c t i o n ”
w a r n in g w h e n it c o m p ile s m a i n ?
The com piler has noticed that m a in , despite having i n t as its return type, doesn’t
have a r e t u r n statement. Putting the statement

return 0;

at the end o f m a i n will keep the com piler happy. Incidentally, this is good practice
even if your com piler doesn’t object to the lack of a r e t u r n statement.
     When a program is com piled using a C99 compiler, this warning shouldn’t
occur. In C99, it's OK to “fall o f f ' the end of m a in without returnin ^g» a value: the
standard states that m a i n autom atically returns 0 in this situation.

W ith r e g a r d to th e p r e v io u s q u e s t io n : W h y n o t j u s t d e fi n e m a i n ’s r e tu r n ty p e
to b e v o i d ?
Although this practice is fairly com m on, it’s illegal according to the C89 standard.
Even if it w eren’t illegal, it w ouldn't be a good idea, since it presumes that no one
will ever lest the program ’s status upon term ination.
     C99 opens the door to legalizing this practice, by allowing m a i n to be
declared “in some other im plem entation-defined m anner’' (with a return type other
than i n t or parameters other than those specified by the standard). However, any
such usage isn’t portable, so it's best to declare m a in 's return type to be i n t .
21 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r9    F u n c tio n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                           Q:     I s it le g a l fo r a fu n c t io n f l to c a ll a fu n c t io n f 2 , w h ic h th e n c a lls f l ?
                            A:    Yes. This is just an indirect form of recursion in which one call of f l leads to
                                  another. (But make sure that either f l or f 2 eventually terminates!)aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   E x e r c is e s

S e c t i o n 9.1            I.   The following function, which computes the area o f a triangle, contains (wo errors. Locale
                                                                       (Hint: There are no errors in the formula.)
                                  the errors and show how to fix ihem. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   d o u b le tria n g le _ _ _ a re a (d o u b le b a s e ,       h e ig h t)
                                   d o u b le p r o d u c t;
                                   {
                                      p ro d u c t = b ase * h e ig h t;
                                       r e tu r n p ro d u c t / 2;


                       ©     2.    Write a function c h e c k ( x , y , n ) that returns l if both x and y fall between 0 and n - 1,
                                   inclusive. The function should retum 0 otherwise. Assume that x, y, and n are all of type
                                   in t.

                             3.   W rite a function g c d (m, n ) that calculates the greatest common divisor of the integers m
                                  and n. (Programming Project 2 in Chapter 6 describes Euclid’s algorithm for computing the
                                  GCD.)

                       ©    4.    W rite a function d a y _ o f _ _ y e a r ( m o n th , d a y , y e a r ) that returns the day of the year
                                  (an integer between 1 and 366) specified by lhe three arguments.

                            5.    Write a function n u m _ d i g i t s (n ) that returns the num ber o f digits in n (a positive inte­
                                  ger). H int: To determ ine the number of digits in a number /z. divide it by 10 repeatedly.
                                  When n reaches 0. the number ofdivisions indicates how many digits n originally had.

                       ©    6.    Write a function d i g i t ( n , k ) that returns the k z// digit (from the right) in n (a posi­
                                  tive integer). For example, d i g i t ( 8 2 9 , 1) retums 9. d i g i t ( 8 2 9 , 2) returns 2. and
                                  d i g i t ( 8 2 9 , 3) retums 8. If k is greater than the number o fd ig its in n. have the func­
                                  tion return 0.

                            7.    Suppose that the function f has the following definition:
                                   in t    f(in t    a,    i n t b)     { ... }
                                  Which of the following statements are legal? (Assume that i has type i n t and x has type
                                  d o u b le .)
                                   (a)    i = f ( 8 3 , 12) ;
                                   (b)    x = f ( 8 3 , 12) ;
                                   (c)    i = f ( 3 . 1 5 , 9 .2 8 ) ;
                                   (d)    x = f ( 3 .1 5 , 9 .2 8 ) ;
                                   (e)    f (8 3 , 12) ;

S e c t i o n 9 .2     ©    8.    Which of the following would be valid prototypes for a function that returns nothing and has
                                  one d o u b l e parameter?
                                   (a) v o i d   f (d o u b le x) ;
                                                                                                                                                215onmlkjihgfedcbaZYXW
                                                                                                                         E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJI


                              (b) v o i d f ( d o u b l e ) ;
                              (c) v o i d f (x ) ;
                              (d) f ( d o u b l e x ) ;aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c t io n 9 .3       *9.   What will be the output of the following program?
                              # in c lu d e     < s td io .h >
                              v o id    s w a p (in t a ,       in t b );

                              i n t m a in (v o id )
                              {
                                  i n t i = 1, j            = 2;

                                 sw a p (i , j );
                                 p r i n t f ( " i = %d,          j    = % d \n " ,    i z j);
                                 r e tu r n 0;


                              v o id    s w a p (in t a ,       in t    b)

                                 i n t te m p = a ;
                                 a = b;
                                 b = te m p ;


                    ©   10.   Write functions that retum the following values. (Assume that a and n are parameters,
                              where a is an array of i n t values and n is the length of the array.)
                              (a) The largest element in a.
                              (b) The average of all elements in a.
                              (c) The number of positive elements in a .

                        11.   Write the following function:
                              flo a t      c o m p u te _ _ G P A (c h a r g r a d e s [ ] , i n t n ) ;
                              The g r a d e s array will contain letter grades (A, B, C. D, or F. either upper-case or lower­
                              case); n is the length of the array. The function should return the average of the grades
                              (assume that A = 4, B = 3, C = 2, D = 1, and F = 0).

                        12.   Write thc following function:
                              d o u b le    in n e r_ p ro d u c t(d o u b le         a [],    d o u b le b [ ] ,     in t n );
                              T h e fu n c tio n s h o u ld rc tu rn a [0 ] * b [ 0 ] 4 ^ a [ l ] * b [ l ] + . . . + a [ n - l ] * b [ n - l ] .

                        13.   Write the following function, which evaluates a chcss position:
                              in t     e v a l u a t e _ j p o s i t i o n ( c h a r b o a r d [ 8 ] [8] ) ;
                              b o a r d represents a configuration of pieces on a chessboard, where the letters K, Q, R, B, N,
                              P represent White pieces, and the letters k, q. r , b, n, and p represent Black pieces,
                              e v a l u a t e _ p o s i t i o n should sum the values of the White pieces (Q = 9. R = 5, B = 3,
                              N = 3. P = 1). It should also sum the values of the Black pieces (done in a sim ilar way). The
                              function will return the difference between the two numbers. This value will be positive if
                              W hite has an advantage in material and negative if Black has an advantage.

S e c t io n 9 .4       14.   Thc following function is supposed to return t r u e if any element of the array a has the
                              value 0 and f a l s e ifall elements are nonzero. Sadly, it contains an error. Find lhc error and
                              show how to fix it:
2 1 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r9     F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      b o o l h a s _ _ z e ro (in t a [ ] ,       i n t n)

                                          in t    i ;

                                          f o r ( i = 0; i < n ;               i+ + )
                                              i f ( a [ i ] == 0)
                                                 re tu rn tr u e ;
                                              e ls e
                                                 r e t u r n f a ls e ,-


                         ©    15.     The following (rather confusing) function finds the median of three numbers. Rewrite the
                                      function so that it hasjust one r e t u r n statement.
                                      d o u b le m e d ia n (d o u b le       x,    d o u b le y ,   d o u b le   z)

                                          if     (x <= y )
                                              i f (y <= z) r e t u r n y ;
                                              e l s e i f (x <= z ) r e t u r n           z;
                                              e ls e re tu rn x;
                                          i f (z <= y ) r e t u r n y ;
                                          i f (x <= z ) r e t u r n x ;
                                          r e t u r n z ;aZYXWVUTSRQPONMLKJIHGFEDCBA



S e c t io n 9 .6             16.     Condense the f a c t function in the samc way we condensed p o w e r.

                         ©    17.     Rewrite the f a c t function so that it’s no longer recursive.

                              18.     Write a recursive version of the g c d function (see Exercise 3). Here’s the strategy to use for
                                      computing g c d ( m , n ) : I f n is 0, return m. Otherwise, call g c d recursively, passing n as
                                      the first argument and m % n as the second.

                         © *19.       Consider the following “m ystery’* function:
                                      v o id p b ( i n t n)

                                          if     (n 1= 0) {
                                               p b (n / 2 ) ;
                                               p u tc h a r(* 0 ' + n % 2 );
                                          }

                                      Trace the execution of the function by hand. Then write a program that calls the function,
                                      passing it a number entered by the user. What does the function do?




                                      P r o g r a m m in g P r o je c t s

                                      Write a program that asks the user to enter a series of integers (which it stores in an array),
                                      then sorts the integers by calling the function s e l e c t i o n _ s o r t . W hen given an array
                                      with n elements, s e l e c t i o n - s o r t must do the followine*~:
                                      1. Search the array to find the largestelem enl. then move it to the last position in the array.
                                      2. Call itself recursively to sort the first n - 1 elements o fth e array.
                                                                                                                  217onmlkjihgfedcbaZYXWV
                                                                           P ro g ra m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLKJIHG

2.   M odify Programming Project 5 from C hapter 5 so that it uses a function to com pute the
     amount of income tax. When passed an am ount of taxable income* the function will return
     the tax due.

3.   Modify Programming Project 9 from C hapter 8 so that it includes the following functions:
     v o id g e n e r a te _ r a n d o m _ w a lk ( c h a r w a lk [1 0 ] [ 1 0 ] ) ;
     v o id p r i n t _ a r r a y ( c h a r w a lk [1 0 ] [1 0 ]) ;
     m a in first calls g e n e r a t e _ r a n d o m _ w a l k . which initializes the array to contain ’ . ’
     characters and then replaces som e of these characters by the letters A through Z. as
     described in the original project, m a in then calls p r i n t _ a r r a y to display the array on
     the screen.

4.   M odify Programming Project 16 from C hapter 8 so that it includes the following functions:
     v o i d r e a d _ _ w o r d ( i n t c o u n t s [2 6 ] ) ;
     b o o l e q u a l _ a r r a y ( i n t c o u n t s l [2 6 ] ,   in t     c o u n ts 2 [2 6 ]) ;
     m a in will call r e a d _ w o r d twice, once for each o flh e two words entered by the user. As it
     reads a word, r e a d _ w o r d will use the letters in the word to update the c o u n t s array, as
     described in the original project, ( m a in will declare two arrays, one for each word. These
     arrays are used to track how many times each letter occurs in the words.) m a i n will then
     call e q u a l _ a r r a y , passing it the two arrays, e q u a l _ a r r a y will return t r u e if the ele­
     ments in the two arrays are identical (indicating that the words arc anagrams) and f a l s e
     otherwise.

5.   M odify Programming Project 17 from C hapier 8 so that it includes the following functions:
     v o id c re a te _ _ m a g ic _ s q u a re (in t n , c h a r m a g ic _ s q u a r e [ n ] [ n ] ) ;
     v o id p r in t_ m a g ic _ s q u a r e ( in t n , c h a r m a g ic _ s q u a r e [ n ] [ n ] ) ;
                                           n from the user, m a i n will call c r e a t e _ m a g i c _ s q u a r e .
     After obtaining thc number cbaZYXWVUTSRQPONMLKJIHGFEDCBA
     passing it an n x n array that is declared inside m a in , c r e a t e _ m a g i c _ s q u a r e will fill
     the array with the numbers 1, 2. .... i r as described in the original project, m a i n will then
     call p r i n t _ m a g i c _ s q u a r e . which will display the array in the format described in the
     original project. Note: If your com piler doesn't support variable-length arrays, declare the
     array in m a in to bc 99 x 99 instead of ti x n and use the following prototypes instead:
     v o i d c r e a t e _ m a g i c _ s q u a r e ( i n t n , c h a r m a g i c _ s q u a r e [ 9 9] [ 9 9 ] ) ;
     v o id p r in t_ m a g ic _ s q u a r e ( in t n z c h a r m a g ic _ s q u a re [9 9 ] [ 9 9 ] ) ;

6.   W rite a function that computes the value olThc following polynomial:
     3.v5 4- 2.f’ - 5.v3 - x 2 4- 7 x - 6
     Write a program that asks the user to enter a value for.r. calls the function to com pute the
     value of the polynomial, and then displays the value returned by the function.

7.   Thc p o w e r function of Section 9.6 can be madc faster by having it calculate x" in a differ­
     ent way. We first notice that if n is a power of 2, then xJI can be computed by squaring. For
                  i                  T      1                        •                    •  •  •    •
     examplc. r is the square o f . r , so r can be computed using only two multiplications instead
     of three. As it happens, this technique can be used even when n is not a power of 2. If n is
     even, we use thc formula x" = (.\J ,/2 )2 . If n is odd, then xJ! = .v x .r"~*. Write a recursive func­
     tion that computes .v". (The recursion ends when n = 0. in which case the function returns 1.)
     To test your function, write a program that asks the user to enter values for x and //, calls
     p o w e r to compute x “, and then displays the value returned by the function.

8.   W rite a program that simulates the game of craps, which is played with two dice. On thc
     first rolL lhc player wins if the sum o fth e dice is 7 or 11. The player loses ifth e sum is 2. 3.
2 1 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 9     F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       or l2. Any other roll is called the “point” and the game continues. On each subsequent roll,
                                       the player wins ifh e or she rolls the point again. The pIaycr loses by rolling 7. Any other roll
                                       is ignored and the game continues. At the end ofeach game, the program will ask the user
                                       whether or not to play again. When the user enters a response other than y or Y. the program
                                       will display the number o fw ins and losses and then terminate.
                                       You r o l l e d : 8
                                       Y our p o in t i s 8
                                       Y ou r o l l e d : 3
                                       You r o l l e d : 10
                                       You r o l l e d : 8
                                       You w in !

                                       P la y a g a in ? y
                                       Y ou r o l l e d : 6
                                       Y our p o in t i s 6
                                       You r o l l e d : 5
                                       You r o l l e d : 12
                                       You r o l l e d ; 3
                                       You r o l l e d : 7
                                       Y ou l o s e !
                                       P la y a g a in ?      y
                                       You r o l l e d : 11
                                       You w in ! kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       Play again? n
                                      W in s :    2     L osses:        1
                                       Write your program as three functions: m a in , r o l l _ d i c e . and p la y _ g a m e . Here are
                                       the prototypes for the latter two functions:
                                      in t r o ll_ d ic e (v o id );
                                      b o o l p la y _ g a m e ( v o i d ) ;
                                      r o l l _ d i c e should generate two random numbers, each between 1 and 6, and return their
                                      sum. p l a y _ g a m e should play one craps game (calling r o l l _ d i c e to determine the out­
                                      come ofeach dice roll); it will return t r u e ifth e p la y e rw in sa n d f a l s e ifth e player loses,
                                      p l a y _ g a m e is also responsible for displaying messages showing the results o fth e player’s
                                      dice rolls, m a in will call p l a y _ g a m e repeatedly, keeping track of the number of wins and
                                                                                                              H int: Use the r a n d function
                                      losses and displaying the “you win” and “you lose” messages. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      to generate random numbers. See the d e a l . c program in Section 8.2 for an example of
                                      how to call r a n d and the related s r a n d function.
1 0       P r o g r a m O r g a n iz a t io n                                           ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                A s W ill R o g e rs w o u ld h a v e s a id , “ T h e re
                                                                      is n o s u c h th in g a s a fre e v a r ia b le " onmlkjihgfedcbaZYXW




          Having covered functions in C hapter 9, w e’re ready to confront several issues that
          arise when a program contains more than one function. The chapter begins with a
          discussion o f th e differences between local variables (Section 10.1) and external
          variables (Section 10.2). Section 10.3 then considers blocks (com pound statements
          containing declarations). Section 10.4 tackles the scope rules that apply to local
          names, external names, and names declared in blocks. Finally, Section 10.5 sug­
          gests a way to organize function prototypes, function definitions, variable declara­
          tions, and the other parts of a C program .




 1 0 .1   L o c a lV a r ia b le s

          A variable declared in the body of a function is said to be RQPONMLKJIHGFEDCBA
                                                                            l o c a l to the function. In
          the following function, sum is a local variable:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

          int sum_digits(int n)

             int sum = 0;           /* local variable */

             while (n > 0) {
               sum += n % 10;
               n /= 10 ;


             return sum;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                                  219
2 2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r1 0     P r o g r a m O r g a n iz a tio n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               By default, local variables have the following properties:RQPONMLKJIHGFEDCBA

                                         ■ A                                                                          (or e x t e n t } of a variable is
                                                u t o m a t i c s t o r a g e d u r a t i o n . The s t o r a g e d u r a t i o n
                                               the portion of program execution during which storage for the variable exists.
                                               Storage for a local variable is ''automatically" allocated when the enclosing
                                               function is called and deallocated when the function returns, so the variable is
                                               said to have a u t o m a t i c s t o r a g e d u r a t i o n . A local variable doesn’t retain its
                                               value when its enclosing function returns. When the function is called again,
                                               there's no guarantee that the variable will still have its old value.
                                         ■ B lo c k sco p e .   The s c o p e of a variable is the portion of the program text in
                                               which the variable can be referenced. A local variable has b l o c k s c o p e : it is
                                               visible from its point of declaration to the end of the enclosing function
                                               body. Since the scope o f a local variable doesn't extend beyond the function
                                               to which it belongs, other functions can use the same name for other pur­
                                               poses.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      Section l8.2 covers these and other related concepts in more detail.
                                          Since C99 doesn’t require variable declarations to come at the beginning of a
                                      function, it’s possible for a local variable to have a very small scope. In the follow­
                                      ing example, the scope of i doesn’t begin until the line on which it’s declared,
                                      which could be near the end of the function body:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      void f (void)


                                          int i ;—
                                                             — scope of i




                                      S ta ti c L o c a l V a r ia b le s

                                      Putting the word s t a t i c in the declaration of a local variable causes it to have
                                      s t a t i c s t o r a g e d u r a t i o n instead of automatic storage duration. A variable with
                                      static storage duration has a permanent storage location, so it retains its value
                                      througGhout the execution of the program. Consider the following function:
                                                                                          I     u>                                  ^ 1



                                      void f (void)

                                          static int i;                       /* static local variable */



                                      Since the local variable i has been declared s t a t i c . it occupies the same mem­
                                      ory location throughout the execution of the program. When f returns, i w on't
                           Q&A        lose its value.
                                           A static local variable still has block scope, so it’s not visible to other func­
                                      tions. In a nutshell, a static variable is a place to hide data from other functions but
                                      retain it for future calls o fth e same function.
                                                                         1 0 .2                                        221 dcbaZYXWVUTSRQPON
                                                                                  E x te rn a l V a ria b le s hgfedcbaZYXWVUTSRQPONMLKJIHGF


         P a r a m e t e r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         Parameters have the same properties— automatic storage duration and block
         scope— as local variables. In fact, the only real difference between parameters and
         local variables is that each parameter is initialized automatically when a function is
         called (by being assigned the value o fth e corresponding argument).aZYXWVUTSRQPONMLKJIHGFEDCBA




1 0 .2   E x te r n a lV a r ia b le s

         Passing arguments is one way to transmit information to a function. Functions can
                                      extern a l variables— variables that are declared outside
         also communicate throuu£Th cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         the body ofany function.
              The properties ofexternal variables (o rg lo b a l variables, as they’re sometimes
         called) are different from those of local variables:

           ■ Static storage duration. External variables have static storage duration, just
             like local variables that have been declared s t a t i c . A value stored in an
             external variable will stay there indefinitely.
           ■ File scope. An external variable \vasfile scope: il is visible from its point of
             declaration to the end of the enclosing file. As a result, an external variable
             can be accessed (and potentially modified) by all functions that follow its dec­
             laration.


         E x a m p le : U s in g E x te r n a l V a r ia b le s to I m p le m e n t a S ta c k

         To illusiraie how external variables mi2«_»h1 be used, let's look at a data structure
         known as a stack. (Slacks are an abstract concept, not a C feature; they can be
         implemented in most programming languages.) A stack, like an array, can store
         multiple data items of the same type. However, the operations on a stack are lim­
         ited: we can either/;//.?// an item onto the stack (add it to one end— the “stack top”)
         o vp o p it from the stack (remove il from the same end). Examining or modifying an
         item that’s not at the top o fth e stack is forbidden.
               One way to implement a stack in C is to store its items in an array, which w e’ll
         call c o n t e n t s . A separate integer variable named t o p marks the position of the
         stack top. When lhe stack is empty, t o p has the value 0. To push an item on the
         stack, we simply store the item in c o n t e n t s al the position indicated by t o p .
         then increment t o p . Popping an item requires decrementing t o p , then using i( as
         an index into c o n t e n t s to fetch the item that\s being popped.
               Based on this outline, here’s a program fragment (not a complete program)
         that declares the c o n t e n t s and t o p variables for a stack and provides a set of
         functions that represent operations on the stack. All five functions need access to
         the t o p variable, and two functions need access to c o n t e n t s , so w e’ll make
         c o n t e n t s and t o p external.
2 22 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 10      P r o g r a m O r g a n iz a t io n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       #include <stdbool.h>                        /* C99 only */

                                       #define STACK_SIZE 100

                                       /* external variables */
                                       int contents[STACK_SIZE];
                                       int top = 0;

                                      void make_empty(void)

                                           top - 0;


                                      bool is_empty(void)

                                           return top == 0;


                                       bool is_full(void)

                                           return top == STACK_SIZE;


                                      void push(int i)

                                           if (is_full())
                                             stack_overflow() ;
                                           else
                                             contents[top++] = i;


                                       int pop(void)

                                           if (is_emptyO)
                                             stack_underflow();
                                           else
                                             return contents[--top];dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                       P r o s a n d C o n s o f E x te r n a l V a r ia b le s

                                       External variables are convenient when many Functions must share a variable or
                                       when a few functions share a laro ge number of variables. In most cases, however.
                                       it’s better for functions to communicate through parameters rather than by sharing
                                       variables. H ere’s why:
                                         ■ If we change an external variable during program maintenance (by altering its
                                             type. say), w e’ll need to check every function in the same file to see how the
                                             chang<_^e affects il.
                                                  1 0 .2                                         2 2 3 onmlkjihgfedcbaZYXW
                                                           E x te r n a l V a ria b le s hgfedcbaZYXWVUTSRQPONMLKJIHG


  ■ If an external variable is assigned an incorrect value, it may be difficult to
      identify the guilty function. I t’s like trying to solve a murder committed at a
      crowded party— there's no easy way to narrow the list of suspects.
  ■ Functions that rely on external variables are har d to reuse in other programs. A
     function that depends on external variables isn’t self-contained; to reuse the
     function, we'll have to drag along any external variables that it needs.
     Many C programmers rely far too much on external variables. One common
abuse: using the same external variable for different purposes in different func­
tions. Suppose that several functions need a variable named i to control a f o r
statement. Instead ofdeclaring i in each function that uses it, some programmers
declare it at the top o fth e program, thereby making the variable visible to all func­
tions. This practice is poor not only for the reasons listed earlier, but also because
it’s misleading; someone reading the program later may think that the uses of the
variable are related, when in fact they’re not.
     When you use external variables, make sure they have meaningful names.
(Local variables don’t always need meaningful names: it’s often hard to think o f a
better name than i for the control variable in a f o r loop.) If you find yourself
using names like i and te m p for external variables, that’s a clue that perhaps they
should really be local variables.


Making variables external when they should be local can lead to some rather frus­
trating bugs. Consider the following example, which is supposed to display a 10 x
10 arrangement of asterisks:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
int i;

void print_one_row(void)

   for (i = 1; i <= 10; i++)
     printf(”* ");


void print_all_rows(void)

   for (i = 1; i <= 10; i++)             {
     print_one_row();
     printf(”\n");



Instead of printing 10 rows, p r i n t _ a l l _ r o w s prints only one row. When
p r i n t _ o n e _ r o w returns after being called the first time, i will have the value
11. The f o r statement in p r i n t _ a l l _ r o w s then increments i and tests
whether it’s less than or equal to 10. It’s not, so the loop terminates and the func­
tion returns.
2 2 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 10     P r o g r a m O r g a n iz a t io n


                                 G u e s s in g a N u m b e r
               PR O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     To gel more experience with external variables, w e'll write a sim ple gam e-playing
                                     program. The program generates a random num ber between l and l00, which the
                                     user attem pts lo guess in as few tries as possible. H ere’s what the user will see
                                     when the program is run:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     Guess the secret number between 1 and 100.

                                     A new number has been chosen.
                                     Enter guess: 55
                                     Too low; try again.
                                     Enter guess: 65
                                     Too high; try again.
                                     Enter guess: 60
                                     Too high; try again.
                                     Enter guess: 58
                                     You won in 4 guesses!

                                     Play again?            (Y/N) y

                                     A new number has been chosen.
                                     Enter guess: 78
                                     Too high; try again.
                                     Enter guess: 34
                                     You won in 2 guesses!

                                     Play again?             (Y/N) n

                                          This program will need to carry out several different tasks: initializing the ran­
                                     dom num ber generator, choosing a secret number, and interacting with the user
                                     until the correct num ber is picked. If we write a separate function to handle each
                                     task, we might end up with the following program.cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      g u e s s .c   /★    Asks user to guess a hidden number */

                                     #include <stdio.h>
                                     #include <stdlib.h>
                                     #include <time.h>

                                     #define MAX_NUMBER 100

                                      /* external variable */
                                      int secret_number;

                                     /♦ prototypes */
                                     void initialize_number_generator(void);
                                     void choose_new__secret_number(void) ;
                                     void read_guesses(void);

                                      int main(void)

                                          char command;
                                                                                                                                                                                  1 0 .2                                                                 225
                                                                                                                                                                                                                     E x te rn a l V a ria b le s kjihgfedcbaZYXWVUTSRQPONMLKJ


            printf("Guess the secret number between 1 and %d.\n\n",
                       MAX_NUMBER);
            initialize_number_generator();
            do {
              choose_new_secret_number();
              printf("A new number has been chosen.\n");
              read_guesses();
              printf("Play again? (Y/N) ");
              s c a n f (" % c " , &command);
              p r i n t f ("\n");
            } while (command == *y* || command == 'Y*);

            return 0;aZYXWVUTSRQPONMLKJIHGFEDCBA


/       *   it ir       ★      *   *   *       ★       i* ir i t ir i t ir it      ★      ir it       ★   it   ★   ir ir ir *         ir ir *    *   *   ir ir ir ir i r ir ir ir ir                                 ★    ★   ir ir ir *          ir    ★   ir ir ir      ★    ir      ★       ir *       *    i r ie


        * initialize_number_generator: Initializes the random                                                                                                                                                                                                                                                        *
        *                             number generator using                                                                                                                                                                                                                                                  *
        *                              the time of day.                                                                                                                                                                                                                                                              *
    ★                                                                                                                                                        ★           ir it *          ★       ★        i r BA
                                                                                                                                                                                                               k *       ir k -fc ir ic ★             ir i r ★       ir ir *       *       ★       ir *       it *       ir ir   ★   ir *   *   ir   ★   *   ir


void initialize_number_generator(void)

            s r a n d ((unsigned)                                                                     time(NULL));


[       *   *       *   *      *   *   *       *   ★      ir   ★   *   *   ★   ir *       *   *       *   *    *   *   *       ir *   it *   ★   *   *   *           *        *   *   *       *           i; *   *   *    *   *   *   *       *   *    *    *    ★    *   *    *       *       *    *     *    *     *


    * choose_new_secret_number: Randomly selects a number     *
    *                          between 1 and MAX_NUMBER and *
    *                           stores it in secret_number.   *
    ir i :      ★           ir ir i t ir ir i t i t ir ir ir i r ir i t ir i t                    ★       ir ir ir ir      ★      ir i t ir it ir ir i-          ★        ★       ir ir ir            ★      i t ir ir ir ir i- ir        ★       ir i t ir ir ir i- ir ir i t                      ★     it ir i t |


void choose_new_secret_number(void)
{
  secret_number = rand() % MAX_NUMBER 4- 1;


| ± ir * i* * it *                         ★       ir ir ir it         'k i t i r i t ★       ir ir it i t i t it *               ir *   ★   ir it ir ir it ir it it ir ir it it ir i t i: i t ir ir it it ir ir *                                                        it ir ir ir ir it i t ir


 *              read_guesses: Repeatedly reads user guesses and tell
 *               the user whether each guess is too low,           *
 *              too high, or correct. When the guess is           *
 *              correct, prints the total number of               *
 *              guesses and returns.                               *
 *                              *** **** *** *** ** *** **** **** *** *** *** **
void read_guesses(void)

            int guess, num_guesses = 0;

            for (;;) {
              num_gues s e s++ ;
              printf("Enter guess: *');
              scanf("%d", &guess);
              if (guess == secret_number) {
                printf("You won in %d guesses!\n\n",                                                                                                                                                                              num_guesses);
                return;
              } else if (guess < secret_number)
2 2 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 10    P ro g r a m O rg a n iz a tio n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                     printf("Too low; try again.\n");
                                                   else
                                                     printf("Too high; try again.\n");



            t i m e fu n c tio n > 2 6 . 3                 For random num ber generation, the g u e s s . c program relies on the t i m e ,
           s r a n d fu n c tio n > 2 6 . 2       s r a n d , and r a n d functions, which we first used in d e a l . c (Section 8.2). This
                                                  time, w e’re scaling^*- the return value of r a n d so that it falls between l and
             r a n d fu n c tio n > 2 6 . 2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                             M 7kX _NU M BER.
                                                   Although g u e s s . c works fine, it relies on an external variable. We made
                                             s e c r e t _ n u m b e r external so that both c h o o s e _ n e w _ s e c r e t _ n u m b e r and
                                             r e a d _ g u e s s e s could access it. If we alter c h o o s e _ n e w _ s e c r e t _ n u m b e r
                                             and r e a d _ g u e s s e s just a little, we should be able to move s e c r e t _ n u m b e r
                                             into the m a i n function. WeTl modify c h o o s e _ n e w _ s e c r e t _ n u m b e r so
                                             that it returns the new number, and w e ? ll rewrite r e a d _ g u e s s e s so that
                                             s e c r e t _ n u m b e r can be passed to it as an argument.
                                                   H ere’s our new program, with changes in dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                   b o ld : BA

                      guess2.c               /* Asks user to guess a hidden number */

                                             #include <stdio.h>
                                             #include <stdlib.h>
                                             #include <time.h>

                                             #define MAX_NUMBER 100

                                             /* prototypes */
                                             void initialize_number_generator(void);
                                             int new_secret_number(void);
                                             void read_guesses(int secret_number);

                                             int main(void)

                                                char command;
                                                int secret_number;

                                                printf("Guess the secret number between 1 and %d.\n\n",
                                                       MAX_NUMBER) ;
                                                initialize_number_generator();
                                                do {
                                                  secret_number = new_secret_number();
                                                  printf("A new number has been chosen.\n");
                                                  read_guesses(secret_number);
                                                  printf("Play again? (Y/N) ”);
                                                  scanf(" %c", &command);
                                                  printf("\n");
                                                } while (command == 'y' || command == ’Y ’);

                                                return 0;
                                                                                                                                                1 0 .3                                   227
                                                                                                                                                                       B lo c k s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF

         I ***** ** ** **** ** * *★ * * ** * **** ** * ** * ** ** * * * * ** * * * ** *** * ** * * * *
             * initialize_number_generator: Initializes the r a n d o m                          *
             *                             number g e n erator u s i n g                      *
             *                              the time of day.                                     *
             *                              * * * * * * * * * * * * * * * * * * * * * * * * * * * **** * * * * * * * * *
         void i n i t i a l i z e _ n u m b e r _ g e n e r a t o r (void)

               s r a n d ( (unsigned)                          t i m e ( N U L L ) );


         I ★ ^- ★ ★ ★ ★ * ★ ★ ★ ★ ★ ★ ★ * * ★ ★ * ★ ★ ★ * ★ * * * ★ * * * ★ * * * * * ★ * ★ ★ * * * ★ ★ * ★ ★ ★ * * * ★ ★ * ★ *
             * new_secret_number: Returns a randomly chosen n u m b er                          *
             *                   between 1 and MAX_NUMBER.                                    *
             *                              * * * * * * * * * * * * * * * ★ * * * * * * * ** * * * * * ★ * * * * * * * * *
         int n e w _ s e c r e t _ n u m b e r (void)

               return rand()                              % MAX_NUMEER 4- 1;cbaZYXWVUTSRQPONMLKJIHGFEDCBA


         /   & ^k ★   * * * ★   * * * ★   * ★   ★   * ★    * * * ★   ★   * ★   * * * ★   * * ★   * ★   ★   ★   ★   ★   ★   ★   ★   ★   ★   ★   * ★   ★   ★   * ★   ★    ★   ★   ★   ★   ★   ★   ★   ★   ★

           * read_guesses: Repeatedly reads use r guesses and tells                                                          *
           *                             the user whether each guess is too low,                                           *
           *                               too high, or correct. W h e n the guess is                                        *
           *                               correct, prints the total num b e r of                                            *
           *                              guesses and returns.                                                               *
           ir★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ * 4-★ ★ ★ ★ ★ * ★ ★ ★ ★ ★ ★ ★ ★ + ★ ★ * +r★ ★ ★ ★ ★ ★ *
         v o i d read_guesses(int secret_number)

               int guess,                   num_guesses = 0;

               for (;;) {
                 num_guesses++;
                 printf("Enter guess: ");
                 scanf("%d", &guess);
                 if (guess == secret_number) {
                   printf("You won in %d guesses!\n\n", num_guesses);
                   return,-
                 } else if (guess < secret_number)
                   printf("Too low; try again.\n");
                 else
                   printf("Too high; try again.\n");aZYXWVUTSRQPONMLKJIHGFEDCBA




1 0 .3   B lo c k s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         In Section 5.2, we encountered compound statements o fth e form

         { statements }
            C h a p te r 10
2 2 8 ZYXWVUTSRQPONMLKJIHGFEDCBA P ro g ra m O rg a n iz a tio n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      It turns out that C allows compound statements to contain declarations as weU:


                         b lo c k cbaZYXWVUTSRQPONMLKJIHGFEDCBA           { declarations statem ents }


                                      I'll use the term block to describe such a compound statement. H ere’s an example
                                      o fa block:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      if (i > j) {
                                        /* swap values of i and j */
                                        int temp = i;
                                        i = j;
                                        j = temp;


                                      By default, the storage duration o fa variable declared in a block is automatic: stor­
                                      age for lhe variable is allocated when the block is entered and deallocated when the
                                      block is exited. The variable has block scope; it can't be referenced outside the
                                      block. A variable that belongv»s to a block cG
                                                                                   a?n be declared s t a t i c to give it static
                                      storage duration.
                                           The body of a function is a block. Blocks are also useful inside a function
                                      body when we need variables for temporary use. In our last example, we needed a
                                      variable temporarily so that we could swap the values of i and j . Putting tempo­
                                      rary variables in blocks has two advantages: (I) ll avoids cluttering the declara­
                                      tions at the beginning of the function body with variables that are used only briefly.
                                      (2) Il reduces name conflicts. In our example, the name te m p can be used else­
                                      where in the same function for different purposes— the te m p variable is strictly
                                      local lo the block in which it's declared.
                                           C99 allows variables to be declared anywhere within a block, just as it allows
                                      variables to be declared anywhere within a function.aZYXWVUTSRQPONMLKJIHGFEDCBA




                        1 0 .4        S cope

                                      In a C program, lhe same identifier may have several different meanings. C ’s scope
                                      rules enable the programmer (and the compiler) to determine which meaning is
                                      relevant at a given point in the program.
                                            Here’s the most important scope rule: When a declaration inside a block
                                      names an identifier that’s already visible (because it has file scope or because it’s
                                      declared in an enclosing block), the new declaration temporarily “hides” the old
                                      one, and the identifier takes on a new meaning. Al the end of lhe block, the identi­
                                      fier regains its old meaning.
                                            Consider the (somewhat extreme) example al the lop of the next page, in
                                      which the identifier i has fourdifferenl meaning<^s:

                                        ■ In Declaration I, i is a variable with static sto rage duration and file scope.
                                                                              1 0 .5                                             229
                                                                                       O r g a n iz in g a C P ro g r a m kjihgfedcbaZYXWVUTSRQPONMLKJIH


                                                                                /* Declaration 1 */

                                                                                /* Declaration 2 */




                                                    void g(void)

                                                                                /* Declaration 3 */


                                                                                /* Declaration 4 */




                                                    void h(void)onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                  ■ In   Declaration 2, i is a parameter with block scope.
                          ■          ln Declaration 3, i is an automatic variable with block scope.
                  ■                  In Declaration 4, i is also automatic and has block scope.
         i is used five times. C\s scope rules allow us to determine the meaning of i in each
         case:
              ■                      The i = 1 assignment refers to the parameter in Declaration 2, not the variable
                                     in Declaration 1. since Declaration 2 hides Declaration 1.
                              ■      The i > 0 test refers to the variable in Declaration 3, since Declaration 3 hides
                                     Declaration 1 and Declaration 2 is out ofscope.
          ■                          The i = 3 assigc?nment refers to the variable7 in Declaration 4, which hides Dec-
                                     laration 3.
                      ■              The i = 4 assi<g^nment refers to the variable in Declaration 3. It can’t refer to
                                     Declaration 4, which is out of scope.
                                  ■ T he i = 5 assi^gnment refers to the variable in Declaration I .aZYXWVUTSRQPONMLKJIHGFEDCBA




1 0 .5   O r g a n iz in g a C P r o g r a m

         Now that w e’ve seen the major elements that make up a C program, it’s time to
         develop a strategy for their arrangement. For now, w e’ll assume that a program
2 3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 10      P r o g r a m O r g a n iz a tio n


                                     always fits into a single file. Chapter 15 shows how to organize a program that’s
                                     split over several files.
                                          So far, w e’ve seen that a program may contain the following:

                                           Preprocessing directives such as # i n c l u d e and # d e f i n e
                                           Type definitions
                                           Declarations ofexternal variables
                                           Function prototypes
                                           Function definitions aZYXWVUTSRQPONMLKJIHGFEDCBA

                                     C imposes only a few rules on the order of these items: A preprocessing directive
                                     doesn’t take effect until the line on which it appears. A type name can’t be used
                                     until it’s been defined. A variable can’t be used until it’s declared. Although C isn’t
                                     as picky about functions, I strongly recommend that every function be defined or
                          C 99       declared prior to its first call. (C99 makes this a requirement anyway.)
                                          There are several ways to organize a program so that these rules are obeyed.
                                     H ere’s one possible ordering:

                                           # i n c l u d e directives
                                           # d e f i n e directives
                                           Type definitions
                                           Declarations ofexternal variables
                                           Prototypes for functions other than m a in
                                           Definition of m a in
                                           Definitions of other functions

                                     It makes sense to put # i n c l u d e directives first, since they bring in information
                                     that will likely be needed in several places within the program, # d e f i n e direc­
                                     tives create macros, which are generally used throughout the program. Putting type
                                     definitions above the declarations ofexternal variables is logical, since the declara­
                                     tions of these variables may refer to the type nam esjust defined. Declaring exter­
                                     nal variables next makes them available to all the functions that follow. Declaring
                                     all functions except for m a in avoids the problems that arise when a function is
                                     called before the compiler has seen its prototype. This practice also makes it possi­
                                     ble to arrange the function definitions in any order whatsoever: alphabetically by
                                     function name or with related functions grouped together, for example. Defining
                                     m a in before the other functions makes it easier for a reader to locate the pro­
                                     gram ’s starting point.
                                          A final suggestion: Precede each function definition by a boxed comment that
                                     gives the name of the function, explains its purpose, discusses the meaning ofeach
                                     parameter, describes its return value (if any), and lists any side effects it has (such
                                     as modifying external variables).hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                 C la s s if y in g a P o k e r H a n d
               P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    To show how a C program might be organized, let’s attempt a program that’s a lit­
                                    tle more complex than our previous examples. The program will read and classify
                                            1 0 .5   O r g a n iz in g a C P ro g ra m hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                               231 onmlkjihgfedcbaZYXW


                                                         suit (clubs, diamonds, hearts,
a pokcr hand. Each card in the hand will have both a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
or spades) and a rank (two. three, four. Five, six, seven, eight, nine, ten,jack. queen,
king, or ace). We won't allow the use o fjo k ers. and we’ll assume that aces are
high. The program will read a hand of five cards, then classify the hand into one of
the following categories (listed in order from best to worst):
     straight flush (both a straight and a flush)
     four-of-a-kind (four cards o f the same rank)
     full house (a three-of-a-kind and a pair)
     flush (five cards of the same suit)
     straight (five cards with consecutive ranks)
     three-of-a-kind (three cards of the same rank)
     two pairs
     pair (two cards of the same rank)
     high card (any other hand)

If a hand falls into two or more categories, the program will choose the best one.
     For input purposes, we’ll abbreviate raiJcs and suits as follows (letters may be
either upper- or lower-case):

     Ranks: 2 3 4 5 6 7 8 9 t               j   q k a
     Suits: c d h s

If the user enters an illegal card or tries to enter the same card twice, the program
will ignore the card, issue an error message, and then request another card. Enter­
ing the number 0 instead o fa card will cause the program to terminate.
     A session with the program will have the following appearance:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Enter a card: 2s
Enter a card: 5s
Enter a card: 4s
Enter a card: 3s
Enter a card: 6s
Straight flush

Enter a card: 8c
Enter a card: as
Enter a card: 8c
Duplicate card; ignored.
Enter a card: 7c
Enter a card: ad
Enter a card: 3h
Pair

Enter a card: 6s
Enter a card: d2
Bad card; ignored.
Enter a card: 2d
Enter a card: 9c
Enter a card: 4h
Enter a card: ts
2 3 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 10      P ro g ra m O rg a n iz a tio n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     High card

                                     Enter a card: 0onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           From this description o fth e program, we see that it has three tasks:

                                           Read a hand of five cards.
                                           A nalyze the hand for pairs, straights, and so forth.
                                           Print the classification of the hand.

                                     We'lI divide the program into three functions— r e a d _ c a r d s , a n a l y z e _ h a n d .
                                     and p r i n t _ r e s u l t — that perform these three tasks, m a i n docs nothing but call
                                      these functions inside an endless loop. The functions will need to share a fairly
                                      large am ount of information, so weUl have them com m unicate through external
                                      variables, r e a d _ c a r d s will store inform ation about the hand into several exter­
                                      nal variables, a n a l y z e _ h a n d will then exam ine these variables, storing its find­
                                      ings into other external variables for the benefit o f p r i n t _ r e s u l t .
                                           Based on this preliminary design, we can begin to sketch an outline of the pro­
                                     g^*ram:

                                     /* #include directives go here */

                                     /* #define directives go here */

                                     /* declarations of external variables go here */

                                     /* prototypes */
                                     void read_cards(void);
                                     void analyze_hand(void);
                                     void print_result(void);

                                     ! ** * ** * **★ *★ * *★ *** ★ **★ * * *★ ★ * ★ ★ *★ ★ ★ * *** * ★ ± *★ ★ * * ★ ★ ★ ★ ★ * ★ ★ * ★ * * ★
                                       * main: Calls read_cards, analyze_hand, and print_result *
                                       * repeatedly.                                                                                                      *cbaZYXWVUTSR
                                       * ★ ★ * * * ★ ★ * -k * * * * ★ ★ ★ * * * ★ ★ * * * ★ * ★ * ★ * ★ ★ * * ★ ★ * * * ★ * * * * ★ ★ ★ ★ * ★ ★ * * * * ★ ★ I
                                     int main(void)

                                         for (;;) {
                                           read_cards();
                                           analyze_hand();
                                           print_result();



                                     ] ★ *★ ** * *★ * ★ ★ ★ * *★ ★ ★ ★ r* ★ ★ * ** ★ * *★ * ★ ★ ★ ★ ★ ★ * ic*★ ★ *★ ★ ★ ★ * ★ ★ ** ★ ★ ★ ★ ★ ★ *
                                      * read_cards: Reads the cards into external variables; *
                                       * checks for bad cards and duplicate cards. *
                                       ★ ★ ★ ★ ★ * *★ ** ★ ** *★ * ** i fr★ *★ ★ ★ ★ *★ * ★ ** ** ** **★ ★ * * ★ ** * *★ ★ * **★ ★ ★ ★ **★
                                     void read_cards(void)
                                                                                                                 10.5                  O rg a n iz in g a C P r o g ra m hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                                                                                 233

               I *• ★          * * * * * ★        ★   ★   * * * ★   * it ir ★   ir * ★   ir ir ir ★   ★   ic ★   * ★   ★   ★   ★   ★       ★       * * ★   ★   ★   * ★      ★       * ★     * ★   ★     * ★   ★   ★   it it it it it itkjihgfedcbaZYXWVUTSRQ

                     * analyze_hand: Determines whether the hand contains a    *
                     *              straight, a flush, four-of-a-kind,        *
                     *               and/or three-of-a-kind; determines the    *
                     *               number of pairs,- stores the results into *
                     *               external variables.                       *
                     it it it it it it it it it it it it it it it it it it it it it it it it it it * it it it it it + ★                ★           ir it it it it it ir it it it ir it it it it it it it it it it ic it

               void analyze_hand(void)
               {



               / ★     ★   ★     ★   ★   it it it it it it it it it it it it it ir ir ir ir it ir it ir it it ir it ir ir it it it it ir it ir * ★                   it ★       ★         * i ir ir ★     * * * * * it * * *

                     * print_result: Notifies the user of the result, using                                                                                                                                                     *
                     *              the external variables set by                                                                                                                                                              *
                     *               analyze_hand.                                                                                                                                                                              *
                     ir ic it it it ir ir ir it it it it it it it it it it it it ir it ir it it ir ir it ir ir it it it it ★                   ★     it ic it it it it ir ir it i it ir it it ic it it it it it it * j

               void print_result(void)onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                     The most pressing question that remains is how to represent the hand ofcards.
               Let’s see what operations r e a d _ c a r d s and a n a l y z e _ _ h a n d will perform on
               the hand. During the analysis of the hand, a n a l y z e _ h a n d will need to know
               how many cards are in each rank and each suit. This suggests that we use two
               arrays, n u m _ i n _ r a n k and n u m _ i n _ s u i t . The value of n u m _ i n _ r a n k [ r ]
               will be the n u m b ero fcard s with rank r , and the v a lu e o f n u m _ in _ _ s u it [ s ] will
               be the number of cards with suit s. (W e'll encode ranks as numbers between 0 and
                l2. and suits as numbers between 0 and 3.) We’ll also need a third array,
               c a r d _ e x i s t s , so that r e a d _ c a r d s can detect duplicate cards. Each time
               r e a d _ c a r d s reads a card with rank r and suit s , it checks whether the value of
               c a r d _ e x i s t s [ r ] [ s ] is t r u e . If so. the card was previously entered; if not,
               r e a d _ c a r d s assigns t r u e to c a r d _ e x i s t s [ r ] [ s ] .
                     Both the r e a d _ c a r d s function and the a n a l y z e _ h a n d function will need
               access to the n u m _ i n _ r a n k and n u m _ i n _ s u i t arrays, so I’ll make them exter­
               nal variables. The c a r d _ e x i s t s array is used only by r e a d _ c a r d s . so it can
               be local to that function. As a rule, variables should be m adeextem al only ifn eces-
               sary.
                     Having decided on the major data structures, we can now finish the program:

p o k e r .c   /* Classifies a poker hand */

               #include <stdbool.h>                                                         /* C99 only */
               #include <stdio.h>
               #include <stdlib.h>

               #define NUM_RANKS 13
               #define NUM_SUITS 4
               #define NUM_CARDS 5
            C h a p te r 10
2 3 4 ZYXWVUTSRQPONMLKJIHGFEDCBAP ro g ra m O rg a n iz a tio n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     /* external variables */
                                     int num_in_rank[NUM_RANKS];
                                     int num_in_suit[NUM_SUITS];
                                     bool straight, flush, four, three;
                                     int pairs;    /* can be 0, 1, or 2 */

                                     /* prototypes */
                                     void read_cards(void);
                                     void analyze_hand(void);
                                     void print_result(void);

                                     | -k * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

                                           * main: Calls read_cards, analyze_hand, and print_result *
                                           *      repeatedly.                                      *
                                       ★   ★   * k k k k k k k ★       ★       ★     k ★     ★   ★       ★     ★   * ★   ★   ★   ★   ★   ★   k k k ★   ★   ★       ★     ★   k ★       ★       ★         * ★     * ★   ★     k * ★     ★   ★   ★   * k ★   ★   * k * ★    ★

                                     int main(void)

                                           for (;;) {
                                             read_cards();
                                             analyze_hand();
                                             print result();



                                     [ k k k k * k ★     ★   * ★   ★       ★       k ★     + ★       ★       k k k k k k k k + + * ★                * ★        ★       + + ★       ★       ★       * ★         k ^ ★       k k ★     k k k ★       k k * k k k ★         * k

                                      * read_cards: Reads the cards into the external                                                                        *
                                      *                          variables num_in_rank and num_in_suit;                                                        *
                                      *                          checks for bad cards and duplicate cards. *
                                      k ★ k k k k k k k k ★ ★ k W k k ^k ★ k ★ k ^k k k k * W ★ k * k k k ^k k ★ ★ ★ k k ^ k k ^c k k k k 'k k ★ ★ ★ k -k ic k ±

                                     void read_cards(void)
                                     {
                                        bool card_exists[NUM_RANKS][NUM_SUITS];
                                        char ch, rank_ch, suit_ch;
                                        int rank, suit;
                                        bool bad_card;
                                        int cards_read = 0;

                                           for (rank = 0; rank < NUM_RANKS; rank++) {
                                             num_in_rank[rank] = 0;
                                             for (suit = 0; suit < NUM_SUITS; suit++)
                                               card_exists[rank][suit] = false;


                                               for (suit = 0; suit < NUM_SUITS; suit++)
                                                 num_in_suit[suit] = 0;

                                           while (cards_read < NUM_CARDS)                                                                                              {
                                             bad_card = false;

                                                printf(”Enter a card: •');

                                                 rank_ch = getchar();
                                                 switch (rank_ch) {
                                                         1 0 .5                                              235
                                                                    O r g a n iz in g a C P ro g ra m kjihgfedcbaZYXWVUTSRQPONMLKJ


             case '0'                             e x i t (EXIT_SUCCESS
             case '2'                             rank = 0; break;
             case ’3 ’                            rank = 1; break;
             case ’4 ’                            rank = 2; b r e a k ;
             case ’5 ’                            rank = 3; b r e a k ;
             case 1 6 ’                           rank = 4; break;
             case '7’                             rank = 5; break;
             case '8'                             rank = 6; break;
             case ’9'                             rank = 7; break;
             case ’t ’         case      'T'      rank = 8; break;
             case ’j ’         case      ’J ’     rank = 9; b r e a k ;
             case ‘q ’         case      'Q’      rank = 10; break;
             case 'k'          case      'K'      rank = 11; break;
             case ’a ’         case      ’A ’     rank = 12; break;
             default:                             bad card = true,-


        suit_ch = getchar();
                            I
        switch (suit_ch)hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          case 'c ' : case ’C' : suit = 0; break;
          case 'd' : case 'D' : suit = 1; break;
          case •h' : case ’H ’ : suit = 2; break;
          case ’s ' : case ’S ’ : suit = 3; break;
          def a u l t :              bad card = true;


        while ((ch = getchar()) ’= '\n')
          if (ch .'= ’ ’) bad_card = true;

        if  (bad_card)
          printf(”Bad card; ignored.\n'*);
        else if (card_exists [rank] [suit])
          printf("Duplicate card; ignored.\n”) ;
        else {
          num__in_rank[rank]+ + ;
          num_in_suit[suit] ++;
          card_exists[rank] [suit] = true;
          cards_read++;

     }cbaZYXWVUTSRQPONMLKJIHGFEDCBA


| k *************************★ ******★ *******★ **★ *************
 * analyze_hand: Determines whether the hand contains a    *
 *              straight, a flush, four-of-a-kind,       *
 *               and/or three-of-a-kind; determines the    *
 *               number of pairs; stores the results into *
 *               the external variables straight, flush,   *
 *               four, three, and pairs.                   *
 *                               * * * * * * * * ★ * * * * ★ * * ★ * * * * *★ ■ * ★ * ★ ★ * * * * ★ * * * * * * * * * * * * * * * * * *
void analyze_hand(void)

     int num_consec = 0 ;
     int rank, suit;
2 3 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 10    P ro g ra m O rg a n iz a tio n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           straight = false;
                                           flush = false;
                                           four = false;
                                           three = false;
                                           pairs = 0;

                                            /* check for flush */
                                            for (suit = 0; suit < NUM_SUITS; suit++)
                                              if (num_in_suit[suit] == NUM_CARDS)
                                                flush = true;

                                           /* check for straight ★ /
                                           rank = 0;
                                           while (num_in_rank[rank] == 0) rank++;
                                           for (; rank < NUM_RANKS && num_in_rank[rank]                                                                                                         > 0; rank++)
                                             num_consec++;
                                           if (num_consec == NUM_CARDS) {
                                             straight = true;
                                             return;


                                            /* check for 4-of-a-kind, 3-of-a-kind, and pairs */
                                            for (rank = 0; rank < NUM_RANKS; rank++) {
                                              if (num_in_rank[rank] == 4) foui' = true;
                                              if (num_in_rank[rank] == 3) three = true;
                                              if (num_in_rank[rank] == 2) pairs++;cbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                          * * * * + + * + * + + * + + * + + + + + + ★ + + + -fc + -k + * * + ★                                           ★ * ★ ★ +* ★ * * ★ ★ ++* * ★ ★ ★ +++★ +★ ★
                                      * print_result: Prints the classification of the hand,                                                                                                                                                    *
                                      ★               based on the values of the external                                                                                                                                                       *
                                      *               variables straight, flush, four, three,                                                                                                                                                   *
                                      *               and p a i r s .                                                                                                                                                                       ★
                                      ★     ★   ★   ★   ★   ★   ★   ★   ★   *   *   + + *   *   *   *   *   + *   *   *   *   + *   + + + + ★   ^r ★   + +   *• ★   + + ★   + + ★   ★   + + ★   ★   ★   ★   ★   ★   ★   ★   ★   ★   ★   ★       ★


                                    void print_result (void)

                                           if (straight && flush)                                                              printf("Straight flush");
                                           else if (four)                                                                      printf("Four of a kind");
                                           else if (three &&
                                                    pairs == 1)                                                                printf("Full house");
                                           else if (flush)                                                                     p r i n t f ("Flush");
                                           else if (straight)                                                                  p r i n t f ("Straight");
                                           else if (three)                                                                     printf("Three of a kind");
                                           else if (pairs == 2)                                                                printf("Two pairs");
                                           else if (pairs == 1)                                                                p r i n t f ("Pair");
                                           else                                                                                printf("High card");

                                           p r i n t f ("\n\n");onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         Notice the use ofthe e x i t function in r e a d _ c a r d s (in case 1 0 1 ofthe first
                                    s w i t c h statement), e x i t is convenient for this program because o fits ability to
                                    terminate execution from anywhere in the program.
                                                                                                                                             237
                                                                                                                               Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGF




                               Q&A          dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                         Q:    W h a t im p a c t d o lo c a l v a r ia b le s w ith s ta tic s t o r a g e d u r a tio n h a v e o n r e c u r s iv e
                               fu n c tio n s ? [p. 2 2 0 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         A:    When a function is called recursively, fresh copies are made of its automatic vari­
                               ables for each call. This doesn’t occur for static variables, though. Instead, all calls
                                                         sam e static variables.
                               of the function share the cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                         Q:    In th e fo llo w in g e x a m p le , j is in itia liz e d to th e s a m e v a lu e a s i , b u t th e r e a r e
                               tw o v a r ia b le s n a m e d i : kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                               int i = 1;

                               void f (void)
                               {
                                 int j = i;
                                 int i = 2;
                                 •••


                               Is th is c o d e le g a l? I f s o , w h a t is j ’s in itia l v a lu e , 1 o r 2 ?
                         A:    The code is indeed legal. The scope of a local variable doesn't begin until its decla­
                               ration. Therefore, the declaration of j refers to the external variable named i . The
                               initial value of j will be 1.




                               E x e rc is e s

S e c tio n 1 0 .4   ©    l.   The following program outline shows only function definitions and variable declarations,
                               int a ;
                               void f(int b)
                               {
                                 int c ;

                               void g (void)

                                   int d ;
                                   {
                                     int e;
                               } }

                               int main(void)

                                   int f ;
2 3 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 10      P ro g r a m O r g a n iz a tio n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       For each o fth e following scopcs, lisi all variable and parameter names visible in that scope:
                                       (a)   The f function
                                       (b)   The g function
                                       (c)   The block in which e is declared
                                       (d)   The m a in function

                                2.    The following program outline shows only function definitions and variable declarations,kjihgfedcba
                                       int b, c;
                                      void f (void)

                                             int b, d;

                                      void g(int a)

                                             int c;

                                               int a, d;



                                       int main(void)
                                       {
                                         int c , d ;

                                      For each of the following scopes, list all variable and parameter names visible in that scope.
                                      If there’s more than one variable or parameter with the same name, indicate which one is
                                      visible.
                                      (a) The f function
                                      (b) The g function
                                      (c) The block in which a and d are declared
                                      (d) The m a in function

                              *3.     Suppose that a program has only one function (m a in ). How many different variables named
                                      i could this program contain? aZYXWVUTSRQPONMLKJIHGFEDCBA




                                       P r o g r a m m in g P r o je c t s

                                l.    Modify the stack example of Section lO.2 so that it stores characters instead of integers.
                                      Next, add a m a in function that asks the user to enter a series of parentheses and/or braces,
                                      then indicates whether or not theyTe properly nested:
                                      Enter parentheses and/6r braces: (() {} { () })
                                      Parentheses/braces are nested properlycbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      H int: As the program reads characters, have it push each left parenthesis or left brace. When
                                      it reads a right parenthesis or brace, have il pop the stack and check that the item popped is a
                                      matching parenthesis or brace. (If n o t the parentheses/braces aren’t nested properly.) When
                                      the program reads the new-line character, have it check whether the stack is empty: ifso, the
                                      parentheses/braces are matched. If the stack isn 't empty (or i f s t a c k _ u n d e r f l o w is ever
                                                                                                             239onmlkjihgfedcbaZYX
                                                                     P ro g r a m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLKJ


         called), the pareniheses/braces aren't matched. If s t a c k _ o v e r f l o w is called, have the
         program print the message S t a c k o v e r f l o w and terminate immediately.

    2.   Modify the p o k e r . c prograin of Section 10.5 by moving the n u m _ i n _ r a n k and
         n u m _ i n _ s u i t arrays into m a in , which will pass them as arguments to r e a d _ c a r d s
         and a n a l y z e _ h a n d .

©   3.   Remove the n u m _ in _ r a n k , n u m _ i n _ s u i t , and c a r d _ e x i s t s arrays from the
         p o k e r . c program of Section 10.5. Have the program store the cards in a 5 x 2 array
         instead. Each row of the array will represent a card. For example, if the array is named
         h a n d , then h a n d [0] [0] will store the rank of the first card and h a n d [0] [1] will store
         the suit of the first card.

    4.   Modify the p o k e r . c program of Section 10.5 by having it recognize an additional cate­
         gory, “royal flush" (ace, king, queen,jack, ten of the same suiL). A royal flush ranks higher
         than all other hands.

©   5.   Modify the p o k e r . c program ofS ection 10.5 by allowing “ace-low" straights (acc, two,
         three, four. five).

    6.   Some calculators (notably those from Hewlett-Packard) use a system of writing mathemati­
         cal expressions known as Reverse Polish Notation (RPN). In this notation, operators are
                after their operands instead tfb e tw e e n their operands. For example. 1 + 2 would bc
         placed cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         written 1 2 + in RPN, and 1 + 2 * 3 would be written 1 2 3 * +. RPN expressions can easily
         be evaluated using a stack. The algorithm involves reading the operators and operands in an
         expression from left to right, performing the following actions:
              When an operand is encountered, push il onto the slack.
              When an operator is encountered, pop its operands from the staek. perform the opera­
              tion on those operands, and then push the result onto the stack.
         Write a program that evaluates RPN expressions. The operands will be single-digit integers.
         The operators are +. - . *, /. and =. The = operator causes the top stack item to be displayed;
         afterwards, the stack is cleared and the user is prompted to enter another expression. Thc
         process continues until the user enters a character that is not an operator or operand:
         E n te r   an   RPN e x p r e s s i o n :    1 2 3 * 4- =
         V a lu e   of   e x p re s s io n : 7
         E n te r   an   RPN e x p r e s s i o n :    5 8 ★   4 9 - /     =
         V a lu e   of   e x p r e s s i o n : -8
         E n te r   an   RPN e x p r e s s i o n :    g
         If the stack overflows, the program will display the message E x p r e s s i o n i s t o o co m ­
         p l e x and terminate. If the stack underflows (because of an expression such as 1 2 4* +). the
         program will display the message N o t e n o u g h o p e r a n d s i n e x p r e s s i o n and term i­
         nate. Hints: Incorporate the stack code from Section 10.2 into your program. Use
         s c a n f (" % c " , &ch) lo read the operators and operands.

    7.   Write a program that prompts the user for a number and then displays the number, using
         characters to simulate the effect of a seven-segment display:
         E n t e r a n u m b e r:    4 9 1 -9 0 1 4




         Characters other than digits should bc ignored. Write the program so that the maximum
         number ofdigits is controlled by a macro named MAX_DIGITS. which has the value 10. If
2 4 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 10      P ro g ra m O rg a n iz a tio n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                                                                        sr'its are i^2n0red. H ints: Use
                                     the num ber contains more than this num ber of dig0 its, the extra di\cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     two external arrays. One is the s e g m e n t s array (see Exercise 6 in C hapter 8), which stores
                                     data representing the correspondence between digits and segments. The other array, d i g ­
                                     i t s . will be an array of characters with 4 rows (since each segm ented digit is four charac­
                                     ters high) and MAX_DIGITS * 4 colum ns (digits are three characters wide, but a space is
                                     needed between digits for readability). W rite your program as four functions: m a in ,
                                     c l e a r _ d i g i t s _ a r r a y . p r o c e s s _ d i g i t . and p r i n t _ d i g i t s _ a r r a y . Here arc
                                     the prototypes for the latter three functions:
                                     v o id c le a r _ d ig its _ a r r a y ( v o id ) ;
                                     v o id p r o c e s s _ d i g i t ( i n t d i g i t , i n t p o s i t i o n ) ;
                                     v o id p r in t _ d ig i ts _ a r r a y ( v o i d ) ;
                                     c l e a r _ d i g i t s _ a r r a y will store blank characters into all elem ents of the d i g i t s
                                     array. p r o c e s s _ d i g i t will store the seven-segment representation of d i g i t into a
                                     specified position in the d i g i t s array (positions range from 0 to M AX_DIGITS - l).
                                     p r i n t _ d i g i t s _ a r r a y will display the rows o fth e d i g i t s array, each on a single line,
                                     producing output such as that shown in the example.
11        P o in te r s            ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                         T h e 1 1th c o m m a n d m e n t w a s " T h o u S h a lt C o m p u te ”
                                                                  o r “T h o u S h a lt N o t C o m p u te ”— ! fo rg e t w h ic h . onmlkjihgfedcba




          Pointers are one o f C ’s most im portant— and most often m isunderstood— features.
          Because of their im portance, w e’ll devote three chapters to pointers. In this chap­
          ter. w e’ll concentrate on the basics; Chapters 12 and 17 cover more advanced uses
          of pointers.
               W e’ll start with a discussion of mem ory addresses and their relationship to
          pointer variables (Section 11.1). Section 11.2 then introduces the address and indi­
          rection operators. Section 11.3 covers pointer assignm ent. Section 11.4 explains
          how to pass pointers to functions, while Section 11.5 discusses returning pointers
          from functions.




 1 1 .1   P o in te r V a r ia b le s

          The first step in understanding pointers is visualizing what they represent at the
                                                                                                   bytes.
          machine level. In most modern com puters, main memory is divided into cbaZYXWVUTSRQPONMLKJ
          with each byte capable o fsto rin g eight bits of information:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         I       i       i       i       I       i       I
                                     0       1       0       1       0       0       1       1
                                         I       I       !       I____I____ !____ I___


          Each byte has a unique a d d ress to distinguish it from the other bytes in memory. If
          there are n bytes in memory, we can think ofaddresses as numbers that range from
          0 to n - 1 (see the figure at the top of the next page).
               An executable program consists of both code (m achine instructions corre­
          sponding to statements in the original C program) and data (variables in the origi­
          nal program). Each variable in the program occupies one or more bytes of mem ory;hgfedcbaZYXW



                                                                                                                               241
2 4 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 11     P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                      the address of the first byte is said to be the address of the variable. In the follow ing
                                      figure, the variable i occupies lhe bytes at addresses 2000 and 2001. so i ’s address
                                      is 2000:aZYXWVUTSRQPONMLKJIHGFEDCBA




                                            H ere's w here pointers com e in. Although addresses are represented by num ­
                                     bers, their range of values may differ from that o f integers, so we can ’t necessarily
                                     store them in ordinary integer variables. We can, however, store them in specialcbaZYXWV
                                     p o in te r variables. W hen we store the address o f a variable i in the pointer variable
                                     p. we say that p “points to” i . In other words, a pointer is nothing more than an
                          Q&A        address, and a pointer variable isju st a variable that can store an address.
                                            Instead of showing addresses as num bers in our exam ples, 1’11 use a sim pler
                                     notation. To indicate that a pointer variable p stores the address o f a variable i , 1’11
                                     show the contents of p as an arrow directed toward i :dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                      D e c la r in g P o in te r V a r ia b le s

                                      A pointer variable is declared in much the same way as an ordinary variable. The
                                      only difference is that the nam e of a pointer variable must be preceded by an aster­
                                      isk:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      int *p;
                                                                      1 1 .2                                                                      2 4 3 onmlkjihgfedcbaZYX
                                                                               T h e A d d re s s a n d In d ire c tio n O p e r a to r s hgfedcbaZYXWVUTSRQPONMLKJIH


                                                                                                                     objects of
                                          This declaration states that p is a pointer variable capable ofpointing to cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                          type i n t . frn using the term object instead of variable since— as we'll see in
                                          Chapter 17— p might point to an area of memory that doesn't belong to a variable.
                                          (Be aware that “object” wiU have a different meaning when we discuss program aZYXWVUTSRQPO
    a b s tr a c to b |e c ts > /9 J      design in Chapter 19.)
                                              Pointer variables can appear in declarations along with other variables:kjihgfedcbaZYXWVUTSRQPONML
                                          int i, j, a[10], b[20], *p, *q;

                                          hi this example, i and j are ordinary integer variables, a and b are arrays of inte­
                                          gers, and p and q are pointers to integer objects.
                                               C requires that every pointer variable point only to objects of a particular type
                                          (the referenced type)\
                                          in t *p;              / ★ p o i n t s o n ly t o i n t e g e r s    */
                                          d o u b le *q;        /* p o i n t s o n ly t o d o u b le s        */
                                          ch ar * r;            /* p o i n t s o n ly t o c h a r a c t e r s * /
                                          There are no restrictions on what the referenced type may be. In fact, a pointer
                                   17.6
p o in t e r s to p o in t e r s > BA     variable can even point to another pointer.




                        1 1 .2            T h e A d d r e s s a n d In d ir e c t io n O p e r a t o r s

                                          C provides a pair of operators designed specifically for use with pointers. To find
                                          the address of a variable, we use the & (address) operator. If x is a variable, then
                                          &x is the address o f x in memory. To gain access to the object that a pointer points
                                          to, we use the * (indirection) operator. If p is a pointer, then *p represents the
                                          object to which p currently points.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          T he A d d r ess O p era to r

                                          Declaring a pointer variable sets aside space for a pointer but doesn't make it point
                                          to an object:
                                          i n t *p;         /* p o i n t s now here i n p a r t i c u l a r * /
                                          It’s crucial to initialize p before we use it. One way to initialize a pointer variable
                    iv a iu e s > 4 .2    is to assign it the address of some variable— or, more generally, lvalue— using the
                                          & operator:
                                          in t i ,    *p;
                                          •••

                                          p = &i;
                                          By assigning the address of i to the variable p . this statement makes p point to i :
244 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 11      P o in te r s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          It’s also possible lo initialize a pointer variable at the time we declare it:kjihgfedcbaZYXWV

                                    int i ;
                         Q&A        int *p = &i ;

                                    We can even com bine the declaration of i with the declaration of p , provided that
                                    i is declared first:

                                    int i, *p = &i,-


                                    T h e I n d ir e c tio n O p e r a to r

                                    Once a pointer variable points to an object, we can use the * (indirection) operator
                                    to access w hat’s stored in the object. I f p points to i , for example, we can print the
                                    value of i as follows:

                                    printf("%d\n",             *p);

                         Q&A                                     value o f i , not the address o f i .
                                    p r i n t f will display the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                          The m athem atically inclined reader may wish to think of * as the inverse o f &.
                                    Applying & to a variable produces a pointer to the variable; applying * to the
                                    pointer takes us back to the original variable:

                                    j = *&i;            /* same as j = i; */

                                         As long as p points to i , * p is an alias for i . Not only does * p have the same
                                    value as i , but changing the value of * p also changes the value o f i . (* p is an
                                    lvalue, so assignm ent to it is legal.) The following exam ple illustrates the equiva­
                                    lence of * p and i ; diagrams show the values o f p and i at various points in the
                                    com putation.

                                   P = &i;




                                    i = 1;




                                   printf("%d\n",              i);            /* prints 1 */
                                   printf("%d\n",              *p);           /* prints 1 */
                                   *P = 2;




                                   printf("%d\n",              i);            /* prints 2 */
                                   printf("%d\n",              *p);           /* prints 2 */
                                                              1 1 .3                                          245
                                                                       P o in te r A s s ig n m e n t hgfedcbaZYXWVUTSRQPONMLKJIH




             Never apply the indirection operator to an uninitialized pointer variable. If a
 A           pointer variable p hasn’t been initialized, attempting to use the value o f p in any
     onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
             way causes undefined behavior. In the following example, the call o f p r i n t f may
             print garbage, cause the program to crash, or have some other effect:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB
         int *p;
         printf("%d",         *p);       /*** WRONG ***/

         Assigning a value to *p is particularly dangerous. I f p happens lo contain a valid
         memoiy address, the following assignment will attempt to modify the data stored
         at that address:
          int *p;
          *P = 1;        /*** WRONG ***/

         If the location modified by this assignment belongs to the program, it may behave
         erratically: if it belongs to the operating system, the program will most likely
         crash. Your compiler may issue a warning that p is uninitialized, so pay close
         attention to any warning messages you get.aZYXWVUTSRQPONMLKJIHGFEDCBA




1 1 .3    P o in t e r A s s ig n m e n t

         C allows the use of the assignment operator to copy pointers, provided that they
         have the same type. Suppose that i . j . p. and q have been declared as follows:

          int i, j, *p, *q;

         The statement

         p = &i;

         is an example of pointer assignment; the address of i is copied into p. Here’s
         another example of pointer assignment:

         q = p;
         This statement copies the contents o f p (the address of i ) into q, in effect making
         q point to the same place as p:




         Both p and q now point to i , so we can change i by assigning a new value to
         either *p or *q:
246 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p t e r 11     P o in te rs




                                                                  p




                                   Any number of pointer variables may point to the same object.
                                      Be careful not to confuse



                                   with



                                   The first statement is a pointer assignment; the second isn't, as the following
                                   example shows:


                                   q
                                   1




                                   The assignment * q = *p copies the value that p points to (the value of i ) into the
                                   object that q points to (the variable j) .
                                                          1 1 .4                                             247aZYXWVUTSRQPO
                                                                   P o in te rs a s A r g u m e n t s kjihgfedcbaZYXWVUTSRQPONMLKJI




1 1 .4   P o in te r s a s A r g u m e n t s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         So far, w e’ve managed to avoid a rather important question: W hat are pointers
         good for? There’s no single answ er to that question, since pointers have several
         distinct uses in C. In this section, w e’ll see how a pointer to a variable can be use­
         ful as a function argument. We’lI discover other uses for pointers in Section 11.5
         and in Chapters 12 and l7.
              We saw in Section 9.3 that a variable supplied as an argument in a function
         call is protected against change, because C passes arguments by value. This prop­
         erty o f C can be a nuisance if we want the function to be able to modify the vari­
         able. In Section 9.3, we tried— and failed— to write a d e c o m p o s e function that
         could modify two of its arguments.
              Pointers offer a solution to this problem: instead of passing a variable x as the
         argument to a function, w e’ll supply &x, a pointer to x. We’ll declare the corre­
         sponding param eter p to be a pointer. When the function is called, p will have the
         value &x. hence * p (the object that p points to) will be an alias for x. Each appear­
         ance of * p in the body of the function will be an indirect reference to x , allowing
         the function both to read x and to modify it.
              To see this technique in action, let’s modify the d e c o m p o s e function by
         declaring the parameters i n t _ p a r t and f r a c _ p a r t to be pointers. The defini­
         tion of d e c o m p o s e will now look like this:

         void decompose(double x, long *int_part, double *fracjpart)

              *int_part = (long) x,-
              *frac_part = x - *int_part;


         The prototype for d e c o m p o s e could be either

         void decompose(double x, long *int_part, double *frac_part);

         or

         void decompose(double, long *, double *);

               We’ll call d e c o m p o s e in the following way:

         decompose(3.14159, &i, &d);

         Because of the & operator in front of i and d. the arguments to d e c o m p o s e are cbaZYXWVUTSRQPO
         p o in ters lo i and d, not the values of i and d. When d e c o m p o s e is called, the
         value 3.14l59 is copied into x . a pointer to i is stored in i n t _ p a r t , and a
         pointer to d is stored in f r a c _ p a r t :
            C h a p te r 11
2 4 8 ZYXWVUTSRQPONMLKJIHGFEDCBAP o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                      The first assignment in the body of d e c o m p o s e converts the value o f x to type
                                      l o n g and stores it in the object pointed to by i n t _ p a r t . Since i n t _ p a r t
                                      points to i , the assignment puts the value 3 in i :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                          int_part


                                                                        frac part


                                      The second assignment fetches the value that i n t j p a r t points to (the value of
                                      i ) ? which is 3. This value is converted to type d o u b l e and subtracted from x, giv­
                                      ing .l4 l5 9 , which is then stored in the object that f r a c _ p a r t points to:




                                      When d e c o m p o s e retums. i and d will have the values 3 and .l4 l5 9 J u s l as we
                                      originally wanted.
                                           Using pointers as arguments to functions is actually nothing new; w e’ve been
                                      doing it in calls of s c a n f since Chapter 2. Consider the following example:

                                      int i ;

                                      scanf("%d", &i);

                                      We must put the & operator in front of i so that s c a n f is given a pointer     to i ; that
                                                                                                            cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      pointer tells s c a n f where to put the value that it reads. Without the &? s c a n f
                                      would be supplied with the value of i .
                                          Although s c a n f ’s arguments must be pointers, it’s not always true that every
                                      argument needs the & operator. In the following example, s c a n f is passed a
                                      pointer variable:
                                                                   1 1 .4                                                   249 kjihgfedcbaZYXWVU
                                                                            P o i n t e r s a s A r g u m e n t s onmlkjihgfedcbaZYXWVUTSRQPONMLK


                  int i, *p;
                  •••
                  p = &i;
                  scanf("%d”, p ) ;

                  Since p contains the address of i . s c a n f will read an integer and store it in i .
                  Using the & operator in the call would be wrong:

                  scanf("%d", &p);              /*** WRONG ***/

                  s c a n f would read an integer and store it in p instead of in i .


                  Failing to pass a pointer to a function when one is expected can have disastrous
        A         results. Suppose that we call d e c o m p o s e without the & operator in front of i and
                  d:
                  decompose(3.14i59,            i, d);

                  d e c o m p o s e is expecting pointers as its second and third arguments, but it’s been
                  given the v a lu e s of i and d instead, d e c o m p o s e has no way to tell the difference,
                  so it will use the values of i and d as though they were pointers. When d e c o m ­
                  p o s e stores values in * i n t _ p a r t and * f r a c _ p a r t , it will attempt to change
                  unknown memory locations instead of modifying i and d.
                        Lf we've provided a prototype for d e c o m p o s e (as we should always do. of
                  course), the compiler will let us know that w e’re attempting to pass arguments of
                  the wrong type. In the case of s c a n f , however, failing to pass pointers often goes
                  undetected by the compiler, making s c a n f an especially error-prone function.hgfedcbaZYXWVUTSRQPON




                  F in d in g th e L a r g e s t a n d
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA             S m a l le s t E le m e n ts in a n A r r a y

                  To illustrate how pointers are passed to functions, let’s look at a function named
                  m ax _ m in that fmds the largest and smallest elements in an array. When we call
                  m ax_m in, we’ll pass it pointers to two variables: m ax _ m in will then store its
                  answers in these variables, m ax _ m in has the following prototype:

                  void max_min(int a[] , int n, int *max, int *min) ;

                  A call o fm a x _ m in might have the following appearance:

                  max_min(b, N, &big, &small);

                  b is an array of integers; N is the number of elements in b. b i g and s m a l l are
                  ordinary integer variables. When m a x _ m in finds the largest element in b, it stores
                  the value in b i g by assigning it to *max. (Since m ax points lo b i g . an assign­
                  ment to *m ax will modify the value of b i g .) m a x _ m in stores the smallest ele­
                  ment o f b in s m a l l by assigning it to *m in.
                       To test m ax _ m in . we’ll write a program that reads 10 numbers into an array,
                  passes the array to m ax_m in, and prints the results:
2 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 11     P o in te rs kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
                                      Largest: 102
                                      Smallest: 7onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      Here’s the complete program:BA

                   maxmin.c           /★    Finds the largest and smallest elements in an array */

                                      #include <stdio.h>

                                      #define N 10

                                      void max_min(int a[], int n, int *max, int *min);

                                      int main(void)

                                           int b[N], i, big, small;

                                           printf("Enter %d numbers: ", N);
                                           for (i = 0; i < N; i++)
                                             scanf("%d", &b[i]);

                                           max_min(b, N, &big, &small);

                                           printf("Largest: %d\n", big);
                                           printf("Smallest: %d\n", small);

                                           return 0;


                                      void max_min(int a[], int n, int *max, int *min)

                                           int i ;

                                           *max = *min = a[0] ;
                                           for (i = 1; i < n; i++) {
                                             if (a[i] > *max)
                                               *max = a [i];
                                             else if (a[i] < *min)
                                               *min = a [i];dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                      U s i n g c o n s t to P r o t e c t A r g u m e n ts

                                      When we call a function and pass il a pointer to a variable, we normally assume
                                      that the function will modify the variable (otherwise, why would the function
                                      require a pointer?). For example, ifw e see a statement like

                                      f(&x) ;
                                                    1 1 .5                                                        2 51 dcbaZYXWVUTSRQPON
                                                             P o i n t e r s a s R e t u r n V a l u e s hgfedcbaZYXWVUTSRQPONMLKJIHGFED


           in a program, w e’d probably expect f to change the value of x. It’s possible,
           though, that f merely needs to examine the value of x, not change it. The reason
           for the pointer might be efficiency: passing the value of a variable can waste time
           and space if the variable requires a large amount ofstorage. (Section l2.3 covers
           this point in more detail.)
                    We can use the word c o n s t to document that a function w on’t chang e an             <2


           object whose address is passed to the function, c o n s t goes in the parameter’s
           declaration, just before the specification of its type:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
 Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         void f(const int *p)

                *p = 0;     /*** WRONG ***/


         This use of c o n s t indicates that p is a pointer to a “constant integer.” Attempting
         to modify *p is an error that the compiler will detect.aZYXWVUTSRQPONMLKJIHGFEDCBA




1 1 .5    P o in t e r s a s R e tu r n V a lu e s

                                                                                      return
         We can not only pass pointers to functions but also write functions that cbaZYXWVUTSRQPONMLKJIHGFEDCB
         pointers. Such functions are relatively common; w e’ll encounter several in Chapter
         l3.
             The following function, when given pointers to two integers, returns a pointer
         to whichever inte^g*er is lar^g?er:

          int *max(int *a, int *b)

                if (*a > *b)
                  return a;
                else
                  return b;


         When we call max, we’ll pass pointers to two i n t variables and store the result in
         a pointer variable:

          int *p, i, j;
         • ••

         p = max(&i, &j ) ;

         During the call o fm a x , * a is an alias for i , while *b is an alias for j . If i has a
         larger value than j , m ax returns the address of i ; otherwise, it retums the address
         of j . After the call, p points to either i or j .
              Although the m ax function returns one o fth e pointers passed to it as an argu­
         ment, that’s not the only possibility. A function could also return a pointer to an
         external variable or to a local variable that’s been declared s t a t i c .
            C h a p te r 11
2 5 2 ZYXWVUTSRQPONMLKJIHGFEDCBA P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                    autom atic local variable:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       Never return a pointer to an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       int *f(void)

                                           int i;
                                           •••
                                           return &i;


                                       The variable i doesn’t exist once f returns, so the pointer to it will be invalid.
                                       Some compilers issue a warning such as “fu n ctio n returns address o flo c a l vari­
                                       able” in this situation.


                                            Pointers can point to array elements, not just ordinary variables. If a is an
                                       array, then &a [ i ] is a pointer to element i of a. When a function has an array
                                       argument, it’s sometimes useful for the function to return a pointer to one of the
                                       elements in the array. For example, the following function returns a pointer to the
                                       middle element of the array a, assuming that a has n elements:

                                       int *find_middle(int a[], int n) {
                                         return & a [n/2];


                                       Chapter 12 explores the relationship between pointers and arrays in considerable
                                       detail.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                       Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             *Q :     Is a p o in te r a lw a y s th e s a m e a s a n a d d r e s s ? [p . 2 4 2 ]
                                A:     Usually, but not always. Consider a com puter whose main memory is divided into
                                       yvords rather than bytes. A word might contain 36 bits, 60 bits, or some other
                                       number of bits. If we assume 36-bit words, memory will have the following
                                       appearance:

                                                                 A d d re s s                  C o n te n ts

                                                                                001010011001010011001010011001010011

                                                                                001110101001110101001110101001110101

                                                                                001110011001110011001110011001110011

                                                                                001100001001100001001100001001100001

                                                                                001101110001101110001101110001101110



                                                                                001000011001000011001000011001000011
                                                                                                                      2 5 3 onmlkjihgfedcbaZYXWVU
                                                                                                        Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFE


            When memory is divided into words, each word has an address. An integer
       usually occupies one word, so a pointer to an integer can just be an address. How­
       ever, a word can store more than one character. For example, a 36-bit word might
       store six 6-bit characters:GFEDCBA

                                      010011    110101    110011    100001    101110    000011



       or four 9-bit characters:

                                         001010011   001110101       001110011      001100001
                                     !


       For this reason, a pointer to a character may need to be stored in a different form
       than other pointers. A pointer to a character might consist o fa n address (the word
       in which the character is stored) plus a small integer (the position of the character
       within the word).
            On some computers, pointers may be “offsets" rather than complete
       addresses. For example, CPUs in the Intel x86 family (used in many personal com­
       puters) can execute programs in several modes. The oldest of these, which dates
                                                                real m ode. In this mode, addresses
       back to the 8086 processor of 1978, is called cbaZYXWVUTSRQPONMLKJIHGFEDCBA
       are sometimes represented by a single 16-bit number (an offset) and sometimes by
       two 16-bit numbers (a se g m e n t:o ffse t pair). An offset isn’t a true memory address;
       the CPU must combine it with a segment value stored in a special register. To sup­
       port real mode, older C compilers often provide two kinds of pointers: n e a rp o in t-
       ers (16-bit offsets) a n d fa r p o in te r s (32-bit segment:offset pairs). These compilers
       usually reserve the words n e a r and f a r as nonstandard keywords that can be
       used to declare pointer variables.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

*Q :   I f a p o in te r c a n p o in t to data in a p r o g r a m , is it p o s s ib le to h a v e a p o in t e r to
       p r o g r a m code?
 A:    Yes. We’ll cover pointers to functions in Section 17.7.

 Q:    It s e e m s to m e th a t t h e r e ’s a n in c o n s is te n c y b e tw e e n th e d e c la r a tio n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFED

       int *p = &i;
       a n d th e s ta te m e n t

       p = &i;
       W h y is n ’t p p r e c e d e d b y a * s y m b o l in th e s ta te m e n t, a s it is in th e d e c la r a ­
       tio n ? [p . 2 4 4 ]
 A:    The source of the confusion is the fact that the * symbol can have different mean­
       ings in C, depending on the context in which it’s used. In the declaration
       int *p - &i;
       the * symbol i.s not the indirection operator. Instead, it helps specify the type of p,
       informing the compiler that p is a p o in te r to an i n t . When it appears in a statement,
            C h a p te r 11
2 5 4 ZYXWVUTSRQPONMLKJIHGFEDCBAP o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      however, the * symbol performs indirection (when used as a unary operator). The
                                      statement
                                      * p = & i;               /* * *    WRONG * * * /

                                      would be wrong, because it assigns the address of i to the object that p points to.
                                      not to p itself.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Q:      Is th e r e s o m e w a y to p r in t th e a d d r e s s o f a v a r ia b le ? [p . 2 4 4 ]
                              A:      Any pointer, including the address of a variable, can be displayed by calling the
                                      p r i n t f function and using %p as the conversion specification. See Section 22.3
                                      for details.

                              Q:      T h e fo llo w in g d e c la r a tio n is c o n fu s in g :

                                      v o id     f (co n st       in t    * p );

                                      D o e s th is sa y th a t f c a n ’t m o d ify p ? [p. 2 5 1 ]
                              A:                                                         points to\ it doesn’t prevent f
                                      No. It says that f can’t change the integer that p cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      from changing 4pv itself.
                                                    <«*   ^J



                                      v o id     f(c o n st       in t    *p)

                                          in t    j ;

                                          *p = 0 ;              / * * * WRONG * * * /
                                          P = & j;              /* l e g a l * /


                                      Since arguments are passed by value, assigning p a new value— by making it point
                                      somewhere else— won’t have any effect outside the function.

                            *Q :      W h e n d e c la r in g a p a r a m e te r o f a p o in te r ty p e , is it le g a l to p u t th e w o rd
                                      c o n s t in fr o n t o f th e p a r a m e te r ’s n a m e , a s in th e fo llo w in g e x a m p le ?

                                      v o id     f(in t        * co n st p );

                              A:      Yes, although the effect isn’t the same as if c o n s t precedes p ’s type. We saw in
                                      Section 11.4 that putting c o n s t before p ’s type protects the object that p points
                                      to. Putting c o n s t a fte r p 's type protects p itself:
                                      v o id     f(in t        * c o n s t p)

                                          in t    j ;

                                          *p = 0 ;              /* l e g a l * /
                                          p = Scj;              / * * * WRONG * * * /


                                      This feature isn’t used very often. Since p is merely a copy of another pointer (the
                                      aigument when the function is called), there’s rarely any reason to protect it.
                                          An even greater rarity is the need to protect both p and the object it points to,
                                      which can be done by putting c o n s t both before and after p ’s type:
                                                                                                                                              255
                                                                                                                       E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJ


                                v o id f (c o n s t i n t       * c o n s t p)

                                   in t    j ;

                                   *p = 0 ;           / * * * WRONG * * * /
                                   p = & j;           / * * * WRONG * * * /hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                E x e rc is e s

Section 11.2               1.   If i is a variable and p points to i . which of the following expressions are aliases for i ?
                                (a) * p          (c) *&p             (e) * i            (g) *& i
                                (b) &p           (d) &*p             (f) &i             (h) & *i

Section 11.3onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                     © 2.          If i is an i n t variable and p and q are pointers to i n t . which o fth e following assignments
                                are leouaI?
                                (a) p = i ;                 (d) p = &q;                  (g) P = * q ;
                                (b) * p = & i;              (e) p = *&q;                 (h) * p = q,-
                                (c) &p = q ;                (D p = q ;                   (i) * p = *q,-

Section 11.4              3.    The following function supposedly computes the sum and average of the numbers in the
                                array a . which has length n. a v g and sum point to variables that the function should mod­
                                ify. Unfortunately, the function contains several errors; find and correct them.
                                v o i d a v g _ _ s u m ( d o u b le a [ ] ,       in t n,   d o u b le   *avg,      d o u b le    *sum )
                                {
                                    in t i ;

                                   sum = 0 . 0 ;
                                   f o r (i = 0; i < n;                   i+ + )
                                       sum += a [ i ] ;
                                   a v g = sum / n ;


                     ©    4.    Write the following function:
                                v o id    s w a p (in t   *p,      in t    * q );
                                When passed the addresses of two variables, s w a p should exchange the values of the vari­
                                ables:
                                s w a p (& i,    & j);        /*    ex ch an g es v a lu e s        of    i   and j     */

                          5.    Write the following^* function:
                                v o id    s p lit_ tim e (lo n g          to ta l_ s e c ,   in t   * h r,    in t   * m in ,     in t   * se c );
                                t o t a l _ s e c is a time represented as the number of seconds since midnight, h r . m in . and
                                s e c are pointers to variables in which the function will store the equivalent time in hours
                                (0-23), minutes (0-59). and seconds (0-59), respectively.

                     ©    6.    Write the following function:
                                v o id    fin d _ tw o _ la rg e s t(in t           a [ ] , in t n, in t * la r g e s t,
                                                                     in t           * s e c o n d _ la rg e s t);
             C h a p te r 11
2 5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA P o in te rs


                                    When passed an array a of length n. the function will search a for its largest and second-
                                    largest elements, storing them in the variables pointed lo by l a r g e s t and
                                    s e c o n d _ l a r g e s t , respectively.

                              7.    Write the following function:
                                    v o id s p l i t _ d a t e ( i n t d a y _ o f_ y e a r, i n t y e a r,
                                                                 i n t * m o n th , i n t * d a y ) ;
                                    d a y _ o f _ y e a r is an integer between l and 366, specifying a particular day within the year
                                    designated by y e a r , m o n th and d a y point lo variables in which the function will store the
                                    equivalent month ( l - l 2 ) and day within that month ( l- 3 l) .

                                  8.    Write the following^ function:
S e c tio n 11.5 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     in t   * fin d _ la rg e s t(in t a [ ] ,      in t n );
                                    When passed an array a of length n. the function will return a pointer to the array’s largest
                                    element.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     P r o g r a m m in g P r o je c t s

                              l.    Modify Programming Project 7 from Chapter 2 so that il includes the following function:
                                    v o id p a y _ a m o u n t(in t d o l l a r s , i n t * tw e n tie s ,        in t   * te n s ,
                                                              i n t * fiv e s , i n t * o n e s);
                                    The function determines the smallest number of$20, SlO, $5, and Sl bills necessary to pay
                                    the amount represented by the d o l l a r s parameter. The t w e n t i e s parameter points to a
                                    variable in which the function will store the number of S20 bills required. The t e n s ,
                                    f i v e s , and o n e s parameters are similar.

                              2.    Modify Programming Project 8 from Chapler 5 so that it includes the following function:
                                    v o id f i n d _ c l o s e s t _ f l i g h t ( i n t d e s ir e d _ tim e ,
                                                                                   i n t * d e p a rtu re _ tim e ,
                                                                                   in t * a rriv a l_ tim e );
                                    This function will find the flight whose departure time is closest to d e s i r e d _ t i m e
                                    (expressed in minutes since midnight). It will store the departure and arrival times of this
                                    flight (also expressed in minutes since midnight) in the variables pointed to by
                                    d e p a r t u r e _ t i m e and a r r i v a l _ t i i n e , respectively.

                              3.    Modify Programming Project 3 from Chapler 6 so lhal il includes the following function:
                                    v o id r e d u c e ( i n t n u m e ra to r, i n t d e n o m in a to r,
                                                        i n t * re d u c e d _ n u m e ra to r,
                                                        i n t * re d u c e d _ d e n o m in a to r);
                                    n u m e r a t o r and d e n o m i n a t o r are lhe numerator and denominator of a fraction,
                                    r e d u c e d _ n u m e r a t o r and r e d u c e d _ d e n o m i n a t o r are pointers to variables in
                                    which the function will store the numerator and denom inalorofthe fraction once it has been
                                    reduced io lowest terms.

                              4.    Modify the p o k e r . c program of Seclion lO.5 by moving all external variables into main
                                    and modifying functions so lhal ihey communicate by passing arguments. The
                                    a n a l y z e _ h a n d function needs lo change the s t r a i g h t , f l u s h , f o u r , t h r e e , and
                                    p a i r s variables, so it will have to bc passed pointers lo ihose variables.
1 2     P o in te r s a n d A r r a y s                            ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                  O p tim iz a tio n h in d e r s e v o lu tio n . onmlkjihgfedcbaZYXWVU




        Chapter 11 introduced pointers and showed how they’re used as function argu­
        ments and as values returned by functions. This chapter covers anotherapplication
        for pointers. W hen pointers point to array elem ents, C allows us to perform arith­
        metic— addition and subtraction— on the pointers, which leads to an alternative
        way of processing arrays in which pointers take the place o fa rra y subscripts.
              The relationship between pointers and arrays in C is a close one, as we'U soon
        see. W e’ll exploit this relationship in subsequent chapters, including C hapter 13
        (Strings) and C hapter 17 (A dvanced Uses o fP o in iers). U nderstanding the connec­
        tion between pointers and arrays is critical for m astering C: it will give you insight
        into how C was designed and help you understand existing program s. Be aware,
        however, that one o flh e prim ary reasons for using pointers to process arrays— effi­
        ciency— is no longer as im portant as it once was. thanks to improved com pilers.
              Section 12.1 discusses pointer arithm etic and shows how pointers can be com ­
        pared using the relational and equality operators. Section 12.2 then dem onstrates
        how we can use pointer arithm etic for processing array elem ents. Section 12.3
        reveals a key fact about arrays— an array nam e can serve as a pointer to the array’s
        first elem ent— and uses it to show how array argum ents really work. Section 12.4
        shows how the topics o f the first three sections apply to m ultidim ensional arrays.
        Section 12.5 wraps up the chapter by exploring the relationship betw een pointers
        and variable-length arrays, a C99 feature.




 12.1   P o in t e r A r it h m e t ic

        We saw in Section 11.5 that pointers can point to array elem ents. For exam ple,
        suppose that a and p have been declared as follows:hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                                                                         257
           C h a p te r 1 2    P o in te r s a n d A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
2 5 8 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                      in t    a [1 0 ] ,    *p;

                                      We can make p point to a [0] by writing

                                      p = &a [0] ;

                                      Graphically, here's what w e’v eju st done:




                                      We can now access a [0] through p; for example, we can store the value 5 in
                                      a [ 0 ] by writing

                                      *P = 5 ;

                                      H ere’s our picture now:GFEDCBA




                                                                            0    1     2    3     4    5     6    7     8    9


                                           M aking a pointer p point to an elem ent o fa n array a isn’t particularly excit­
                                      ing. However, by RQPONMLKJIHGFEDCBA
                                                         ^ v { o v m x \ g p o i n t e r c i r i t h m e t i c ( o \ a d d r e s s a r i t h m e t i c ) on p , we
                                      can access the other elem ents of a . C supports three (and only tlu*ee) forms of
                                      pointer arithmetic:

                                             Adding an integer to a pointer
                                             Subtracting an integer from a pointer
                                             Subtracting one pointer from another

                                      L et’s take a close look at each of these operations. Our examples assum e that the
                                      following declarations are in effect:

                                      in t    a [1 0 ] ,    *p,     *q,     i ;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      A d d in g a n I n te g e r to a P o in te r

                                      Adding an integer j to a p o in te rp yields a pointer to the element j places after thc
                                      one that p points to. M ore precisely, if p points to the array elem ent a [ i ] , then
                          Q&A         p 4- j points to a [ i + j ] (provided, ofcourse, that a [ i + j ] exists).
                                            The following exam ple illustrates pointer addition; diagram s show the values
                                      o f p and q at various points in the computation.
                                                            12.1                                            2 5 9 GFEDCBA
                                                                       P o in te r A r it h m e tic hgfedcbaZYXWVUTSRQPONMLKJIHGFED




                                                            0   1      2    3    4    5 cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                            6   7    8    9




                                                        a

                                                            0   1      2    3    4    5    6    7     B    9




                                                            0   1      2    3    4    5    6    7     8    9dcbaZYXWVUTSRQPONMLK




S u b tr a c tin g a n I n te g e r fr o m a P o in te r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

If p points to the array element a [ i ] . then p - j points to a [ i - j ]. For example:




                                                            0   1      2    3    4    5    6     7    8    9




                                                            0   1      2    3    4    5    6    7     8    9




                                                            0      1   2    3    4    5    6    7    8    9




S u b tr a c tin g O n e P o in te r f r o m A n o t h e r

When one pointer is subtracted from another, the result is the distance (measured
in array elements) between the pointers. Thus, if p points lo a [ i ] and q points to
a [ j ] , then p - q is equal to i - j . For example:
2 6 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 12      P o in te r s a n d A r r a y s


                                               p = &a [5] ;
                                               q = & a [1] ; GFEDCBA



                                                                                                                  0    1    2       3   4   5   6   7   8   9
                                               i   = p - q;           /*    i   is    4 */
                                               i   = Q " P;           /*    i   is    ^4 * /kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                               Performing arithmetic on a pointer that doesn’t point to an array elem ent causes
                                  A            undefined behavior. Furthermore, the effect of subtracting one pointer from
                                                                                                         sam e array.dcbaZYXWVUTSRQPONMLKJIHGFE
                                               another is undefined unless both point to elements of the cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               C o m p a r in g P o in te r s
                                               We can compare pointers using the relational operators (<, <=, >, >=) and the
                                               equality operators (== and 1=). Using the relational operators to compare two
                                               pointers is meaningful only when both point to elements of the same array. The
                                               outcome of the comparison depends on the relative positions of the two elements
                                               in the array. For example, after the assignments

                                               p = & a [5] ;
                                               q = & a [1] ;

                                               the value o f p <= q is 0 and the value o f p >= q is 1.


                                  < J^ )       P o in te r s to C o m p o u n d L ite r a ls
                                               It’s legal for a pointer to point to an elem ent within an array created by a com-hgfedcbaZ
           c o m p o u n d iite ra is   >s.3   pound literal. A compound literal, you may recall, is a C99 feature that can be used
                                               to create an array with no name.
                                                    Consider the following example:

                                               in t   *p =    (in t        []){ 3 ,    0,   3,    4,    1};

                                               p points to the first element of a five-element array containing the integers 3, 0, 3,
                                               4, and 1. Using a compound literal saves us the trouble of first declaring an array
                                               variable and then making p point to the first element of that array:

                                               i n t a [ ] = { 3 , 0 , 3 , 4 , 1} ;
                                               i n t *p = & a [ 0 ] ;aZYXWVUTSRQPONMLKJIHGFEDCBA




                               1 2 .2          U s in g P o in te r s f o r A r r a y P r o c e s s in g

                                               Pointer arithmetic allows us to visit the elements of an array by repeatedly incre­
                                               menting a pointer variable. The following program fragment, which sums the ele­
                                               ments of an array a , illustrates the technique. In this example, the pointer variable
                                       12.2                                                                         261 onmlkjihgfedcbaZYXW
                                                 U s in g P o in t e r s f o r A r r a y P r o c e s s in g hgfedcbaZYXWVUTSRQPONMLKJIHG


      p initially points to a [ 0 ] . Each time through the loop, p is increm ented; as a
      result, it points to a [ 1 ] , then a [ 2 ] , and so forth. The loop term inates when p
      steps past the last element of a .kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      #define N 10
      «••
      int a [N], sum,          *p;

      sum - 0;
      for (p = &a[0] ; p < &a[N] ; p++)
        sum += *p;

      The following figures show the contents of a , sum , and p at the end of the first
      three loop iterations (before p has been increm ented).

      At the end of the first iteration:




      At the end of the second iteration:




      At the end o fth e third iteration:aZYXWVUTSRQPONMLKJIHGFEDCBA




           The condition p < & a[N ] in the f o r statement deserves special mention.
      Strange as it may seem, it’s legal to apply the address operator to a [N ], even
      though this element doesn’t exist (a is indexed from 0 to N - 1). Using a [N] in
      this fashion is perfectly safe, since the loop doesn’t attem pt to examine its value.
      The body of the loop will be executed with p equal to & a [ 0 ] , & a [ l ] , ...,
      &a [ N - 1 ] , but when p is equal to &a [N ], the loop term inates.
           We could just as easily have written the loop without pointers, of course, using
      subscripting instead. The argum ent most often cited in support o fp o in ter arithm etic
      is that it can save execution time. However, that depends on the im plem entation—
Q&A   som e C compilers actually produce belter code for loops that rely on subscripting.
2 6 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 12      P o in te rs a n d A r ra y s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    C o m b in in g th e * a n d + + O p e r a to r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    C programmers often combine the * (indirection) and ++ operators in statements
                                    that process array elements. Consider the simple case o f storing a value into an
                                    array element and then advancing to the next element. Using array subscripting,
                                    we mioght write

                                    a [ i + +J = j ;

                                    If p is pointing to an array element, the corresponding statem ent would be

                                    *p+ + = j ;

                                    Because the postfix version of ++ takes precedence over *, the com piler sees this
                                    as

                                     * (p+ + )   = j ;

                                    The value o f p + + is p. (Since w e’re using the postfix version of ++. p w on’t be
                                    incremented until after the expression has been evaluated.) Thus, the value of
                                    * (p + + ) will be * p — the object to which p is pointing.
                                          O fcourse, *p++ isn’t the only legal combination of * and ++. We could write
                                     (* p ) ++, for example, which returns the value of the object that p points to, and
                                    then increments that object (p itself is unchanged). If you find this confusing, the
                                    following table may help:cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                               Expression                                        M eaning
                                           *p+ + or * (p+ + )          Value ofexprcssion is *p before increment; increment p later
                                           (* p ) + +                  V alueofexpression is * p before increment; increment *p lalcr
                                           *+ + p or * (+ + p)         Increment p first; value ofexpression is * p after increment
                                           + + * p or ++ ( * p )       Increment *p first: value of expression is *p after increment
                                    All four combinations appear in programs, although some are far more common
                                    than others. The one w e’ll see most frequently is *p+ + , which is handy in loops.
                                    Instead of writing

                                    f o r (p = & a [0 ] ; p < &a[N ] ; p+ + )
                                        sum += * p ;

                                    to sum the elements of the array a, we could write

                                    p = &a [0] ;
                                    w h i l e (p < & a [N ])
                                       sum += * p + + ;

                                         The * and - - operators mix in the same way as * and ++. For an application
                                    that combines * and - - , let’s return to the stack example of Section 10.2. The orig­
                                    inal version o fth e stack relied on an integer variable named t o p to keep track of
                                    the “top-of-stack" position in the c o n t e n t s array. L e fs replace t o p by a pointer
                                    variable that points initially to element 0 of the c o n t e n t s array:

                                    in t    * to p _ p tr = & c o n te n ts [0 ];
                                           1 2 .3                                                            2 6 3 onmlkjihgfedcbaZYXWVUT
                                                    U s in g a n A r r a y N a m e a s a P o in te r hgfedcbaZYXWVUTSRQPONMLKJIHGFED


         Here are the new p u s h and p o p functions (updating the other stack functions is
         left as an exercise):kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         void push(int i)

            if (is_full())
              stack_overflow();
            else
              *top_ptr++ = i;


         int pop(void)

            if (is_empty())
              stack_underflow();
            else
              return *--top_ptr;


         Note that I’ve written * - - t o p _ p t r , not * t o p _ j p t r - - , since 1 want p o p to dec­
                                before fetching the value to which it points.aZYXWVUTSRQPONMLKJIHGFEDCBA
         rement t o p _ j p t r cbaZYXWVUTSRQPONMLKJIHGFEDCBA




1 2 .3   U s in g a n A r r a y N a m e a s a P o in te r

         Pointer arithmetic is one way in which arrays and pointers are related, but it’s not
         the only connection between the two. H ere’s another key relationship: The n am e o f
         an array can be used as a p o in ter to the first elem ent in the array. This relationship
         simplifies pointer arithmetic and makes both arrays and pointers more versatile.
              For example, suppose that a is declared as follows:

         int a [10];

         Using a as a pointer to the first element in the array, we can modify a [ 0 ] :

         *a = 7;         /* stores 7 in a[0] */

         We can modify a [1] through the pointer a + 1:

         *(a+1) = 12;            /* stores 12 in a[l] */

         Tn general, a + i is the same as &a [ i ] (both represent a pointer to element i of a)
         and * ( a + i ) is equivalent to a [ i ] (both represent elem ent i itself^ In other
         words, array subscripting can be viewed as a form ofpointer arithmetic.
              The fact that an array name can serve as a pointer makes it easier to write
         loops that step through an array. Consider the following loop from Section 12.2:

         for (p = &a[0]; p < &a[N]; p++)
           sum += *p;
2 6 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 12      P o in te r s a n d A r r a y s


                                          To simplify the loop, we can replace &a [0] by a and &a [N] by a + N:aZYXWVUTSRQPONMLK

                          id io m          for (p = a; p < a 4- N; p++)
                                       kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                             sum += *p;


                                           Although an array name can be used as a pointer, it’s not possible to assign it a new

                           A               value. Attempting to make it point elsewhere is an error:
                                           while (*a != 0)
                                             a++;   /*** WRONG ***/

                                          This is no great loss: we can always copy a into a pointer variable, then change the
                                          pointer variable:

                                          P = a;
                                          while (*p != 0)
                                            p++;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



               PROGRAM                     R e v e r s in g a S e r ie s o f N u m b e r s (R e v is ite d )

                                           The r e v e r s e . c program ofS ection 8.1 reads 10 numbers, then writes the num­
                                           bers in reverse order. As the program reads the numbers, it stores them in an array.
                                           Once all the numbers are read, the program steps through the array backwards as it
                                           prints the numbers.
                                                The original program used subscripting to access elements of the array. Here’s
                                           a new version in which Tve replaced subscripting with pointer arithmetic.RQPONMLKJIHGFED

                  r e v e r s e 3 .c       /* Reverses a series of numbers (pointer version) */

                                           #include <stdio.h>

                                           #define N 10

                                           int main(void)

                                               int a [N] , *p;

                                               printf("Enter %d numbers: ”, N);
                                               for (p = a; p < a + N; p++)
                                                 scanf("%d", p ) ;

                                               printf("In reverse order:");
                                               for (p = a + N - 1; p >= a; p--)
                                                 printf(" %d", *p);
                                               printf("\n");

                                               return 0;


                                               In the original program, an integer variable i kept track of the current position
                                           within the array. The new version replaces i with p, a pointer variable. The num-
                                  1 2 .3                                                              265
                                           U s in g a n A r r a y N a m e a s a P o in t e r onmlkjihgfedcbaZYXWVUTSRQPONMLKJI


bers arc still stored in an array; w e’re sim ply using a different technique to keep
track o f where we are in the array.
     Note that the second argum ent to s c a n f is p , not &p. Since p points to an
array elem ent, it’s a satisfactory argum ent for s c a n f ; &p. on the other hand,
would be a pointer to a pointer to an array elem ent.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


A r r a y A r g u m e n t s (R e v is ite d )

W hen passed to a function, an array name is always treated as a pointer. C onsider
the following function, which returns the largcst elem ent in an array ofintegers:kjihgfedcbaZYXWVUTSRQPO

int find_largest(int a[], int n)

   int i, max;

   max = a [0];
   for (i = 1; i < n; i++)
     if (a [i] > max)
       max = a [i];
   return max;


Suppose that we call f i n d _ l a r g e s t as follows:

largest = find_largest(b, N);

This call causes a pointer to the first elem ent o f b to be assigned to a ; the array
itself isn’t copied.
     The fact that an array argument is treated as a pointer has som e im portant con­
sequences:

  ■ When an ordinary variable is passed to a function , its value is copied; any
     changes to the corresponding param eter d o n 't affect the variable. In contrast,
     an array used as an argum ent isn't protected against change, since no copy is
     made of the array itself. For exam ple, the following function (which we first
     saw in Section 9.3) modifies an array by storing zero into each o fits elements:

     void store_zeros(int a[], int n)

         int i;

         for (i = 0; i < n; i++)
           a[i] = 0;


     To indicate that an array param eter w on't be changed, we can include the word
     c o n s t in itsdeclaration:

     int find largest(const int a[], int n)
2 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r1 2      P o in t e r s a n d A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              If c o n s t is present, the compiler will check that no assignment to an element
                                              of a appears in the body of f i n d _ l a r g e s t .
                                          ■ The lime required lo pass an array to a function doesn’t depend on the size of
                                             the array. There’s no penalty for passing a large array, since no copy of the
                                             array is made.
                                          ■ An array parameter can be declared as a pointer i f desired. For example,
                                             f i n d _ l a r g e s t could be defined as follows:

                                              i n t f i n d l a r g e s t ( i n t * a z i n t n) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                              Declaring a to be a pointer is equivalent to declaring it to be an array; the
                            Q&A               compiler treats the declarations as though they were identical.kjihgfedcbaZYXWVUTSRQPONMLKJIH


                                                              param eter to be an array is the same as declaring it to be a
                                       Although declaring a cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                           A           pointer, the same isn’t true for a variable. The declaration
                                        int a [10] ;

                                       causes the compiler to set aside space for 10 integers. In contrast, the declaration

                                        int *a;

                                       causes the compiler to allocate space for a pointer variable. In the latter case, a is
                                       not an array; attempting to use it as an array can have disastrous results. For exam­
                                       ple, the assignment

                                        *a = 0;            /*** WRONG ***/

                                       will store 0 where a is pointing. Since we don’t know where a is pointing, the
                                       effect on the program is undefined.


                                          ■ A function with an array parameter can be passed an array “slice”— a sequence
                                             of consecutive elements. Suppose that we want f i n d _ l a r g e s t to locate the
                                                 largest element in some portion o fan array b, say elements b [ 5 ] ..b [1 4 ].
                                             When we call f i n d _ l a r g e s t , weTl pass it the address of b [5] and the
                                             number 10, indicating that we want f i n d _ l a r g e s t to examine 10 array
                                             elements, starting at b [5] :

                                              largest = find_largest(&b[5], 10);


                                       U s in g a P o in te r a s a n A r r a y N a m e

                                       Tf wc can use an array name as a pointer, will C allow us to subscript a pointer as
                                       though it were an array name? By now, you’d probably expect the answer to be
                                       yes, and you’d be right. Here’s an example:
                                       1 2.4                                                                      267
                                               P o in t e r s a n d M u lt id im e n s io n a lA r r a y s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


         #define N 10

         int a[N], i, sum = 0, *p = a;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
         •••


         for (i = 0; i < N; i++)
           sum += p[i];onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         The compiler treats p [ i ] as * ( p + i ) , which is a perfectly legal use of pointer
         arithmetic. Although the ability to subscript a pointer may seem to be little more
         than a curiosity, w e’ll see in Section 17.3 that it’s actually quite useful.aZYXWVUTSRQPONMLKJIHGFEDCBA




1 2 .4   P o in t e r s a n d M u lt id im e n s i o n a l A r r a y s

         Just as pointers can point to elements of one-dimensional arrays, they can also
         point to elements of multidimensional arrays. In this section, w e’ll explore com ­
         mon techniques for using pointers to process the elements of multidimensional
         arrays. For simplicity. I’ll stick to two-dimensional arrays, but everything w e’ll do
         applies equally to higher-dimensional arrays.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



         P r o c e s s in g th e E le m e n ts o f a M u ltid im e n s io n a l A r r a y

         We saw in Section 8.2 that C stores two-dimensional arrays in row-major order; in
         other words, the elements of row 0 come first, followed by the elements of row l,
         and so forth. An array with r rows would have the following appearance:

                                    ro w 0           ro w 1                  ro w r - 1




         We can take advantage of this layout when working with pointers. If we make a
         pointer p point to the first element in a two-dimensional array (the elem ent in row
         0, column 0), we can visit every elem ent in the array by incrementing p repeatedly.
              As an example, let’s look at the problem of initializing all elements of a two-
         dimensional array to zero. Suppose that the array has been declared as follows:

         int a[NUM_ROWS][NUM_COLS];

         The obvious technique would be to use nested f o r loops:

         int row, col;

         for (row = 0; row < NUM_ROWS; row++)
           for (col = 0; col < NUM_COLS; col++)
             a[row] [col] = 0;
2 6 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r1 2      P o in t e r s a n d A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        But if we view a as a one-dimensional array of integers (which is how it’s stored),
                                        we can replace the pair o f loops by a single loop:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        int *p,-

                                        for (p = & a [ 0 ] [0]; p <= &a[NUM_ROWS-l][NUM_COLS-1]; p++)
                                          *p = 0;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       The loop begins with p pointing to a [0] [ 0 ] . Successive increments o f p make
                                       it point to a [ 0 ] [ 1 ] , a [ 0 ] [ 2 ] . a [ 0 ] [ 3 ] , and so on. When p reaches
                                       a [0] [NUM_COLS-1] (the last element in row 0), incrementing it again makes
                                       p point lo a [1] [ 0 ] , the first element in row 1. The process continues until p
                                       goes past a [NUM_ROWS-1] [N U M _COLS-1]. the last element in the array.
                                            Although treating a two-dimensional array as one-dim ensional may seem like
                            Q&A        cheating, it works with most C compilers. W hether it’s a good idea to do so is
                                       another matter. Techniques like this one definitely hurt program readability, but—
                                       at least with some older com pilers— produce a com pensating increase in effi­
                                       ciency. With many modern compilers, though, there’s often little or no speed
                                       advantaaoe.


                                       P r o c e s s in g th e R o w s o f a M u ltid im e n s io n a l A r r a y

                                                                                            row o f a two-dimensional array?
                                       W hat about processing the elem ents in just one cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       Again, we have the option of using a pointer variable p. To visit the elements of
                                       row i , w e’d initialize p to point lo element 0 in row i in the array a:

                                       p = &a [i] [0] ;

                                        Or we could simply write

                                       p = a [il ;

                                       since, for any two-dimensional array a, the expression a [ i ] is a pointer to the
                                       first element in row i . To see why this works, recall the magic formula that relates
                                       array subscripting to pointer arithmetic: for any array a , the expression a [ i ] is
                                       equivalent to * (a + i ). Thus, &a [ i ] [ 0 ] is the sam e as & (* (a [ i ] + 0 ) ) ,
                                       which is equivalent to t * a [ i ] , which is the same as a [ i ] , since the & and *
                                       operators cancel. W e’ll use this simplification in the following loop, which clears
                                       row i of the array a:

                                        int a[NUM_ROWS][NUM_COLS],                           *p,     i;

                                        for (p = a [ i ] ; p < a[i]                    + NUM_COLS; p++)
                                          *p = 0;

                                            Since a [ i ] is a pointer to row i of the array a , we can pass a [ i ] to a
                                        function that’s expecting a one-dimensional array as its argument. In other words,
                                        a function that’s designed lo work with one-dim ensional arrays will also work
                                        with a row belonging to a two-dimensional array. As a result, functions such as
                             1 2 .4                                                                    269onmlkjihgfedcbaZYXWV
                                      P o in te rs a n d M u ltid im e n s io n a l A r r a y s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


f i n d _ l a r g e s t and s t o r e _ z e r o s are more versatile than you might expect.
Consider f i n d _ l a r g e s t , which we originally designed to find the largest ele­
ment of a one-dim ensional array. We can just as easily use f i n d _ l a r g e s t to
determ ine the largest elem ent in row i o fth e two-dimensional array a:

largest = find_largest(a[i], NUM_COLS);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


P r o c e s s in g th e C o lu m n s o f a M u ltid im e n s io n a l A r r a y

                               colum n of a tw o-dimensional array isn’t as easy,
Processing the elements in a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
because arrays are stored by row, not by column. H ere’s a loop that clears column
i of the array a:

int a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS], i;

for (p = &a[0] ; p < &a[NUM_ROWS] ; p++)
  (*p) [i] = 0;

I’ve declared p to be a pointer to an array of length NUM_COLS whose elem ents
are integers. The parentheses around *p in (* p ) [NUM_COLS] are required;
without them, the com piler would treat p as an array of pointers instead of a
pointer to an array. The expression p + + advances p to the beginning of the next
row. In the expression (* p ) [ i ] , * p represents an entire row o f a , so (* p ) [ i ]
selects the elem ent in column i of that row. The parentheses in (* p ) [ i ] are
essential, because the com piler would interpret * p [ i ] as * (p [ i ] ).


U sin g th e N a m e o f a M u lt id im e n s io n a l A r r a y a s a P o in te r

Just as the name of a one-dim ensional array can be used as a pointer, so can the
name of any array, regardless o f how many dim ensions it has. Som e care is
required, though. Consider the following array:

int a [NUM_ROWS][NUM_COLS];

a is not a pointer to a [0] [ 0 ] ; Instead, it’s a pointer to a [ 0 ] . This makes more
sense if we look at it from the standpoint o f C, which regards a not as a two-
dimensional array but as a one-dim ensional array whose elem ents are one­
dimensional arrays. When used as a pointer, a has type i n t (* ) [NUM_COLS]
(pointer to an integer array of length NUM_COLS).
     Knowing that a points to a [0 ] is useful for sim plifying loops that process the
elements o f a two-dimensional array. For example, instead ofw ritin g

for (p = &a[0] ; p < &a[NUM_ROWS] ; p+ + )
  (*p) [iJ = 0;

to clear column i of the array a , we can write

for (p = a; p < a + NUM_ROWS; p++)
  (*p) [i] = 0;
2 7 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 12      P o in te rs a n d A rra y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                          Another situation in which this knowledge comes in handy is when we wanl
                                                     to “trick” a function into thinking that a multidimensional array is really one­
                                                     dimensional. For example, consider how we might use f i n d _ l a r g e s t to find
                                                     the largest element in a. As the first argument to f i n d _ l a r g e s t , let’s try
                                                     passing a (the address of the array); as the second, w e’ll pass NUM_ROWS *
                                                     NUM_COLS (the total number of elements in a):kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     largest = find_largest(a,             NUM_ROWS * NUM_COLS);               /* WRONG */

                                                     Unfortunately, the compiler will object to this statement, because the type of a is
                                                     i n t (* ) [NUM_COLS] but f i n d _ l a r g e s t is expecting an argument of type
                                                     i n t *. The correct call is dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     largest = find_largest(a[O],              NUM_ROWS * NUM_COLS);

                                               a [0] points to element 0 in row 0, and it has type i n t * (after conversion by the
                                               compiler), so the latter call will work correctly.
                                       Q&A aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   1 2 .5            P o in t e r s a n d V a r ia b le -L e n g t h A r r a y s ( C 9 9 )

                                                     Pointers are allowed to point to elements of variable-length arrays (VLAs), a fea­
       v a r ia b le -le n g th a r ra y s > 8 . 3   ture ofC 99. An ordinary pointer variable would be used to point to an elem ent ofa
                                                     one-dimensional VLA:

                                                     void f (int n)
                                                     {
                                                         int a [n], *p;
                                                         P = a;



                                                         When the VLA has more than one dimension, the type of the pointer de­
                                                     pends on the length of each dimension except for the first. L et’s look at the two-
                                                     dimensional case:

                                                     void f(int m z int n)

                                                         int a [m] [n] , (*p) [n] ;
                                                         P = a;



                                                                                                                                  variably
                                                     Since the type o f p depends on n, which isn’t constant, p is said to have a cbaZYXWVUTSRQPON
                                                     m o d ified type. Note that the validity of an assignment such as p = a can’t always
                                                     be determined by the compiler. For example, the following code will compile but is
                                                     correct only ifm and n are equal:

                                                     int a [m] [n] , (*p) [m] ;
                                                     P = a;
                                                                                                                    271 onmlkjihgfedcbaZYXWVU
                                                                                                      Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFE


       If m * n. any subsequent use of p will cause undefined behavior.
            Variably modified types are subject to certain restrictions, just as variable-
       length arrays are. The most important restriction is that the declaration of a vari­
       ably modified type must be inside the body of a function or in a function proto­
       type.
            Pointer arithmetic works with VLAs just as it does for ordinary arrays.
       Returning to the example of Section l2.4 that clears a single column of a two-
       dimensional array a, let's declare a as a VLA this time:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

       int a [m] [n];

       A pointer capable of pointing to a row of a would be declared as follows:

       int (*p)[n];

       The loop that clears column i is almost identical to the one we used in Section
       12.4:

        for (p = a; p < a + m; p++)
          (*p) li] = 0;aZYXWVUTSRQPONMLKJIHGFEDCBA




        Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

 Q:    I d o n ’t u n d e r s ta n d p o in te r a r it h m e t ic . I f a p o in te r is a n a d d r e s s, d o e s th a t
       m e a n th a t a n e x p r e s s io n lik e p + j a d d s j to th e a d d r e s s s to r e d in p ? [p . 2 5 8 ]
 A:    No. Integers used in pointer arithmetic are scaled depending on the type of the
       pointer. If p is of type i n t *, for example, then p + j typically adds 4 x j to p.
       assuming that i n t values are stored using 4 bytes. But if p has type d o u b l e *,
       then p + j will probably add 8 x j to p, since d o u b l e values are usually 8 bytes
       lont*i^-.

 Q:    W h e n w r itin g a lo o p to p r o c e s s a n a r r a y , is it b e tte r to u se a r r a y s u b s c r i p t in g
       o r p o in te r a r ith m e tic ? [p . 2 6 1 ]
 A:    There’s no easy answer to this question, since il depends on the machine youTe
       using and the compiler itself. In the early days of C on the PD P-11, pointer arith­
       metic yielded a faster program. On today’s machines, using today's compilers,
       array subscripting is often just as good, and sometimes even better. The bottom
       line: Learn both ways and then use whichever is more natural for the kind of pro­
       gram you’re writing.

*Q :   I r e a d s o m e w h e r e th a t i [ a ] is th e s a m e a s a [ i ] . Is th is tr u e ?
 A:    Yes, it is, oddly enough. The com piler treats i [a ] as * ( i + a ) , which is the same
       as * ( a + i ) . (Pointer addition, like ordinary addition, is commutative.) But
       * (a + i ) is equivalent to a [ i ] . Q.E.D. But please don’t use i [a ] in programs
       unless you’re planning to enter the next Obfuscated C contest.
2 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 12     P o in te r s a n d A r r a y s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                             Q:     W h y is * a th e s a m e a s a [] in a p a r a m e te r d e c la r a tio n ? [p , 2 6 6 ] onmlkjihgfedcbaZYXWVUTSRQPONM
                             A:      Both indicate that the argument is expected lo be a pointer. The same operations on
                                     a are possible in both cases (pointer arithmetic and array subscripting, in particu­
                                     lar). And, in both cases, a itself can be assigned a new value within the function.
                                                                                              variable only as a “constani
                                     (Although C allows us to use the name of an array cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     pointer,’’ there’s no such restriction on the name of an array param eter.)

                             Q:     Is it b e tte r s ty le to d e c la r e a n a r r a y p a r a m e te r a s * a o r a [] ?
                             A:     That’s a tough one. From one standpoint, a [] is the obvious choice, since * a is
                                    ambiguous (does the function want an array of objects or a pointer to a single
                                    object?). On the other hand, many programmers argue that declaring the parameter
                                    as * a is more accurate, since it reminds us that only a pointer is passed, not a copy
                                    of the array. Others switch between * a and a [ ] , depending on whether the func­
                                    tion uses pointer arithmetic or subscripting to access the elements of the array.
                                    (That’s the approach I’ll use.) In practice, * a is more common than a [ ] , so you’d
                                    better get used to it. For what it’s worth, Dennis Ritchie now refers to the a []
                                    notation as “a living fossil” that “serves as much to confuse the learner as to alert
                                    the reader.”
                                                        •
                             Q:     W e ’v e s e e n th a t a r r a y s a n d p o in te r s a r e c lo s e ly r e la te d in C . W o u ld it b e a c c u ­
                                    r a te to s a y th a t t h e y ’re in te r c h a n g e a b le ?
                             A:     No. It’s true that array param eters are interchangeable with pointer parameters, but
                                    array variables aren’t the same as pointer variables. Technically, the name of an
                                    array isn’t a pointer; rather, the C compiler converts it to a pointer when necessary.
                                    To see this difference more clearly, consider what happens when we apply the
                                    s i z e o f operator to an array a. The value of s i z e o f (a ) is the total number of
                                    bytes in the array— the size ofeach element multiplied by the number ofelements.
                                    But i f p is a pointer variable, s i z e o f (p ) is the number ofbytes required to store
                                    a pointer value.

                             Q:      Y ou sa id th a t tr e a tin g a tw o -d im e n s io n a l a r r a y a s o n e - d im e n s io n a l w ork s
                                    w ith “ m o st” C c o m p ile r s . D o e s n ’t it w o r k w ith a ll c o m p ile r s ? [p . 2 6 8 ]
                             A:     No. Some modern “bounds-checking” compilers track not only the type of a
                                    pointer, but— when it points to an array— also the length of the array. For example,
                                    suppose that p is assigned a pointer to a [0] [ 0 ] . Technically, p points to the first
                                    element of a [ 0 ] , a one-dimensional array. If we increment p repeatedly in an
                                    effort to visit all the elements of a, w e’ll go out ofbounds once p goes past the last
                                    element of a [ 0 ] . A compiler that performs bounds-checking may insert code to
                                    check that p is used only to access elements in the array pointed to by a [ 0 ] : an
                                    attempt to increment p past the end of this array would be detected as an error.

                            Q:      I f a is a tw o -d im e n s io n a l a r r a y , w h y c a n w e p a s s a [ 0 ] — b u t n o t a it s e lf — to
                                     f i n d _ l a r g e s t ? D o n ’t b o th a a n d a [ 0 ] p o in t to th e s a m e p la c e (th e b e g in ­
                                    n in g o f th e a r r a y )? [p. 2 7 0 ]
                             A:     They do, as a matter of fact— bolh point to element a [ 0 ] [ 0 ] . The problem is that
                                                                                                                                        273onmlkjihgfedcbaZYXW
                                                                                                                 E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJI


                                  a has the wrong type. When used as an argument, if s a pointer to an array, but
                                  f i n d _ l a r g e s t is expecting a pointer to an integer. However, a [ 0 ] has type
                                  i n t *. so iCs an acceptable argument for f i n d _ l a r g e s t . This concern about
                                  types is actually good; if C w eren’t so picky, we could make all kinds of horrible
                                  pointer mistakes without the com piler noticing.




                                  E x e r c is e s

S e c t io n 1 2 .1         1.    Suppose that the following declarations are in effect:
                                  i n t a [ ] = {5, 1 5 , 3 4 , 5 4 , 1 4 ,          2,   52,    72};
                                  i n t *p = & a [ l ] , * q = & a [ 5 ] ;
                                  (a)   What is the value of * ( p + 3 ) ?
                                  (b)   What is the value of * ( q - 3) ?
                                  (c)   What is the value of q - p ?
                                  (d)   ls the condition p < q irue or false?
                                  (e)   Is the condition *p < * q true or false?

                      © *2.       Suppose that h i g h , low , and m i d d l e are all pointer variables of the same type, and that
                                  lo w and h i g h point to elements of an array. Why is the following statement illegal, and
                                  how could it be fixed?
                                  m i d d l e = (lo w + h i g h )      /   2;

S e c t io n 1 2 .2         3.    Whal will bc the contents of the a array after the following statements are executed?
                                  # d e f i n e N 10
                                  i n t a [N ] = { 1 , 2 , 3 , 4 , 5 , 6 ,           7, 8,      9,   10};
                                  i n t *p = & a [ 0 ] , * q = & a [ N - l ] ,       te m p ;
                                  w h i l e (p    < q) {
                                     te m p =     *p;
                                     *p++ =       *q;
                                     * q -- =     te m p ;


                      ©     4.    Rewrite the m a k e _ e m p ty , i s _ e m p t y . and i s _ f u l l functions of Section 10.2 to use the
                                  pointer variable t o p _ p t r instead of the integer variable t o p .

                               5.     Suppose that a
S e c t io n 1 2 .3 ZYXWVUTSRQPONMLKJIHGFEDCBA    is a onc-dimensional array and p is a pointer variable. Assuming that the
                                  assignment p = a has just been performed, which of the foliowing expressions are illegal
                                  because ofm ism atched types? O fth e remaining expressions, which are true (have a nonzero
                                  value)?
                                  (a) p == a [ 0 ]
                                  (b) p == & a[0 ]
                                  (c) * p == a [ 0 ]
                                  (d) p [ 0 ] == a [ 0 ]

                      ©     6.    Rewrite the following function to use pointer arithmetic instead of array subscripting, (ln
                                  other words, eliminate the variable i and all uses of the [] operator.) Make as few changes
                                  as possible.
274ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p t e r 12     P o in te rs a n d A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     in t     su m _ a rra y (c o n st in t a [ ] ,         i n t n)

                                         in t    i,   sum ;
                                         sum = 0 ;
                                         f o r (i = 0; i < n ;               i+ + )
                                             sum += a [ i ] ;
                                         r e t u r n sum ;


                               7.    Write the followinat^ function:
                                     bool se a rc h (c o n st in t a [],                in t n,          in t k e y );
                                     a is an array to be searched, n is the number of elements in lhc array, and k e y is the search
                                     key. s e a r c h should return t r u e if k e y matches some element of a, and f a l s e if it
                                     doesn’t. Use pointer arithmetic— not subscripting— to visit array elements.

                               8.    Re\vritc the following function to use pointer arithmetic instead of array .subscripting. (In
                                     other words, eliminate the variable i and all uses ofthe [] operator.) Make as few changes
                                     as possible.
                                     v o id s t o r e _ z e r o s ( i n t a [ ] ,      i n t n)
                                     {
                                         in t i ;
                                         f o r ( i = 0;         i < n;       i+ + )
                                             a [ i ] = 0;


                               9.    Write the following function:
                                     d o u b le in n e r _ p r o d u c t( c o n s t d o u b le * a,            c o n s t d o u b le   *b,
                                                                          in t n ) ;
                                     a and b both point to arrays of length n. The function should return a [ 0 ] * b [ 0 ] +
                                     a [1] * b [1] + ... + a [ n - 1 ] * b [ n - 1 ] . Use pointer arithmetic— not subscripting—to
                                     visit array elements.

                              10.    Modify the f i n d _ m i d d l e function of Section 11.5 so that it uses pointer arithmetic to
                                     calculate the return value.

                              II.    Modify the f i n d _ l a r g e s t function so that it uses pointer arithmetic— not subscript­
                                     ing— to visit array elements.

                              12.    Write the following function:
                                     v o id     fin d _ _ tw o _ la rg e s t(c o n s t i n t *a, i n t n, i n t               * la rg e s t,
                                                                             in t * s e c o n d _ la rg e s t);
                                     a points to an array of length n. The function searches the array for its largest and second-
                                     largest elements, storing them in the variables pointed to by l a r g e s t and
                                     s e c o n d —l a r g e s t , respectively. Use pointer arithmetic— not subscripting— to visit array
                                     elements.aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c t io n 1 2 .4     ©     l3.    Section 8.2 had a program fragment in which two nested f o r loops initialized !he aiTay
                                     i d e n t for use as an identity matrix. Rewrite this code, using a single pointer to step
                                                                              Hint: Since we won’t be using ro w and c o l index
                                     through the array one element at a lime. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     variables, it wonT be easy to tell where to store 1. Instead, we can use the fact that the first
                                     element of the array should be I. the next N elements should be 0, the next element should
                                                                                                            2 7 5 onmlkjihgfedcbaZYXW
                                                                    P ro g ra m m in g P ro je c ts hgfedcbaZYXWVUTSRQPONMLKJIHG


          be 1. and so forth. Use a variable to keep track of how many consecutive 0s have been
          stored; when the count reaches N, it’s time to store 1.

    14.   Assume that the following array contains a week’s worth o fh o u rly temperature readings,
          with each row containing the readings for one day:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          int temperatures[7] [24] ;
          Write a statement that uses the s e a r c h function (see Exercise 7) to search the entire
          t e m p e r a t u r e s array for the value 32.

©   15.   Write a loop that prints all temperature readings stored in row i of the t e m p e r a t u r e s
          array (see Exercise 14). Usc a pointer to visit each element of the row.

    16.   Write a loop that prints the highest temperature in the t e m p e r a t u r e s array (see Exercise
          14) for each day of the week. Thc loop body should call the f i n d _ l a r g e s t function,
          passing il one row of the array at a lime.

    17.   Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
          other words, eliminate the variables i and j and all uses of the [] operator.) Use a single
          loop instead of nested loops.
          int sum_two_dimensional_array(const int a[] [LEN], int n)

              int i , j , sum = 0;
              for (i = 0; i < n; i++)
                for (j = 0; j < LEN; j++)
                  sum += a [i] [j ] ;
              return sum;
          }

    18.   W rite the e v a l u a t e _ p o s i t i o n function described in Exercise 13 o f Chapter 9. Use
          pointer arithmetic— not subscripting— to visit array elements. Use a single loop instead of
          nested loops.aZYXWVUTSRQPONMLKJIHGFEDCBA




          P r o g r a m m in g P r o je c t s

©    1.   (a) Write a program that reads a message, then prints the reversal o fth e message:
          Enter a message: Don’t get mad, get even.
          Reversal is: .neve teg ,dam teg t ’noDcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          H int: Read lhc message one character at a time (using g e t c h a r ) and store the characters in
          an array. Stop reading when the array is full or the character read is ' \ n ’ .
          (b) Revise the program to use a pointer instead of an integer to keep track of the current
          position in the array.

     2.   (a) Write a program that reads a message, then checks whether it’s a palindrome (the letters
          in the message are the same from left to right as from right to left):
          Enter a message: He lived as a devil, eh?
          Palindrome
          Enter a message: Madam, I am Adam.
          Not a palindrome
2 7 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 12      P o in te r s a n d A r r a y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       Ignore all characters that aren’t letters. Use integer variables to keep track ofpositions in the
                                       array.
                                       (b) Revise the program to use pointers instead of integers to keep track of positions in the
                                       array.

                         ©      3.     Simplify Programming Project l(b) by taking advantage of the fact that an array name can
                                       be used as a pointer.

                                4.     Simplify Programming Project 2(b) by taking advantage of the fact that an array name can
                                       be used as a pointer.

                                5.     Modify Programming Project 14 from Chapter 8 so that it uses a pointer instead of an inte­
                                       ger to keep track of the current position in the array that contains the sentence.

                                6.     Modify the q s o r t . c program of Section 9.6 so that low , h i g h , and m i d d l e are pointers
                                       to array elements rather than integers. The s p l i t function will need to retum a pointer, not
                                       an inte*s^-er.

                                7.     Modify the m a x m in .c program of Section 11.4 so that the m a x _ m in function uses a
                                       pointer instead o fan integer to keep track o fth e current position in the array.
1 3       S t r in g s         cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                             It’s difficult to extract sense from strings, but
                                                   they’re the only communication coin we can count on. onmlkjihgfedcbaZYXWV




          Although we’ve used c h a r variables and arrays of c h a r values in previous chap­
          ters, we still lack any convenient way to process a series of characters (a string, in
          C terminology). We’ll remedy that defect in this chapter, which covers both string
          constants (or literals, as they’re called in the C standard) and string variables.
          which can change during the execution o fa program.
                Section l3 .l explains the rules that govern string literals, including the rules
          for embedding escape sequences in string literals and for breaking long string liter­
          als. Section l3.2 then shows how to declare string variables, which are simply
          arrays of characters in which a special character— the null character— marks the
          end of a string. Section 13.3 describes ways to read and write strings. Section l3.4
          shows how to write functions that process strings, and Section l3.5 covers some of
          the string-handling functions in the C library. Section l3.6 presents idioms that are
          often used when working with strings. Finally. Section l3.7 describes how to set
          up arrays whose elements are pointers to strings of different lengths. This section
          also explains how C uses such an array to supply command-line information to
          programs.




 1 3 .1   S t r in g L it e r a ls

          A strin g literal is a sequence of characters enclosed within double quotes:

          "When you come t o a f o r k i n t h e r o a d ,            ta k e i t . "

          We first encountered string literals in Chapter 2; they often appear as format
          strings in calls o f p r i n t f and s c a n f .kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                       277
2 7 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13     S tr in g s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            E s c a p e S e q u e n c e s in S t r i n g L it e r a ls aZYXWVUTSRQPONMLKJIHGFEDCBA

                                            String literals may contain the same escape sequences as character constants.
          e s c a p e s e q u e n c e s > z s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            We've used character escapes in p r i n t f and s c a n f formal strings for some
                                            time. For example, w e’ve seen that each \ n character in the string kjihgfedcbaZYXWVUTSRQPONMLKJI

                                            "Candy\nIs dandy\nBut liquor\nIs quicker.\n                                    --Ogden Nash\n"

                                            causes the cursor to advance to the next line:

                                            Candy
                                            Is dandy
                                            But liquor
                                            Is quicker.
                                              --Ogden Nash

                                            Although octal and hexadecimal escapes are also legal in string literals, they’re not
                                            as common as character escapes.


                                            Be careful when using octal and hexadecimal escape sequences in string literals.

                             A              An octal escape ends after three digits or with the first non-octal character. For
                                            example, the string " \ 1 2 3 4 " contains two characters ( \ 1 2 3 and 4), and the
                                            string " \ 1 8 9 " containslhreecharacters ( \ 1 , 8, and 9). A hexadecimal escape, on
                                            the other hand, isn’t limited to three digits; it doesn’t end until the first non-hex
                                            character. Consider whal happens if a string contains the escape \ x f c . which rep­
                                                                    ii in the Latinl character set, a common extension of ASCII.
                                            resents the character cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            The string " Z \ x f c r i c h 1* (“Zurich”) has six characters (Z. \ x f c , r , i , c, and
                                            h), but the string ” \ x f c b e r " (a failed attempt at “liber”) has only two ( \ x f c b e
                                            and r). Most compilers will object to the latter string, since hex escapes are usually
                              Q&A           limited to the range \ x O - \ x f f .



                                            C o n tin u in g a S tr in g L ite r a l

                                            If we find that a string literal is too long to fit conveniently on a single line, C
                                            allows us to continue il on the next line, provided that we end the first line with a
                                            backslash character ( \) . No other characters may foLlow \ on the same line, other
                                            than the (invisible) new-line character at the end:

                                            printf("When you come to a fork in the road, take it.
                                            --Yogi Berra”);

                                            ln general, the \ character can be used tojoi.n two or more lines of a program into
                                            a single line (a process that the C standard refers to as “splicing”). We'll see more
                                            examples ofsplicing in Section 14.3.
                                                  The \ technique has one drawback: the siring must continue at the beginning
                                            o fth e next line, thereby wrecking the program’s indented structure. There's a bet­
                                            ter way to deal with long siring literals, thanks to lhe following rule: when two or
                                            more string literals are adjacent (separated only by white space), the compiler will
                                                           13.1                                  279onmlkjihgfedcbaZYXWV
                                                                    S trin g L ite r a ls kjihgfedcbaZYXWVUTSRQPONMLKJIHG


join them into a single string. This rule allows us to split a string literal over two or
 more lines:

printf("When you come to a fork in the road, take it.
       "--Yogi Berra’1);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


H o w S tr in g L it e r a ls A r e S to r e d

We’ve used string literals often in calls o t'p r i n t f and s c a n f . But when we call
p r i n t f and supply a string literal as an argument, what are we actually passing?
To answer this question, we need to know how string literals are stored.
      In essence, C treats string literals as character arrays. When a C compiler
encounters a string literal of length RQPONMLKJIHGFEDCBA
                                         n in a program, it sets aside n + 1 bytes of
memory for the string. This area of memory will contain the characters in the
string, plus one extra character— the n u l l c h a r a c t e r — to mark the end o fth e string.
The null character is a byte whose bits are all zero, so it’s represented by the \ 0
escape sequence.


Don’t confuse the null character ( 1 \ 0 1 ) with the zero character ( ’ 0 ’). The null
character has the code 0; the zero character has a different code (48 in ASCII).


     For example, the string literal " a b c ” is stored as an array of four characters
(a, b, c, and \0 ):




String literals may be empty: the string " " is stored as a single null character:


                                                 \o


     Since a string literal is stored as an array, the compiler treats it as a pointer of
type c h a r *. Both p r i n t f and s c a n f . for example, expect a value of type
c h a r * as theirfirst argument. Consider the following example:

printf("abc");

When p r i n t f is called, it’s passed the address of ’’a b c ” (a pointer to where the
letter a is stored in memory).


O p e r a tio n s o n S tr in g L ite r a ls

In general, we can use a string literal wherever C allows a c h a r * pointer. For
example, a string literal can appear on the right side of an assignment:
2 8 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S tr in g s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       char *p;

                                      p = "abc";onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      This assignment doesn't copy the characters in " a b c ” ; it merely makes p point to
                                      the first character of the string .       o


                                           C allows pointers to be subscripted, so we can subscript string literals:

                                       chai^ ch;

                                       ch = "abc"[1];

                                      The new value of c h will be the letter b. The other possible subscripts are 0 (which
                                      would select the letter a). 2 (the letter c). and 3 (the null character). This property
                                      of string literals isn’t used that much, but occasionally it’s handy. Consider the fol­
                                      lowing function, which converts a number between 0 and 15 into a character that
                                      represents the equivalent hex digit:

                                       char digit_to_hex_char(int digit)

                                           return "0X23456789ABCDEF"[digit];



                                       Attempting to modify a string literal causes undefined behavior:
                                       char *p = "abc";

                                       *p = 'd';              /*** WRONG ***/dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                           Q&A        A program that tries to change a string literal may crash or behave erratically.




                                      S tr in g L ite r a ls v e r s u s C h a r a c te r C o n s ta n ts

                                      A string literal containing a single character isift the same as a character constant.
                                                                                   p o in ter to a memory location that con­
                                      The string literal " a " is represented by a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      tains the character a (followed by a null character). The character constant ’ a ’ is
                                      represented by an integer (the numerical code for the character).


                                      Don’t ever use a character when a string is required (or vice versa). The call
                                      printf(”\n”);

                                      is legal, because p r i n t f expects a pointer as its first argument. The following
                                      call isn’t legal, however:
                                      printf('\n*);                   /*** WRONG ***/
                                                                                1 3 .2                                    281 aZYXWVUTSRQPON
                                                                                         S tr in g V a ria b le s hgfedcbaZYXWVUTSRQPONMLKJIHG




1 3 .2        S t r i n g V a r i a b l e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

             Som e programming languages provide a special s t r i n g type for declaring string
             variables. C takes a different tack: any one-dim ensional array of characters can be
             used to store a string, with the understanding that the string is term inated by a null
             character. This approach is simple, but has significant difficulties. Tt’s sometim es
             hard to tell whether an array of characters is being used as a string. If we write our
             own string-handling functions, w e’ve got lo be careful that they deal properly with
             the null character. Also, there’s no faster way to determ ine the length of a string
             than a character-by-character search for the null character.
                   L et’s say that we need a variable capable of storing a string of up to 80 charac­
             ters. Since the string will need a null character at the end, w e’ll declare the variable
             to be an array o f8 1 characters:

id io m       #define STR_LEN 80
          kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



              char str[STR_LEN+l];

             We defined STR_LEN to be 80 rather than 81. thus em phasizing the fact that s t r
             can store stringG*s of no more than 80 characters, and then ad_ded 1 to STR LEN in
             the declaration of s t r . This a com m on practice am ong C programmers.


             When declaring an array of characters that will be used to hold a string, always

 A           make the array one character longer than the string, because of the C convention
             that every string is terminated by a null character. Failing to leave room for the null
             character may cause unpredictable results when the program is executed, since
             functions in the C library assume that strings are null-term inated.


                   Declaring a character array to have length STR_LEN + 1 doesn’t mean that it
              will always contain a string of STR_LEN characters. The length o f a string
              depends on the position of the term inating null character, not on the length o f the
              array in which the string is stored. An array of STR_LEN + 1 characters can hold
              strings of various lengths, ranging from the em pty string to strings of length
              STR_LEN.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



              I n itia liz in g a S tr in g V a r ia b le

              A string variable can be initialized at the same time it’s declared:

              char da t e l [8]                   "June 14";
2 8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
             C h a p te r 13     S tr in g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       The compiler will put ihe characters from " J u n e 1 4 " in the d a t e l array, then
                                       add a null character so that d a t e l can be used as a string. Here’s what d a t e l
                                                                                                                      K^



                                       will look like:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                    datel



                                       Although " J u n e 1 4 " appears to be a siring literal, it’s not. Instead, C views it as
                                       an abbreviation for an array initializer. In fact, we could have written

                                       c h a rd a te l[8 ]         = { 'J \        'u ',   'n ',   'e ',   '   ’,   ’1 ',   '4 ',   '\ 0 '} ;

                                       I Lhink you’ll agree that the original version is easier to read.
                                            W hat if the initializer is too short to fill the string variable? In that case, the
                                       compiler adds extra null characters. Thus, after the declaration

                                       c h a r d a te 2 [9 ]       = ’’J u n e     14";

                                       d a t e 2 will have the following appearance:


                                                                 date2



                                >8.1 This behavior is consistent with C ’s treatment of array initializers in general. When
              arrayiniti0iizers cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       an array initializer is shorter than the array itself, the remaining elements are ini­
                                       tialized to zero. By initializing the leftover elements o f a character array to \ 0 , the
                                       compiler is following the same rule.
                                             What if the initializer is longer than the string variable? T hat’s illegal for
                                       strings, just as it’s illegal for other arrays. However, C does allow the initializer
                                       (not counting the null character) to have exactly the same length as the variable:

                                       c h a r d a te 3 [7 ]       = "June 14";

                                       There’s no room for the null character, so the compiler makes no attempt to store
                                       one:


                                                                       date3



                                       lfy o u ’re planning lo initialize a character array to contain a string, be sure that the
                           A           length of the array is longer than the length of the initializer. Otherwise, the com­
                                       piler will quietly omit the null character, making thc array unusable as a string.


                                          The declaration of a string variable may omit its length, in which case the
                                       compiler computes it:

                                       c h a r d a t e 4 []          "June 14";
                                                                                                                     1 3 .2                                   283onmlkjihgfedcbaZYX
                                                                                                                              S tr in g V a ria b le s kjihgfedcbaZYXWVUTSRQPONMLKJ


                                                        The compiler sets aside eight characters for d a t e 4 , enough to store the characters
                                                        in ”J u n e 14 ” plus a null character. (The fact that the length of d a t e 4 isn’t spec­
                                                        ified doesn't mean that (he array’s length can be changed later. Once the program
                                                        is compiled, the length of d a t e 4 is fixed at eight.) Omitting the length of a string
                                                        variable is especially useful if the initializer is long, since com puting the length by
                                                        hand is error-prone.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                        C h a r a c te r A r r a y s v e r s u s C h a r a c te r P o in te r s

                                                        L et’s compare the declaration

                                                        char date[] = "June 14";

                                                                                        array, with the similar-looking
                                                        which declares d a t e to be an cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                        char *date = "June 14";

                                                        which declares d a t e to be a pointer. Thanks to the close relationship between
                                                        arrays and pointers, we can use either version of d a t e as a string. In particular,
                                                        any function expecting to be passed a character array or character pointer will
                                                        accept either version o f d a t e as an argument.
                                                             However, we must be carel’ul not to make the mistake o f thinking that the two
                                                        versions of d a t e are interchangeable. There are significant differences between
                                                        the two:

                                                          ■       In the array version, the characters stored in d a t e can be modified, like the
                                                                  elements of any array. In lhc pointer version, d a t e points to a string literal,
                                                                  and we saw in Section 13.1 that string literals shouldn’t be modified.
                                                              ■   In the array version, d a t e is an array name. In the pointer version, d a t e is a
                                                                  variable that can be made to point to other strings during program execution.
                                                             If we need a string that can be modified, it’s our responsibility to set up an
                                                        array ofcharacters in which to store the string; declaring a pointer variable isn’t
                                                        enough. The declaration

                                                        char *p;

                                                        causes the compiler to set aside enough memory for a pointer variable; unfortu­
                                                        nately, it doesn’t allocate space for a string. (And how could it? We haven’t indi­
                                                        cated how long the string would be.) Before we can use p as a string, it must point
                                                        to an array ofcharacters. One possibility is to make p point to a string variable:

                                                        char str[STR_LEN+l], *p;

                                                        p = str;

                                                        p now points to the firsi character of s t r . so we can use p as a string. Another hgfedcbaZYXWVUTS
d y n a m ic a iiy a iio c a ie d s ir in g s > 7 Z 2   possibility is to make p point to a dynam ically allocated string.
2 8 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S trin g s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                      Using an uninitialized pointer variable as a string is a serious error. Consider the

                          A           following example, which attempts to build the siring " a b c " :
                                 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      char * p ;

                                      p[0]       = 'a' ;             /***    WRONG
                                      p [1]      = 'b';              /***    WRONG
                                      P [2]      = 1C ';             /***    WRONG
                                      p[3]       = '\0';             /***    WRONG

                                      Since p hasn’t been initialized, we don’t know where it’s pointing. Using the
                                      pointer lo write the characters a , b, c. and \ 0 into memory causes undefined
                                      behavior.aZYXWVUTSRQPONMLKJIHGFEDCBA




                        1 3 .3        R e a d in g a n d W r itin g S tr in g s

                                      Writing a string is easy using either the p r i n t f or p u t s functions. Reading a
                                      string is a bit harder, primarily because of the possibility that the input string may
                                      be lon tg—er than th^e* string variable into which it’s being stored. To read a string in a
                                                                                          ^»                        l^

                                      single step, we can use either s c a n f or g e t s . As an alternative, we can read
                                      strings   one character at a time.
                                            dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                             &




                                      W r itin g S tr in g s U s in g p r i n t f a n d p u t s

                                      The %s conversion specification allows p r i n t f to write a string. Consider the
                                      following example:

                                      char str[]             = ”Are we having fun y e t ? ’1 ;

                                      printf("%s\n",                 str);

                                      The output will be

                                      Are we having fun yet?

                                      p r i n t f writes the characters in a string one by one until it encounters a null char­
                                      acter. (If the null character is missing, p r i n t f continues past the end o fth e string
                                      until— eventually— il finds a null character somewhere in memory.)
                                            To print just part of a string, we can use the conversion specification %.p s,
                                      where is the number of characters to be displayed. The statement.
                                                 p




                                      princf("%.6s\n",                   str);

                                      will print

                                      Are we
                                                                                      1 3 .3   R e a d in g a n d W ritin g S trin g s hgfedcbaZYXWVUTSRQPONM
                                                                                                                                                2 8 5 onmlkjihgfedcb


                                                    A string, like a number, can be printed within a field. The %ws conversion will
                                                                                      in. (A string with more than m characters will be
                                               display a string in a field o fsize cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                               printed in full, not truncated.) If the string has fewer than in characters, it will be
                                               right-justified within the field. To force left justification instead, we can put a
                                               minus sign in front of/n. The in and p values can be used in combination: a conver­
                                               sion specification oftlie form %/// . p s causes the first p characters o fa string to be
                                               displayed in a field of size m.
                                                    p i ^ i n t f isn’t the only function that can write strings. The C library also pro­
                                               vides p u t s , which is used in the following way:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                               puts(str);                                      •
                                               p u t s has only one argument (the string to be printed). After writing the string,
                                               p u t s always writes an additional new-line character, thus advancing to the begin­
                                               ning of the next output line.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               R e a d in g S t r in g s U s in g s c a n f a n d g e t s

                                               The %s conversion specification allows s c a n f to read a string into a character
                                               array:

                                               scanf("%s", str);

                                               There’s no need to put the & operator in front of s t r in the call of s c a n f : like any
                                               array name, s t r is treated as a pointer when passed to a function.aZYXWVUTSRQPONMLKJIHGFEDCBA
w iiite -s p a c e c h a r a c te r s > 3 .2         When s c a n f is called, it skips white space, then reads characters and stores
                                               them in s t r until it encounters a white-space character, s c a n f always stores a
                                               null character at the end of the string.
                                                     A string read using s c a n f will never contain white space. Consequently,
                                               s c a n f won’t usually read a full line of input; a new-line character will cause
                                               s c a n f to stop reading, but so will a space or tab character. To read an entire line
                                               ofinput at a time, we can use g e t s . Like s c a n f . the g e t s function reads input
                                               characters into an array, then stores a null character. In other respects, however,
                                               g e t s is somewhat different from s c a n f :
                                                 ■   g e t s doesn’t skip white space before starting to read the string ( s c a n f
                                                     does).
                                                 ■ g e t s reads until it finds a new-line character ( s c a n f stops at any white­
                                                     space character). Incidentally, g e t s discards the new-line character instead of
                                                     storing it in the array; the null character takes its place.
                                                     To see the difference between s c a n f and g e t s , consider the following pro­
                                               ^g^ram fra^gw
                                                           ^ment:
                                               char sentence[SENT_LEN+l];

                                               printf("Enter a sentence;\n");
                                               scanf("%s", sentence);
2 8 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13    S t r in g s


                                           Suppose that after the promptkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           Enter a sentence:

                                           the user enters the line

                                                     To C, or not to C: that is the question.

                                           s c a n f will store the string^* "T o " in s e n t e n c e . The next call of s c a n f will
                                           resume reading the line at the space after the word To.
                                                 Now suppose that wc replace s c a n f by g e t s :

                                           gets(sentence);

                                           When the user enters the same input as before, g e t s will store the string

                                           •• To C, or not to C: that is the question."

                                           in s e n t e n c e .


                                           As they read characters into an array, s c a n f and g e t s have no way to detect

                              A            when it’s full. Consequently, they may store characters past the end of the array,
                                           causing undefined behavior, s c a n f can bc made safer by using the conversion
                                                                                          n is an integer indicating the maximum
                                           specification %ns instead of %s, where cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           number of characters to be stored, g e t s , unfortunately, is inherently unsafe:hgfedcb
           fg e ts fu n c iio n > 2 ? .5   f g e t s is a much better alternative,dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                           R e a d in g S tr in g s C h a r a c te r b y C h a r a c te r

                                           Since both s c a n f and g e t s are risky and insufficiently flexible for many appli­
                                           cations, C programmers often write their own input functions. By reading strings
                                           one character at a time, these functions provide a greater degree of control than the
                                           standard input functions.
                                                If we decide to design our own input function, w e’ll need to consider the fol­
                                           lowing issues:

                                                 ■ Should th e function skip white space before beginning to store the siring?
                                                 ■    What character causes the function to stop reading: a new-line character, any
                                                      white-space character, or some other character? Is this character stored in the
                                                      stringu- or discarded?
                                             ■        W hat should the function do if the input string is too long lo store: discard the
                                                      extra characters or leave them for the next input operation?
                                               Suppose we need a function that doesn’t skip white-space characters, stops
                                           reading at the first new-line character (which isn’t stored in the string), and dis­
                                           cards extra characters. The function might have the following prototype:

                                           int read_line(char str[], int n);
                                                                  1 3 .4                                                                       287
                                                                           A c c e s s in g th e C h a r a c t e r s in a S t r in g onmlkjihgfedcbaZYXWVUTSRQPON


                                      s t r represents the array into which w e’ll store the input, and n is the maximum
                                      number ofcharacters to be read. If the input line contains more than n characters,
                                      r e a d _ l i n e will discard the additional characters. We’ll have r e a d _ l i n e
                                      return the number ofcharacters it actually stores in s t r (a number anywhere from
                                      0 to n). We may not always need r e a d _ l i n e \ s return value, but it doesn’t hurt to
                                      have it available.aZYXWVUTSRQPONMLKJIHGFEDCBA
                             > 7 .3
g e t c h a r f u n c t io n BA             r e a d _ l i n e consists primarily of a loop that calls g e t c h a r to read a char­
                                      acter and then stores the character in s t r , provided that there’s room left. The loop
                                      terminates when the new-line character is read. (Strictly speaking, we should also
                                      have the loop terminate if g e t c h a r should fail to read a character, but w e’ll
                         Q&A          ignore that complication for now.) Here's the complete definition of r e a d _ l i n e :kjihgfedcbaZYX

                                      int read_line(char str[], int n)

                                         int ch, i = 0;

                                         while ((ch = getchar()) •= '\n*)
                                           if (i < n)
                                             str[i++] = ch;
                                         str[i] = *\0';      /* terminates string */
                                         return i;           /* number of characters stored */


                                      Note that c h has i n t type rather than c h a r type, because g e t c h a r returns the
                                      character that it reads as an i n t value.
                                           Before returning, r e a d _ l i n e puts a null character at the end of the string.
                                      Standard functions such as s c a n f and g e t s automatically put a null character at
                                      the end of an input string: if w e’re writing our own input function, however, we
                                      must take on that responsibility.




                     1 3 .4           A c c e s s in g t h e C h a r a c t e r s in a S tr in g

                                      Since strings are stored as arrays, we can use subscripting to access the characters
                                      in a string. To process every character in a string s , for example, we can set up a
                                      loop that increments a counter i and selects characters via the expression s [ i ] .
                                           Suppose Lhat we need a function that counts the number ofspaces in a string.
                                      Using array subscripting, we might write the function in the following way:

                                      int count_spaces(const char s[])

                                         int count = 0, i ;

                                         for (i = 0; s[i] != '\0'; i++)
                                           if (s[i] == ' ')
                                             count++;
                                         return count;
2 8 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S trin g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       I ’ve included c o n s t in the declaration of s to indicate that c o u n t _ s p a c e s
                                       doesn’t change the array that s represents. If s were not a string, the function
                                       would need a second argument specifying the length of the array. Since s is a
                                       string, however, c o u n t _ s p a c e s can determine where it ends by testing for the
                                       null character.
                                             Many C programmers w ouldn't write c o u n t _ s p a c e s as we have. Instead,
                                       they’d use a pointer to keep track of the current position within the string. As we
                                       saw in Section 12.2, this technique is always available for processing arrays, but it
                                       proves to be especially convenient for working with strings.
                                             L et’s rewrite the c o u n t _ s p a c e s function using pointer arithmetic instead
                                       of array subscripting. We’ll eliminate the variable i and use s itselfto keep track
                                       o fo u r position in the string. By incrementing s repeatedly, c o u n t _ s p a c e s can
                                       step through each character in the string. Here's our new version of the function:kjihgfed

                                       int count_spaces(const char *s)

                                           int count = 0;

                                           for (; *s •= ’\0 ’; s+ + )
                                             if (*s == ’ ’)
                                               count++;
                                           return count;


                                       Note that c o n s t doesn't prevent c o u n t _ s p a c e s from modifying s ; it's there to
                                       prevent the function from modifying what s points to. And since s is a copy ofthe
                                       pointer that’s passed to c o u n t _ s p a c e s , incrementing s doesn’t affect the origi­
                                       nal pointer.
                                            The c o u n t _ s p a c e s example raises some questions about how to write
                                       string functions:RQPONMLKJIHGFEDCBA

                                         ■ Is    it b e t te r to u s e a r r a y o p e r a tio n s o r p o i n t e r o p e r a t io n s to a c c e s s th e c h a r ­
                                                                   W e’re free to use whichever is more convenient; we can
                                             a c t e r s in a s t r i n g ?
                                             even mix the two. In the second version of c o u n t _ s p a c e s . treating s as a
                                             pointer simplifies the function slightly by removing the need for the variable
                                             i . Traditionally, C programmers lean toward using pointer operations for pro­
                                             cessing^^ string^^s.
                                         ■ S h o u ld a s tr in g p a r a m                                                   The two
                                                                                 e te r b e d e c la r e d a s a n a r r a y o r a s a p o in te r ?
                                             versions o f c o u n t _ s p a c e s illustrate the options: the first version declares s
                                             to be an array; the second declares s to be a pointer. Actually, there’s no dif­
                                             ference between the two declarations— recall from Section 12.3 that the com­
                                             piler treats an array parameter as though it had been declared as a pointer.
                                         ■ D o e s t h e f o r m o f t h e p a r a m e t e r (s [] o r
                                                                                                 * s ) a f f e c t w h a t c a n b e s u p p li e d as
                                             a n a r g u m e n t ? No. When c o u n t _ s p a c e s is called, the argument could be
                                             an array name, a pointer variable, or a string literal— c o u n t _ s p a c e s can’t
                                             tell the difference.
                                                                         1 3 .5                                                289aZYXWVUTSRQPO
                                                                                  U s in g th e C S trin g L ib r a r y kjihgfedcbaZYXWVUTSRQPONMLKJ




                1 3 .5      U s in g t h e C S tr in g L ib r a r y onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                            Some programming languages provide operators that can copy strings, com pare
                            strings, concatenate strings, select substrings, and the like. C ’s operators, in con­
                            trast, are essentially useless for working with strings. Strings are treated as arrays
                            in C. so they're restricted in the same ways as arrays— in particular, they can’t be
                            copied or compared using operators.


                            Direct attempts to copy or compare strings will fail. For example, suppose that

                  A         s t r l and s t r 2 have been declared as follows:
                            char strl [10] , str2 [10] ;

                            Copying a string into a character array using the = operator is not possible:
                            strl = "abc";          /*** WRONG ***/
                            str2 = strl;           /*** WRONG ***/

                            We saw in Section 12.3 that using an array name as the left operand of = is illegal.cbaZYXWVUTSRQPON
                            Initializing acharacter array using = is legal, though:

                            char strl[10] = "abc";

                            ln the context o f a declaration, = is not the assignm ent operator.
                                 Attem pting to com pare strings using a relational or equality operator is legal
                            but w on’t produce the desired result:
                            if (strl =- str2) ...               /*** WRONG ***/

                            This statement com pares s t r l and s t r 2 as p o inters\ it doesn’t com pare the con­
                            tents of the two arrays. Since s t r l and s t r 2 have different addresses, the
                            expression s t r l == s t r 2 must have the value 0.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                Fortunately, all is not lost: the C library provides a rich set of functions for
                                          performing operations on strings. Prototypes for these functions reside in the
                                          < s t r i n g . h > header, so programs that need string operations should contain the
< s t r i n g . h > h e a d e r RQPONMLKJIHGFEDCBA
                                > 2 3 .6

                                          following line:

                            #include <string.h>

                                 Most of the functions declared in < s t r i n g . h> require at least one string as
                            an argument. String parameters are declared to have type c h a r *. allowing the
                            argument to be a character array, a variable of type c h a r *, or a string literal— all
                            are suitable as strings. Watch out for string parameters that aren’t declared c o n s t ,
                            however. Such a parameter may be modified when the function is called, so the
                            corresponding argument shouldn’t be a string literal.
            C h a p te r 13
2 9 0 ZYXWVUTSRQPONMLKJIHGFEDCBAS trin g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                  There are many functions in < s t r i n g . h>; IT1 cover a few of the most basic.
                                             In subsequent examples, assume that s t r l and s t r 2 are character arrays used as
                                             strings.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             T h e s t r c p y (S tr in g C o p y ) F u n c tio n

                                             The s t r c p y function has the following prototype in < s t r i n g . h>:kjihgfedcbaZYXWVUTSRQPON

                                             char *strcpy(char *sl, const char *s2);

                                             s t r c p y copies the string s 2 into the string s l . (To be precise, we should say
                                             “s t r c p y copies the string pointed to by s 2 into the array pointed to by s l . ”)
                                             That is, s t r c p y copies characters from s 2 to s l up to (and including) the first
                                             null character in s 2 . s t r c p y returns s l (a pointer to the destination string). The
                                             string pointed to by s 2 isn’t modified, so if s declared c o n s t .
                                                    The existence of s t r c p y compensates for the fact that we can't use the
                                             assignment operator to copy strings. For example, suppose that we want to store
                                             the string " a b c d " in s t r 2 . We can’t use the assignment

                                             str2 = ’'abcd”;                           /*** WRONG ***/

                                             because s t r 2 is an array name and can’t appear on the left side of an assignment.
                                             Instead, we can call s t r c p y :

                                             strcpy(str2, “abcd”);                 /* str2 now contains "abcd” */

                                             Similarly, we can’t assign s t r 2 to s t r l directly, but we can call s t r c p y :

                                             strcpy(strl, str2);                   /* strl now contains ”abcd” */

                                                  Most o fth e time, we'll discard the value that s t r c p y returns. On occasion,
                                             though, it can be useful to call s t r c p y as part of a larger expression in order to
                                             use its return value. For example, we could chain together a series of s L r c p y
                                             calls:

                                             strcpy(strl, strcpy(str2, "abcd”));
                                               /* both strl and str2 now contain ”abcd" */


                                             In the call s t r c p y ( s t r l , s t r 2 ), s t r c p y has no way to check that the string
                                A            pointed to by s t r 2 will actually fit in the array pointed to by s t r l . Suppose that
                                             s t r l points to an array of length //. If the string that s t r 2 points to has no more
                                                    n - 1 characters, then the copy will succeed. But if s t r 2 points to a longer
                                             than cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                             string, undefined behavior occurs. (Since s t r c p y always copies up to the first null
                                             character, it will continue copying past the end of the array that s t r l points to.)


        s tr n c p y iu n c tio n > 2 3 .6          Calling the s t r n c p y function is a safer, albeit slower, way to copy a string,
                                             s t r n c p y is similar to s t r c p y but has a third argument that limits the number of
                                             characters that will be copicd. To copy s t r 2 into s t r l , we could use the follow­
                                             ing call of s t r n c p y :
                                                                     1 3 .5                                                   291 kjihgfedcbaZY
                                                                              U s in g th e C S tr in g L ib r a r y onmlkjihgfedcbaZYXWVUTSRQPON


                          strncpy(strl, str2, sizeof(strl));

                          As long as s t r l is large enough to hold the string stored in s t r 2 (including the
                          null character), the copy will be done correctly, s t r n c p y itself isn't without dan­
                          ger,1 thougCh. For one thingC,7 it will leave the stringv- in s t r l without a terminating^7
                          O
                          null character if the length of the string stored in s t r 2 is greater than or equal to
                          the size of the s t r l array. Here\s a safer way to use s t r n c p y :

                          strncpy(strl, str2, sizeof(strl)                    - 1);
                          strl[sizeof(strl)-l] = *\0*;

                          The second statement guarantees that s t r l is always null-terminated, even if
                          s t r n c p y fails to copy a null character from s t r 2 .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                          T h e s t r l e n (S tr in g L e n g th ) F u n c tio n

                          The s t r l e n function has thc following prototype:

                          size_t strlen(const char *s);aZYXWVUTSRQPONMLKJIHGFEDCBA

s iz e _ tty p e > 7 .6   s iz e _ _ t, which is defined in the C library, is a t y p e d e f name that represents
                          one of C's unsigned integer types. Unless we’re dealing with extremely long
                          strings, this technicality need not concern us— we can simply treat the return value
                          of s t r l e n as an integer.
                                s t r l e n returns the length o f a string s: the number of characters in s up to.
                          but not including, the first null character. Here are a few examples:

                          int len;

                          len = strlen(”abc“);                /* len is now 3 *
                          len = strlen("”);                   /* len is now 0 *
                          strcpy(strl, ”abc”);
                          len = strlen(strl);                 /* len is now 3 *

                          The last example illustrates an important point. When given an array as its argu­
                          ment. s t r l e n doesn’t measure the length o fth e array itself; instead, it returns the
                          length of the string stored in the array.


                          T h e s t r c a t (S tr in g C o n c a te n a tio n ) F u n c t io n

                          The s t r c a t function has the following prototype:

                          char *strcat(char *sl, const char *s2);

                          s t r c a t appends the contents of the string s2 to the end of the string s l ; it
                          returns s l (a pointer to the resulting string).
                                Here are some examples of s t r c a t in action:

                          strcpy(strl,        "abc");
                          strcat(strl,        "def");         /* strl now contains "abcdef" */
2 9 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13     S trin g s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          strcpy(strl, "abc");
                                          strcpy(str2, “def”);
                                          strcat(strl, str2);                      /* strl now contains ’’abcdef" */onmlkjihgfedcbaZYXWV

                                               As with s t r c p y , the value returned by s t r c a t is normally discarded. The
                                          following example shows how the return value might be used:

                                          strcpy(strl, "abc");
                                          strcpy(str2, "def");
                                          strcat(strl, strcat(str2, "ghi"));
                                            /* strl now contains "abcdefghi"; str2 contains "defghi" */


                                          The effect of the call s t r c a t ( s t r l , s t r 2 ) is undefined if the array pointed to
                                          by s t r l isn't long enough to accommodate the additional characters from s t r 2 .
                                          Consider the following example:
                                          char strl[6] = "abc";

                                          strcat(strl, "def");                     /*** WRONG ***/

                                          s t r c a t will attempt to add the characters d. e, f , and \ 0 to the end of the string
                                          already stored in s t r l . Unfortunately, s t r l is limited to six characters, causing
                                          s t r c a t to write past the end of the array.aZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 The s t r n c a t function is a safer but slower version of s t r c a t . Like
                                     > 2 3 .6dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
        s t r n c a t f u n c t io n BA

                                          s t r n c p y , it has a third argument that limits the number ofcharacters it will copy.
                                          Here’s what a call might look like:

                                          strncat(strl, str2, sizeof(strl) - strlen(strl) - 1);

                                          s t r n c a t will terminate s t r l with a null character, which isn’t included in the
                                          third argument (the number of characters to be copied). In the example, the third
                                          argument calculates the amount ofspace remaining in s t r l (given by the expres­
                                          sion s i z e o f ( s t r l ) - s t r l e n ( s t r l ) ) and then subtracts 1 to ensure that
                                          there will be room for the null character.


                                          T h e s t r c m p (S tr in g C o m p a r is o n ) F u n c tio n

                                          The s t r c m p function has the following prototype:

                                          int strcmp(const char *sl, const char *s2);

                                          s t r c m p compares the strings s l and s 2 , returning a value less than, equal to, or
                             Q&A          greater than 0, depending on whether s l is less than, equal to. or greater than s2 .
                                          For example, to see if s t r l is less than s t r 2 , w e’d write

                                          if (strcmp(strl, str2) < 0)                        /* is strl < str2? */
                                                                                            1 3 .5                                               2 9 3 onmlkjihgfedcbaZYXWVU
                                                                                                     U s in g th e C S trin g L ib ra ry hgfedcbaZYXWVUTSRQPONMLKJIHGF


                                               To test whether s t r l is less than or equal to s t r 2 . w e’d write kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                               if (strcmp(strl, str2) <= 0)                      /* is strl <= str2? */


                                               By choosing the proper relational operator (<, <=, >, >=) or equality operator (==,
                                               ! =), we can test any possible relationship between s t r l and s t r 2 .
                                                    s t r c m p compares strings based on their lexicographic ordering, which re­
                                               sembles the way words are arranged in a dictionary. More precisely, s t r c m p con­
                                               siders s l to be less than s2 ifeither one o fth e following conditions is satisfied:
                                                 ■ The first i characters of s l and s 2 match, but the (z+l)st character of s l is
                                                    less than the (/+l)st character of s 2 . For example, " a b c " is less than ”b c d ” ,
                                                    and ” a b d ” is less than ”a b e ” .
                                                 ■ All characters of s l match s 2 . but s l is shorter                 than s 2 . For example,
                                                     " a b c " is lessthan " a b c d " .aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                     As it compares characters from two strings, s t r c m p looks at the numerical
                                               codes that represent the characters. Some knowledge of the underlying character
                                               set is helpful in order to predict what s t r c m p will do. For example, here are a few
                                 >Appendix E
A S C II c h a r a c t e r s e t BA            important properties o fth e ASCII character set:
                                                 ■ The characters in each of the sequences A -Z , a-z, and 0-9 have consecutive
                                                     codes.
                                                  ■ All upper-case letters are less than all lower-ca se letters. (In ASCII, codes
                                                     between 65 and 90 represent upper-case letters; codes between 97 and 122
                                                     represent lower-case letters.)
                                                 ■ Digits are less than letters. (Codes between 48 a nd 57 represent digits.)
                                                 ■ Spaces are less than all printing characters. (Th e space character has the value
                                                    32 in ASCII.)


                                     P r in t in g a O n e -M o n th
                   P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA                   R e m in d e r L is t

                                               To illustrate the use of the C string library. w e’Il now develop a program that prints
                                               a one-month list of daily reminders. The user will enter a series of reminders, with
                                               each prefixed by a day of the month. When the user enters 0 instead of a valid day,
                                               the program will print a list of all reminders entered, sorted by day. Here’s what a
                                               session with the program will look like:

                                               Enter day       and reminder           24 Susan's birthday
                                               Enter day       and reminder           5 6:00 - Dinner with Marge and Russ
                                               Enter day       and reminder           26 Movie - "Chinatown 11
                                               Enter day       and reminder           7 10:30 - Dental appointment
                                               Enter day       and reminder           12 Movie - "Dazed and Confused"
                                               Enter day       and reminder           5 Saturday class
                                               Enter day       and reminder           12 Saturday class
                                               Enter day       and reminder           0
                                                                                                                                           1
294 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 13     S trin g s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         Day Reminder
                                           5 Saturday class
                                           5 6:00 - Dinner with Marge and Russ
                                           7 10:30 - Dental appointment
                                          12 Saturday class
                                          12 Movie - "Dazed and Confused"
                                          24 Susan’s birthday
                                          26 Movie - "Chinatown"

                                                The overall strategy isn't very com plicated: w e’ll have the program read a
                                         series of day-and-rem inder com binations, storing them in order (sorted by day),
                                         and then display them. To read the days, w e’ll use s c a n f ; to read the reminders,
                                         w e'll use the r e a d _ _ l i n e function o fS ectio n 13.3.
                                                W e’ll store the strings in a two-dimensional array o fcharacters, with each row
                                         of the array containing one string. A fter the program reads a day and its associated
                                         reminder, it will search the array to determ ine where the day belongs, using
                                                                                                                            below
                                         s t r c m p to do comparisons. It will then use s t r c p y to move all strings cbaZYXWVUTSRQPON
                                         that point down one position. Finally, the program will copy the day into the array
                                         and call s t r c a t to append the rem inder to the day. (The day and the reminder
                                         have been kept separate up to this point.).
                                                 O f course, there are always a few m inor com plications. For exam ple, we want
                                         the days to be right-justified in a tw o-character field, so that their ones digits will
                                         line up. There are many ways to handle the problem. J’ve chosen to have the pro-
        s p rin tffu n c tio n > 2 2 8   gram use s c a n f to read the day into an integer variable, then call s p r i n t f to
                                         convert the day back into string form, s p r i n t f is a library function that’s similar
                                         to p r i n t f , except that it writes output into a string. The call

                                         sprintf(day_str,          "%2d", day);

                                         writes the value o f d a y into d a y _ _ s tr . Since s p r i n t f autom atically adds a null
                                         character when it's through writing, d a y _ _ s t r will contain a properly null-termi­
                                         nated string.
                                              A nother com plication is making sure that the user doesn't enter more than two
                                         digits. W e’ll use the following call o f s c a n f for this purpose:

                                         scanf("%2d", &day);

                                         The num ber 2 between % and d tells s c a n f to stop reading after two digits, even
                                         if the input has more digits.
                                               With those details out of the way, here’s the program:BA

                      rem ind.C          /★   Prints a one-month reminder list */

                                         #include <stdio.h>
                                         #include <string.h>

                                         #define MAX_REMIND 50                  /* maximum number of reminders */
                                         #define MSG_LEN 60                     /* max length of reminder message */
                                            1 3 .5   U s in g th e C S tr in g L ib r a r y hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                    2 9 5 kjihgfedcbaZYXWVU


int read_line(char str[], int n);

int main(void)

    char reminders[MAX_REMIND][MSG_LEN+3];
    char day_str[3], msg_str[MSG_LEN+l];
    int day, i, j, num_remind = 0;

    for (;;) {
      if (num_remind == MAX_REMIND) {
        printf(”-- No space left --\n");
        break;


       printf("Enter day and reminder: ");
       scanf("%2d", &day);
       if (day == 0)
         break;
       sprintf(day_str, H %2d”, day);
       read_line(msg_str, MSG_LEN);

       for (i = 0; i < num_remind; i++)
         if (strcmp(day_str, reminders[i]) < 0)
           break;
       for (j = num_remind; j > i; j--)
         strcpy(reminders[j] , reminders[j-l]);

       strcpy(reminders[i], day_str);
       strcat(reminders[i], msg_str);

       num_remind++;


    printf(”\nDay Reminder\n");
    for (i = 0; i < num_remind; i++)
      printf(” %s\n”, reminders[i]);

    return 0;
}

int read_line(char str[], int n)

    int ch, i = 0;

    while ((ch = getchar()) != '\n')
      if (i < n)
         str[i ++] = ch;
    str [i] = ’\0' ;
    return i;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


       Although r e m i n d . c is useful fordem onstrating the s t r c p y , s t r c a t , and
s t r c m p functions, il lacks something as a practical reminder program . There are
2 9 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13     S trin g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      obviously a number of im provements needed, ranging from m inor tweaks to major
                                      enhancem ents (such as saving the reminders in a file when the program termi­
                                      nates). W e’ll discuss several improvements in the program m ing projects at thcend
                                      of this chapter and in later chapters.aZYXWVUTSRQPONMLKJIHGFEDCBA




                        1 3 .6        S t r in g id io m s

                                      Functions that m anipulate strings are a particularly rich source of idioms. In this
                                      section, w e’ll explore som e of the most famous idioms by using them to write the
                                      s t r l e n and s t r c a t functions. You’ll never have to write these functions, of
                                      course, since they’re part of the standard library, but you may have to write func­
                                      tions that are similar.
                                             The concise style I’Ll use in this section is popular with many C programmers.
                                      You should m aster this style even ify o u don't plan to use il in your own programs,
                                      since you're likely to encounter it in code written by others.
                                             One last note before we get started. If you want to try out any of the versions
                                      of s t r l e n and s t r c a t in this section, be sure to alter the name of the function
                                      (changing s t r l e n to m y _ s t r l e n , for example). As Section 2 l .l explains,
                                      w e’re not allowed to write a function that has the same name as a standard library
                                      function,7 even when we d o n 't include the header to which the functioV?n belongs. In
                                      fact, all names that begin with s t r and a lower-case letter are reserved (to allow
                                      functions to be added to the < s t r i n g . h> header in future versions o fth e C stan­
                                      dard).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      S e a r c h in g fo r th e E n d o f a S tr in g

                                      M any string operations require searching for the end of a string. The s t r l e n
                                      function is a prime example. The following version o f s t r l e n searches its string
                                      argum ent to find the end. using a variable to keep track o fth e string's length:kjihgfedcbaZYX

                                      size t strlen(const char *s)

                                          size t n;

                                          for (n = 0; *s != ’\0 ’; s++)
                                            n+ + ;
                                          return n;


                                      As the pointer s moves across the string from left to right, the variable n keeps
                                      track o fhow many characters have been seen so far. When s finally points to a null
                                      character, n contains the length of the string.GFEDCBA
                                                                             ^J          ±*


                                            L et’s see if we can condense the function. First, w e’ll move the initialization
                                      o f n to its declaration:
                                                         1 3 .6                              297
                                                                  S tr in g Id io m s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


size_t strlen(const char *s)

    size_t n = 0;

    for (; *s != ’\0'; s++)
      n++ ;
    return n;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


Next, we notice that the condition * s ! = ’ \ 0 ’ is the same as * s ’ = 0, because
the integer value of the null character is 0. But testing * s ! = 0 is the same as test­
ing * s ; both are true i f * s isn’t equal to 0. These observations lead to our next ver-


size_t strlen(const char *s)

    size_t n = 0;

    for (; *s; s++)
      n++;
    return n,-


But, as we saw in Section l2.2. it's possible to increment s and test * s in the same
expression:

size_t strlen(const char *s)
{
  size_t n = 0;

    for (; *s++;)
      n++ ;
    return n;
}
Replacing the f o r statement with a w h i l e statement, we arrive at the following
version o f s t r l e n :

size_t strlen(const char *s)
{
  size_t n = 0;

    while (*s++)
      n++ ;
    return n;


    Although w e’ve condensed s t r l e n quite a bit, it’s likely that we haven’t in­
                                         does run faster, at least with some compilers:
creased its speed. Here’s a version that cbaZYXWVUTSRQPONMLKJIHGFEDCBA

size_t strlen(const char *s)

    const char *p = s;
2 9 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S tr in g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           w h ile (* s)
                                              S + 4- ;
                                           re tu rn s - p;


                                       This version of s t r l e n computes the length o fth e siring by locating the position
                                       of the null character, then subtracting from it the position of the first character in
                                       the string. The improvement in speed comes from not having to increment n inside
                                       the w h i l e loop. Note the appearance of the word c o n s t in the declaration o fp ,
                                       by the way; witlioul it, the compiler would notice that assigning s to p places the
                                       string that s points to at risk.
                                            The statement
                          id io m      w h ile (* s)
                                          S++ ;

                                       and the related
                          id io m      w h ile      (* s + + )
                                            F
                                       are idioms meaning “search for the null character at the end of a string.'’ The first
                                       version leaves s pointing to the null character. The second version is more concise,
                                       but leaves s pointingjust past the null character.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       C o p y in g a S tr in g

                                       Copying a string is another common operation. To introduce C ’s “string copy”
                                       idiom, we’ll develop two versions of the s t r c a t function. Let’s start with a
                                       straightforward but somewhat lengthy version:
                                       ch ar * s trc a t(c h a r           * s l,     c o n s t c h a r *s2)

                                           c h a r *p = s l ;

                                           w h i l e ( *p != ’ \ 0 ' )
                                              p++;
                                           w h i l e ( * s 2 != ' \ 0 ’ ) {
                                              *p = * s 2 ;
                                              P++;
                                                      f
                                              S 2 4*+ cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           *p = ' \ 0 ' ;
                                           re tu rn s l;


                                       This version of s t r c a t uses a two-step algorithm: (1) Locate the null character at
                                       the end of the string s l and make p point to it. (2) Copy characters one by one
                                       from s 2 to w h erep is pointing.
                                             The first w h i l e statement in the function implements step (1). p is set to
                                       point to the first character in the s l string. Assuming that s l points to the string
                                       " a b c " , we have the following picture:
                                                       1 3 .6                              299onmlkjihgfedcbaZYXWV
                                                                S tr in g Id io m s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF




p is then incremented as long as it doesn’t point to a null character. When the loop
terminates, p must be pointing to the null character:




      The second w h i l e statement implements step (2). The loop body copies one
character from where s 2 points to where p points, then increments both p and s 2 .
If s 2 originally points to the string " d e f ” , here’s what the strings will look like
after the first loop iteration:




The loop terminates when s 2 points to the null character:




After putting a null character where p is pointing, s t r c a t returns.
     By a process similar to the one we used for s t r l e n , we can condense the
definition of s t r c a t , arriving at the following version:
char *strcat(char *sl, const char *s2)

   char *

   while (*p)
     p++;
   while (*p++ = *s2++)
     /
   return sl;
3 0 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S trin g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       The heart o fo u r streamlined s t r c a t function is the “siring copy’’ idiom:aZYXWVUTSRQPONML

                          id io m      while (*p++ = *s2++)
                                    kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            7


                                        lf we ignore the two ++ operators, the expression inside the parentheses simplifies
                                        to an ordinary assignment:

                                        *p = *s2

                                       This expression copies a character from where s 2 points to where p points. After
                                       the assignment, both p and s 2 are incremented, thanks to the ++ operators.
                                       Repeatedly executing this expression has the effect of copying a series of charac­
                                       ters from where s 2 points to where p points.
                                            But what causes the loop to terminate? Since the primary operator inside the
                                       parentheses is assignment, the w h i l e statement tests the value of the assign­
                                       ment— the character that was copied. All characters except the null character lest
                                       true, so the loop w on’t terminate until the null character has been copied. And
                                                                   qfter the assignment, we don’t need a separate statement
                                       since the loop terminates cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       to put a null character at the end of the new string.




                         1 3 .7         A r r a y s o fS tr in g s

                                       Let's now turn to a question that w e’ll often encounter: w hat’s the best way to store
                                       an array of strings? The obvious solution is to create a two-dimensional array of
                                       characters, then store the strings in the array, one per row. Consider the following
                                       example:

                                        char planets[][8] = {"Mercury”, ”Venus", "Earth”,
                                                             "Mars”, "Jupiter”, "Saturn",
                                                             "Uranus", "Neptune", "Pluto"};

                                       (In 2006, the International Astronomical Union demoted PIuto from “planet” to
                                       “dw arf planet,” but I’ve left it in the p l a n e t s array for old tim es’ sake.) Note that
                                       w e’re allowed to omit the number of rows in the p l a n e t s array— since that's
                                       obvious from the number of elements in the initializer— but C requires that we
                                       specify the number of columns.
                                            The figure at the top of the next page shows what the p l a n e t s array will
                                       look like. Not all our strings were long enough to fill an entire row of the array, so
                                       C padded them with null characters. There’s a bit of wasted space in this array,
                                       since only three planets have names long enough to require eight characters
                                       (including the terminating null character). The r e m i n d , c program (Section I3.5)
                                       is a glaring example of this kind of waste. It stores reminders in rows of a two-
                                       dimensional character array, with 60 characters set aside for each reminder. In our
                                       example, the reminders ranged from 18 to 37 characters in length, so the am ount of
                                       wasted space was considerable.
                                                                      1 3 .7                                             301 dcbaZYXWVUTSRQPONMLK
                                                                                    A r r a y s o f S t r in g s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB


                                  0         1   2    3   4       5       6     7

                                  M         2   r    c   u       r       y     \o

                                  V         e   n    u       s   \0     \o     \0

                                  E
                                  ***       a   *•   t   h       \0     \o     \0

                                  M         a   r    s   \0      \0     \o     \0

                                  J         u   P    i       t   c       r     \0

                                  S         a   t    u       r   n      \0     \o

                                  u         r   a    n   u       s      \0     \o

                                  N         ^   P    t   u       n       ^     \o

                                  P         1   u    t   □       \0     \0     \ o onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




    The inefficiency that’s apparent in these exam ples is common when working
                                      s of strings will have a mixtu&re of I^ona strings
with stringOs ,’ since most collection&
and short strings. What we need is a ra     g g e d a rra y : a two-dimensional array whose
                                        cbaZYXWVUTSRQPONMLKJIHGFEDCBA

rows can have different lengths. C doesn’t provide a “ragged array ty p e;’ but it
does give us the tools to simulate one. The secret is to create an array whose ele­
ments are pointers to strings.
    H ere’s the p l a n e t s array again, this time as an array of pointers to strings:kjihgfedcbaZYXWVUTSRQPONM
char *planets[] = {“Mercury”, “Venus", “Earth",
                   “Mars”, “Jupiter", "Saturn",
                   “Uranus", “Neptune", “Pluto"};

Not much ofach an g e, eh? We simply removed one pair ofbrackets and put an aster­
isk in front o f p l a n e t s . The effect on how p l a n e t s is stored is dramatic, though:

                             p la n e v s




Each element of p l a n e t s is a pointer to a null-terminated string. There are no
longer any wasted characters in the strings, although w e’ve had to allocate space
for the pointers in the p l a n e t s array.
     To access one of the planet names, all we need do is subscript the p l a n e t s
array. Because of the relationship between pointers and arrays, accessing a charac­
ter in a planet name is done in the same way as accessing an element of a two-
                                                                                                                                                                1
3 0 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S tr in g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                dim ensional array. To search the p l a n e t s array for strings beginning with the
                                                letter M } for exam ple, we could use the follow ing loop:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                for (i = 0; i < 9; i4-4-)
                                                  if (planets[i] [0] == 'M')
                                                    printf("%s begins with M\n", planets[i]);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                C o m m a n d -L in e A r g u m e n ts

                                                W hen we run a program , w e’ll often need to supply it with inform ation— a file
                                                nam e, perhaps, or a sw itch that m odifies the p rogram 's behavior. C onsider the
                                                UNIX l s com m and. Ifw e run l s by typing

                                                ls

                                                at the com m and line, it will display the nam es o f the files in the current directory.
                                                But ifw e instead type

                                                ls -1

                                                then l s will display a “long” (detailed) listing o f files, show ing the size o f each file,
                                                the file’s owner, the date and tim e the file was last m odified, and so forth. To modify
                                                the behavior o f l s further, we can specify that it show details for ju st one file:

                                                ls -1 remind.c

                                                l s will display detailed inform ation about the file nam ed r e m i n d , c .
                                                       C om m and-line inform ation is available to all program s, n o tju st operating sys­
                                 Q&A            tem com m ands. To obtain access to these RQPONMLKJIHGFEDCBA
                                                                                                    c o m m a n d - l i n e a r g u m e n t s (called p r o ­
                                                g r a m p a r a m e t e r s in the C standard), we must define m a i n as a function w ith two
                                 Q&A            param eters, which are custom arily nam ed a r g c and a r g v :

                                                int main(int argc, char *argv[])aZYXWVUTSRQPONMLKJIHGFEDCBA




                                                a r g c (“argum ent count” ) is the num ber o f com m and-line argum ents (including
                                                 the nam e o f the program itself), a r g v (“argum ent vector”) is an array o fp o in te rs
                                                to the com m and-line argum ents, which are stored in string form, a r g v [0 ] points
                                                to the nam e o f the program , w hile a r g v [1 ] through a r g v [ a r g c - 1 ] point to
                                                the rem aining com m and-line argum ents.
                                                        a r g v has one additional elem ent, a r g v [ a r g c ] , w hich is alw ays a n u l l
                                                p o i n t e r — a special pointer that points to nothing. W e’ll discuss null pointers in a
                n u ii p o in te rs > / 7 . /   later chapter; for now, all we need to know is that the m acro NULL represents a null
                                                pointer.
                                                        If the user enters the com m and line

                                                ls -1 remind.c

                                                then a r g c will be 3. a r g v [ 0 ]         will point to a string containing the program
                                                                          1 3 .7   A rra y s o f S tr in g s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                                      3 0 3 onmlkjihgfedcbaZYXWVUTS


                  name, a r g v [1] will point to the string ” - 1 " , a r g v [2] will point to the string
                  " r e m i n d , c " , and a r g v [3] will be a null pointer:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           argv
                                       o              >program name

                                       i


                                       2                                     d        c     \0

                                       3 cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                  This figure doesn’t show the program name in detail, since it may include a path or
                  other information that depends on the operating system. Ifth e program name isn’t
                  available, a r g v [0] points to an empty string.
                       Since a r g v is an array of pointers, accessing command-line arguments is
                  easy. Typically, a program that expects command-line arguments will set up a loop
                  that examines each argument in turn. One way to write such a loop is to use an
                  integer variable as an index into the a r g v array. For example, the following loop
                  prints the command-line arguments, one per line:
                  int i ;

                  for (i = 1; i < argc; i++)
                    p r i n t f ("%s\n" f a r g v [i]);

                  Another technique is to set up a pointer to a r g v [ 1 ] , then increment the pointer
                  repeatedly to step through the rest of the array. Since the last element of a r g v is al­
                  ways a null pointer, the loop can terminate when it finds a null pointer in the array:
                  char **p;

                  for (p = &argv[l]; *p != NULL; p+ + )
                    p r i n t f ("%s\n" t * p ) ;

                  Since p is a p o in ter to a p o in ter to a character, w e’ve got to use it carefully. Setting
                  p equal to & a r g v [ l ] makes sense; a r g v [ l ] is a pointer to a character, so
                  & a rg v [1] will be a pointer to a pointer. The test *p ! = NULL is OK, since *p
                  and NULL are both pointers. Incrementing p looks good: p points to an array ele­
                  ment. so incrementing it will advance it to the next element. Printing * p is fine,
                  since *p points to the first character in a string.


                   C h e c k in g P la n e t N a m e s
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  Our nexl program, p l a n e t . c, illustrates how to access command-line argu­
                  ments. The program is designed to check a series of strings to see which ones are
                  names of planets. When the program is run. the user will put tlie strings to be tested
                  on the command line:

                  planet Jupiter venus Earth fred
3 0 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S t r in g s


                                      The program will indicate whether or not each string is a planet name; if it is, the
                                      program will also display the planet’s number (with planet l being the one closest
                                      to the Sun):kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      Jupiter is planet 5
                                      venus is not a planet
                                      Earth is planet 3
                                      fred is not a planet

                                      Notice that the program doesn’t recognize a string as a planet name unless its first
                                      letter is upper-case and its remaining letters are lower-case.BA

                     planet.c         /* Checks planet names */

                                      #include <stdio.h>
                                      #include <string.h>

                                      #define NUM_PLANETS 9

                                      int main(int argc, char *argv[])

                                          char *planets[]              = {’’Mercury”, "Venus", "Earth",
                                                                          "Mars", "Jupiter", "Saturn",
                                                                          "Uranus", "Neptune", "Pluto"};
                                          int i , j ;

                                          fo r    ( i = 1; i < a r g c ;          i+ + )   {
                                                for (j = 0; j < NUM_PLANETS; j++)
                                                  if (strcmp(argv[i], planets[j]) == 0) {
                                                    printf("%s is planet %d\n", argv[i], j + 1);
                                                    break;

                                                if (j == NUM_PLANETS)
                                                  printf("%s is not a planet\n", argv[i]);


                                          return 0;


                                            The program visits each command-line argument in turn, com paring it with
                                      the strings in the p l a n e t s array until it fmds a match or reaches the end of
                                      the array. The most interesting part of the program is the call of s t r c m p , in
                                      which the arguments are a r g v [ i ] (a pointer to a com m and-line argument) and
                                      p l a n e t s [ j ] (a pointer to a planet name).aZYXWVUTSRQPONMLKJIHGFEDCBA




                                      Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Q:      H o w lo n g c a n a s t r in g lite r a l b e?
                              A:      According to the C89 standard, compilers must allow string literals to be at least
                                                                                                          Q ZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                            & A        3 0 5 onmlkjihgfedcbaZYXWVUT


         509 characters long. (Yes, you read that right— 509. D on’t ask.) C99 increases the
< ffi>   minimum to 4095 characters.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

   Q:    W h y a r e n ’t s tr in g lite r a ls c a lle d “ s tr in g c o n s ta n ts ” ?
   A:    Because they’re not necessarily constant. Since string literals are accessed through
         pointers, there’s nothing to prevent a program from attem pting to modify the char­
         acters in a stringo literal,

   Q:    H o w d o w e w r ite a s tr in g lite r a l th a t r e p r e se n ts “ lib e r ” if ” \ x f c b e r " d o e s n ’t
         w o r k ? [p . 2 7 8 ]
   A:    The secret is to write two adjacent string literals and let the com piler join them into
         one. In this exam ple, writing " \ x f c " " b e r " will give us a string literal that rep­
         resents the word “liber.”

   Q:    M o d ify in g a s tr in g lite r a l s e e m s h a r m le s s e n o u g h . W h y d o e s it c a u s e u n d e ­
         fin e d b e h a v io r ? [p. 2 8 0 ]
   A:    Some compilers try to reduce m emory requirem ents by storing single copies of
         identical string literals. Consider the following example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         char *p = "abc", *q = "abc”;

         A com piler might choose to store " a b c " just once, making both p and q point to
         it. If w e were to change " a b c ” through the pointer p , the string that q points to
         would also be affected. Needless to say. this could lead to some annoying bugs.
         Another potential problem is that string literals might be stored in a “read-only”
         area ofm em ory; a program that attem pts to modify such a literal will simply crash.

   Q:    S h o u ld e v e r y a r r a y o f c h a r a c te r s in c lu d e ro o m fo r a n u ll c h a r a c te r ?
   A:    Not necessarily, since not every array of characters is used as a string, hicluding
         room for the null character (and actually putting one into the array) is necessary
         only if you’re planning to pass it to a function that requires a null-term inated
         stringo,
               You do cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                        n o t need a null character if you’ll only be perform ing operations on
         individual characters. For exam ple, a program might have an array of characters
         that it will use to translate from one character set to another:

         char translation_table[128];

         The only operation that the program will perform on this array is subscripting.
         (The value of t r a n s l a t i o n _ t a b l e [c h ] will be the translated version of the
         character c h .) We would not consider t r a n s l a t i o n _ t a b l e to be a string: it
         need not contain a null character, and no string operations will be perform ed on it.

   Q:    I f p r i n t f a n d s c a n f e x p e c t th e ir fir st a r g u m e n t to h a v e ty p e c h a r * , d o e s
         th a t m e a n th a t th e a r g u m e n t c a n b e a s tr in g RQPONMLKJIHGFEDCBA
                                                                          v a r i a b l e in s te a d o f a s tr in g lit-
         e r a ll
3 0 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 13      S tr in g s


                                  A:     Yes, as the following exam ple shows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         char fmt[] = "%d\n";
                                         int i ;
                                         •••
                                         printf(fmt, i);

                                         This ability opens the door to some intriguing possibilities— reading a format
                                         string as input, for example.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                 Q:      I f 1 w a n t p r i n t f to w r ite a s t r in g s t r , c a n ’t I j u s t s u p p ly s t r a s th e fo r m a t
                                         s t r in g , a s in th e f o llo w in g e x a m p l e ?

                                         printf(str);

                                  A:     Yes. but it’s risky. If s t r contains the %character, you w on’t get the desired result,
                                         s i n c e p r i n t f will assume it’s the beginning o faco n v ersio n specification.

                               *Q :      H o w can r e a d          l i n e d e t e c t w h e th e r g e t c h a r h a s fa ile d to r e a d a c h a r a c ­
                                         te r ? [p . 2 8 7 ]
                                  A:     If it can’t read a character, either because of an error or because of end-of-file,hgfedc
               E O F m a c ro > 2 2 .4   g e t c h a r retums the value EOF, which has type i n t . H ere’s a revised version of
                                         r e a d _ l i n e that tests w hether the return value o f g e t c h a r is EOF. Changes are
                                         marked in b o ld :

                                         int read_line(char str[], int n)

                                             int ch, i = 0;

                                             while ((ch = getchar())                          != ’\n' && ch 1= EOF)
                                               if (i < n)
                                                  str[i++] = ch;
                                             str [i] = '\0';
                                             return i;


                                 Q:      W h y d o e s s t r c m p r e tu r n a n u m b e r t h a t ’s le s s th a n , e q u a l to , o r g r e a te r th a n
                                         z e r o ? A ls o , d o e s th e e x a c t r e tu r n v a lu e h a v e a n y s ig n if ic a n c e ? [p . 2 9 2 ]
                                  A:     s t r c m p ’s return value probably stems from the way the function is traditionally
                                                                                                   The C Program m ing Lam
                                         written. Consider the version in Kernighan and R itchie’s cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         guage:

                                         int strcmp(char *s, char *t)

                                             int i;

                                             for (i = 0; s[i] == t[i] ; i+ + )
                                               if (s [i] == ’\0’)
                                                 return 0;
                                             return s[i] - t[i] ;
                                                                                                             3 0 7 onmlkjihgfedcbaZYXWVU
                                                                                              Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFE


     The return value is the difference between the first "m ism atched” characters in the
     s and t strings, which will be negative if s points to a “sm aller” string than t and
     positive if s points lo a “larger” siring. There’s no guarantee that s t r c m p is actu­
     ally written this way, though, so it’s best not to assume that the magnitude of its
     return value has any particular meaning.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q:   M y c o m p i le r is s u e s a w a r n in g w h e n I tr y to c o m p ile th e w h i l e s t a t e m e n t in
     th e s t r c a t fu n c tio n : kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

     while (*p++ = *s2++)cbaZYXWVUTSRQPONMLKJIHGFEDCBA
       !

     W h a t a m I d o in g w r o n g ?
A:   Nothing. Many compilers— but not all. by any means— issue a warning ify o u use
     = where == is normally expected. This warning is valid at least 95% of the time,
     and it will save you a lot ofdebugging ify o u heed it. Unfortunately, the warning
     isn’t relevant in this particular example; we actually do mean to use =. not ==. To
     gel rid o fth e warning, rewrite the w h i l e loop as follows:

     while ((*p++ = *s2++)                      ’= 0)


     Since the w h i l e statement normally tests whether *p+ + = * s 2 + + is not 0. we
     haven’t changed the meaning of the statement. The warning goes away, however,
     because the statement now tests a condition,• not an assiognment. With the GCC
     compiler, putting a pair of parentheses around the assignment is another way lo
     avoid a warnin vs~*:

     while ((*p++ = *s2++))RQPONMLKJIHGFEDCBA
         r




Q:   A r e th e s t r l e n a n d s t r c a t fu n c tio n s a c t u a lly w r itte n a s s h o w n in S e c tio n
     1 3 .6 ?
A:   Possibly, although it’s common practice for com piler vendors to write these func­
     tions— and many other string functions— in assembly language instead o fC . The
     string functions need to be as fast as possible, since they’re used often and have to
     deal with strings of arbitrary length. Writing these functions in assembly language
     makes it possible to achieve great efficiency by taking advantage of any special
     string-handling instructions that the CPU may provide.

Q:   W h y d o e s th e C s ta n d a r d u se th e te r m “ p r o g r a m p a r a m e t e r s ” in s te a d o f
     “ c o m m a n d - lin e a r g u m e n ts ” ? [p . 3 0 2 ]
A:   Programs aren't always run from a command line. In a typical graphical user inter­
     face, for example, programs are launched with a mouse click. In such an environ­
     ment, there’s no traditional command line, although there may be other ways of
     passing information to a program; the term “program parameters” leaves the door
     open for these alternatives.
            C h a p te r 13
3 0 8 ZYXWVUTSRQPONMLKJIHGFEDCBAS trin g s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                     D o I h a v e to u se th e n a m e s a r g c a n d a r g v fo r m a i n ’s p a r a m e te r s ? [p . 3 0 2 ]
                                           Q : onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            A:      No. Using the names a r g c and a r g v is inerely a convention, not a language
                                                    requirement.

                                           Q:       I ’v e s e e n a r g v d e c la r e d a s * * a r g v in s te a d o f * a r g v [ ] . Is th is le g a l?
                                            A:      Certainly. When declaring a parameter, writing * a is always the same as writing
                                                    a [ ] , regardless of the type of a 's elements.

                                           Q:       W e ’v e s e e n h o w to s e t u p a n a r r a y w h o s e e le m e n ts a r e p o in te r s to s t r in g lite r ­
                                                    a ls. A r e th e r e a n y o t h e r a p p lic a tio n s fo r a r r a y s o f p o in te r s ?
                                            A:      Yes. Although w e’ve focused on arrays of pointers to character strings, that’s not
                                                    the only application of arrays of pointers. We could just as easily have an array
                                                    whose elements point to any type of data, whether in array form or not. Arrays of
  d y n a m ic s to ra g e a llo c a tio n > 17.1   pointers are particularly useful in conjunction with dynamic storage allocation.




                                                    E x e rc is e s

S e c t io n 1 3 .3                           1.    The following function calls supposedly write a single new-line character, but some are
                                                    incorrect. Identify which calls don’t work and explain why.
                                                    (a) p r i n t f ( " % c " ,                          (g) p u t c h a r ( ’ \ n ' ) ;
                                                    (b) p r i n t f ( " % c " ,                          (h) p u t c h a r ( " \ n " ) ;
                                                    (c) p r i n t f (" % s" ,                            (i) p u t s ( ' \ n ' ) ;
                                                    (d) p r i n t f ( ” % s” t                           (i) p u t s ( ” \ n ” ) ;
                                                    (e) p r i n t f ( ' \ n ’ )                          (k) p u t s ( ” ") ;
                                                    (0 p r i n t f ( ” \ n " )

                                    ©         2.    Suppose that p has been declared as follows:
                                                    c h a r *p = " a b c " ;
                                                    Which of the following function calls are legal? Show the output produced by each legal
                                                    call, and explain why the others are illegal.
                                                    (a)   p u tc h a r(p );
                                                    (b)   p u t c h a r (* p ) ;
                                                    (c)   p u t s (p) ;
                                                    (d)   p u t s (* p ) ;

                                           *3.      Suppose that we call s c a n f as follows:
                                                    s c a n f(" % d % s % d " ,    & i,    s,    & j);
                                                    If the user enters 1 2 a b c 3 4 5 6 d e f 7 8, what will bc the values of i , s, and j after the
                                                    call? (Assume that i and j are i n t variables and s is an array ofcharacters.)

                                    ©        4.     Modify the r e a d _ _ l i n e function in each of the following ways:
                                                    (a) Have it skip white space before beginning to store input characters.
                                                    (b) Have it stop reading at the lirst white-space character. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                     Hint: To determine whetheror
           i s s p a c e fu n c tio n > 2 3 . 5         not a character is white space, call the i s s p a c e function.
                                                                                                                                          309
                                                                                                                  E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIH


                                   (c) Have it stop reading al the first new-line character, then store the new-line character in
                                       the strin^s*.
                                   (d) Have it leave behind characters that il doesn't have room to store.

S e c tio n 1 3 .4                    (a) Write a function named c a p i t a l i z e
                             5. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                that capitalizes all letters in its argument. The
                                           argument will be a null-terminated string containing arbitrary characters, not just letters.
                                           Use array subscripting lo access the characters in the siring. Hint: Use the t o u p p e r func­
                                > 2 3 .5   tion to convert each character to upper-case.
         t o u p p e r function cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   (b) Rewrite the c a p i t a l i z e function, this lime using pointer arithmetic lo access the
                                   characters in the string.

                       ©     6.    Write a function named c e n s o r that modifies a string by replacing every occurrence of
                                   f o o by x x x . Forexam ple, ihe string " f o o d f o o l " would become " x x x d x x x l ". Make
                                   the function as shori as possible without sacrificing clarity.

S e c tio n 1 3 .5           7.    Suppose that s t r is an array of characters. Which one of the following statements is not
                                   equivalent lo the other three? kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   (a) *str = 0;
                                   (b) str [0] = 1 \0 ';
                                   (c) strcpy(str, "");
                                   (d) strcat (str, "") ;

                       ©   *8 .    Whal will be the value of the strin.^u* s t r after the followingu> staiements have been executed?
                                   strcpy(str, "tire-bouchon”);
                                   strcpy(&str[4], "d-or-wi");
                                   strcat(str, "red?");

                             9.    Whal will be the value of the string s l after the following statements have been executed?
                                   strcpy(sl, "computer");
                                   strcpy(s2, "science");
                                   if (strcmp(sl, s2) < 0)
                                     strcat (sl, s2);
                                   else
                                     strcat(s2, sl);
                                   sl[strlen(sl)-6] = '\0';

                       ©    10.    The following function supposedly creates an identical copy o fa string. What\s wrong with
                                   the function?
                                   char *duplicate(const char *p)

                                      char *q;
                                      strcpy(q, p);
                                      return q;


                            11.    The Q&A section at the end of this chapier shows how the s t r c m p function might be wril-
                                   ten using array subscripting. Modify the function to use pointer arithmetic instead.

                            12.    Write the following function:
                                                        &




                                   void get_extension(const char *file_name, char *extension);
3 1 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r1 3      S trin g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       f i l e _ n a m e points to a string containing a file name. The function should store the exten­
                                       sion on the file name in the string pointed to by e x t e n s i o n . For example, ifth e file name
                                       is "m em o. t x t ", the function will store ” t x t ” in the string pointed to by e x t e n s i o n . If
                                       the file name doesn’t have an extension, the function should store an empty string (a single
                                       null character) in the string pointed to by e x t e n s i o n . Keep the function as simple as pos­
                                       sible by having it use the s t r l e n and s t r c p y functions.

                               l3.    Write the following function:
                                      v o i d b u i l d _ i n d e x _ u r l ( c o n s t c h a r * d o m a in ,   c h a r * in d e x _ u rl);
                                       d o m a in points to a string containing an Internet domain, such as "k n k i n g . c o m ". The
                                       function should add " h t t p : / / w w w . " to the beginning of this string and " /
                                       i n d e x . h t m l " to the end of the string, storing the result in the string pointed to by
                                       i n d e x _ u r l . (In this example, the result will be "h t t p : / / w w w . k n k i n g . c o m /
                                       i n d e x . h t m l " . ) You may assume that in d e x _ _ u r l points to a variable that is long
                                       enought to hold the resulting string. Keep the function as simple as possible by having it use
                                       the s t r c a t and s t r c p y functions.aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 1 3 .6           * l4 .   What does the following program print?
                                       # in c lu d e    < s td io .h >
                                       i n t m a in (v o id )

                                           ch ar s[]        = " H s jo d i" ,       *p;
                                          f o r (p = S ;           * p ; p+ + )
                                              --* p ;
                                          p u ts (s );
                                          r e t u r n 0;


                         © *15.        Let f be the following function:
                                       in t   f ( c h a r *s,       c h a r * t)

                                          c h a r * p l,      *p2;
                                           f o r ( p l = s ; * p l ; p l+ + ) {
                                               f o r (p2 = t ; * p 2 ; p 2 + + )
                                                   i f ( * p l == * p 2 ) b r e a k ;
                                               i f (* p 2 == ' \ 0 ' ) b r e a k ;

                                          re tu rn p l        - s;

                                       (a) What is the value of f (" a b c d " , " b a b c " ) ?
                                       (b) What is the value of f ( " a b c d " , " b c d " ) ?
                                       (c) In general, what value does f return when passed two strings s and t ?

                         ©    16.      Use the techniques of Section 13.6 to condense the c o u n t_ _ s p a c e s function of Section
                                       13.4. In particular, replace the f o r statement by a w h i l e loop.

                               17.    Write the following function:
                                                              <p



                                      b o o l te s t _ e x t e n s i o n ( c o n s t c h a r * file _ n a m e ,
                                                                           c o n st c h a r * e x te n s io n );
                                                                                                                                    311onmlkjihgfedcbaZYXWVUTS
                                                                                            P r o g ra m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFED


                               f i l e _ n a m e points lo a string containing a file name. The function should retum t r u e if
                               the file’s extension matches the string pointed to by e x t e n s i o n , ignoring the case of let­
                               ters. For example, the call t e s t _ e x t e n s i o n ( " m e m o . t x t " , "T X T ") w ould return
                               t r u e . Incorporate the “search for the end o f a string” idiom into your function. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                            H int: Use
c o u p p e r lunclion >23.5   the t o u p p e r function to convert characters to upper-case before comparing them.

                        18.    Write the followingc^ function:
                               v o id     re m o v e _ file n a m e (c h a r * u r l ) ;
                               u r l points to a string containing a URL (Uniform Resource Locator) that ends with a file
                               name (such as " h t t p : / / w w w . k n k i n g . c o m / i n d e x . h t m l "). The function should
                               modify the string by removing the file name and the preceding slash, (ln this example, the
                               result will be " h t t p : / / w w w .k n k i n g .c o m ".) Incoq>orate the “search for the end of a
                               string” idiom into your function. Hint: Have the function replace the last slash in the siring
                               by a null character.aZYXWVUTSRQPONMLKJIHGFEDCBA




                               P r o g r a m m in g P r o je c ts

                  ©       L    Write a program that finds the “smallest” and “largest” in a series of words. After the user
                               enters the words, the program will determine which words would come first and last if the
                               words were listed in dictionary order. The program must stop accepting input when the user
                               enters a four-lcller word. Assume that no word is more than 20 letters long. An interactive
                               session with the program might look like this:
                               E n te r    w o rd     dog
                               E n te r    w o rd     z e b ra
                               E n te r    w o rd     ra b b it
                               E n te r    w o rd     c a tfis h
                               E n te r    w o rd     w a lru s
                               E n te r    w o rd     cat
                               E n te r    w o rd     fis h

                               S m a lle s t w o rd : c a t
                               L a r g e s t w o rd : z e b r a
                               Hint: Use two strings named s m a l l e s t _ w o r d and l a r g e s t _ w o r d to keep track of the
                               “smallest” and “largest” words entered so far. Each time the user enters a new word, use
                               s t r c m p to compare it with s m a l l e s t _ w o r d ; ifth e new word is “smaller.” use s t r c p y
                               to save it in s m a l l e s t _ w o r d . Do a sim ilar comparison with l a r g e s t _ w o r d . Use
                               s t r l e n to deiermine when the user has entered a four-letter word.

                         2.    Improve the r e m i n d . c program of Section I3.5 in the following ways:
                               (a) Have the program print an error message and ignore a reminder if the corresponding
                                   day is negative or larger than 3 l. Hint: Use the c o n t i n u e statement.
                               (b) Allow the user to enter a day. a 24-hour time, and a reminder. The printed rem inder list
                                   should be sorted first by day, then by lime. (The original program allows the user to
                                   enter a time, but it’s treated as part o flh e reminder.)
                               (c) Have the program print a one-yer/r reminder list. Require the user to enter days in the
                                   form niontli/dciy.

                         3.    Modify the d e a l . c program of Section 8.2 so that it prints the full names of the cards it
                               deals:
312 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 3     S trin g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      E n te r num ber o f c a rd s in h a n d : £
                                      Y our h an d :
                                      S even o f c lu b s
                                      Two o f s p a d e s
                                      F i v e o f d ia m o n d s
                                      A ce o f s p a d e s
                                      Two o f h e a r t s cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      Hint: Replace r a n k _ c o d e and s u i t _ c o d e by arrays containing pointers to strings.

                         ©     4.     Write a program named r e v e r s e . c that echoes its command-line arguments in reverse
                                      order. Running the program by typing
                                      r e v e r s e v o id     and n u ll
                                      should produce the following output:
                                      n u ll    and v o id

                               5.     Write a program named s u m .c that adds up its command-line arguments, which are
                                      assumed to be integers. Running the program by typing
                                      sum 8 24 62
                                      should produce the following output:
                                      T o ta l:     94
             a to i iunction >26.2    Hint: Use the a t o i function to convert each command-line arU
                                                                                                    g>ument from strin ke~- form to
                                      inte^g^er form.

                         ©     6.     Improve the p l a n e t . c program ofS ection l3.7 by having it ignore case when comparing
                                      command-line arguments with strings in the p l a n e t s array.

                               7.    Modify Programming Project 11 from Chapter 5 so that it uses arrays containing pointers to
                                     strings instead of s w i t c h statements. For example, instead of using a s w i t c h statement
                                     to print the word for the first digit, use the digit as an index into an array that contains the
                                     strings ’’t w e n t y ” , ’’t h i r t y ” , and so forth.

                               8.    Modify Programming Project 5 from Chapter 7 so that it includes (he following function:
                                      in t     c o m p u te _ s c r a b b le _ v a lu e ( c o n s t c h a r * w o rd );
                                      The function returns the SCRABBLE value of the string pointed to by w o rd .

                               9.    Modify Programming Project 10 from Chapter 7 so that it includes the following function:
                                      in t     c o m p u te _ v o w e l_ c o u n t(c o n s t c h a r * s e n te n c e ) ;
                                      The function reium s the num ber of vowels in the string pointed to by the s e n t e n c e
                                      parameter.

                              10.    Modify Programming Project 11 from Chapter 7 so that it includes (he following function:
                                      v o id    r e v e r s e _ n a m e ( c h a r * n a m e );
                                      The function expccts nam e to point to a string containing a first name followed by a last
                                      name. It modifies the string so that the last name comes first, followed by a comma, a space,
                                      the first initial, and a period. The original string may contain extra spaces before the first
                                      name, between the first and last names, and after the last name.

                              11.    Modify Programming Project 13 from Chapter 7 so that it includes the following function:
                                      d o u b le    c o m p u te _ a v e ra g e _ w o rd _ le n g th (c o n s t c h a r     * s e n te n c e );
                                      The function returns the average length of the words in the string pointed to by s e n t e n c e .
                                                                                                                313onmlkjihgfedcbaZYXWVUT
                                                                         P ro g ra m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE


12.    Modify Program ming Project 14 from C hapter 8 so that it stores the words in a two-
      dimensional c h a r array as it reads the sentence, with each row of the array storing a sin­
      g^tf'le word. Assum e that the sentence contains no more than 30 words and no word is more
       than 20 characters long. Be sure to store a null character at the end o fe a c h word so that il
      can be treated as a string.

13.   Modify Program m ing Project 15 from C hapter 8 so ihal it includes the following function:
      v o id    e n c ry p t(c h a r    *m essage,       in t    s h ift);
      The function expects m e s s a g e to point to a string containing the message to be encrypted;
      s h i f t represents the amount by which each letter in the m essage is lo be shifted.

14.   Modify Program m ing Project 16 from C hapter 8 so that il includes the following function:
      bool a re _ a n a g ra m s(c o n st c h a r          * w o rd l,    const      char      * w o rd 2 );
      The function returns t r u e if the strings pointed to by w o r d l and w o rd 2 are anagram s.

15.   Modify Program ming Project 6 from C hapter 10 so that il includes the following function:
      in t     e v a lu a te _ R P N _ e x p re s s io n (c o n s t c h a r   * e x p re s s io n );
      The function returns the value o fth e RPN expression pointed to by e x p r e s s i o n .

16.   Modify Program m ing Project I from Chapter 12 so that il includes the following function:
      v o id    re v e rse (c h a r     * m essa g e);
      The function reverses the siring pointed to by m e s s a g e . cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                      H int: Use two pointers, one ini­
      tially pointing to the first character of the string and the other initially pointing to the last
      character. Have the function reverse these characters and then move the pointers toward
      each olher, repeating the process until the pointers meet.

17.   Modify Program m ing Project 2 from C hapter 12 so that it includes the following function:
      bool      is jp a lin d ro m e (c o n s t c h a r      * m e ssa g e );
      The function returns t r u e if the string pointed to by m e s s a g e is a palindrom e.

18.   Write a program that accepts a date from the user in lhe form m m / d d / y y y y and then dis­
      plays it in the form m onth d d , yyyy, where m onth is the name o f the month:
      E n te r a d a t e (m m /d d /y y y y ): 2 /1 7 /2 0 1 1
      Y ou e n t e r e d t h e d a t e F e b r u a r y 1 7 , 2 0 1 1
      Store the month names in an array that contains pointers to strings.
1 4       T h e P re p ro ce s s o r                                         ZYXWVUTSRQPONMLKJIHGFEDCBA




                                            T h e re w ill a lw a y s b e th in g s w e w is h to s a y in o u r p ro g r a m s
                                                      th a t in a ll k n o w n la n g u a g e s c a n o n ly b e s a id p o o rly . onmlkjihgfedcbaZYXWV




          In previous chapters. Tve used the # d e f i n e and # i n c l u d e directives without
          going into detail about what they do. These directives— and others that we haven’t
          yet covered— are handled by the preprocessor,           a piece of software that edits C pro-
                                             cbaZYXWVUTSRQPONMLKJIHGFEDCBA

          gram sjust prior to compilation. Its reliance on a preprocessor makes C (along with
          C++) unique among major programming languages.
               The preprocessor is a powerful tool, but it also can be a source of hard-to-find
          bugs. Moreover, the preprocessor can easily be misused to create programs that are
          almost impossible to understand. Although some C programmers depend heavily
          on the preprocessor, 1 recommend that it— like so many other things in life— be
          used in moderation.                                                                   *
               This chapter begins by describing how the preprocessor works (Section 14.1)
          and giving some general rules that affect all preprocessing directives (Section
          14.2). Sections 14.3 and 14.4 cover two of the preprocessor’s major capabilities:
          macro definition and conditional compilation. (I’ll defer detailed coverage of file
          inclusion, the other major capability, until Chapter 15.) Section 14.5 discusses the
          preprocessor’s le.sser-used directives: # e r r o r , # l i n e , and # p r a g m a .




 1 4 .1   H o w th e P r e p r o c e s s o r W o rk s

          The behavior of the preprocessor is controlled by p rep ro cessin g directives: com ­
          mands that begin with a # character. W e’ve encountered two of these directives,
          # d e f i n e and # i n c l u d e , in previous chapters.
               The # d e f i n e directive defines a m a cro — a name that represents something
          else, such as a constant or frequently used expression. The preprocessorresponds to
          a # d e f i n e directive by storing the name o fth e macro together with its definition.hgfedcbaZYXWVUTSRQ



                                                                                                                            315
            C h a p te r1 4
3 1 6 ZYXWVUTSRQPONMLKJIHGFEDCBA T h e P r e p r o c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       When the macro is used later in the prograin, (he preprocessor “expands" the
                                       macro, replacing it by its defined value.
                                            The # i n c l u d e directive tells the preprocessor to open a particular file and
                                       “ include” its contents as part ol' the file being compiled. For example, the line kjihgfedcbaZ
                                       #include <stdio.h>

                                       instructs the preprocessor to open the file named s t d i o . h and bring its contents
                                       into the program. (Among other things, s t d i o . h contains prototypes for C’s
                                       standard input/output functions.)
                                            The following diagram shows the preprocessor’s role in the compilation pro­
                                       cess:
                                                                                              C p ro g ra m
                                                                                                     I
                                                                                                    T
                                                                                                                     1
                                                                                          P re p ro c e s s o r       I


                                                                                        M o d ifie d C p ro g ra m




                                                                                             C o m p ile r



                                                                                            O b je c t c o d e


                                       The input to the preprocessor is a C program, possibly containing directives. The
                                       preprocessor executes these directives, removing (hem in the process. The output
                                       of the preprocessor is another C program: an edited version o f the original pro­
                                       gram, containing no directives. The preprocessor’s output goes directly into the
                                       compiler, which checks the program for errors and translates it to object code
                                       (machine instructions).
                                            To see whal the preprocessor does, let’s apply it to the c e l s i u s . c program
                                       of Section 2.6. H ere’s the original program:
                                       /* Converts a Fahrenheit temperature to Celsius */

                                       #include <stdio.h>

                                       #define FREEZING_PT 32.0f
                                       #define SCALE_FACTOR (5.0f / 9.0f)

                                       int main(void)

                                           float fahrenheit, celsius;

                                           printf("Enter Fahrenheit temperature: ");
                                           scanf("%f", &fahrenheit);

                                           celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
                                           14.1                                                           317
                                                        H o w th e P r e p ro c e s s o r W o rk s kjihgfedcbaZYXWVUTSRQPONMLKJIH

  printf("Celsius equivalent is: %.lf\n", celsius);

   return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


After preprocessing, the program will have the following appearance:PONMLKJIHGFEDCBA

Blank line
Blank line
Lines brought infroni stdio.h
Blank line
Blank line
Blank line
Blank line
int main(void)

   float fahrenheit, celsius;

  printf("Enter Fahrenheit temperature:                                   ”);
  scanf("%f", &fahrenheit);

   celsius = (fahrenheit - 32.0f) * (5.0f / 9.0f);

  printf("Celsius equivalent is: %.lf\n", celsius);

   return 0;


The preprocessor responded to the # i n c l u d e directive by bringing in the con­
tents of s t d i o . h . The preprocessor also removed the # d e f i n e directives and
replaced FREEZING_PT and SCALE_FACTOR wherever they appeared later in
the file. Notice that the preprocessor doesn't remove lines containing directives;
instead, it simply makes them empty.
     As this example shows, the preprocessor does a bit more than just execute
directives. In particular, it replaces each com m ent with a single space character.
Some preprocessors go further and remove unnecessary w hite-space characters,
including spaces and tabs at the beginning of indented lines.
     In the early days of C. the preprocessor was a separate program that fed its
output into the compiler. Nowadays, the preprocessor is often part o f the compiler,
and some of its output may not necessarily be C code. (For example, including a
standard header such as < s t d i o . h > may have the cffect of making its functions
available to the program without necessarily copying the contents of the header
into the program 's source code.) Still, it’s useful to think of the preprocessor as
separate from the compiler. In fact, most C com pilers provide a way to view the
output of the preprocessor. Some compilers generate preprocessor output when a
certain option is specified (GCC will do so when the -E option is used). Others
come with a separate program that behaves like the integrated preprocessor. Check
your com piler's documentation for more information.
     A word ofcaution: The preprocessor has only a limited knowledge of C. As
a result, it’s quite capable of creating illegal program s as it executes directives.
Often the original program looks fine, making errors harder to find. In com plicated
318 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p t e r 14     T he P re p ro c e s s o r


                                   programs, examining the output of the preprocessor may prove useful for locating
                                   this kind oferror.aZYXWVUTSRQPONMLKJIHGFEDCBA



                      1 4 .2       P r e p r o c e s s in g D ir e c tiv e s
                                   Most preprocessing directives fall into one of three categories:RQPONMLKJIHGFEDCBA

                                                                        The # d e f i n e directive defines a macro; the # u n d e f
                                                 ■ M a c r o d e f in itio n .
                                                     directive removes a macro definition.
                                                                      The # i n c l u d e directive causes the contents of a specified
                                                 ■ F ile in c lu s io n .
                                                     file to be included in a program.
                                                 ■                               The # i f , # i f d e f , # i f n d e f , # e l i f , # e l s e .
                                                     C o n d itio n a l c o m p ila tio n .
                                                     and # e n d i f directives allow blocks of text to be either included in or
                                                     excluded from a program, depending on conditions that can be tested by the
                                                     preprocessor.
                                  The remaining directives— # e r r o r , # l i n e . and # p r a g m a — are more special­
                                  ized and therefore used less often. We’ll devote the rest of this chapter to an in­
                                  depth examination of preprocessing directives. The only directive we won’t dis­
                                  cuss in detail is # i n c l u d e , since it’s covered in Section l5.2.
                                      Before we go further, let’s look at a few rules that apply to all directives:

                                     ■               D i r e c t i v e s a l w a y s b e g i n w i t h t h e # s y m b o l . The # symbol need not be at the be­
                                                     ginning o fa lin e , as long as only white space precedes it. Afler the # comes the
                                                     name o fth e directive, followed by any other information the directive requires.
                                             ■ Any          n u m b e r o f s p a c e s a n d h o r iz o n ta l ta b        c h a r a c t e r s m a y s e p a r a t e th e
                                                     t o k e n s in a d i r e c t i v e . For example, the following directive is legal: kjihgfedcbaZYXWVUTSRQP

                                                     #             define            N            100

                                         ■           D ir e c tiv e s a lw a y s e n d a t th e f i r s t n e w -lin e c h a ra c te r , u n le s s e x p lic itly co n ­
                                                             To continue a directive to the next line, we must end the current line
                                                     tin u e d .
                                                     with a \ character. For example, the following directive defines a macro that
                                                     represents the capacity o fa hard disk, measured in bytes:
                                                     #define DISK_CAPACITY (SIDES *             \
                                                                            TRACKS_PER_SIDE *   \
                                                                            SECTORS_PER_TRACK * \
                                                                            BYTES_PER_SECTOR)

                                                 ■ D ir e c tiv e s                                                Although we usually pul
                                                                      c a n a p p e a r a n y w h e r e in a p r o g r a m .
                                                     # d e f i n e and # i n c l u d e directives at the beC
                                                                                                           g^7inningt**o fa file . other directives
                                                     are more likely to show up later, even in the middle of function definitions.
                                             ■       C o m m e n t s m a y a p p e a r o n t h e s a m e l i n e a s a d i r e c t i v e . In fact, it’s good prac­
                                                     tice to put a comment at the end of a macro definition to explain the meaning
                                                     of the macro:
                                                     #define FREEZING_PT 32.0f                                /* freezing point of water */
                                                                                            1 4 .3                                     319aZYXWVUTSRQPO
                                                                                                     M a c r o D e fin itio n s kjihgfedcbaZYXWVUTSRQPONMLKJI




                   1 4 .3      M a c r o D e f i n i t i o n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                               The macros that w e’ve been using since Chapter 2 are known as sim ple macros,
                               because they have no parameters. The preprocessor also supports param eterized
                               macros. We’ll look first at simple macros, then at parameterized macros. After
                               covering them separately, w e’ll examine properties shared by both.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                               S im p le M a c r o s
                               The definition of a sim ple m acro (or object-like m acro, as it's called in the C stan­
                               dard) has the form hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


# d e f i n e d ir e c tiv e                               #define identifier replacem ent-list
     (s im p le m a c ro )

                               replacement-list is any sequence o fp re p ro ce ssin g tokens, which are similar to the
                               tokens discussed in Section 2.8. Whenever we use the term “token” in this chapter,
                               it means “preprocessing token.”
                                    A macro’s replacement list may include identifiers, keywords, numeric con­
                               stants, character constants, string literals, operators, and punctuation. When it
                               encounters a macro definition, the preprocessor makes a note that identifier repre­
                               sents replacement-list; wherever identifier appears later in the file, the preproces­
                               sor substitutes replacem ent-list.


                               Don’l put any extra symbols in a macro definition— they’ll become part of the
                    A          replacement list. Putting the = symbol in a macro definition is a common error:
                               #define N = 100                /*** WRONG ***/
                               •••

                               int a[N] ,-                    /* becomes int a[= 100] ; */

                               In this example, w e’ve (incorrectly) defined N to be a pair ol’ tokens (= and 100).
                               Ending a macro definition with a semicolon is another popular mistake:
                               #define N 100;                 /*** WRONG ***/
                               •••

                               int a[N];                      /* becomes int a[100;]; */

                               Here N is defined to be the tokens 10 0 and ;.
                                    The compiler will detect most errors caused by extra symbols in a macro defi­
                               nition. Unfortunately, the compiler will flag each use of the macro as incorrect,
                               rather than identifying the actual culprit— the macro’s definition— which will have
                               been removed by the preprocessor.


                                    Simple macros are primarily used for defining what Kernighan and Ritchie
                               call “manifest constants.” Using^ macros,1 we can O
                                                                                 g iv7e names to numeric, character,
                     Q&A       and stringo values:
3 2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P re p r o c e s s o r kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               #define STR_LEN 80
                                               #define TRUE    1
                                               #define FALSE   0
                                               #define PI      3.14159
                                               #define CR      *\r'
                                               #define EOS     ’\0‘
                                               #define MEM ERR "Error: not enough memory"onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                               Using # d e f i n e to create names for constants has several significant advantages:RQPO

                                                                                      The name of the macro— if well-chosen—
                                                ■ I t m a k e s p r o g r a m s e a s ie r to re a d .
                                                    helps the reader understand the meaning of the constant. The alternative is a
                                                    program full o f “magic numbers” that can easily mystify the reader.
                                                                                             We can change the value of a constant
                                                ■ I t m a k e s p r o g r a m s e a s i e r to m o d if y .
                                                    throughout a program by modifying a single macro definition. “ Hard-coded’’
                                                    constants are more difficult to change, especially since they sometimes appear
                                                    in a slightly altered form. (For example, a program with an array of length 100
                                                    may have a loop that goes from 0 to 99. If we merely try to locate occurrences
                                                    of 1 0 0 in the program, w e’ll miss the 99.)
                                                                                                                  If a numerical con­
                                                ■ I t h e lp s a v o id in c o n s is te n c ie s a n d ty p o g r a p h ic a l   e rro rs.
                                                    stant like 3 .1 4 1 5 9 appears many times in a program, chances are it will
                                                    occasionally be written 3 .1 4 1 6 or 3 .1 4 1 9 5 by accident.
                                                    Although simple macros are most often used to define names for constants,
                                               they do have other applications:

                                                                                                Wc can— in effect— alter the syn­
                                                ■ M a k in g m in o r c h a n g e s to th e s y n ta x o f C .
                                                    tax o fC by defining macros that serve as alternate names for C symbols. For
                                                    example, programmers who prefer Pascal’s b e g i n and e n d to C ’s { and }
                                                    can define the following macros:
                                                    #define BEGIN ’
                                                    #define END
                                                    We could go so far as to invent our own language. For example, we might cre­
                                                    ate a LOOP “statement” that establishes an infinite loop:
                                                    #define LOOP for (;; )
                                                    Changing the syntax o fC usually isn’t a good idea, though, since it can make
                                                    programs harder for others to understand.
                                                ■ R e n a m in g ty p e s.     In Section 5.2. we created a Boolean type by renaming i n t :
                                                    #define BOOL intaZYXWVUTSRQPONMLKJIHGFEDCBA

              ty p e d o fin itio n s > 7 .5        Although some programmers use macros for this purpose, type definitions are
                                                    a superior way to define type names.
                                                                                            Macros play an important role in con­
                                                ■ C o n tr o llin g c o n d itio n a l c o m p ila tio n .
                                                    trolling conditional compilation, as w e’ll see in Section 14.4. Forexam ple, the
                                                    presence of the following line in a program might indicate that it’s to be com-
                                                                                                       14.3        M a c ro D e fin itio n s hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                                                     321 onmlkjihgfedcbaZYXWV


                                                piled in “debugging m ode;’ with extra statements included to produce debug­
                                                ging output:aZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 #define DEBUG
                                                Incidentally, it’s legal for a m acro’s replacement list to be empty, as this exam ­
                                                ple shows.
                                               W hen macros are used as constants, C programmers customarily capitalize all
                                          letters in their names. However, there’s no consensus as to how to capitalize mac­
                                          ros used for other purposes. Since macros (especially parameterized macros) can
                                          be a source ofbugs. some programmers like to draw attention to them by using all
                                          upper-case letters in their names. Others prefer lower-case names, following the
                                                                           The C P rogram m ing Language. dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                          style of Kernighan and Ritchie’s cbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                          P a r a m e te r iz e d M a c r o s

                                          The definition of a p a ra m eterized m acro (also known as a fu n c tio n -lik e m a cro )
                                          has the form


                                                                                                              x
     # d e f i n e d i r e c t iv e                   # d e fin e       id en tifier( x,   f   .v2 • ••• /        n ) replacem ent-list
( p a r a m e t e r i z e d m a c r o ) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                          where .Vj, _v2 , ..., x n arc identifiers (the m acro’s p a ra m eters). The parameters may
                                          appear as many times as desired in the replacement list.


                                         There must be no space between the macro name and the left parenthesis. If space
                                         is left, the preprocessor will assum e that w e’re defining a simple macro; it will
                                         treat U p x 2 f . . . t x n ) a s p a rto fth e re p la c e m e n tlis t.


                                                When the preprocessor encounters the definition of a parameterized macro, it
                                          stores the definition away for later use. W herever a macro in vocation o f the form
                                          id e n fiJ ie r (\\, y 2 , . . . , y l t ) appears later in the program (w hereV |, y 2 . .... y ft are
                                          sequences of tokens), the preprocessor replaces it with replacem ent-list, substitut­
                                          ing V] for .Vp y 2 for.v 2 , and so forth.
                                                For example, suppose that w e’ve defined the following macros:

                                          #define MAX(x,y)                      ((x)>(y)?(x):(y))
                                          #define IS_EVEN(n)                    ((n)%2==0)

                                          (The number ofparentheses in these macros may seem excessive, but there’s a rea­
                                          son. as w e’U see later in this section.) Now suppose that we invoke the two macros
                                          in the following way:

                                          i = M A X (j+k, m-n);
                                          if (IS_EVEN(i)) i++;
3 2 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P r e p r o c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                Thc preprocessor will replace these lines by kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                i = ((j+k)>(m-n)?(j+k):(m-n));
                                                if (((i)%2==0)) i++;

                                                As this example shows, parameterized macros often serve as simple functions. MAX
                                                behaves like a function that computes the larger o ftw o values. IS_EV EN behaves
                                                like a function that returns l ifits argument is an even num ber and 0 otherwise.
                                                     Here’s a more complicated macro that behaves like a function:
                                                #define TOUPPER(c)             ('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))

                                                    This macro tests whether the character c is between ' a ' and ' z '. If so, it pro­
                                                    duces the upper-case version of c by subtracting ' a ' and adding ' A ' . If not, it
                                                    leaves c unchanged. (The < c t y p e . h> header provides a similar function named
       < c t y p e . h > h e a d e r > 2 3 . 5 GFEDCBA

                                                    t o u p p e r that’s more portable.)
                                                          A parameterized macro may have an empty param eter list. Here’s an example:

                                                #define getchar()            getc(stdin)

                                                The empty parameter list isn’t really needed, but it makes g e t c h a r resemble a
                                                function. (Yes, this is the same g e t c h a r that belongs to < s t d i o . h>. W e’ll see
                                                in Section 22.4 that g e t c h a r is usually implemented as a macro as well as a
                                                function.)
                                                     Using a parameterized macro instead of a true function has a couple of advan­
                                                tages:cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  ■ T he p ro g ra m m ay be slightly fa ste r. A function call usually requires some
                                                    overhead during program execution— context inform ation must be saved,
                                                    arguments copied, and so forth. A macro invocation, on the other hand,
                                   C99              requires no run-time overhead. (Note, however, that C 99's inline functions
             In lin e fu n c tio n s > 1 8 .6       provide a way to avoid this overhead without the use of macros.)
                                                  ■ M acros are “g e n e ric .” Macro parameters, unlike function parameters, have
                                                    no particular type. As a result, a macro can accept arguments o fan y type, pro­
                                                    vided that the resulting program— after preprocessing— is valid. For example,
                                                    we could use the MAX macro to find the larger o f two values of type i n t .
                                                    l o n g , f l o a t , d o u b l e , and so forth.
                                                But parameterized macros also have disadvantages:
                                                  ■ T h e co m p iled code will o ften be larger. Each macro invocation causes the
                                                    insertion of the macro’s replacem ent list, thereby increasing the size of the
                                                    source program (and hence the compiled code). The more often the macro is
                                                    used, the more pronounced this effect is. The problem is com pounded when
                                                    macro invocations are nested. Consider what happens when we use MAX to
                                                    find the lar^gest of three numbers:
                                                     n = MAX (i, MAX(j , k) ) ;

                                                     Here’s the same statement after preprocessing:
                                                     n =    ((i)>(((j)>(k)?(j):(k)))?(i):(((j)>(k)?(j):(k))));
                                                                         1 4 .3                                     3 2 3 RQPONMLKJIHGFEDCB
                                                                                  M a c ro D e fin itio n s hgfedcbaZYXWVUTSRQPONMLKJIHGFED


 ■ A r g u m e n ts a r e n                                      When a function is called,
                                                                        the com piler
                                 ’t t y p e - c h e c k e d . onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
       checks each argum ent to see if it has the appropriate type. If not, either the
       argum ent is converted to the proper type or the com piler produces an error
       message. M acro argum ents aren’t checked by the preprocessor, nor are they
       converted.
                                                        As w e’ll see in Section 17.7, C
 ■ I t ’s n o t p o s s i b l e t o h a v e a p o i n t e r t o a m a c r o .
       allows pointers to functions, a concept that’s quite useful in certain program ­
       ming situations. M acros are rem oved during preprocessing, so there’s no cor­
       responding notion of “pointer to a m acro” ; as a result, macros can ’t be used in
       these situations.
                                                                     A function evaluates
 ■ A m a c r o m a y e v a lu a te its a r g u m e n ts m o r e th a n o n c e .
       its argum ents only once; a m acro may evaluate its argum ents tw o or more
       times. Evaluating an argum ent m ore than once can cause unexpected behavior
       if the argum ent has side effects. C onsider what happens if one o f MAX’s argu­
       ments has a side effect:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
       n = MAX(i++, j );

       H ere’s the sam e line after preprocessing:

       n=     ((i++)>(j)?(i++):(j));

       lf i is larger than j , then i will be (incorrectly) incremented twice and n will
       be assigned an unexpected value.


Errors caused by evaluating a m acro argum ent m ore than once can be difficult to
find, because a m acro invocation looks the sam e as a function call. To m ake m at­
ters worse, a m acro may work properly most o f the tim e, failing only for certain
argum ents that have side effects. For self-protection, it’s a good idea to avoid side
effects in ar4g_*>'um ents.


     Param eterized m acros are good for m ore than ju st sim ulating functions. In
particular, they’re often used as patterns for segm ents o f code that we find our­
selves repeating. Suppose that we grow tired o fw ritin g

printf("%d\n", i);

every time we need to print an integer i . We m ight define the following macro,
which makes it easier to display integers:

#define PRINT__INT(n) printf("%d\n", n)

Once P R IN T _ IN T has been defined, the preprocessor will turn the line

PRINT_INT(i/j);

into

printf("%d\n", i/j);
3 2 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P r e p r o c e s s o r aZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T h e # O p e r a to r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      M acro definitions may contain two special operators, # and # # . N either operator is
                                      recognized by the com piler; instead, they’re executed during preprocessing.
                                           The # operator converts a macro argument into a string literal; it can appear
                          Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      only in the replacement list of a parameterized macro. (The operation performed
                                      by # is known as “stringization." a term that I’m sure you w on’t find in the dictio­
                                      nary.)
                                           There are a number o f uses for #; let’s consider ju st one. Suppose that we
                                      decide to use the P R IN T _ IN T macro during debugging as a convenient way to
                                      print the values of integer variables and expressions. The # operator makes it pos­
                                      sible for P R IN T _IN T to label each value that it prints. H ere’s our new version of
                                      PR IN T _IN T :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     #define PRINT_INT(n) printf(#n " = %d\n", n)

                                     The # operator in front of n instructs the preprocessor to create a string literal from
                                     P R IN T _ IN T 's argument. Thus, the invocation

                                     PRINT_INT(i/j);

                                     will become

                                     printf("i/j" " = %d\n", i/j);

                                     We saw in Section 13.l that the com piler autom aticallyjoins adjacent string liter­
                                     als, so this statement is equivalent to

                                     printf("i/j = %d\n", i/j);

                                     When the program is executed, p r i n t f will display both the expression i / j and
                                     its value. If i is 11 and j is 2. for example, the output will be

                                     i/j = 5


                                     T h e # # O p e r a to r

                                     The # # operator can “paste” two tokens (identifiers, for example) together to form
                                     a single token. (Not surprisingly, the # # operation is known as “token-pasting.” ) If
                                     one of the operands is a macro parameter, pasting occurs after the param eter has
                                     been replaced by the corresponding argument. Consider the following macro:

                                     #define MK_ID(n) i##n

                                     When MK_ID is invoked (as MK_ID ( 1 ) . say), the preprocessor first replaces the
                                     parameter n by the argum ent (1 in this case). Next, the preprocessor joins i and 1
                                     to make a single token ( i l ) . The following declaration uses MK_ID lo create three
                                     identifiers:

                                     int MK_ID(1), MK_ID(2), MK_ID(3);
                                                                         1 4 .3                                          3 2 5 onmlkjihgfedcbaZ
                                                                                    M a c r o D e fin it io n s hgfedcbaZYXWVUTSRQPONMLK


After preprocessing, this declaration becomes kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

int il, i2, i3;

     The # # operator isn’t one of the most frequently used features o f the prepro­
cessor; in fact, it’s hard to think ofm anysituations that require it. To find a realistic
application of # # , let's reconsider the MAX macro described earlier in this section.
As we observed then, MAX doesn’t behave properly if its arguments have side
effects. The alternative to usingc> the MAX macro is to write a m ax function. Unfor-
tunately, one m ax function usually isn’t enough; we may need a m ax function
                                           ** hose arguments are f l o a t values, and so
whose arkg^»uments are i n 2t values, one cw
on. All these versions of m ax would be identical except for the types of the argu­
ments and the return type, so it seems a shame (o define each one from scratch.
     The solution is to write a macro that expands into the definition of a m ax func­
tion. The macro will have a single parameter, t y p e , which represents the type of
the arguments and the return value. T here’s ju s t one snag: if we use the macro to
create more than one m ax function, the program w on’t compile. (C doesn’t allow
two functions to have the same name if both are defined in the same file.) To solve
this problem, w e’ll use the # # operator to create a different nam e for each version
o fm a x . Here’s what the macro will look like:

#define GENERIC_MAX(type)       \
type type##_max(type x, type y) \

      return x > y ? x : y;                                        \


Notice how t y p e is joined with _ m ax to form the name of the function.
     Suppose that we happen to need a m ax function that works with f l o a t val­
ues. Here’s how w e’d use GENERIC_MAX lo define the function:

GENERIC_MAX(f1oa t)

The preprocessor expands this line into the following code:

float float_max(float x, float y) { return x > y ? x : y; }dcbaZYXWVUTSRQP


G e n e r a l P r o p e r tie s o f M a c r o s
Now that w e’ve discussed both simple and parameterized macros, let’s look at
some rules that apply to both:RQPONMLKJIHGFEDCBA
  ■    A m a c r o ’s r e p l a c e m e n t l i s t m a y c o n t a i n i n v o c a t i o n s o f o t h e r m a c r o s .   For
       example, we could define the macro TWO_PI in terms o fth e macro P I:

       #define PI     3.14159
       #define TWO_PI (2*PI)

       When it encounters TWO_PI later in the program, the preprocessor replaces it
       by ( 2 * P I ) . The preprocessor then r e s c a n s the replacem ent list to see if it
            C h a p te r 14
3 2 6 ZYXWVUTSRQPONMLKJIHGFEDCBAT h e P re p ro c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            contains invocations o f other macros ( P I , in this case). The preprocessor will
                                            rescan the replacement list as many times as necessary to elim inate all macro dcbaZY
                          Q&A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        ■ T h e p rep ro cesso r rep la ces o n ly en tire to ken s, n o t p o rtio n s o f to ken s. As a
                                          result, the preprocessor ignores macro names that are embedded in identifiers,
                                          character constants, and string literals. For example, suppose that a program
                                          contains the following lines:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            #define SIZE 256

                                            int BUFFER_SIZE;

                                            if (BUFFER_SIZE > SIZE)
                                              puts("Error: SIZE exceeded");

                                            After preprocessing, these lines will have the following appearance:

                                            int BUFFER_SIZE;

                                            if (BUFFER_SIZE > 256)
                                              puts("Eri'or: SIZE exceeded");

                                            The identifier BUFFER S IZ E and the string " E r r o r : S IZ E e x c e e d e d "
                                                                             ^^^                        s^


                                            w eren’t affected by preprocessing, even though both contain the word S IZ E .
                                        ■ A m acro d e fin itio n n o rm a lly re m a in s in e ffe c t u n til th e e n d o f th e f i l e in
                                          w hich it appears. Since macros are handled by the preprocessor, they don’t
                                          obey normal scope rules. A macro defined inside the body of a function isn*t
                                          local to that function; it remains deRned until the end of the file.
                                        ■ A m acro m a y n o t be d e fin e d tw ice u n less (he n ew d e fin itio n is id e n tic a l to
                                          th e o ld one. Differences in spacing are allowed, but the tokens in the m acro’s
                                          replacem ent list (and the parameters, ifan y ) must be the same.
                                        ■ M a cro s m a y be “u n d e fin e d ” by th e # u n d e f directive. The # u n d e f direc­
                                          tive has the form


       # u n d e f directive                                                       # u n d e f id entifier


                                            where identifier is a macro name. For example, the directive

                                            #undef N

                                            removes the current definition of the macro N. (lfN hasn’t been defined as a
                                            macro, the # u n d e f directive has no effect.) One use o f # u n d e f is to remove
                                            the existing definition o f a macro so that it can be given a new definition.GFEDCBA
                                                          u^                                                 t^




                                      P a r e n th e s e s in M a c r o D e fin itio n s

                                     The replacem ent lists in our macro definitions have been full of parentheses. Ts it
                                     really necessary to have so many? The answer is an em phatic yes; if we use fewer
                                                1 4 .3                                      3 2 7 onmlkjihgfedcbaZYXWVUT
                                                         M a c ro D e fin itio n s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC


parentheses, the macros will sometimes give unexpected— and undesirable—
results.
     There are two rules to follow when deciding where to put parentheses in a
macro definition. First, if the macro’s replacement list contains an operator, always
enclose the replacement list in parentheses:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

#define TWO_PI (2*3.14159)

Second, if the macro has parameters, put parentheses around each parameter every
time il appears in the replacement list:

#define SCALE(x)        ((x)*10)

Without the parentheses, we can’t guarantee that the compiler will treat replace­
ment lists and arguments as whole expressions. The compiler may apply the rules
ofoperator precedence and associativity in ways that we didn’t anticipate.
    To illustrate the importance of putting parentheses around a macro’s replace­
ment list, consider the following macro definition, in which the parentheses are
missing^:

#define TWO_PI 2*3.14159
  /* needs parentheses around replacement list */

During preprocessing, the statement

conversion_factor = 360/TWO_PI;

becomes

conversion_factor = 360/2*3.14159;

The division will be performed before the multiplication, yielding a result different
from the one intended.
     Putting parentheses around the replacement list isn’t enough if the macro has
parameters— each occurrence o f a parameter needs parentheses as well. For exam ­
ple, suppose that SCALE is defined as follows:

#define SCALE(x)        (x*10)      /* needs parentheses around x */

During preprocessing, the statement

j = SCALE(i+l);

becomes

j = (i+l*10);

Since multiplication lakes precedence over addition, this statement is equivalent to

j = i+10;

Of course, what we wanted was

j = (i+l)*10;
            C h a p te r 14
3 2 8 ZYXWVUTSRQPONMLKJIHGFEDCBA T h e P re p r o c e s s o r




                                       A shortage of parentheses in a macro definition can cause some of C ’s most frus­
                         A             trating errors. The program will usually com pile and the m acro will appear to
                               onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       work, failing only at the least convenient times.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                     C r e a tin g L o n g e r M a c r o s

                                     The com m a operator can be useful for creating m ore sophisticated macros by
                                     allowing us to make the replacement list a series ofexpressions. For example, the
                                     following macro will read a string and then print it:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     #define ECHO(s)               (gets(s), puts(s))

                                     Calls o f g e t s and p u t s are expressions, so it’s perfectly legal to com bine them
                                     using the com m a operator. We can invoke ECHO as though it were a function:

                                     ECHO(str);                 /* becomes (gets(str), puts(str)); */

                                         Instead o f using the comma operator in the definition of ECHO, we could have
                                     enclosed the calls o f g e t s and p u t s in braces lo form a com pound statement:

                                     #define ECHO(s)               { gets(s); puts(s);    }

                                     Unfortunately, this method doesn’t work as well. Suppose that we use ECHO in an
                                     i f statement:

                                     if (echo_flag)
                                       ECHO(str);
                                     else
                                       gets(str);

                                     Replacing ECHO gives the following result:

                                     if (echo_flag)
                                       { gets(str); puts(str); };
                                     else
                                       gets(str);

                                     The com piler treats the first two lines as a com plete i f statement:

                                     if (echo_flag)
                                       { gets(str); puts(str); }

                                     It treats the semicolon that follows as a null statem ent and produces an error mes­
                                     sage for the e l s e clause, since it doesn’t belong to any i f . We could solve thc
                                     problem by remem bering not to put a semicolon after each invocation of ECHO,
                                     but then the program would look odd.
                                           The com m a operator solves this problem for ECHO, but not for all macros.
                                                                                           sia tenients, not ju st a series of
                                     Suppose that a macro needs to contain a series o f cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     expressions. The com m a operator is of no help: it can glue together expressions.
                                                                                 1 4 .3                                          3 2 9 onmlkjihgfedcbaZY
                                                                                               M a c ro D e fin itio n s hgfedcbaZYXWVUTSRQPONMLKJI


                         bul not statements. The solution is to wrap the statements in a d o loop w hose con­
                         dition is false (and which therefore will be executedjust once):kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                         do { ... } while (0)

                         Notice that the d o statement isn’t com plete— il needs a semicolon at the end. To
                         see this trick (ahem, technique) in action, let’s incorporate it into our ECHO macro:

                         #define ECHO(s)     \
                                 do {        \
                                   gets(s); \
                                   puts(s); \
                                 } while (0)

                         When ECHO is used, it must be followed by a sem icolon, which com pletes the d o
                         statement:

                         ECHO(str);
                           /* becomes do { gets(str); puts(str);                               } while (0); */dcbaZYXWVUTSRQPONMLKJIHG


                         P r e d e fin e d M a c r o s

                         C has several predefined macros. Each macro represents an integer constant or
                         string literal. As Table l4.l shows, these macros provide information about the
                         current compilation or about the com piler itself.

       T a b le 1 4 .1                N am e                              D e s c r ip tio n
Predefined Macros RQPONMLKJIHGFEDCBA
                                 __LINE__          Line iniinber o ffile being compiled
                                  __FILE__         Name of file being compiled
                                    DATE           Date of compilation (in the form “Mmm d d y y y y " )
                                  __TIME__         Time ofcom pilation (in the form "h h :m m : s s " )
                                  __STDC__         1 if the com piler conforms to the C standard (C89 or C99)

                              T h e __ DATE    and    TIM E     macros identify when a program was com ­
                         piled. For example, suppose that a program begins with the following statements:

                         printf("Wacky Windows (c) 2010 Wacky Software, Inc.\n");
                         printf("Compiled on %s at %s\n", __D A T E , __TIME__);

                         Each time it begins to execute, the program will print two lines of the form

                         Wacky Windows (c) 2010 Wacky Software, Inc.
                         Compiled on Dec 23 2010 at 22:18:48

                         This information can be helpful fordistinguishing am ong different versions o fth e
                         same program.
                              We can use t h e     L IN E   and    F IL E __ macros to help locate errors.
                         Consider the problem of detecting the location of a division by zero. W hen a C
                         program terminates prematurely because it divided by zero, there's usually no indi­
                         cation ofw hich division caused the problem. The following macro can help us pin­
                         point the source of the error:
3 3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P re p r o c e s s o r kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 #define CHECK_ZERO(divisor) \
                                                   if (divisor == 0) \
                                                     printf("*** Attempt to divide by zero on line %d "
                                                            "of file %s ***\n",   L I N E , F I L E )onmlkjihgfedcbaZYXWVUTSRQPONM

                                                 The CHECK_ZERO macro would be invoked prior to a division:

                                                 CHECK_ZERO(j );
                                                 k = i / j;

                                                 If j happens to be zero, a message of the following form will be printed:

                                                 *** Attempt to divide by zero on line 9 of file foo.c ***aZYXWVUTSRQP

                                                 Error-detecting macros like this one are quite useful. In fact, the C library has a
                                 > 2 4 .1
           a s s e r t m a c r o BA              general-purpose error-detecting macro named a s s e r t .
                                                      The    STDC        macro exists and has the value I if the compiler conforms to
                                                 the C standard (either C89 or C99). By having the preprocessor test this macro, a
                                                 program can adapt to a compiler that predates the C89 standard (see Section 14.4
                                                 for an example).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 A d d it io n a l P r e d e f in e d M a c r o s in C 9 9

                                                 C99 provides a few additional predefined macros (Table 14.2).

                       T a b I c 1 4 .2                                     N am e                               D escrip tio n
     A dditional Predefined            STDC HOSTED                                             1 if this is a hosted im plem entation; 0 if it is
             M acros in C99 cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                     freestandinu^
                                                       STDC__ VERSION__                       Version o f C standard supported
                                                       STDC_IEC_559__ f                       1 ifIE C 60559 floating-point arithm etic is
                                                                                              supported
                                                       STDC_IEC_5 5 9_COMPLEX__ '             1 if IEC 60559 com plex arithm etic is supported
                                                       STDC_ISO_10646__ ’                     yyyyn m fL i f w c h a r _ t values match the lSO
                                                                                              10646 standard o f the specified year and month
                                                  f o o n d iiio n a llv d e fin e d
                                                                      *




                                                      To understand the meaning o f        STDC HOSTED__ , we need some new
                                                 vocabulary. An im plem entation of C consists of the compiler plus other software
                                                 necessary to execute C programs. C99 divides implementations into two catego­
                                                 ries: hosted and freestanding. A hosted im plem entation must accept any program
                                                 that conforms to the C99 standard, whereas a fre e sta n d in g im plem entation
             c o m p le x t y p e s   > 2 7 .3   doesn’t have to compile programs that use complex types or standard headers
                                                 beyond a few of the most basic, (ln particular, a freestanding implementation
                                  Q&A            doesn’t have to support the < s t d i o . h > header.) T h e  STDC HOSTED__
                                                 macro represents the constant 1 if the compiler is a hosted implementation; other­
                                                 wise, the macro has the value 0.
                                                      The     STDC VERSION           macro provides a way to check which version
                                                 of the C standard is recognized by the compiler. This macro first appeared in
                                                 Amendment 1 to the C89 standard, where its value was specified to be Ute long
                                                                                                                  1 4.3                                    331aZYXWVUTSRQP
                                                                                                                          M a c ro D e fin itio n s kjihgfedcbaZYXWVUTSRQPONMLK


                                                          integer constant 1 9 9 4 0 9 L (representing the year and month o fth e am endm ent). If
                                                          a com piler conform s to the C99 standard, the value is 1 9 9 9 0 1 L . For each subse­
                                                          quent version of the standard (and each am endment to the standard), this macro
                                                          will have a different value.
                                                               A C99 com piler may (or may not) define three additional macros. Each m acro
                                                          is defined only if the com piler meets a certain requirement:
                                                                   ■     S T D C _ IE C _ 5 5 9 is defined (and has the value 1) if the com piler per­
                                                                       forms floating-point arithm etic according to the IEC 60559 standard (another
                                                 > 7 .2
I E E E f lo a t in g - p o in t s t a n d a r d BA                    name for the IEEE 754 standard).
                                                               ■        S T D C _ IE C _ 5 5 9 _ C O M P L E X is defined (and has the value I) if the
                                                                       com piler performs com plex arithmetic according to the IEC 60559 standard.
                                                           ■          S T D C _ I S O _ 1 0 6 4 6 is defined as an integer constant of the form
                 w c h a r _ t t y p e > 2 5 .2                   yyyyvnmL (for exam ple, 1 9 9 7 1 2 L ) if values o f type w c h a r _ t are repre­
                                                                  sented by the codes in the ISO/IEC 10646 standard (with revisions as of the
   I S O / I E C 1 0 6 4 6 s t a n d a r d > 2 5 .2onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                  specified year and month).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                          E m p ty M a c r o A r g u m e n ts

                                                          C99 allows any or all of the argum ents in a macro call to be empty. Such a call will
                                                          contain the same number ofcom m as as a normal call, however. (That way, ifs easy
                                                          to see which arO
                                                                         g um ents have' been omitted.)
                                                               ln most cases, the effect o f an em pty argument is clear. W herever the corre­
                                                          sponding parameter name appears in the replacem ent list, it’s replaced by noth­
                                                          ing— it simply disappears from the replacem ent list. H ere’s an example:

                                                          #define ADD(x,y)                (x+y)

                                                          After preprocessing, the statem ent

                                                          i = ADD(j,k) ;

                                                          becom es

                                                          i = (j+k) ;

                                                          whereas the statement

                                                          i = ADD(,k) ;

                                                          becom es

                                                          i = (+k);

                                                               When an empty argum ent is an operand of the # or # # operators, special rules
                                                          apply. If an empty argument is wtstringized” by the # operator. the result is "" (the
                                                          em pty string):

                                                          #define MK_STR(x) #x
                                                          •«♦
                                                          char empty_string[] = MK_STR();
            C h a p te r 14
3 3 2 ZYXWVUTSRQPONMLKJIHGFEDCBAT h e P re p r o c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      After preprocessing, the declaration will have the following appearance:
                                      c h a r e m p t y _ s t r i n g []     = aZYXWVUTSRQPONMLKJIHGFEDCBA

                                           Tf one of the argum ents of the # # operator is empty, it's replaced by an invisi­
                                      ble “placem arker" token. Concatenating an ordinary token with a placem arker
                                      token yields the original token (the placem arker disappears). If two placem arker
                                      tokens are concatenated, the result is a single placemarker. Once macro expansion
                                      has been completed, placem arker tokens disappear ftom the program . C onsider the
                                      following example:
                                      # d e fin e    J O I N ( x ,y ,z )    x##y##z

                                      in tJ O I N ( a ,b ,c ) ,       J O I N ( a ,b ,) ,     J O I N ( a ,,c ) ,   J O I N ( ,,c ) ;

                                      After preprocessing, the declaration will have the following appearance:
                                      in t    abc,     ab,     ac,     c;

                                      The missing argum ents were replaced by placem arker tokens, which then disap­
                                      peared when concatenated with any nonem pty argum ents. All three argum ents to
                                      the JO IN macro could even be missing, which would yield an em pty result.dcbaZYXWVUTSRQP


                                      M a c r o s w ith a V a r ia b le N u m b e r o f A r g u m e n t s

                                                                 In C89, a macro must have a fixed number of arguments, if it has any at all. C99
                                                                 loosens things up a bit, allowing macros that take an unlimited num ber of argu­
      v a r i a b l e - l e n g t f i a r g u m e n i lis t s BA ments. This feature has long been available for functions, so it’s not surprising that
                                                  > 2 6 .1
                                                                 macros were finally put on an equal footing.
                                                                      The prim ary reason for having a macro with a variable num ber ofargum ents is
                                                                 that il can pass these argum ents to a function that accepts a variable num ber of
                                                                 arguments, such as p r i n t f or s c a n f . Here’s an example:
                                      # d e f in e T E S T (c o n d itio n , . . . )      ((c o n d itio n )?          \
                                         p r i n t f ( " P a s s e d t e s t : % s \n " , # c o n d i t i o n ) :      \
                                         p r i n t f ( VA_ARGS_) )

                                                                  ellipsis, goes at the end of a m acro's param eter list, pre­
                                      The . . . Loken, known as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      ceded by ordinary parameters, if there are a n y . VA_ARGS           is a special identi­
                                      fier that can appear only in the replacem ent list o f a macro with a variable number
                                      of arguments; it represents all the arguments that correspond to the ellipsis. (There
                                      must be at least one argum ent that corresponds to the ellipsis, although that argu­
                                      ment may be empty.) The TEST macro requires at least two arguments. The first
                                      argument matches the c o n d i t i o n parameter; the remaining arguments match
                                      the ellipsis.
                                           H ere’s an exam ple that shows how the TEST macro might be used:
                                      T E S T ( v o l t a g e <= m a x _ v o l t a g e ,
                                              ’’V o l t a g e %d e x c e e d s % d \n " ,          v o lta g e ,    m a x _ v o lta g e );

                                      The preprocessor will produce the following output (reform atted for readability):
                                                      1 4.4                                                  3 3 3 kjihgfedcbaZYXWVUT
                                                               C o n d it io n a l C o m p ila tio n hgfedcbaZYXWVUTSRQPONMLKJIHGFE


         ((voltage <= max_voltage)?
           printf("Passed test: %s\n", "voltage <= max_voltage"):
           printf("Voltage %d exceeds %d\n", voltage, max_yoltage));onmlkjihgfedcbaZYXWVUTSRQ

         When the program is executed, the program will display the message

         Passed test: voltage <= max_voltage

         i f v o l t a g e is no more than m a x _ v o l t a g e . Otherwise, it will display the values
         of v o l t a g e and m a x _ v o l t a g e :

         Voltage 125 exceeds 120dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


<i^5>    The        fu n c       I d e n tifie r

         Another new feature o fC 9 9 is th e    f u n c __ i d e n t i f i e r . f u n c has nothing
         to do with the preprocessor, so it actually doesn’t belong in this chapter. However,
         like many preprocessor features, it’s useful for debugging, so I’ve chosen to dis­
         cuss it here.
               Every function has access to th e     fu n c       identifier, which behaves like a
         string variable that stores the name of the currently executing function. The effect
         is the same as if each function contains the following declaration at the beginning
         o fits body:

         static const char __f u n c [] PONMLKJIHGFEDCBA
                                         = "fiuiction-iicinie";cbaZYXWVUTSRQPONMLKJIHGFEDCBA

         w h e re fim a io n -iia m e is the name of the function. The existence of this identifier
         makes it possible to write debugging macros such as the following:

         #define FUNCTION_CALLED() printf("%s called\n", __func__);
         #define FUNCTION_RETURNS() printf("%s returns\n", __f u n c );

         Calls of these macros can then be placed inside functions to trace their calls:

         void f (void)

            FUNCTION_CALLED();                /* displays "f called" */

            FUNCTION_RETURNS();               /* displays "f returns" */


         Another use o f     f u n c : it can be passed to a function to let it know the name
         of the function that called it.aZYXWVUTSRQPONMLKJIHGFEDCBA




1 4 .4   C o n d it io n a l C o m p ila t io n

         The C preprocessor recognizes a number of directives that support c o n d itio n a l
         com pilation— the inclusion or exclusion of a section of program text depending on
         the outcome of a test performed by the preprocessor.
3 3 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14     T h e P r e p ro c e s s o r dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T h e # i f a n d # e n d i f D ir e c tiv e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     Suppose we’re in the process of debugging a program. We’d like the program to
                                     print the values of certain variables, so we put calls o f p r i n t f in critical parts of
                                     the program. Once we've located the bugs, it's often a good idea to let the p r i n t f
                                     calls rem ain.just in casc we need them later. Conditional compilation allows us to
                                     leave the calls in place, but have the compiler ignore them.
                                          Here’s how we’ll proceed. We’ll first define a macro and give it a nonzero
                                     value:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     #define DEBUG 1

                                     The name of the macro doesn’t matter. Next, we'll surround each group of
                                     p r i n t f calls by an # i f - # e n d i f pair:

                                     #if DEBUG
                                     printf("Value of i: %d\n", i);
                                     printf("Value of j: %d\n", j);
                                     #endif

                                     During preprocessing, the # i f directive will test the value of DEBUG. Since its
                                     value isn’t zero, the preprocessor will leave the two calls o f p r i n t f in the pro­
                                     gram (the # i f and # e n d i f lines will disappear, though). If we change the value
                                     of DEBUG to zero and recompile the program, the preprocessor will remove all
                                     four lines from the program. The compiler won’t see the calls o f p r i n t f . so they
                                     won’t occupy any space in the object code and won’t cost any time when the pro­
                                     gram is run. We can leave the # i f - # e n d i f blocks in the final program, allowing
                                     diagnostic information to be produced later (by recompiling with DEBUG set to I)
                                     if any problems turn up.
                                          In general, the # i f directive has the form aZYXWVUTSRQPONMLKJIHGFEDCBA


             # i f d ir e c t iv e                                        # i f cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                  constrmt-cxpression


                                     The # e n d i f directive is even simpler:


      # e n d i f d ir e c t iv e                                                     # e n d if


                                     When the preprocessor encounters the # i f directive, it evaluates the constant
                           Q&A       expression. If the value of the expression is zero, the lines between # i f and
                                     # e n d i f will be removed from the program during preprocessing. Otherwise, the
                                     lines between # i f and # e n d i f will remain in the program to be processed by the
                                     compiler— the # i f and # e n d i f will have had no cffect on the program.
                                          It’s worth noting that the # i f directive treats undefined identifiers as macros
                                     that have the value 0. Thus, if we ne^g^lecl to define DEBUG,7 the test

                                     #if DEBUG
                                                                                         14.4                                                  335aZYXWVUTSRQP
                                                                                                   C o n d itio n a l C o m p ila tio n kjihgfedcbaZYXWVUTSRQPONMLK


                               will fail (but not generate an error message), while the test

                               #if !DEBUG

                               will succeed.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                               T h e d e f i n e d O p e r a to r

                               We encountered the # and # # operators in Section l4.3. T here's just one other
                               operator, d e f i n e d , that’s specific to the preprocessor. When applied to an identi­
                               fier, d e f i n e d produces the value l ifth e identifier is a currently defined macro; it
                               produces 0 otherwise. The d e f i n e d operator is normally used in conjunction
                               with the # i f directive; it allows us to write

                               # if de fined(DEBUG)
                               • • •



                               #endif

                               The lines between the # i f and # e n d i f directives will be included in the program
                               only if DEBUG is defined as a macro. The parentheses around DEBUG aren’t
                               required; we could simply write

                               #if defined DEBUG

                                    Since d e f i n e d tests only whether DEBUG is defined or not, it’s not neces­
                               sary to give DEBUG a value:

                               #define DEBUG


                               T h e # i f d e f a n d # i f n d e f D ir e c tiv e s

                               The # i f d e f directive tesLs whether an identifier is currently defined as a macro:


# i f d e f d i r e c t iv e                                                 # i f d e f cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                           identifier


                               Using # i f d e f is sim ilar to using # i f :
                                       ^J*   • ’                 <^p   • •




                                          identifier
                               # ifde f PONMLKJIHGFEDCBA
                               Lines to be included ifidentifierisdefined as a macro
                               #endif

                                  Strictly speaking, there's no need for # i f d e f , since we can com bine the # i f
                                  directive with the d e f i n e d operator to get the same effect. Ln other words, the
                     Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  directive

                               #ifdef identifier

                               is equivalent to

                               #if defined(identifier)
336       C h a p te r 14
      ZYXWVUTSRQPONMLKJIHGFEDCBA   T h e P re p r o c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             The # i f n d e f directive is sim ilar to # i f d e f , but tests w hether an identifier
                                         not defined as a macro:aZYXWVUTSRQPONMLKJIHGFEDCBA
                                      is cbaZYXWVUTSRQPONMLKJIHGFEDCBA


  # i f n d e f d ir e c t iv e                                                     # i f n d e f id entifier

                                      W riting

                                      # ifn d e f     id entifier

                                      is the same as writingo

                                      # if     !d e fin e d (/? /e /ir/7 7 e r) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      T h e #elif a n d #else D ir e c tiv e s

                                      # i f , # i f d e f , and # i f n d e f blocks can be nested ju st like ordinary i f state­
                                      ments. When nesting occurs, it’s a good idea to use an increasing am ount o f inden­
                                      tation as the level o f nesting grows. Some program m ers put a com m ent on each
                                      closing # e n d i f to indicate what condition the marching # i f tests:
                                      # if    DEBUG

                                      # e n d if    /*    DEBUG * /

                                      This technique makes it easier for thc reader to find the beginning o f the # i f block.
                                           For additional convenience, the preprocessor supports the # e l i f and # e l s e
                                      directives:


       # e l i f d ir e c t iv e                                              # e 1 i f constant-expressio n



       # e l s e d ire c tiv e                                                                # e ls e


                                      # e l i f and # e l s e can be used in conjunction with # i f , # i f d e f , or # i f n d e f
                                      to test a series of conditions:
                                      # i f e x p rl
                                      Lines to be in cluded i f e x p r l is nonzero
                                      # e l i f expr2
                                      L in es to he included i f e x p rl is zero but expr2 is nonzero
                                      # e ls e
                                      Lines to he included otherw ise
                                      # e n d if

                                      Although the # i f directive is shown above, an # i f d e f or # i f n d e f directive
                                      can be used instead. Any number of # e l i f directives— but at most one # e l s e —
                                      may appear between # i f and # e n d i f .
                                                                  14.4       C o n d itio n a l C o m p ila tio n hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                           3 3 7 dcbaZYXWVUTSRQP


U s e s o f C o n d itio n a l C o m p ila tio n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Conditional compilation is certainly handy for debugging, but its uses don’t stop
there. Here are a few other com m on applications:RQPONMLKJIHGFEDCBA

  ■           W r itin g p r o g r a m s th a t a r e p o r ta b le to s e v e r a l m a c h in e s o r o p e r a tin g s y s ­
              t e m s . The following example includes one of three groups of lines depending
              on whether W IN32. MAC_OS, or LINUX is defined as a macro:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

              #if defined(WIN32)
              •••
              #elif defined(MAC_OS)
              •••
              #elif defined(LINUX)
              •••
              #endif

              A program might contain many o fth e se # i f blocks. Al the beginning of the
              program, one (and only one) o f the macros will be defined, thereby selecting a
              particular operating system. For example, defining the LINUX macro might
              indicate that the program is to run under the Linux operating system.

      ■                                                                            Different
              W r itin g p r o g r a m s th a t c a n b e c o m p i l e d w ith d i f f e r e n t c o m p ile r s .
              compilers often recognize somewhat different versions of C. Some accept a
              standard version of C. some d o n ’t. Som e provide machine-specific language
              extensions; some don’t, or provide a different set of extensions. Conditional
              compilation can allow a program to adjust to different compilers. Consider the
              problem of writing a program that might have to be compiled using an older,
              nonstandard compiler. The       STDC_ macro allows the preprocessor to
              detect whether a com piler conform s to the standard (either C89 or C99): if it
              doesn’t, we may need to change certain aspects of the program. In particular,
              we may have to use old-style function declarations (discussed in the Q&A at
              the end of Chapter 9) instead of function prototypes. At each point where
              functions are declared, we can put the following lines:

              #if __STDC__PONMLKJIHGFEDCBA
              Function prototypes
              #else
              Old-stylefunction declarations
              #endif

          ■                                                Conditional com pilation allows
              P r o v id in g a d e f a u lt d e f in itio n f o r a m a c r o .
              us to check whether a macro is currently defined and, if not, give it a default
              definition. For example, the following lines will define the macro
              B U FFER _SIZE ifit w asn’t previously defined:

              #ifndef BUFFER_SIZE
              #define BUFFER_SIZE 256
              #endif
3 3 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P r e p r o c e s s o r cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              ■ Tem porarily disabling code that contains com m ents. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                        We can’t use a / * ... * /
                                                comment to “comment out’' code that already contains / * . . . * / comments.
                                                Instead, we can use an # i f directive:

                                                 # if 0
                                                 Lines containing com m ents
                                                 # e n d i f aZYXWVUTSRQPONMLKJIHGFEDCBA

                                Q&A              Disabling code in this way is often called “conditioning o u t/
                                                 Section l5.2 discusses anothercom m on use ofconditional compilation: pro­
                                            tecting header files against multiple inclusion.




                             1 4 .5         M is c e lla n e o u s D ir e c t iv e s

                                            To end the chapter, w e’ll take a brief look at the # e r r o r , # l i n e , and # p r a g m a
                                            directives. These directives are more specialized than the ones w e’ve already
                                            examined, and they’re used much less frequently.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            T h e # e r r o r D ir e c t iv e

                                            The # e r r o r directive has the form


       # e r r o r d ir e c t iv e                                                    # e r r o r m essage


                                            where m essage is any sequence of tokens. If the preprocessor encounters an
                                            # e r r o r directive, it prints an error message which must include m essage. The
                                            exact form of the error message can vary from one com piler to another; it might be
                                            somethingCP like

                                            E rro r d ire c tiv e :       m essage

                                            or perhapsjust

                                            # e r r o r m essage

                                            Encountering an # e r r o r directive indicates a serious flaw in the program; some
                                            compilers immediately terminate compilation without attempting to find other
                                            errors.
                                                 # e r r o r directives are frequently used in conjunction with conditional com­
                                            pilation to check for situations that shouldn’t arise during a normal compilation.
                                            For example, suppose that we want to ensure that a program can’t be compiled on
                                            a machine whose i n t type isn't capable of storing numbers up to l00,000. The
                                  > 23 .2
          I N T _ M A X m a c r o BA        largest possible i n t value is represented by the INT_MAX macro, so all we need
                                            do is invoke an # e r r o r directive if INT MAX isn't at least l00,000:
                                                                               1 4 .5                                                   339
                                                                                         M is c e lla n e o u s D ir e c tiv e s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


                             #if INT_MAX < 100000
                             #error int type is too small
                             #endifonmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Attem pting to com pile the program on a m achine whose integers are stored in 16
                             bits will produce a message such as

                             Error directive: int type is too small

                                   Thc # e r r o r directive is often found in the # e l s e part of an # i f - # e l i f -
                             # e l s e series:

                             #if defined(WIN32)

                             #elif defined(MAC__OS)hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                             •••


                             #elif defined(LINUX)
                             • ••


                             #else
                             #error No operating system specified
                             #endifdcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                             T h e # l i n e D ir e c tiv e

                             The # l i n e directive is used to alter the way program lines are numbered. (Lines
                             are usually numbered 1, 2, 3, as yoird expect.) We can also use this directive to
                             make the com piler think that it’s reading the program from a file with a different
                             name.
                                 The # l i n e directive has tw o forms. In one form, we specify a line number:aZYXWVUTSRQPONMLKJI


# lin e   d i r e c t iv e                                                # lin e       //
           ( fo r m 1 )

                             // must be a sequence of digits representing an integer between l and 32767
                < ffi>       (2147483647 in C99). This directive causes subsequent lines in the program to be
                                                  n + 2, and so forth.
                             numbered //, /? + 1, cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  Tn the second form o fth e # l i n e directive, both a line num ber and a file name
                             are specified:


# lin e   d i r e c t iv e                                           # lin e      // "file "
           (fo rm 2)

                             The lines that follow this directive are assumed to com e from file . with line num ­
                             bers starting at //. The values of/? and/or they?/e string can be specified using m ac­
                             ros.
                                  One effect: of the # l i n e directive is to chang4^e the value o f the *^-^-L IN E *^^—
                                                                                                                         ^^»
                             macro (and possibly t h e        F IL E   macro). M ore importantly, most com pilers
                             will use the information from the # l i n e directive when generating error messages.
             C h a p te r 14
3 4 0 ZYXWVUTSRQPONMLKJIHGFEDCBA T h e P r e p ro c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      For example. suppose that the following directive appears at the beginning of the
                                      file f o o . c:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       #line 10 "bar.c"

                                      Let’s say that the compiler delects an error on line 5 of f o o . c. The error message
                                      will refer to line 13 of file b a r . c, not line 5 of file f o o . c. (Why line 13? The
                                      directive occupies line 1 of f o o . c, so the renumbering of f o o . c begins at line 2,
                                      which is treated as line 10 of b a r . c.)
                                             At first glance, the # l i n e directive is mystifying. Why would we want error
                                      messages to refer to a different line and possibly a different file? Wouldn’t this
                                      make programs harder to debug?
                                             In fact, the # l i n e directive isn't used very often by programmers. Instead,
                                      it’s used primarily by programs that generate C code as output. The most famous
                                      example of such a program is y a c c (Yet Another Compiler-Compiler), a UNLX
                                      utility that automatically generates part o fa compiler. (The GNU version o f y a c c
                                      is named b i s o n . ) Before using y a c c . the programmer prepares a file that con­
                                      tains information for y a c c as well as fragments of C code. From this file, y a c c
                                      generates a C program, y . t a b . c. that incorporates the code supplied by the pro­
                                      grammer. The programmer then compiles y . t a b . c in the usual way. By inserting
                                      # l i n e directives in y . t a b . c, y a c c tricks the compiler into believing that the
                                      code comes from the original file— the one written by the programmer. As a result,
                                      any error messages produced during the compilation o f y . t a b . c will refer to
                                      lines in the original file, not lines in y . t a b . c . This makes debugging easier,
                                      because error messages refer to the file written by the programmer, not the (more
                                      complicated) file generated by y a c c .


                                      T h e # p r a g m a D ir e c tiv e

                                      The # p r a g m a directive provides a way to request special behavior from the com­
                                      piler. This directive is most useful for programs that arc unusually large or that
                                      need to take advantage of the capabilities of a particular compiler.
                                           The # p r a g m a directive has the form


     # p r a g m a d ir e c tiv e                                                                    tokens
                                                                                     # p r a g m a cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      where tokens are arbitrary tokens, # p ra g m a directives can be very simple (a sin­
                                      gle token) or they can be much more elaborate:

                                      #pragma data(heap_size => 1000, stack_size => 2000)

                                            Not surprisingly, the set ofcom m ands that can appear in # p r a g m a directives
                                      is different for each compiler: you'll have to consult the documentation for your
                                      compiler to see which commands it allows and what those commands do. Inciden­
                                      tally, the preprocessor must ignore any # p r a g m a directive that contains an unrec­
                                      ognized command: it’s not permitted to give an error message.
                                                                               1 4 .5       M is c e lla n e o u s D ir e c tiv e s hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                                            341 onmlkjihgfedcbaZYXW


                                       In C 89, there are no standard pragm as— th ey ’re all im plem entation-defined.
                        <^>       C 99 has three standard pragm as, all o f w hich use STDC as the first token follow ing
                                  # p r a g m a . T hese pragm as are FP_CONTRACT (covered in Section 23.4),
                                  CX_LIMITED__RANGE (S ection 27.4), and FENV_ACCESS (Section 27.6).dcbaZYXWVUTSRQPONMLKJI


                        <%Jfr     T h e _ P r a g m a O p e r a to r

                                  C 99 introduces the _ P r a g m a operator, w hich is used in conjunction w ith the
                                  # p r a g m a directive. A _ P r a g m a expression has the form


_ P r a g m a e x p re s s io n                                 _ P ra g m a   (   s tr in g - lite r a l   )


                                  W hen it encounters such an expression, the preprocessor “d estrin g izes” the string
                                  literal (yes, th at’s the term used in the C 99 standard!) by rem oving the double
                                  quotes around the string and replacing the escape sequences \ " and \ \ by the
                                  characters " and \ , respectively. T he result is a series o f tokens, w hich are then
                                  treated as though they appear in a # p r a g m a directive. For exam ple, w riting kjihgfedcbaZYXWVUTSRQPONM

                                  _Pragma("data(heap_size => 1000, stack_size => 2000)")

                                  is the sam e as w ritin vs^

                                  #pragma data(heap_size => 1000, stack_size => 2000)

                                        T he _ P r a g m a operator lets us w ork around a lim itation o f the preprocessor:
                                  the fact that a preprocessing directive c a n ’t generate another directive. _ P r a g m a .
                                  however, is an operator, not a directive, and can therefore appear in a m acro defini­
                                  tion. T his m akes it possible for a m acro expansion to leave behind a # p r a g m a
                                  directive.
                                         L et’s look at an exam ple from the G C C m anual. The follow ing m acro uses the
                                  _ P r a g m a operator:

                                  #define DO_PRAGMA(x) _Pragma(#x)

                                  T he m acro w ould be invoked as follow s:

                                  DO_PRAGMA(GCC dependency "parse.y")

                                  A fter expansion, the result will bc

                                  #pragma GCC dependency ’’parse.y"

                                  w hich is one o f th e pragm as supported by G C C . (It issues a w arning if the date o f
                                  the specified file— p a r s e . y in this exam ple— is m ore recent than the date o f the
                                  current file— the one being com piled.) Note that the argum ent to the call o f
                                  DO_PRAGMA is a series o f tokens. T he # operator in the definition o f DO_PRAGMA
                                  causes the tokens to be stringized into "GCC d e p e n d e n c y \ " p a r s e . y \ " " :
                                  this string is then passed to the _ P r a g m a operator, w hich destringizes it, produc­
                                  ing a # p r a g m a directive containing the original tokens.
            C h a p te r 14
3 4 2 ZYXWVUTSRQPONMLKJIHGFEDCBAT h e P r e p ro c e s s o r aZYXWVUTSRQPONMLKJIHGFEDCBA




                                    Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                            Q:     I ’v e s e e n p r o g r a m s th a t c o n ta in a # o n a lin e b y its e lf. Is th is le g a l? onmlkjihgfedcbaZYXWVUTSRQ
                             A:                     n u l l d i r e c t i v e ; it has no effect. Some programmers use null direc­
                                   Yes. This is the RQPONMLKJIHGFEDCBA
                                   tives for spacing within conditional compilation blocks:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    #if INT_MAX < 100000
                                    #
                                    #error int type is too small
                                    #
                                    #endif

                                    Blank lines would also work, ofcourse, but the # helps the reader see the extent of
                                    the block.

                            Q:      I ’m n o t s u r e w h ic h c o n s t a n t s in a p r o g r a m n e e d to b e d e fi n e d a s m a c r o s . A r e
                                    th e r e a n y g u id e l i n e s to fo llo w ? [p . 3 1 9 ]
                             A:     One rule of thumb says that every numeric constant, other than 0 or 1, should be a
                                    macro. Character and string constants are problematic, since replacing a character
                                    or siring constant by a macro doesn’t always improve readability. 1 recommend
                                    using a macro instead of a character constant or string literal provided that (1) the
                                    constant is used more than once and (2) the possibility exists that the constant
                                    might someday be modified. Because of rule (2), I don’t use macros such as

                                    #define NUL '\0'

                                    although some programmers do.

                            Q:      W h a t d o e s t h e # o p e r a t o r d o i f th e a r g u m e n t th a t i t ’s s u p p o s e d to “ s t r in g i z c ”
                                    c o n t a in s a " o r \ c h a r a c t e r ? [p . 3 2 4 ]
                             A:     lt converts " to \ " and \ to \ \ . Consider the following macro:

                                    #define STRINGIZE(x) #x

                                    T hepreprocessorw ill re p la c e S T R IN G IZ E (" fo o " ) by " \ " f o o \ " " .

                           *Q :     I c a n ’t g e t th e f o llo w in g m a c r o to w o r k p r o p e r ly :

                                    #define CONCAT(x,y) x##y

                                    CONCAT ( a , b ) g iv e s a b , a s e x p e c t e d , b u t CONCAT ( a , CONCAT ( b , c ) ) g iv e s
                                    a n o d d r e s u lt. W h a t ’s g o in g o n ?
                             A:     Thanks to rules that Kernighan and Ritchie call “bizarre," macros whose replace­
                                    ment lists depend on ## usually can’t be called in a nested fashion. The problem is
                                    that C O N C A T (a,C O N C A T (b,c) ) isn’t expanded in a “normal” fashion, with
                                    CONCAT ( b , c ) yielding b c , then C O N C A T (a,bc) giving a b c . Macro parame­
                                    ters that are preceded or followed by # # in a replacement list aren’t expanded at
                                                                                                                    Q ZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                      & A        3 4 3 onmlkjihgfedcbaZYXWVUT


                    the time of substitution. As a result, C O N C A T (a,C O N C A T (b ,c) ) expands to
                    aCONCAT ( b , c ) , which can 't be expanded further, since there’s no m acro named
                    aCONCAT.
                         T here’s a way to solve the problem, but it’s not pretty. The trick is to define a
                    second macro that sim ply calls the first one:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                    #define C0NCAT2(x,y) CONCAT(x,y)

                    W riting C0NCAT2 ( a , C0NCAT2 ( b , c ) ) now yields the desired result. As the
                    preprocessor expands the outer call of C0NCAT2, it will expand C0NCAT2 ( b , c )
                    as well; the difference is that CONCAT2’s replacem ent list doesn’t contain # # . Tf
                    none of this makes any sense, don’t worry; it’s not a problem that arises often.
                          The # operator has a sim ilar difficulty, by the way. If # x appears in a replace­
                    ment list, where x is a macro parameter, the corresponding argum ent is not
                    expanded. Thus, ifN is a macro representing 10, and STR (x ) has the replacem ent
                    list # x , expanding ST R (N ) yields ”N ”, not “ 1 0 “ . The solution is sim ilar to the
                    one we used with CONCAT: defining a second macro w h o sejo b is to call STR.dcbaZYXWVUTSRQPONMLKJIH

            *Q :    S u p p o s e th a t th e p r e p r o c e ss o r e n c o u n te r s th e o r ig in a l m a c r o n a m e d u r in g
                    r e s c a n n in g , a s in th e fo llo w in g e x a m p le:

                    #define N (2*M)
                    #define M (N+1)

                    i = N;           /* infinite loop? */

                    T h e p r e p r o c e s s o r w ill r e p la c e N b y ( 2 * M ) , th e n r e p la c e M b y ( N + 1 ) . W ill th e
                    p r e p r o c e s so r r e p la c e N a g a in , th u s g o in g in to a n in fin ite lo o p ? [p . 3 2 6 ]
             A:     Some old preprocessors will indeed go into an infinite loop, but newer ones
                    shouldn’t. According to the C standard, ifth e original macro nam e reappears dur­
                    ing the expansion of a macro, the name is not replaced again. H ere’s how the
                    assignm ent to i will look after preprocessing:

                    i = (2*(N+1));

                                Som e enterprising programmers take advantage of this behavior by w riting
                          macros whose names match reserved words or functions in the standard library,
sq rt iunction cbaZYXWVUTSRQPONMLKJIHGFEDCBA
               >23.3      Consider the s q r t library function, s q r t com putes the square root of its argu­
                          ment, returning an im plem entation-defined value if the argum ent is negative. Per­
                          haps we would prefer that s q r t return 0 if its argum ent is negative. Since s q r t is
                          part of the standard library, we can't easily change it. We can, however, define a
                          s q r t m a c r o that evaluates to 0 when given a negative argument:

                    #undef sqrt
                    #define sqrt(x)                ((x)>=0?sqrt(x):0)

                    A later call of s q r t will be intercepted by the preprocessor, which expands il into
                    the conditional expression shown here. The call of s q r t inside the conditional
                    expression w on’t be replaced during rescanning, so il will rem ain for the com piler
344 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 14      T h e P re p ro c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      to handle. (Note the use o f # u n d e f to undefine s q r t before defining the s q r t
                                      macro. As w e’ll see in Section 2 .l.l, the standard library is allowed to have both a
                                      macro and a function with the same name. Undefming s q r t before defining our
                                      own s q r t macro is a defensive measure, in case the library has already defined
                                      s q r t as a macro.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:       I g e t a n e r r o r w h e n I tr y to u s e p r e d e fin e d m a c r o s s u c h a s              L IN E         and
                                     _ _ F I L E . I s th e r e a s p e c ia l h e a d e r t h a t I n e e d to in c l u d e ?
                              A:      No. These macros are recognized automatically by the preprocessor. M ake sure that
                                               two underscores at the beginning and end o f each macro name, not one.
                                      you have cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:       W h a t ’s th e p u r p o s e o f d is t in g u is h in g h e tw e e n a “ h o s te d im p l e m e n t a t io n ” a n d
                                      a “ f r e e s t a n d in g im p le m e n t a t io n ” ? I f a f r e e s t a n d in g im p le m e n t a t io n d o e s n ’t
                                      e v e n s u p p o r t th e < s t d i o . h > h e a d e r , w h a t u s e is it? [p . 3 3 0 ]
                              A:      A hosted im plem entation is needed for most programs (including the ones in this
                                      book), which rely on the underlying operating system for input/ou(put and other
                                      essential services. A freestanding im plem entation of C would be used for pro­
                                      grams that require no operating system (or only a minimal operating system). For
                                      example, a freestanding implementation would be needed for writing the kernel of
                                      an operating system (which requires no traditional inpu(/output and therefore
                                      doesn’t need < s t d i o . h > anyway). Freestanding im plem entations are also useful
                                      for writing softw are for embedded systems.

                             Q:       I t h o u g h t th e p r e p r o c e s s o r w a s j u s t a n e d ito r . H o w c a n it e v a lu a t e c o n s t a n t
                                     e x p r e s s io n s ? (p . 3 3 4 ]
                              A:     The preprocessor is more sophisticated than you might expect; it knows enough
                                     about C to be able to evaluate constant expressions, although it doesn’t do so in
                                     quite the same way as the compiler. (For one thing, the preprocessor heats any
                                     undefined nam e as having the value 0. The other differences are too esoteric to go
                                     into here.) In practice, the operands in a preprocessor constant expression are usu­
                                     ally constants, macros that represent constants, and applications o f the d e f i n e d
                                     operator.

                             Q:       W h y d o e s C p r o v id e th e # i f d e f a n d # i f n d e f d ir e c ti v e s , s in c e w e c a n g e t
                                     th c s a m e e f f e c t u s in g th e # i f d ir e c ti v e a n d th e d e f i n e d o p e r a t o r ? [p . 3 3 5 ]
                              A:     The # i f d e f and # i f n d e f directives have been a part of C since the l970s. The
                                     d e f i n e d operator, on the other hand, was added to C in the l980s during stan­
                                     dardization. So the real question is; Why was d e f i n e d added to the language?
                                     The answ er is that d e f i n e d adds flexibility. Instead o fju st being able to test the
                                     existence o f a single macro using # i f d e f or # i f n d e f , we can now test any
                                     num ber of macros using # i f together with d e f i n e d . For example, the following
                                     directive checks whether FOO and BAR are defined but BAZ is not defined;kjihgfedcbaZYXWVUTS

                                      #if defined(FOO) && defined(BAR) && !defined(BAZ)
                                                                                                                               E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                                                       3 4 5 dcbaZYXWVUTSRQ


                        Q:     I w a n t e d to c o m p ile a p r o g r a m th a t I h a d n ’t fi n is h e d w r it i n g , s o I “ c o n d i ­
                               tio n e d o u t ” th e u n f in is h e d p a r t: kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                               #if 0

                               #endif

                               W h e n I c o m p ile d th e p r o g r a m , I g o t a n e r r o r m e s s a g e r e f e r r in g to o n e o f th e
                               lin e s b e t w e e n # i f a n d # e n d i f .         D o e s n ’t th e p r e p r o c e s s o r j u s t ig n o r e t h e s e
                               lin e s ? [p . 3 3 8 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         A:    No. lhe lines aren't completely ignored. Comments arc processed before prepro­
                               cessing directives are executed, and the source code is divided into preprocessing
                               tokens. Thus, an unterminated comment between # i f and # e n d i f may cause an
                               error message. Also, an unpaired single quote or double quote character may cause
                               undefined behavior.




                               E x e r c is e s

                               l.    W rite parameterized macros that compute the following values.
S e c tio n 1 4 .3 aZYXWVUTSRQPONMLKJIHGFEDCBA
                               (a) The cube of x.
                               (b) The rem ainder when n is divided by 4.
                               (c) I if lhe product of x and y is less than l00, 0 otherwise.
                               Do your macros always work? If not, describe what argum ents would make them fail.

                    ©     2.   W rite a macro NELEMS (a ) that computes the num ber o felem e n ts in a one-dim ensional
                               array a . H h u : See lhe discussion o fih e s i z e o f operator in Section 8 .l.

                          3.   Let DOUBLE bc the following macro;
                               #define DOUBLE(x) 2*x
                               (a) What is the value ofDOUBLE (1 + 2 ) ?
                               (b) What is the value of 4/DOUBLE (2 ) ?
                               (c) Fix the definition of DOUBLE.

                    ©     4.   For each o fth e following macros, give an exam ple that illustrates a problem with the macro
                               and show how to fix it.
                               (a) #define AVG(x,y)                       (x-y)/2
                               (b) #define AREA(x,y)                      (x)*(y)

                    © *5.      Let TOUPPER be the following macro:
                               #define TOUPPER(c)                      (’a ’< = (c)&&(c)< = ’z ’? (c)- ‘a ’+ ’A ’:(c))
                               Lel s be a string and let i be an i n t variable. Show the output produced by each o f lhe fol­
                               lowing program fragments.
                               (a) strcpy(s, "abcd*1);
                                   i = 0;
                                   putchar(TOUPPER(s[++i]));
3 4 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P re p r o c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       (b) s t r c p y ( s , ” 0 1 2 3 " ) ;
                                           i = 0;
                                           p u tc h a r(T O U P P E R (s [4 - +i ] ) ) ;

                                6.     (a) W rite a macro D IS P ( f , x ) that expands into a call o f p r i n t f that displays the vakie
                                       o f the function f when called with argum ent x . For exam ple.
                                       D IS P ( s q r t , 3 .0 ) ;
                                       should expand into
                                      p rin tf(" s q rt(% g )           = % g \n " ,      3 .0 ,    s q r t( 3 .0 ) ) ;
                                       (b) W rite a macro D IS P 2 ( f , x , y ) that’s sim ilar to D IS P but works for functions with
                                       two argum ents.
                                               *^>




                         t y *7.       Let GENERIC_MAX be the following macro:
                                       # d e f i n e G E N E R IC _ M A X (ty p e)                    \
                                       ty p e ty p e # # _ m a x (ty p e x , ty p e            y)     \

                                           re tu rn     x > y ? x           : y;                      \


                                       (a) Show the preprocessor’s expansion of GENERIC_MAX ( l o n g ) .
                                       (b) Explain why GENERIC_MAX doesn't work for basic types such as u n s i g n e d l o n g .
                                       (c) Describe a technique that would allow us to use GENERIC_MAX with basic types such
                                                                         H in t: D on’t change the definition ofGENERIC_MAX.
                                           as u n s i g n e d l o n g . cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              *8.      Suppose we want a macro that expands into a string containing the current line num ber and
                                       file name. In other words, w e ’d like to write
                                       const         char   * s tr    = L IN E _ F IL E ;
                                       and have it expand into
                                       const char           * s tr    = " L in e      10 o f       file       f o o .c " ;
                                       where f o o . c is the file containing the program and 10 is the line on which the invocation
                                       o f L IN E _ F IL E appears. W arning: This exercise is for experts only. Be sure to read the
                                       Q&A section carefully before attem pting!

                                9.    W rite the following param eterized macros.
                                       (a) C H E C K (x, y , n ) - Has the value 1 if both x and y fall betw een 0 and n - 1. inclusive.
                                       (b) MEDIAN ( x , y , z ) - Finds the median of x . y. and z.
                                       (c) POLYNOMIAL (x ) - Com putes the polynomial 3.r5 + 2.r4 - 5.r3 - x 2 + 7x - 6.

                              10.     Functions can often— but no( alw ays— be written as param eterized macros. Discuss what
                                      characteristics o f a function would m ake it unsuitable as a macro.

                              11.     (C99) C program m ers often use the f p r i n t f function to write error messages:
        fprincftunciion>22.3           fp rin tf(s td e rr,           "R ange e r r o r :          in d e x    = % d \n " ,     in d e x );
          s t d e r r stream >22.1    s t d e r r is C ’s “standard error” stream ; the rem aining argum ents are the sam e as those for
                                      p r i n t f , starting with the form at string. W rite a macro named ERROR that generates the
                                      call of f p r i n t f shown above when given a form al siring and the item s to be displayed:
                                       E R R O R (" R a n g e e r r o r :     in d e x    = % d \n " ,        i n d e x ) ;aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 1 4 .4       ©     12.     Suppose that the macro M has been defined as follows:
                                       # d e fin e     M 10
                                                                                                      347onmlkjihgfedcbaZYXWV
                                                                               E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


          Which of the followin^e* tests will fail?
          (a) # i f M
          (b) # i f d e f M
          (c) # i f n d e f M
          (d) # i f d e f i n e d ( M )
          (c) # i f ! d e f i n e d ( M )

    13. (a) Show what the following program will look like after preprocessing. You may ignore
          any lines added to the program as a result of including the < s t d i o . h> header,
          # in c lu d e    < s td io .h >

          # d e f i n e N 100
          v o id    f (v o id );
          i n t m a in (v o id )

              f() ;
          # ifd e f N
          #undef N
          # e n d if
              r e tu r n 0;


          v o id    f (v o id )

          # i f d e fin e d (N )
              p r i n t f ( '* N i s   % d \n " ,    N );
          # e ls e
              p r i n t f ( ”N i s     u n d e fin e d \n " );
          # e n d if

          (b) What will be the output of this program?

© * 14.   Show what the following program will look like after preprocessing. Some lines of the pro­
          gram may cause compilation errors: find all such errors.
          # d e fin e     N = 10
          # d e fin e     IN C (x ) x+ 1
          # d e fin e     SUB ( x , y ) x - y
          # d e fin e     SQ R (x) ( ( x ) * ( x ) )
          # d e fin e     CUBE(x) ( S Q R ( x ) * ( x ) )
          # d e fin e     M l( x ,y ) x # # y
          # d e fin e     M 2 (x ,y ) # x # y
          i n t m a in (v o id )

              i n t a [N] , i z j , k ,             m;
          # ifd e f N
              i =
          # e ls e
              j =
          # e n d if
              i    = 10 * I N C ( j) ;
3 4 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 14      T h e P re p r o c e s s o r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          i = S U B (j, k) ;
                                          i = S Q R ( S Q R ( j) ) ;
                                          i = CUBE( j ) ;
                                          i = M l( j , k) ;
                                          p u t s (M2 ( i , j ) ) ;
                                       # u n d e f SQR
                                           i = S Q R (j) ;
                                       # d e f i n e SQR
                                           i = S Q R (j) ;
                                           re tu rn     0;


                               l5.     Suppose that a program needs to display messages in either English. French, or Spanish.
                                       Using conditional compilation, write a program fragment that displays one of the following
                                       three messages, depending on whether or not the specified macro is defined:
                                       I n s e r t D is k 1                   (ifE N G L ISH isdefined)
                                       I n s e r e z Le D i s q u e 1         (ifFRENCHisdefm ed)
                                       I n s e r t e E l D is c o 1           (ifSPA N IS H isdefincd) aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 1 4 .5           * 16.     (C99) Assume that the following macro definitions are in effect:
                                       # d e fin e    ID E N T (x) P R A G M A (ident # x )
                                       # d e fin e    PRAGMA(x) _ P r a g m a ( # x )
                                       Whal will the following line look like after macro expansion?
                                       ID E N T (fo o )
1 5                  W r itin g L a r g e P r o g r a m s                                                            ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                             A r o u n d c o m p u te r s it is d iff ic u lt to fin d th e c o r r e c t u n it
                                                            o f tim e to m e a s u r e p ro g re s s . S o m e c a th e d r a ls to o k a
                                                               c e n t u r y to c o m p le te . C a n y o u im a g in e th e g r a n d e u r
                                                                   a n d s c o p e o f a p r o g r a m th a t w o u ld ta k e a s lo n g ? onmlkjihgfedcbaZYXW




                     Although some C programs are small enough to be put in a single file, most aren’t.
                     Program s that consist of more than one file are the rule rather than the exception. In
                     this chapter, w e'll see that a typical program consists of several source files and
                     usually som e header files as well. Source files contain definitions of functions and
                     external variables: header files contain inform ation to beshared among source files.
                     Section l5 .l discusses source files, while Section l5.2 covers header files. Section
                     15.3 describes how to divide a program into source files and header files. Section
                     15.4 then shows how to “build” (compile and link) a program that consists of more
                     than one file, and how to “rebuild" a program after part of it has been changed.




    1 5 .1           S o u r c e F ile s

                     Up to this point, w e’ve assumed that a C program consists o f a single file. In fact, a
                     program may be divided am ong any num ber cA           soiirce file s . By convention, source
                                                                       cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                     files have the extension . c. Each source file contains part o fth e program , prim a­
                     rily definitions offu n ctio n s and variables. O ne source file must contain a function
                     named m a in , which serves as the starting point for the program.
                           For example, suppose that we want to write a sim ple calculator program that
                     evaluates integer expressions entered in Reverse Polish notation (RPN), in which
                     operators follow operands. If the user enters an expression such as GFEDCBA

                     30   5   -   7   *

                     we want the program to print its value (l7 5 . in this case). Evaluating an RPN
                     expression is easy if we have the program read the operands and operators, one by
s ta c k s > /0 .2   one, using a stack to keep track of interm ediate results. If the program reads a hgfedcbaZYXWVUTS



                                                                                                                                        349
3 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15    W ritin g L a rg e P ro g r a m s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    number, w e’ll have it push the number onto the stack. Ifit reads an operator, w e'll
                                    have it pop two numbers from the stack, perform the operation, and then push the
                                    result back onto the stack. When the program reaches the end of the user’s input,
                                    the value of the expression will be on the stack. For example, the program will
                                    evaluate the expression 3 0 5 - 7 * in the following way:
                                           l . Push 30 onto the stack.
                                           2. Push 5 onto the stack.
                                           3. Pop the top two numbers from the stack, subtract 5 from 30, giving 25, and
                                               then push the result back onto the stack.
                                           4. Push 7 onto the stack.
                                           5. Pop the top two numbers from the stack, multiply them, and then push the
                                               result back onto the slack.
                                    After these steps, the stack will contain the value of the expression (l7 5 ).
                                         Turning this strategy into a program isn’t hard. The program ’s m a in function
                                    will contain a loop that performs the following actions:
                                           Read a “token" (a num ber or an operator).
                                           Ifth e token is a number, push il onto the stack.
                                           Lf the token is an operator, pop its operands from the slack, perform the opera­
                                                 tion, and then push the result back onto the slack.
                                    When dividing a program like this one into files, it makes sense to put related func­
                                    tions and variables into the same file. The function that reads tokens could go into
                                    one source file ( t o k e n , c , say), together with any functions that have to do with
                                    tokens. Stack-related functions such as p u s h , p o p , m a k e _ e m p ty , i s _ e m p t y ,
                                    and i s _ f u l l could go into a different file, s t a c k , c. The variables that repre­
                                    sent the stack would also go into s t a c k . c. The m a in function would go into yet
                                    another file, c a l c . c.
                                         Splitting a program into multiple source files has significant advantages:
                                       ■ Group ing related functions and variables into a single file helps clarify the
                                          structure of the program.
                                       ■ E ach source file can be compiled separately— a great tim e-saver if the pro­
                                          gram is large and must be changed frequently (which is common during pro­
                                          gram development).
                                       ■   Functions are more easily reused in other programs when grouped in separate
                                           source files. In our example, splitting off s t a c k . c and t o k e n . c from the
                                           m a in function makes it sim pler to reuse the slack functions and token func­
                                           tions in lhe future.aZYXWVUTSRQPONMLKJIHGFEDCBA



                       1 5 .2       H e a d e r F ile s
                                    When we divide a program into several source files, problems arise: How can a
                                    function in one file call a function th afs defined in another file? How can a func-
                                                                                                  1 5 .2                             351onmlkjihgfedcbaZYXWVU
                                                                                                           H e a d e r F ile s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                  lion access an external variable in another file? How can two files share the same
                                  macro definition or type definition? The answer lies with the # i n c l u d e directive,
                                  which makes it possible to share information— function prototypes, macro defini­
                                  tions. type definitions, and more— among any number ofsource files.
                                        The # i n c l u d e directive tells the preprocessor to open a specified file and
                                  insert its contents into the current file. Thus, if we want several source files to have
                                  access to the same information, we'll put that information in a file and then use
                                  # i n c l u d e to bring^z> the file's contents into each of the source files. Files that are
                                                                              h e a d e r file s (or sometimes in clu d e file s f, I’ll
                                  included in this fashion are called cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  discuss them in more detail later in this section. B•v convention, header files have
                                  lheextension .h .
                                        Noie: The C standard uses the term “source file” to refer to all files written by
                                  the programmer, including both . c and .h files. I'll use “source file” to refer to
                                   . c files only.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  T h e #include D ir e c tiv e
                                  T he # i n c l u d e directive has two primary forms. The first form is used for header
                                  files that belong to C 's own library:aZYXWVUTSRQPONMLKJIHGFEDCBA


# i n c l u d e d ir e c t iv e                                      # in c lu d e    <fi!ename>
                   ( fo r m 1)

                                  The second form is used for all other header files, including any that we write:


# i n c l u d e d ir e c t iv e                                      # in c lu d e    "filenam e"
                   ( fo r m 2 )

                                       The difference between the two is a subtle one having to do with how the com ­
                                  piler locates the header file. Here are the rules that most compilers follow:
                                    ■ # i n c l u d e <filename>: Search the directory (or directories) in which system
                                        header files reside. (On UNIX systems, for example, system header files are
                                        usually kept in thedireciory / u s r / i n c l u d e . )
                                    ■ # in c lu d e   "filenam e": Search the current directory, then search the direc­
                                        tory (ordireciories) in which system header files reside.
                                  The places to be searched for header files can usually be altered, often by a com­
                                  mand-line option such as - lp a th .


                                  D on't use brackets when including header files that you have written:
                                  #include <myheader.h>                   /*** WRONG ***/

                                  The preprocessor will probably look for m y h e a d e r . h where the system header
                                  files are kept (and. ofcourse. w on’t find it).
3 5 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15     W ritin g L a r g e P ro g ra m s


                                                          The file name in an # i n c l u d e directive may include inform ation that helps
                                                     locate the file, such as a directory path o rd riv e specifier:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     #include "c:\cprogs\utils.h"                         /* Windows path */

                                                     #include "/cprogs/utils.h"                           /* UNIX path */

                                                     Although lhc quotation marks in the # i n c l u d e directive make file names look
                                                     like siring literals, the p rep ro cesso rd o esn 't treat them that way. (T hal’s fortunate,
                                                     since \ c and \ u — which appear in the Windows exam ple— would be treated as
                                                     cscapc sequences in a string literal.)

                 p o r ta b ility tip                               u su a lly best not to include p a th o r drive in form ation in # i n c l u d e
                                                            /f'<S' cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                            directives. Such inform ation m akes it diJficult to com pile a p ro g ra m when
                                                            it's tra n sp o rted to a n o th e rm a c h in e or. worse, a n o th e ro p e ra tin g system .

                                                     For exam ple, the following Windows # i n c l u d e directives specify drive and/or
                                                     path inform ation that may not always be valid:

                                                     #include "d-.utils.h”
                                                     #include "\cprogs\include\ucils.h"
                                                     #include "d :\cprogs\include\utils.h"

                                                     The following directives are better: they don’t mention specific drives, and paths
                                                     are relative rather than absolute:

                                                     #include "utils.h"
                                                     #include "..\include\utils.h"

                                                            The # i n c l u d e directive has a'lhird form that's used less often than lhc other
                                                     two:


  # i n c l u d e d ire c tiv e                                                                # i n c 1 u d e tokens
                   (fo rm 3)

      p re p ro c e s s in g :o k c n s ►            where tokens is any sequence ofpreprocessing tokens. The preprocessor will scan
                                            1 4 .3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     the tokens and replace any macros that it finds. After macro replacem ent, the
                                                     resulting directive must match one of the other forms of # i n c l u d e . The advan­
                                                     tage of thc third kind of # i n c l u d e is that the file name can be defined by a macro
                                                     rather than being “hard-coded” into the directive itself, as the following example
                                                     shows:

                                                     #if defined(IA32)
                                                       #define CPU_FILE "ia32.h"
                                                     #elif defined(IA64)
                                                       #define CPU_FILE "iaG4.h"
                                                     #elif defined(AJ4D64)
                                                       #define CPU_FILE "amd64.h"
                                                     #endif

                                                     #include CPU FILE
                                                                  1 5.2                                3 5 3 dcbaZYXWVUTSRQPON
                                                                           H e a d e r F ile s hgfedcbaZYXWVUTSRQPONMLKJIHGFED


S h a r in g M a c r o D e fin itio n s a n d T y p e D e fin itio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Most large programs contain macro definitions and type definitions that need to be
                                                                         all source files).
shared by several source files (or, in the most extreme case. by cbaZYXWVUTSRQPONMLKJIHGFEDCBA
These definitions should i2ta.0 into header files,
     For example, suppose that w e’re wriiing a program that uses macros named
BOOL. TRUE, and FALSE. (There’s no need for these in C99, ofcourse. because
the < s t d b o o l .h > header defines similar macros.) Instead of repeating the defi­
nitions ofthese macros in each source file that needs them, it makes more sense to
put the definitions in a header file with a name like b o o l e a n . h:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
#define BOOL int
#define TRUE 1
#define FALSE 0

Any source file that requires these macros will simply contain the line
#include "boolean.h"

In the following figure, two files include b o o l e a n . h:PONMLKJIHGFEDCBA
                  *^'   k~J




     Type definitions are also common in header files. For example, instead of
defining a BOOL macro, we might use t y p e d e f to create a B o o l type. If we do,
the b o o l e a n . h file will have the following appearance:
#define TRUE 1
#define FALSE 0
typedef int Bool;

     Putting definitions of macros and types in header files has some clear advan­
tages. First, we save time by not having to copy the definitions into the source files
where they’re needed. Second, the program becomes easier to modify. Changing
the definition o fa macro or type requires only that we edit a single header file: we
don’t have to modify the many source files in which the macro or type is used.
Third, wc don't have to worry about inconsistencies caused by source files contain­
ing different definitions of the same macro or type.
3 5 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W r itin g L a r g e P r o g r a m s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                          S h a r in g F u n c tio n P r o to ty p e s

                                                          Suppose that a source file contains a call of a function f that’s defined in another
                                                          file, f o o . c . Calling f without declaring it first is risky. Without a prototype to
                                                          rely on, the com piler is forced to assume that f ’s return type is i n t and that the
                                                          number ofparam eters matches the num berofargum ents in the call of f . The argu­
                                                          ments themselves are converted autom atically to a kind of “standard form" by the hg
 d c f a u i t a r g u m e n t p r o m o t io n s > 9 3   default argum ent prom otions. The com piler’s assumptions may well be wrong, but
                                                          it has no way to check them, since it compiles only one file at a time. If the
                                                          assum ptions are incorrect, the program probably won't work, and there w on't be
                                                          any clues as to why it doesn't. (For this reason, C99 prohibits calling a function for
                                                          which the com piler has not yet seen a declaration or definition.) kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                                          Whcn calling a function f that's defined in another file, always make sure that the

                                           A              com piler has seen a prototype for f prior to the call.aZYXWVUTSRQPONMLKJIHGFEDCBA


                                                               Our first impulse is to declare f in the file where it’s called. That solves the
                                                          problem but can create a maintenance nightmare. Suppose that the function is
                                                          called in fifty different source files. How can we ensure that f ’s prototypes are the
                                                          samc in all the files? How can we guarantee that they match the definition of f in
                                                          f o o . c? lf f should changU-e later, how can wc find all the files where it's used?
                                                               The solution is obvious: put f ’s prototype in a header file, then include the
                                                          header file in all the places where f is called. Since f is defined in f o o . c, let’s
                                           Q&A            name the header file f o o . h . In addition to including f o o . h in the source files
                                                          where f is called, w e’ll need to include it in f o o . c , enabling the com piler to
                                                          check that f ’s prototype in f o o . h matches its definition in f o o . c.


                                                          AIways include the header file declaring a function f in the source file that con­

                                           A              tains f ’s definition. Failure to do so can cause hard-lo-find buus--s, since calls of f
                                                          elsewhere in the program may not match f ’s definition.


                                                               If f o o . c contains other functions, most o f them should bc declared in the
                                                          same header file as f . After all. the olhcr functions in f o o . c are presumably
                                                          related to f ; any file that contains a call o f f probably needs some of the other
                                                          functions in f o o . c . Functions that are intended for use only within f o o . c
                                                          shouldn't be declared in a header file, however; to do so would be misleading^?.
                                                               To illustrate the use of function prototypes in header files, let's return to the
                                                          RPN calculator of Section l 5 .1. The s t a c k . c file will contain definitions of thc
                                                          m a k e _ e m p ty , i s _ e m p t y , i s _ f u l l . p u s h , and p o p functions. The following
                                                          prototypes for these functions should go in the s t a c k . h header file:

                                                          v o id m a k e _ e n ip ty (v o id );
                                                          i n t i s e m p ty (v o id );
                                                                                                               15.2                               355
                                                                                                                        H e a d e rF ile s kjihgfedcbaZYXWVUTSRQPONMLKJI

                                          int is_full(void);
                                          void push(int i);
                                          int pop(void);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                          (To avoid complicating tlie example, i s _ e m p t y and i s _ f u l l will rctum i n t
                                          values instead of Boolean values.) WeTl include s t a c k . h in c a l c . c to allow
                                          the compiler to check any calls of stack functions that appear in the latter file.
                                          We’ll also include s t a c k . h in s t a c k . c so the com piler can verify that the pro­
                                          totypes in s t a c k . h match the definitions in s t a c k . c . The following figure
                                          shows s t a c k . h, s t a c k . c, and c a l c . c:


                                                                             | void make_empty(void);
                                                                               int is_empty(void);
                                                                             | int is_full(void);
                                                                               void push(int i);
                                                                               int pop(void);

                                                                                          stack.h




                                                        #include "stack.h"                           ।   #include "stack.h"

                                                        int rnain(void)                              | int contents[100] ;
                                                        {                                            l int top = 0;
                                                          make_empty() ;
                                                                                                         void make emptv(void)cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                        }'■ ■
                                                                                                         { - }
                                                                                                         int is empty(void)
                                                                   calc.c                                { -} "

                                                                                                         int is_full(void)


                                                                                                         void push(int i)
                                                                                                         {-}

                                                                                                         int pop(void)


                                                                                                                  stack.cdcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                          S h a r in g V a r ia b le D e c la r a tio n s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

o x t e r n a iv a n a b ie s > ? o . 2   External variables can be shared among files in much the same way functions are.
                                          To share a function, we put its definition in one source file, then put declarations in
                                          other files that need to call the function. Sharins  c? an external variable is donc in

                                          much the same way.
                                               Up to this point, we haven’t needed to distinguish between a variable’s decla­
                                          ration and its definition. To declare a variable i , we*ve written

                                          int i;                      /* declares i and defines it as well */
3 5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
             C h a p te r 15     W ritin g L a r g e P r o g r a m s


                                           which not only declares i to be a variable of type i n t . but defines i as well, by hg

         e x t e r n k e y w o rd > 18.2   must put the keyword e x t e r n at the beginning of its declaration:kjihgfedcbaZYXWVUTSRQPONMLKJ

                                                                        declares i without defining it */


                                           likely in a different sourcc file), so there's no nccd to allocate space for it.
                                                e x t e r n works with variables ofall types. When we use it in the declaration
                                           of an array, we can omit the length of lhc array:aZYXWVUTSRQPONMLKJIHGFEDCBA

                               Q&A


                                           Since the compiler doesn’t allocate space for a at this time, there's no need for it to

                                                To share a variable i among several source files, we first put a definition of i
                                           in one file:



                                           If i needs to be initialized, the initializer would go here. When this file is com
                                           piled, the compiler will allocate storage for i . The other files will contain declara
                                           tions of i:



                                           By declaring i in each file, it becomes possible to access and/or modify i within
                                           those files. Because of the word e x t e r n , however, the compiler doesn’t allocate
                                           additional storage for i each time one oflhe files is compiled.
                                                When a variable is shared among files, we'll face a challenge similar to one
                                           that we had with shared functions: ensuring that all declarations o fa variable agree
                                           with the definition of the variable.


                                           When declarations of the same variable appear in different files, the compiler can't
                                           check that the declarations match the variable’s definition. For example, one file
                                           mav* contain the definition


                                           while anothcr file contains the declaration
                                           extern long i;

                                           An error o f this kind can cause the program to behave unpredictably.


                                                To avoid inconsistency, declarations of shared variables are usually pul in
                                           header files. A source file that needs access to a particular variable can then
                                           include the appropriate header file. In addition, each header file that containsa
                                                             15,2    H e a d e rF ile s hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                 3 5 7 onmlkjihgfedcbaZYX

variable declaration is included in the sourcc file that contains the variable's defini­
tion. enabling the com piler to check that the two match.
     Although sharing variables am ong files is a long-standing practice in the C
world, it has significant disadvantages. In Section l9.2, w e'll see what the prob­
lems are and learn how to design program s that don’t need shared variables.dcbaZYXWVUTSRQPONMLKJI


N e ste d I n c lu d e s

A header file may itseIfcontain # i n c l u d e directives. Although this practice may
seem a bit odd, it can be quite useful in practice. C onsider the s t a c k . h filc.
which contains thefollow ing prototypes:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

int is_empty(void);
int is_full(void);

Since these functions return only 0 or 1. it's a good idea to declare their return type
to be B o o l instead of i n t , where B o o l is the type that we defined earlier in this
section:

Bool is_empty(void);
Bool is_full(void);

O fcoiirse, w e'll need to include the b o o l e a n . h file in s t a c k . h so that the def­
inition of B o o l is available when s t a c k . h is com piled. (In C99, w e’d include
< s t d b o o l . h > instead o f b o o l e a n . h and declare the return types of the two
functions to be b o o l rather than B o o l.)
      Traditionally. C program m ers shun nested includes. (Early versions of C
didn’t allow them at all.) However, the bias against nested includes has largely
faded away, in part because nested includes are com mon practice in C++.


P r o t e c tin g H e a d e r F ile s

lf a source file includes the same header file twice, com pilation errors may result.
This problem is common when header files include other header files. For exam ­
ple. suppose that f i l e l . ' n includes f i l e 3 . h , f i l e 2 . h includes f i l e 3 . h .
and p r o g . c includes both f i l e l . h and f i l e 2 . h (see the figure at the top of
lhc next page). When p r o g . c is com piled, f i l e 3 . h will be com piled twice.
     Including the same header file twice doesn’t always cause a com pilation error.
If thc file contains only macro definitions, function prototypes, and/or variable
declarations, there w on’t bc any difficulty. If the file contains a type definition,
however, w e’ll get a compilation error.
     Just lo bc safc. it’s probably a good idea to protect all header files against m ul­
tiple inclusion: that way. we can add type definitions to a file later without the risk
that we might forget to protect the file. In addition, we might save some time d ur­
ing program developm ent by avoiding unnecessary recom pilation o f thc sam e
header file.
3 5 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W ritin g L a rg e P ro g ra m s KJIHGFEDCBA




                                             To protect a header file , w e’ll enclose the contents o ft h e file in an # i f n d e f -
                                        # e n d i f pair. For exam p le, the b o o l e a n . h file could be protected in the follow ­
                                        ing way:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        #ifndef BOOLEAN_H
                                        #define BOOLEAN_H

                                        #define TRUE 1
                                        #define FALSE 0
                                        typedef int Bool;

                                        #endif

                                        When this file is included the first time, the BOOLEAN_H macr o w on ’t be defined,
                                        so the pr eprocessor will allow the lines between # i f n d e f and # e n d i f to slay.
                                        But if the file should be included a second time, the pr epr ocessor will r emove the
                                        lines between # i f n d e f and # e n d i f.
                                             The name o f the macr o (BOOLEAN_H) doesn't r eally matter. However , mak­
                                        ing it resemble the name o f the header file is a good way lo avoid con flicts with
                                        other macros. Sin ce we can 't name the macr o BOOLEAN.H (identifier s can 't con­
                                        tain per iods), a name such as BOOLEAN_H is a good alter native.dcbaZYXWVUTSRQPONMLKJIHGFED


                                        # e r r o r D ir e c tiv e s in H e a d e r F ile s

        se r r 0 r d ir e ciivcs >M.5   # e r r o r directives are often pul in header files to ch eck for conditions under
                                        which the header file sh ould n 't bc included. For exam p le, sup pose that a header




                                                                                                                                          I
                                                                                                                                          I
                                                                   1 5 .3                                                    3 5 9 aZYXWVUTSRQPONM
                                                                            D iv id in g a P ro g ra m in to F ile s hgfedcbaZYXWVUTSRQPONMLKJIHGF


                                   file uses a feature that didn’t exist prior lo lhc original C89 standard. To prevent the
                                   header file from being used with older, nonstandard compilers, it could contain an
                                   # i f n d e f directive that tests fo rth e existence o fth e
                        14.3onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
S T D C _ _ m a c r o > BA                                                                       STDC     macro:kjihgfedcbaZYXWVUTSRQPONMLKJIHGF

                       #ifndef __STDC__
                       #error This header requires a Standard C compiler
                       #endif




           1 5 .3      D iv id in g a P r o g r a m in to F ile s

                       Let’s now use what we know about header files and source files to develop a sim ­
                       ple technique fordividing a program into files. We’ll concentrate on functions, but
                       the same principles apply to external variables as well. W e’ll assum e that the pro­
                       gram has already been designed; that is. w e’ve decided what functions the program
                       will need and how to arrange the functions into logically related groups. (W e'll dis­
                       cuss program design in Chapter 19.)
                             Here's how w c'll proceed. Each set of functions will go into a separate source
                       file (let's use the name f o o . c for one such file). In addition, w e’ll create a header
                       file with the same name as the source file, but with the extension . h ( f o o . h . in
                       our case). Into f o o . h . w e'll put prototypes for the functions defined in f o o . c .
                       (Functions that are designed for use only within f o o . c need not— and should
                       not— be declared in f o o . h . The r e a d _ c h a r function in our next program is an
                       example.) W e'll include f o o . h in each source file that needs lo call a function
                       defined in f o o . c. Moreover, w e’ll include f o o . h in f o o . c so that the com piler
                       can check that the function prototypes in f o o . h are consistent with the definitions
                       in f o o . c.
                             The m a in function will go in a file whose namc matches the name of the pro­
                       gram — if we want the program lo be known as b a r . lhen m a in should be in the
                       file b a r . c. It's possible that there are other functions in thc same file as m a in , so
                       long as they're not called from other files in the program.


                     T e x t F o r m a tt in g
   P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                       To illustrate the technique that w c 'v e ju sl discussed, let's apply it to a small text-
                       formatting program named j u s t i f y . As sample input to j u s t i f y , w e’ll use a
                       file named q u o t e that contains the following (poorly formaited) quotation from
                       “The development o fth e C programming language” by Dennis M. Ritchie (in cbaZYXWVUTSRQPONMLKJIHGF
                                                                                                            H is­
                       tory oj'P rogram m ing Languages IL edited by T. J. Bcrgin, Jr.. and R. G. Gibson.
                       Jr.. Addison-Wesley. Reading, Mass., 1996. pages 671-687):

                          C     is quirky,   flawed,    and an
                       enormous   success.       Although accidents of   history
                        surely helped,     it evidently    satisfied   a   need

                               for     a      system       implementation                 language              efficient
3 6 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W ritin g L a rg e P ro g r a m s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                  enough    to displace          assembly     language,
                                                     yet sufficiently   abstract   and fluent      to describe
                                                    algorithms   and     interactions     in a    wide    variety
                                                 of    environments.
                                                                               Dennis      M.          RitchieonmlkjihgfedcbaZYX

                                                    To run the program from a UNIX or Windows prompt, w e’d enter the com ­
                                                 mand

                                                 justify <quote

                                                 The < symbol informs the operating system that j u s t i f y will read from the file
                                                 q u o t e instead of accepting input from the keyboard. This feature, supported by aZYXW
            in p u tr e d ir e c tio n > 2 2 j   UNIX, Windows, and other operating systems, is called RQPONMLKJIHGFEDCBA
                                                                                                               i n p u t r e d i r e c t i o n . When
                                                 given the q u o t e file as input, the j u s t i f y program will produce the following
                                                 output:

                                                 C is quirky,  flawed,  and an enormous success. Although
                                                 accidents of history surely helped, it evidently satisfied a
                                                 need for a system implementation language efficient enough
                                                 to displace assembly language, yec sufficiently abstract and
                                                 fluent to describe algorithms and interactions in a wide
                                                 variety of environments. -- Dennis M. Ritchie

                                                    The output o f j u s t i f y will norm ally appear on the screen, but we can save it in a
          o u t p u t r e d ir e c t i o n >22.1 ,
                                                  w file by using o u ( p u t r e d i r e c t i o n ' .

                                                 justify <quote >newquote

                                                 The output of j u s t i f y will go into the file n e w q u o te .
                                                       In general, j u s t i f y ' s output should be identical to its input, except that
                                                 extra spaces and blank lines are deleted, and lines are filled andjustified. 'T illing”
                                                 a line means adding^* words until one more word would cause the line to overflow.
                                                 “Justifying" a line means adding exira spaces between words so that each line has
                                                 exactly the same length (60 characters). Justification must be done so that the
                                                 space between words in a line is equal (or as nearly equal as possible). The last line
                                                 of the output w on't be justified.
                                                       W e'll assume that no word is longer than 20 characters. (A punctuation mark
                                                 is considered part of the word to which it is adjacent.) T hat’s a bit restrictive, of
                                                 course, but once the program is written and debugged wc can easily increase this
                                                 lim it to the point that it would virtually never be exceeded. Ifth c program encoun­
                                                 ters a longer word, it must ignore all characters after the first 20. replacing them
                                                 with a single asterisk. For example, the word

                                                 antidisestablishmentarianism

                                                 would be printed as

                                                 antidisestablishment*
                                                                   1 5 .3                                                      361BA
                                                                              D iv id in g a P ro g r a m in to F ile s kjihgfedcbaZYXWVUTSRQPONMLKJI


                  Now that we understand what the program should do. it’s time to think about a
             design. We’ll start by observing that the program can’t write the words one by one
             as they're read. Instead, it will have to store them in a ‘lin e buffer" until there are
             enough to fill a line. After further reflection, we decide that the heart of the pro­
             gram will be a loop that goes something like this:

              for (; ;) {PONMLKJIHGFEDCBA
                read word ;
                if (can'treadword) {
                    write contents ofHne buffer withoutjusiiftcation;
                    terminate program;


                    if (word doesn 'tfitin line buffer) {
                      write contents ofline buffer withJustification ;
                      clear line buffer;

                    add word to line buffer;


             Since w e’ll need functions that deal with words and functions that deal with the
             line buffer, let's split the program into three source files, putting all functions
             related lo words in one file ( w o r d , c) and all functions related to the line buffer in
             another file ( l i n e . c). A third file (j u s t i f y . c) will contain the m a in function.
             In addition to these files, w e’ll need two header files, w o r d . h and l i n e . h . The
             w o r d . h file will contain prototypes for lhe functions in w o r d . c : l i n e . h will
             play a similar role for l i n e . c.
                  By examining the main loop, we see that the only word-related function
             that we'll need is a r e a d _ w o r d function, (lf r e a d _ w o r d can’t read a word
             because it's reached the end of the input file. wcTl have it signal the main loop
             by pretending to read an “empty" word.) Consequently, the w o r d . h file is a
             small one:

word.honmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
            #ifndef WORD_H
              #define WORD_H
                  X * X X * * * X X X X * X X X * X k x * -k * k X * k ^k X X -k k ~k "k k k k X k X X * X k k k X X k X X X * k k k k X
              I irGFEDCBA

                * read_word: Reads the next word from the input and                                                                   *
                * stores it in word. Makes word empty if no   *
                * word could be read because of end-of-file.  *
                * Truncates the word if its length exceeds    *
                * len.                                                                                                                *
                ★   X k X k ~k k k X X * X k X A X X X k k k k X k k X X X X 'k X k X X * X X X X * X k k k k k k X k ^k k k k k ~k k k X |

              void read_word(char *word, int len);

              #endif

              Notice how the WORD_H macro protects w o r d . h from being included more than
              once. Although w o r d . h doesn't really need it. it’s good practice to protect all
              header files in this way.
3 6 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W ritin g L a rg e P ro g ra m s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          The l i n e . h file w on't be as shorl as w o r d . h. Our outline of the main loop
                                      reveals the need for functions that perform the following operations:

                                             Write contents of linc buffer withoutjustification
                                             Determine how many characters are left in line buffer
                                             Write contents of line buffer with justification
                                             Clear line buffer
                                             Add word to line buffer

                                      W e’ll call these functions f l u s h _ l i n e . s p a c e _ r e m a i n i n g , w r i t e _ l i n e .
                                      c l e a r _ l i n e , and a d d _ w o r d . H ere's what the l i n e . h header file will look
                                      like:

                                       #ifndef LIbTE_H
                         lin e .h kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      #define LINE_H
                                      I x********x **x*x*****x* *******x***************** ****x*x*x*x
                                        * clear_line: Clears the current line.                                                                                 *GFEDCBA
                                        X X ^c X X X X -fc X X X X X * X X X X X X X X ★   X X * X X X X X + * X X * X X * X -k X X X -k * +■ X X X X X * X X X X * |

                                      void clear_line(void);
                                 «
                                 <    | X X X * X X * * * * X * * * * * * * * * * * X * * * * * * X * * X * X * * * * * X * * * X X * * * * X X * * X X * X

                                        * add_word: Adds word to the end of the current line.                                                                    *
                                        *           If this is not the first word on the line,                                                                   *
                                        * puts one space before word.                                                                                            *
                                        *   * * * X * * -k + 4r X * X * X * X X X X * * X * x * * X X X X X + X X X X X X X -fr X * X X X X X X X X X X X * X X X /

                                      void add_word(const char *word);
                                      [ X * * X * * * * * * * * * * X * * * * ★    * * * * X X * * * X X * X X * * * * X X X X X X X X X X X X X X X X X X X X

                                        * space_remaining: Returns the number of characters left *
                                        *                 in the current line.                  *
                                        X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X

                                      int space remaining(void);
                                      | -k X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X

                                        * write_line: Writes the current line with                                                                               *
                                        * justification.                                                                                                         *
                                        X   X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X |

                                      void write_line(void);
                                      | X X X X X X X X X x- X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X

                                        * flush_line: Writes the current line without                                                                            *
                                        * justification. If the line is empty, does *
                                        * nothing.                                                                                                               *
                                        X X X X X X X X ★   X X X X X X X X X X X X X X X X X X X X X X X X X X X X X A’X X X X X X X X X X X X X X X X X X X |

                                      void flush_line(void);

                                      #endif

                                           Before wc writc thc w o r d . c and l i n e . c files, we can use thc functions
                                      declared in w o r d . h and l i n e . h to write j u s t i f y . c, the main program. Writ­
                                      ing this lile is mostly a matter of translating our original loop design into C.
                                                   1 5 .3   D iv id in g a P ro g ra m in to F ile s hgfedcbaZYXWVUTSRQPONMLK
                                                                                                              3 6 3 BA


justify.C kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
              /* Formats a file of text */

           #include <string.h>
           #include "line.h"
           #include "word.h”

           #define MAX_WORD_LEN 20

           int main(void)

              char word[MAX_W0RD_LEN+2];
              int word_len;

              clear__line () ;
              for (;;) {
                read_word (word, MAX_WORD_LEN+1) ;
                word_len = s trlen(wo rd) ;
                if (word_len == 0) {
                   flush_line () ;
                  return 0;

                 if (word_len > MAX_WORD_LEN)
                   word[MAX_WORD_LEN] = '* ’;
                 if (word_len + 1 > space_remaining())                          {
                   write_line();
                   clear_line();

                 add_word(word);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



           Including both l i n e . h and w o r d . h gives the compiler access to the function
           prototypes in both files as il compiles j u s t i f y , c.
                  m a in uses a trick to handle words that exceed 20 characters. When it calls
           r e a d _ w o r d . m a in tells it to truncate any word that exceeds 21 characters. After
           r e a d _ w o rd returns, m a in checks whether w o rd contains ac?strins, that^'s lonsjcr
           than 20 characters, lfso. the word that was read must have been at least 21 charac­
           ters long (before truncation), so m a in replaces the word’s 2 lst character by an
           asterisk.
                  Now it's time to write w o r d . c. Although the w o r d . h header file has a pro­
           totype for only one function, r e a d _ w o r d , we can put additional functions in
           w o r d . c if we need to. As il turns out, r e a d _ w o r d is easier to write if we add a
           small ‘"helper” function, r e a d _ c h a r . We’ll assign r e a d _ c h a r the Lask ofread-
           ing a single character and, if il’s a new-line character or tab, converting it to a
           space. Having r e a d _ w o r d call r e a d _ c h a r instead of g e t c h a r solves the
           problem of treating new-line characters and tabs as spaces.
                  Here’s the w o r d . c file:

 word.c    #include <stdio.h>
           #include "word.h"
3 6 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W ritin g L a r g e P ro g r a m s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                 if (ch == '\n'          || ch == '\t')
                                                   return ' ';
                                                 return ch;


                                              void read_word(char *word, int len)

                                                 int ch, pos = 0;

                                                 while ((ch = read_char()) == ’ ’)
                                                   /
                                                 while (ch != 1 ' && ch != EOF) {
                                                   if (pos < len)
                                                     word[pos++] = ch;
                                                   ch = read_char();
                                          r      }

                                                 word[pos]      = '\0’;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                    Before wc discuss r e a d _ w o r d . a couple ofcom m ents are in order concern­
                                              ing the use of g e t c h a r in the r e a d _ c h a r function. First, g e t c h a r returns an
                                              i n t value instead o f a c h a r value: thaf’s why the variable c h in r e a d _ c h a r is
                                              declared to have type i n t and why the return type of r e a d _ c h a r is i n t . Also,
                E O F m a c ro > a ? .4       g e t c h a r returns thc value EOF when it’s unable to continue reading (usually
                                              because it has reached the end of the input file).
                                                    r e a d _ w o r d consists of two loops. The first loop skips over spaces, stopping
                                              at the first nonblank character. (EOF isn’t a blank, so the loop stops ifit reaches the
                                              end o fth e input file.) The second loop reads characters until encountering a space
                                              or EOF. The body o fth e loop stores the characters in w o rd until reaching the l e n
                                              limit. After that, the loop continues reading characters but d o esift store them. The
                                              final statement in r e a d _ w o r d ends the word with a null character, thereby mak­
                                              ingO it a string.
                                                              C2
                                                                 If r e a d - w o r d encounters EOF before finding  o
                                                                                                                       a nonblank charac-
                                              ter. p o s will be 0 at the end. making w o r d an empty string.
                                                    The only file left is l i n e . c , which supplies definitions o f the functions
                                              declared in the l i n e . h file, l i n e . c will also need variables to keep track of the
                                              state of thc line buffer. One variable, l i n e , will store the characters in the current
                                              line. Strictly speaking, l i n e is the only variable wc need. For speed and conve­
                                              nience. however, w e'll use two other variables: l i n e _ l e n (thc num ber o fch ar-
                                              acters in the current line) and n u m _ w o rd s (thc number of words in the current
                                              line).
                                                    H ere's the l i n e . c file:BA

                            line.c            #include <stdio.h>
                                              #include <string.h>
                                              #include "line.h"
                               1 5 .3                                                   365
                                        D iv id in g a P ro g ra m in to F ile s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


#define MAX_LINE_LEN 60

char line[MAX_LINE_LEN+l];
int line_len = 0;
int num_words = PONMLKJIHGFEDCBA
                 0;

void clear_line(void)

  line [0] = ’\ 0 ’;
  line_len = 0;
  num_words = 0;


void add_word(const char *word)

  if (num_words > 0) {
    line[line_len] = ' ';
    line[line_len+l] - '\0';
    line_len++ ;

  strcat(line, word);
  line_len += strlen(word);
  num_words++;


int space_remaining(void)

  return MAX_JjINE_LEN - line_len;


void write_line(void)
{
  int extra_spaces, spaces_to_insert,                i r j;

  extra_spaces = MAX_LINE_LEN - line_len;
  for (i = 0; i < line_len; i+ + ) {
    if (line [i] ’= • ’)
      putchar(line[i]);
    else {
      spaces_to_insert = extra_spaces / (num_words - 1);
      for (j = 1; j <= spaces_to_insert + 1; j++>
        putchar(• ’);
      extra_spaces -= spaces_to_insert;
      num_words- -;


  putchar(1 \ n ’);


void flush_line(void)
{
  if (line_len > 0)
    puts(line);
            C h a p te r 15
3 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA W ritin g L a rg e P ro g ra m s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           Most of the functions in l i n e . c are easy to write. The only tricky one is
                                     w r i t e _ l i n e , which writes a line wilhjiistiFication. w r i t e _ l i n e writes thc
                                     characters in l i n e one by one, pausing at thc space between each pair of words to
                                     write additional spaces if needed. The number of additional spaces is stored in
                                     s p a c e s _ t o _ i n s e r t . which has the value e x t r a _ s p a c e s / (n u m _ w o rd s
                                     - 1 ) , where e x t r a _ s p a c e s is initially the difference between the maximum
                                     line length and the actual line length. Since e x t r a _ s p a c e s and n u m _ w o rd s
                                     change after each word is printed, s p a c e s _ t o _ i n s e r t will change as well. If
                                     e x t r a _ s p a c e s is 10 initially and n u m _ w o rd s is 5, then the first word will be
                                     followed by 2 extra spaces, the second by 2. the third by 3, and the fourth by 3.aZYXWVUTS




                        1 5 .4       B u ild in g a M u lt ip le - F ile P r o g r a m

                                     In Section 2.1, we examined the proccss ofcom piling and linking a program that
                                     fits into a single file. Let's expand that discussion to cover multiple-file programs.
                                     Building a large program requires the same basic steps as building a small one:cbaZYXWVUTS
                                       ■ Com piling. Each source filc in the program must be compiled separately.
                                         (Header files don't need to be compiled; the contents of a header file are auto­
                                         matically compiled whenever a source file that includes il is compiled.) For
                                         each source file, the compiler generates a file containing object code. These
                                         files— known as object file s — have the extension .o in UNIX and . o b j in
                                         Windows.
                                       ■ U n kin g . Thc linker combines the object files created in thc previous step—
                                         along with code for library functions— lo produce an executable file. Among
                                         other duties, the linker is responsible for resolving external references lcfl
                                         behind by the compiler. (An external reference occurs when a function in onc
                                         file calls a function defined in another file or accesses a variable defined in
                                         another file.)
                                         Most compilers allow us to build a program in a single, step. With the GCC
                                     compiler, for example, we'd use the following command to build the j u s t i f y
                                     program ofSection 15.3:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     gcc ~o justify justify.c line.c word.c

                                     Thc three source files are first compiled into object code. The object files are then
                                     automatically passed to thc linker, which combines (hem into a single file. The -o
                                     option specifies that wc want the executable file to be named j u s t i f y .dcbaZYXWVUTSRQPONM


                                     M a k e f ile s

                                     Putting the names of all the source files on lhc command line quickly gets tedious.
                                     Worse still, we could waste a lol of time when rebuilding a program if we recom­
                                     pile all source files, notjust the ones that were affected by our most recent changes.
                                         1 5 .4                                                           3 6 7 onmlkjihgfedcbaZYXW
                                                  B u ild in g a M u ltip le - F ile P ro g ra m hgfedcbaZYXWVUTSRQPONMLKJIHG


           To make ii easier to build large programs. UNIX originated the concept o fth e cbaZYXWVUTSRQPON
      m akefile, a llle containing the information necessary to build a program. A make­
      file not only lists the files that are part of the program, but also describes d ep e n ­
      dencies among the files. Suppose that the file f o o . c includes the file b a r . h. We
      say that f o o . c “depends” on b a r . h, because a change to b a r . h will require us
      to recompile f o o . c.
           H ere’s a UNIX makefile for the j u s t i f y program. The makefile uses GCC
      forcom pilation and linking:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      justify: justify.o word.o line.o
              gcc -o justify justify.o word.o line.o

      justify.o: justify.c word.h line.h
              gcc -c justify.c

      word.o: word.c word.h
              gcc -c word.c

      line.o: line.c line.h
              gcc -c line.c

      Thcrc are four groups of lines: each group is known as a rule. The first line in each
      rule gives a ta rget file, followed by the files on which it depends. The second line
      is a co m m a n d to be executed if the target should need to be rebuilt because of a
      change to one of its dependent files. Let’s look at the first two rules; (hc last two
      are similar.
           In the first rule, j u s t i f y (the executable file) is the target:

      juseify: justify.o word.o line.o
              gcc -o justify justify.o word.o line.o

      The first line states that j u s t i f y depends on the files j u s t i f y . o , w o r d .o .
      and l i n e .o : if any one of these three files has changed since the program was
      last built, then j u s t i f y needs to be rebuilt. The command 011 the following line
      shows how the rebuilding is to be done (by using the g c c command to link the
      three object files).
           In the second rule, j u s t i f y . o is the target:

      justify.o: justify.c word.h line.h
              gcc -c justify.cdcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      The first line indicates that j u s t i f y . o needs to be rebuilt if there’s been a
      change to j u s t i f y . c , w o r d .h . or l i n e . h . (The reason for mentioning
      w o r d . h and l i n e . h is that j u s t i f y . c includes both these files, so it’s poten­
      tially affected by a change to either one.) The next line shows how to update
      j u s t i f y . o (by recompiling j u s t i f y . c ) . The - c option tells the com piler to
      compile j u s t i f y , c into an object file but not attempt to link il.
Q&A         Once we've created a makefile for a program, we can use the m a k e utility to
      build (or rebuild) the program. By checking the time and date associated with each
368 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 15      W r it in g L a r g e P r o g r a m s


                                    llle in the program, m ak e can determine which Tiles are out ofdate. It then invokes
                                    the commands necessary to rebuild the program.
                                          Ifyou want to give m ake a try. here arc a few details you’ll need to know:

                                                  ■ E ach command in a makefile must be preceded by a tab character, not a series
                                                     of spaces. (In our example, the commands appear to bc indented eight spaces,
                                                     but it’s actually a single tab character.)
                                              ■     A makefile is normally stored in a file named M a k e f i l e (or m a k e f i l e ) .
                                                    When the m ake utility is used, it automatically checks the current directory
                                                    for a file with one of these names.
                                          ■         To invoke m ake, use the command kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                         ungei
                                                    make cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                    where targer is one o flh e targets listed in the makefile. To build the j u s t i f y
                                                    executable using our makefile, wc would use the command

                                                    make justify

                                      ■             If no target is specified when m ake is invoked, it will build the target of the
                                                    first rule. For example, the command

                                                    make

                                                    will build the j u s t i f y executable, since j u s t i f y is the first target in our
                                                    makefile. Except for this special property o flh e first rule, the o rd ero fru les in
                                                    a makefile is arbitrary.
                                         m ake is complicated enough that entire books have been written about it, so
                                    we w on't attempt to delve further into its intricacies. L et'sju st say that real make­
                                    files a re n i usually as easy to understand as our example. There are numerous
                                    techniques that reduce the amount ofredundancy in makefiles and make them eas­
                                    ier to modify: at the same lime, though, these techniques greatly reduce thcir read­
                                    ability.
                                          Not everyone uses makefiles, by the way. Other program maintenance tools
                                    arc also popular, including the "project files’’ supported by some integrated devel­
                                    opment environments.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    E r r o r s D u r in g L in k in g

                                    Some errors that can’t be detected during compilation will be found during linking.
                                    In particular, iflh e definition o f a function or variable is missing from a program,
                                    the linker will be unable to resolve external references to it. causin <   a^ a messagk-e
                                    such as "iindefinedsym h(> r or "undefined reference.”
                                         Errors detected by the linker arc usually easy to fix. Here arc some o fth e most
                                    common causes:

                                          ■ M isspellings. If thc name of a variable or function is misspelled, the linker
                                            will report it as missing. For example, ifth c function r e a d _ c h a r is defined
                                   1 5 .4                                                            369onmlkjihgfedcbaZYXWVUT
                                            B u ild in g a M u lt ip le - F ile P r o g ra m kjihgfedcbaZYXWVUTSRQPONMLKJIHGFED


     in the program but called as r e a d _ c a h r , the linker will report that
     r e a d c a h r is missing.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
  ■ M issing file s . If the linker can’t find thc functions that arc in file f o o . c. it
    may not know about the file. Check the makefile or project file to make sure
    that f o o . c is listed there.
  ■ M issin g libraries. The linker may not bc able to find all library functions used
    in thc program. A classic example occurs in UNIX programs that use lhc
    < m a th .h > header. Simply including the header in a program may not be
    enough: many versions o fU N IX require that the - l m option be specified
    when the program is linked, causing the linker to search a system file that con­
    tains compiled versions of the < m a t h . h > functions. Failing to use this option
    may cause “undefined reference” messages during linking.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


R e b u ild in g a P r o g r a m

During the development of a program, it’s rare that w e’ll need to compile all its
files. Most o f the time, w e'll test the program, make a change, then build the pro­
gram again. To save time, lhc rebuilding process should recompile only those files
that might bc affected by thc latest change.
      Let’s assume that w c’vc designed our program in thc way outlined in Section
 15.3. with a header file for each source file. To see how many files will need to be
recompiled after a change, we need to consider two possibilities.
      The first possibility is that the change affects a single source file. In that case,
only that file must be recompiled. (After that, the entire program will need lo be
relinked, of course.) Consider the j u s t i f y program. Suppose that wc dccide to
condense the r e a d _ c h a r function in w o r d . c (changes are marked in bold):

int read_char(void)

   int ch = getchar();GFEDCBA

   return (ch == '\n' || ch == '\t') ? ' ' : ch;


This modification doesn’t affect w o r d . h . so we need only recompile w o r d . c
and relink the program.
     Thc sccond possibility is that the change affects a header file. In that case, we
should recompile all files that include the header file, since they could potentially
be affected by the change. (Some o fth em might not be, but il pays to be conserva­
tive.)
      As an example, consider the r e a d _ w o r d function in lhc j u s t i f y program.
Notice that m a in calls s t r l e n immediately after calling r e a d _ w o r d , in order
to determine the length o fth e word that w asju st read. Since r e a d _ w o r d already
knows the length of the word ( r e a d _ w o r d 's p o s variable keeps track of the
length), it seems silly lo use s t r l e n . M odifying r e a d _ w o r d lo return the
w ord’s length is easy. First, we change thc prototype of r e a d _ w o r d in w o r d . h:
3 7 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r1 5      W r itin g L a r g e P r o g r a m s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                 * ★ ★ A ★ * * ★ ★ ★ 'A'★ ir* ^ ★ * ★ ★
                                                                      * ★ ★ + *+ ★ ★ ★ * ★ *•★ ★ *★ ★ ** *^ ★ * ★ x* * *
                                      I + ie x * *■* *• ★ * ± * kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        * read_word: Reads the next word from the input and                            *
                                        *           stores ic in word. Makes word empty if no                       *
                                        *            word could be read because of end-of-file.                        *
                                        *            Truncates the word if its length exceeds                          *
                                        *            len. Returns the number of characters                            *
                                        *            stored.                                                          *
                                        ★                        ★   aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                     ★ ★ ★ * * 9r ★ ★ ★ Jr ★ ★ ★ ★ ★ ★   ^-   Jr *   *   ★   * • •*• *   J'   ★   +.   *   Jr   ★   Jr Jr *   Jr Jr *   *   ★   £   Jr   ★   J- Jr *   ★   *   *• *   *   *   J



                                      int read_word(char *word,                                int len);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     O f course, we’re careful to change the comment that accompanies r e a d _ w o r d .
                                     Next, we change the definition of r e a d _ w o r d in w o rd . c:

                                      int read_word(char *word,                                int len)
                                      {
                                        int ch, pos = 0;

                                            while      ((ch = read_char())                          == ' •)

                                            while (ch != ' ’ && ch != EOF)                                               {
                                              \if (pos < len)
                                                 word[pos + + ] = c h ;
                                              ch = read_char();

                                            wordlpos] = *\0*;
                                            return pos;
                                      }

                                     Finally, we modify j u s t i f y . c by removing thc include of < s t r i n g . h > and
                                     changing m a in as follows:

                                      int main(void)

                                            char word[MAX_W0RD_LEN+2j;
                                            int word_len,-

                                            clear_line();
                                            for (;;) {
                                              word_len = read_word(word, MAX_WORD_LEN+1);
                                              if (word_len == 0) {
                                                flush_line();
                                                return 0;

                                              if (word_len > MAX_WORD_LEN)
                                                w o r d [MAX_WORD_LEN] = '* 1 ;
                                              if (word_len + 1 > space_remainingO)                                                                         {
                                                write_line();
                                                clear_line();

                                              add w o rd ( w o rd ) ;
                                                                          15.4                                                           371 onmlkjihgfedcbaZYXWVUT
                                                                                  B u ild in g a M u ltip le -F ile P ro g ra m hgfedcbaZYXWVUTSRQPONMLKJIHGFED


                                       Once w e’ve made these changes, w e’ll rebuild the j u s t i f y program by recom ­
                                       piling w o rd . c and j u s t i f y . c and then relinking. T here's no need to recom pile
                                       l i n e . c , which doesn’t include w o r d . h and therefore w on’t be affected by
                                       changes to it. With the GCC com piler, we could use the following com m and to
                                       rebuild the program:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       gcc -o justify justify.c word.c line.o

                                       Note the mention of l i n e . o instead of l i n e . c.
                                             One of the advantagK^3es of usin ^s makefil^e*s is that rebuilding is handled auto-
                                       matically. By exam ining the date o f each file, the m a k e utility can determ ine
                                       which files have changed since the program was last built. It then recom piles
                                       these files, together with all files that depend on them, either directly or indirect­
                                       ly. For example, if we make the indicated changes to w o r d . h , w o r d . c , and
                                       j u s t i f y . c and then rebuild the j u s t i f y program , m a k e will perform the
                                       following actions:

                                            l . Build j u s t i f y . o by com piling j u s t i f y . c (because j u s t i f y . c and
                                                w o r d . h were changed).
                                            2. Build w o r d . o by com piling w o r d . c (because w o r d . c and w o r d . h
                                               were changed).
                                            3 . Build j u s t i f y by linking j u s t i f y . o , w o r d . o , and l i n e . o
                                                (because j u s t i f y . o and w o r d . o were changed).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       D e fin in g M a c r o s O u ts id e a P r o g r a m

                                       C com pilers usually provide som e m ethod ofsp ecify in g the value o f a m acro at the
                                       time a program is com piled. This ability makes it easy to change the value of a
                                       macro without editing any of the program ’s files. It’s especially valuable w hen pro­
                                       gram s are built autom atically using makefiles.
                                           Most com pilers (including G CC) support the -D option, which allow s the
                                       value of a macro to be specified on the com m and line:

                                       gcc -DDEBUG=1 foo.c

                                       In this example, the DEBUG m acro is defined to have the value 1 in the program
                                       f o o . c ,ju s t as if the line

                                       |idefine DEBUG 1

                                       appeared at the beginning of f o o . c . If the -D option names a m acro without
                                       specifying its value, the value is taken to be 1.
                                            Many com pilers also support the -U option, which “undefines” a m acro as ifaZYXWVUTSRQPONML
p r e d e fin e d m a c r o s > f< 3   by u.sing # u n d e f . We can use -U to undefine a predefined m acro or one that was
                                       defined earlier in the com m and line usins -D.
3 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W ritin g L a rg e P ro g ra m s aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                            Q:     Y ou d o n ’t h a v e a n y e x a m p le s tlia t u se th e # i n c l u d e d ir e c tiv e to in c lu d e a
                                   s o u r c e file. W h a t w o u ld h a p p e n i f w e w e r e to d o th is? onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                            A:     T hal's not a good practice, although it’s not illegal. Here*s an exam ple of the kind
                                   o f trouble you can gct into. Suppose that f o o . c defines a function f that we'll
                                   need in b a r . c and b a z . c. so we pul the directive kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   f|include "foo.c"

                                   in both b a r . c and b a z . c. Each of lhese files will com pile nicely. The problem
                                   com es later, when lhc linker discovers two copies o f the object code for f . Of
                                   course, we would have gotlcn away with including f o o . c if only b a r . c had
                                   included il. not b a z . c as well. To avoid problems, it's besl lo use # i n c l u d e
                                   only with header files, not source files.

                            Q:     W h a t a r e th e e x a c t s e a r c h r u le s fo r th e # i n c l u d e d ir e c tiv e ? [p. 3 5 1 ]
                            A:     That depends on yourcom pilcr. The C standard is deliberately vague in its descrip­
                                                                                             brackets, the preprocessor looks
                                   tion of # i n c l u d e . Ifth e file name is enclosed in cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   in a "sequence of im plem entation-defined places.” as lhc standard obliquely puts
                                   it. If the file name is enclosed in quotation m arks, the file “is searched for in an
                                   im plem entation-defined m a n n e r’ and. if not found, then searched as if its name
                                   had been enclosed in brackels. The reason for this waffling is sim ple: not all oper­
                                   ating systems have hierarchical (tree-likc) file system s.
                                         To make matters even more interesting, lhe standard doesn’t require lhal
                                   nam es enclosed in brackets be file names at all, leaving open the possibility that
                                   # i n c l u d e directives using <> are handled entirely within the com piler.

                           Q:      I d o n ’t u n d e r s ta n d w h y e a c h s o u r c e file n e e d s its o w n h e a d e r file. W h y not
                                   h a v e o n e b ig h e a d e r file c o n ta in in g m a c r o d e fin itio n s , ty p e d e fin itio n s , and
                                   fu n c tio n p r o to ty p e s? B y in c lu d in g th is file, e a c h s o u r c e file w o u ld h a v e access
                                   to all th e s h a r e d in fo r m a tio n it n e e d s, [p. 354J
                            A:     The “one big header file" approach certainly works; a num ber of program m ers use
                                   it. And il does have an advantage: with only one header file, there are fewer files io
                                   manage. For large program s, however, lhe disadvantages of this approach lend to
                                   outweigh its advantages.
                                        Using a single header file provides no useful inform ation to som eone reading
                                   lhe program laier. With m ultiple header files, the rcad ercan quickly see what oiher
                                   parts o f lhe program are used by a particular source file.
                                        Bui that's nol all. Since each source file depends on (he big header file, chang­
                                   ing it will cause all source files to bc recom piled— a significanl draw back in a l;uge
                                   program. To makc maiters worse, lhe header file will probably change frequently
                                   because o f the larae am ount of inform ation it contains.
                                                                                                                                                         3 7 3 dcbaZYXWVUTSRQPO
                                                                                                                               E x e r c is e s onmlkjihgfedcbaZYXWVUTSRQPONMLK


                           Q:    T h e c h a p te r s a y s th a t a s h a r e d a r r a y s h o u ld b e d e c l a r e d a s fo llo w s : kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE

                                 extern int a[];

                                 S in c e a r r a y s a n d p o in te r s a r e c lo s e ly r e la te d , w o u ld it b e le g a l to w r ite

                                 extern int *a;

                                 in s te a d ? [p . 3 5 6 ]
                           A:    No. When used in expressions, arrays “decay” inio pointers. (W e've noticed this
                                 behavior when an array namc is used as an argument in a function call.) In variable
                                 declarations, however, arrays and pointers are distinct types.

                           Q:    D o e s it h u r t i f a s o u r c e file in c lu d e s h e a d e r s th a t it d o e s n ’t r e a ll y n e e d ?
                           A:    Not unless the header has a declaration or definition that conflicts with one in the
                                 source file. Otherwise, the worst that can happen is a minor increase in the time it
                                 takes to com pile the source file.

                           Q:    I n e e d e d to c a ll a fu n c tio n in th e file f o o . c , s o I in c lu d e d th e m a t c h in g
                                 h e a d e r file , f o o . h . M y p r o g r a m c o m p ile d , h u t it w o n ’t lin k . W h y ?
                           A;    Compilation and linking are completely separate in C. Header files exist lo provide
                                 information to the compiler, not the linker. If you want to call a function in f o o . c.
                                 then you have to make sure that f o o . c is com piled and that the linker is aware
                                 that it must search the object file for f o o . c lo find the function. Usually this
                                 means naming f o o . c in the program 's makefile or project file.

                           Q:    I f m y p r o g r a m c a lls a fu n c tio n in < s t d i o . h > , d o c s th a t m e a n th a t a ll f u n c ­
                                 tio n s in < s t d i o . h > w ill b e lin k e d w ith th e p r o g r a m ?
                           A:    No. Including < s t d i o . h > (o ran y other header) has no effect on linking. In any
                                 event, most linkers will link only functions that your program actually needs.

                           Q:    W h e r e c a n T g e t th e m a k e u tility ? [p . 3 6 7 ]
                           A:    m a k e is a standard UNIX utility. The GNU version, known as GNU M ake, is
                                 included in most Linux distributions. It’s also available directly from the Free Soft­
                                                   (xvm v.gtut.org/sqft\v(ire/tiuike^. hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 ware Foundation cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                 E x e rc is e s

S e c t i o n 15.1          I.   Section l5.l listed several advantages of dividing a program into multiple sourcc files,
                                 (a) Describe several other advantages.
                                 (b) Describe some disadvantages.

S e c t i o n 1 5 .2   ®    2.   Which of the following should not be put in a header file? Why not?
                                 (a) Function prototypes
                                 (b) Function definitions
3 7 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 15      W ritin g L a rg e P ro g ra m s aZYXWVUTSRQPONMLKJIHGFEDCBA


                                   (c) Macro definitions
                                   (d) Type definitions

                             3.                                           <ftle> instead of # i n c l u d e "file" may not work iffile is
                                   We saw that writing # i n c l u d e cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   one that we’ve written. Would there be any problem with writing # i n c l u d e "Jile" instead
                                   of # i n c l u d e <filc> ifJlle is a system header?

                             4.    Assume that d e b u g . h is a header file with the following contents:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   #ifdef DEBUG
                                   #define PRINT__DEBUG(n) printf("Value of " #n ": %d\n", n)
                                   #else
                                   #define PRINT_DEBUG(n)
                                   #endif
                                   Let t e s t d e b u g . c be the following source file:
                                   #include <stdio.h>
                                   #define DEBUG
                                   #include ”debug.h "
                                   int main(void)
                                  .-{
                                                       = 2, k = 3;
                                         int i = 1, j PONMLKJIHGFEDCBA
                                   #ifdef DEBUG
                                     printf("Output if DEBUG is defined:\n");
                                   #else
                                     printf("Output if DEBUG is not defined:\n");
                                   #endif
                                         PRINT_DEBUG(i);
                                         PRlNT_DEBUG(j);
                                         PRINT_DEBUG(k);
                                         PRINT_DEBUG(i + j);
                                         PRINT_DEBUG(2 * i 4- j - k);
                                         return 0;


                                   (a) What is the output when thc program is cxccuted?
                                   (b) What is the output if the # d e f i n e directive is removed from t e s t d e b u g . c?
                                   (c) Explain why the output is different in parts (a) and (b).
                                   (d) ls il necessary for the DEBUG macro to be defined before d e b u g . h is included in order
                                       for PRINT_DEBUG to have the desired effect? Justify your answer.

                                     5.    Suppose that a program consists of three sourcc files— m a i n . c. f l . c, and f 2 . c — plus
S e c t io n 1 5 .4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   two header files, f l . h and f 2 . h. AI1 three source files include f l . h, but only f l . c and
                                   f 2 . c include f 2 . h. Write a makefile for this program, assuming that lhc com piler is g c c
                                   and that the executable file is to be named dem o.

                       ©     6.    The following questions refer to the program described in Excrcise 5.
                                   (a)   Which files need to be compiled when thc program is built for the first time?
                                   (b)   lf f l . c is changed after the program ha.s bccn built, which files need to be recompiled?
                                   (c)   I f f l . h is changed after the program has bccn built, which files need to be recompiled?
                                   (d)   l f f 2 . h is changed after the program has bccn built, which files need to be recompiled?
                                                                 P r o g r a m m in g P r o je c ts   375aZYXWVUTSRQPONMLKJ




     P r o g r a m m in g P ro je c t s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

I.   The j u s t i f y program of Section 15.3 justifies lines by inserting extra spaces between
     words. The way the w r i t e _ l i n e function currently works, the words closer to the end of
     a line tend to havc slightly wider gaps between them than the words at the beginning. (For
     example, the words closer to the end might havc three spaces between them, while the
     words closer to the beginning might be separated by only two spaces.) Improve the program
     by having w r i t e _ l i n e alternate between putting the larger gaps at the end o fth e line and
     putting them at the beginning of the line.

2.   Modify the j u s t i f y program of Section 15.3 by having the r e a d _ w o r d function
     (instead o fm a in ) store the * characterat (hc cnd o fa word that’s been truncated.

3.   Modify the q s o r t . c program of Section 9.6 so that the q u i c k s o r t and s p l i t func­
     tions are in a separate file named q u i c k s o r t . c. Create a header file named q u i c k -
     s o r t . h that contains prototypes for the two functions and have both q s o r t . c and
     q u i c k s o r t . c include this file.

4.   Modify the r e m i n d . c program of Section 13.5 so that the r e a d _ l i n e function is in a
     separate file named r e a d l i n e . c. Create a header file named r e a d l i n e . h that contains
     a prototype for the function and have both r e m i n d . c and r e a d l i n e . c include this file.

5.   Modify Programming Project 6 from Chapter 10 so that it has separate s t a c k . h and
     s t a c k . c files, as described in Section 15.2.
1 6       S tr u c tu r e s , U n io n s , a n d
          E n u m e r a tio n s                          ZYXWVUTSRQPONMLKJIHGFEDCBA




                                              F u n c tio n s d e la y b in d in g : d a ta s tr u c tu r e s in d u c e b in d in g .
                                               M o ra l: S tr u c tu re d a ta la te in th e p r o g r a m m in g p ro c e s s . onmlkjihgfedcbaZYXWV




          This chapter introduces three new types: structures, unions, and enumerations. A
          structure is a collection of values (members), possibly of different types. A union
          is similar to a structure, except that its members share the same storage; as a result,
          a union can store one m em ber at a time, but not all members simultaneously. An
          enum eration is an integer type whose values are named by ihe programmer.
               Of these three types, structures are by far lhe most important, so I'll devote
          most o fth e chapter to them. Section l6.1 shows how to declare structure variables
          and perform basic operations on them. Section l6.2 then explains how to define
          structure types, which— among other things— allow us to write functions that
          accept structure arguments or retuni structures. Section l6.3 explorcs how arrays
          and structures can be nested. The last two sections are devoted to unions (Section
           l6.4) and enumerations (Section l6.5).




 1 6 .1   S t r u c t u r e V a r ia b le s

          The only data structure w c’vc covered so far is lhc array. Arrays have two impor­
          tant properties. First, all elements o fa n array have the same type. Second, to select
          an array clement, we specify its position (as an integer subscript).
                                      stru ctu re are quite different from those of an array. The
               The properties of a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
          elements of a structure (its m em b ers, in C parlance) aren’t required to have the
          same type. Furthermore, the members o f a structure have names; to select a partic­
          ular member, we specify its name, not its position.
               Structures may sound familiar, since most programming languages provide a
          sim ilar feature. In some languages, structures are called records, and members arc-
          known a sfie ld s.



                                                                                                                               377
3 7 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r1 6      S t r u c t u r e s , U n io n s , a n d E n u m e r a t io n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      D e c la r in g S t r u c t u r e V a r ia b le s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      When we need lo store a collection of related data items, a structure is a log ical           ^^

                                      choice. For example, suppose that we need to keep track of parts in a warehouse.
                                      The information that w e’ll need to store for each part might include a part number
                                      (an integer), a part name (a string of characters), and the number of parts on hand
                                      (an integer). To create variables that can store all three items o fd ata. we might use
                                      a declaration such as the following:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      struct {
                                        int number;
                                        char name[NAME_LEN+l];
                                        int on_hand;
                                      } partl, part2;

                                      Each structure variable has three members: n u m b e r (the part number), n am e (the
                                      name of the part), and o n _ h a n d (the quantity on hand). Notice that this declara­
                                      tion has the same form as other variable declarations in C: s t r u c t { ... } specifies
                                      a type, while p a r t l and p a r t 2 arc variables of that type.
                                           The members of a structure are stored in memory in the order in which they’re
                                      declared. In order to show whal the p a r t l variable looks like in memory, let's
                                      assume that (I) p a r t l is located at address 2000. (2) integers occupy four bytes.
                                      (3) NAME_LEN has lhc value 25, and (4) there are no gaps between the members.
                                      With these assumptions, p a r t l will have the following appearance:
                                                          1 6 .1                                         379onmlkjihgfedcbaZYXWVUT
                                                                   S tr u c tu r e V a ria b le s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


Usually it's not necessary to draw structures in such detail. Tll normally show
them more abstractly, as a series ofboxcs:


                                  number

                                     name

                                on hand


I may som etim es draw the boxes horizontally instead of vertically:




                                     number        name     on_hand

M em ber values will go in the boxes later; for now, Fve left them empiy.
     Each structure represents a new scope: any names declared in that scope w on’t
conflict with other names in a program. (In C term inology, we say that each struc­
ture has a separate RQPONMLKJIHGFEDCBA
                    n a m e s p a c e for its members.) For exam ple, the following decla­
rations can appear in the same program:

s tru c t {
   i n t n u m b e r;
   c h a r n a m e [NAFIE_LEN+1] ;
   in t on_hand;
} p a r tl, p a rt2 ;

s tru c t {
   c h a r n a m e [NAM E_LEN+1];
   i n t n u m b e r;
   ch ar sex;
) e m p lo y e e l, e m p lo y e e 2 ;

The n u m b e r and n am e members in the p a r t l and p a r t 2 structures don’t con-
llict with the n u m b e r and n a m e mem bers in e m p l o y e e l and e m p l o y e e 2 .dcbaZYXWVUTSRQPONMLKJIH


I n it ia liz in g S t r u c t u r e V a r ia b le s

Like an an*ay, a structure variable may be initialized at the time it’s declared. To
initialize a structure, we prepare a list of values lo be stored in the structure and
enclose it in braces:

s tru c t {
   i n t n u m b e r;
   c h a r n a m e [N W 4 E _ L E N + l];
   in t on_hand;
} p a r c l = { 5 2 8 , " D is k d r i v e " , 1 0 } ,
   p a r t2 = {914, " P r in te r c a b le " , 5 );
            C h a p te r 16
3 8 0 ZYXWVUTSRQPONMLKJIHGFEDCBAS tru c tu re s , U n io n s , a n d E n u m e r a tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      The values in the initializer must appear in the same order as the m em bers of the
                                      structure. In our exam ple, the n u m b e r member o f p a r t l will be 528. thc nam e
                                      member will bc " D i s k d r i v e " , and so on. H ere's how p a r t l will look after
                                      initialization:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                           number             528

                                                                              name     Disk drive

                                                                         on hand


                                           Structure initializers follow rules sim ilar to those for array initializers. Expres­
                                      sions used in a structure initializer must be constant: for example, we couldn’t have
                                      used a variable to initialize p a r t l ' s o n _ h a n d member. (This restriction is rc-
                          <•££>       laxed in C99. as w e’ll sec in Section 18.5.) An initializer can have fewer members
                                      than the structure it's initializing: as with arrays, any “leftover” m em bers are given
                                      0 as their initial value. In particular, the bytes in a leftover character array will he
                                      zero, making it represent the empty string.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                          <%?E>       D e s ig n a t e d I n itia liz e r s

                                      C 99's designated initializers, which were discussed in Section 8.1 in the context of
                                      arrays, can also be used with structures. Consider the initializer for p a r t l shown
                                      in the previous example:

                                      {528,       "Disk drive", 10}

                                      A designated initializer would look similar, but with each value labeled by the
                                      name of the m em ber that il initializes:

                                      {.number = 528,                .name = "Disk drive",                     .on_hand = 10}

                                                                                                        designator. (Des­
                                      The com bination of the period and lhc m em ber name is called a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      ignators for array elements have a different fonn.)
                                           Designated initializers have several advantages. For one. they’re easier to read
                                      and check for correctness, because the reader can clearly see the correspondence
                                      between lhc members of the structure and the values listed in thc initializer.
                                      Another is that thc values in the initializer don’t have to be placed in thc same
                                      order that thc members are listed in the structure. Our example initializer could bc
                                      written as follows:

                                      {.on_hand = 10,                .name = "Disk drive",                     .number = 528}

                                      Since the order doesn’t matter, the program m er doesn’t have to rem em ber the
                                      order in which the mem bers were originally declared. Moreover, the order of
                                      the m em bers can be chang^wed in t^h*e futu^**re without affecting designated initializ-
                                      ers.
                                                                                                                  16.1                                            381onmlkjihgfedcbaZYX
                                                                                                                             S tru c tu re V a r ia b le s kjihgfedcbaZYXWVUTSRQPONMLKJ


                                                            Not all values lisiecl in a designated initializer need be prefixed by a designa­
                                                      tor. (This is true for arrav* s as well, as we saw in Section 8 .l.) C onsider the follow-
                                                      ing example:

                                                      { .n u m b e r = 5 2 8 ,     " D is k d r i v e " ,   .o n _ h a n d   = 10}

                                                      The value " D i s k d r i v e " doesn’t have a designator, so the com piler assum es
                                                      that it initializes the member that follows n u m b e r in the structure. Any m em bers           **


                                                      that the initializer fails to account for arc set to zero.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                      O p e r a tio n s o n S tr u c tu r e s

                                                      Since the most com m on array operation is subscripting— selecting an elem ent by
                                                      position— it’s not surprising that the most com m on operation on a structure is
                                                      selecting one o f its members. Structure m em bers are accessed by name, though,
                                                      not by position.
                                                           To access a mem ber within a structure, we write the name o fth e structure first,
                                                      then a period, then the name o fth e member. For example, the following statem ents
                                                      will display the values o f p a r t l ’s members:
                                                      p r i n t f ( " P a r t n u m b e r : % d \n " , p a r t l . n u m b e r ) ;
                                                      p r i n t f ( " P a r t n am e: % s \n " , p a r t l . n a m e ) ;
                                                      p r i n t f ( " Q u a n t i t y o n h a n d : % d \n " , p a r t l . o n h a n d ) ;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              iv a iu e s > < 2           The m em bers of a structure are lvalues, so they can appear on the left side of
                                                      an assignment o r a s the operand in an increm ent ordecrem ent expression:
                                                      p a rtl.n u m b e r = 2 58;                     /* c h a n g e s p a r t l ' s p a r t num ber *
                                                      p a r tl.o n _ h a n d + + ; /*        in c r e m e n ts p a r t l ' s q u a n t i t y on h a n d * /

                                                           The period that we use to access a structure m em ber is actually a C operator. It
t a b ! e o io p e r a io r s > ^ p p e n c f / x 4   has the same precedence as the postfix + 4 - and - - operators, so it takes precedence
                                                      over nearly all other operators. Consider the following example:
                                                      sc a n f("% d ",     & p a r tl.o n _ h a n d ) ;

                                                      The expression & p a r t l . o n _ h a n d contains two operators (& and .). T he .
                                                      operator takes precedence over the & operator, so & com putes the address of
                                                      p a r t l .o n _ h a n d . as we wished.
                                                           The other m ajor structure operation is assignm ent:
                                                      p a rt2   = p a rtl;

                                                      The effect of this statement is to copy p a r t l . n u m b e r into p a r t 2 .n u m b e r ,
                                                      p a r t l . n am e into p a r t 2 . n am e, and so on.
                                                           Since arrays can’t be copied using the = operator, it com es as som ething o f a
                                                      surprise to discover that structures can. It’s even more surprising when you con­
                                                      sider that an array embedded within a structure is copied when the enclosing struc­
                                                      ture is copied. Some programmers exploit this property by creating '“dum m y”
                                                      structures to enclose arrays that will be copicd later:
3 8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 16    S tru c tu re s , U n io n s , a n d E n u m e r a tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                   struct { int a[10] ; } al, a2;

                                                   al - a2;        /* legal, since al and a2 are structures */onmlkjihgfedcbaZYXW

                                                                                                                   co m p a tib le types. Two
                                                        T he = operator can bc used only with structures of cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                   structures declared at the same time (as p a r t l and p a r t 2 were) are compatible.
                                                   As w e’ ll see in the next section, structures declared using the same “structure tag”
                                                   or the sam e type name are also com patible.
                                                        O ther than assignment. C provides no operations on entire structures. In par­
                                                   ticular, we can’t use the == and != operators to test wheiher two structures are dc
                                    Q&A            equal or not equal.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                1 6 .2             S tru c tu re T y p e s

                                                   Although the previous section showed how to declare structure variables, it failed
                                                   to discuss an important issue: naming structure types. Suppose that a program
                                                   needs to declare several structure variables with identical members. [fa ll the vari­
                                                   ables can bc declared at one time, there’s no problem. But if we need to declare the
                                                   variables at different points in the program , then life becomes more difficult. Ifw e
                                                   write

                                                   struct {
                                                     int number;
                                                     char name[NAME_LEN+1];
                                                     int on_hand;
                                                   } partl;

                                                   in one place and

                                                   struct {
                                                     int number;
                                                     char name[NAME_LEN+l];
                                                     int on_hand;
                                                   } parc2;

                                                   in another, w e’ll quickly run into problem s. Repeating the structure information
                                                   will bloat the program. Changing the program later will be risky, since we can’l
                                                   easily guarantee that the declarations will remain consistent.
                                                         But those aren’t the biggest problem s. According to the rules of C, p a r t l
                                                   and p a r t 2 do n ’t have com patible types. As a result, p a r t l can’t be assigned to
                                                   p a r t 2 , and vice versa. Also, since wc don’t have a name for the type o f p a r t l or
                                                   p a r t 2 , we can’t use them as argum ents in function calls.
                                                         To avoid these difficulties, we need to be able to define a name that represenb
                                                   a type o f structure, not a particular structure variable. As it turns out. C provides
                                    Q&A            two ways to name structures: we can either declare a “structure tag” or use
              t y p e d e f in it io n s > 7 . 5   t y p e d e f to define a type name.
                                                                   1 6 .2                                     3 8 3 dcbaZYXWVUTSRQPONML
                                                                             S tr u c tu re T y p e s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC


D e c la r i n g a S t r u c t u r e T a g onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

  stru ctu re tag is a name used to identify a particular kind of structure. The fol­
A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
lowing example declares a structure tag named p a r t :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

struct part {
  int number;
  char name[NAME_LEN+1];
  int on_hand;


Noticc the semicolon that follows the right brace— it must be present to term inate
thc declaration.


Accidentally omitting the semicolon at the end o f a structure declaration can cause
surprising errors. Consider the following example:
struct part {
  int number;
  char name[NAME_LEN^1];
  int on_hand;
}              /*** WRONG: semicolon missing ***/

f (void)


    return 0;               /* error detected at this line */
}

Thc programmer failed to specify the return type o fth e function f (a bit of sloppy
programming). Since the preceding structure declaration w asn’t terminated prop­
erly. the compiler assumes that f returns a value of type s t r u c t p a r t . The error
won’t be detected until the compiler reaches the first r e t u r n statement in the
function. The result: a cryptic error message.


      Once w e’ve created the p a r t tag. we can use it to declare variables:

struct part partl, part2;

Unfortunately, we can't abbreviate this declaration by dropping the word s t r u c t :

part partl, part2;                     /*** WRONG ***/

p a r t isn’t a type name: without the word s t r u c t , it is meaningless.
      Since structure tags aren't recognized unless preceded by the word s t r u c t .
they don't conflict with other names used Ln a program. It would bc perfectly legal
(although more than a little confusing) to have a variable named p a r t .
      Incidentally, the declaration o f a structure tag can be com bined with the decla­
ration of structure variables:
            C h a p te r 16
3 8 4 ZYXWVUTSRQPONMLKJIHGFEDCBAS tru c tu re s , U n io n s , a n d E n u m e ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     struct part {
                                       int number;
                                       char name[NAME LEN+1];
                                       int on_hand;
                                     } partl, part2;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     Here, \ve*ve declared a structure tag named p a r t (making it possible to use p a r t
                                     later to declare more variables) as well as variables named p a r t l and p a r t 2 .
                                          All structures declared to have type s t r u c t p a r t are compatible with one
                                     another:

                                     struct part partl = {528,                        "Disk drive",              10};
                                     struct part part2;

                                     part2 = partl;                  /* legal; both parts have the same type */aZYXWV


                                     D e fin in g a S tr u c tu r e T y p e
                                     As an alternative to declaring a structure tag. we can usc t y p e d e f to define a
                                     genuine type name. For example, we could define a type named P a r t in the fol­
                                     lowing way:

                                     typedef struct {
                                       int number;
                                       char name[NAME_LEN+l];
                                       int on_hand;
                                     } Part;

                                     Note that the name of the type. P a r t , must come at the end. not after the word
                                     s tru c t.
                                            We can use P a r t in the same way as the built-in types. For example, we
                                     mi<4»iht use it to declare variables:

                                     Part partl, part2;

                                      Since P a r t is a t y p e d e f name, we’re not allowed to write s t r u c t P a r t . All
                                      P a r t variables, regardless ofw hcre thcy’rc declared, are compatible.
                                           When it comes time to name a structure, we can usually choose either 10
                                      declare a structure tag or to use t y p e d e f . However, as we’ll see later, declaring a
                          Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                 iinkediists>/7.5 structure tag is mandatory when the structure is to be used in a linked list. I’ll use
                                     structure tags rather than t y p e d e f names in most o fm y examples.


                                     S tr u c tu r e s a s A r g u m e n ts a n d R e tu r n V a lu e s
                                     Functions mavw have str^.uctures as arauments and return values. L et’s look al two
                                     examples. Our first function, when given a p a r t structure as its argument, prints
                                     thc structure's members:

                                     void Drint_part(struct oart p)
                                     {
                                       printfPPart number: %d\n", p.number);
                                                                     1 6 .2                                       3 8 5 kjihgfedcbaZYXWVUTS
                                                                              S t r u c t u r e T y p e s hgfedcbaZYXWVUTSRQPONMLKJIHGFED


                  printf("Part name: %s\n", p.name);
                  printf("Quantity on hand: %d\n", p.on_hand);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                Here’s how p r i n t _ p a r t might be called:

                print_parc(parcl) ;

                Our second function returns a p a r t structure that it constructs from its arguments:

                struct part build_part(int number, const char *name,
                                       int on_hand)

                   struct part p;

                  p.number = number;
                  strcpy(p.name, name);
                  p.on_hand = on_hand;
                  return p;


                Notice that it*s legal for b u i l d _ p a r t ' s parameters to have names that match the
                members o fth e p a r t structure, since thc structure has its own name space. Here's
                how b u i l d _ p a r t might be called:

                partl = build_part(528,            "Disk drive”, 10);

                      Passing a structure to a function and returning a structure from a function both
                require making a copy ofall members in the structure. As a result, these operations
                impose a fair amount of overhead on a program, especially if the structure is large.
                                                                                  p o in ter to a structure
                To avoid this overhead, it's sometimes advisable to pass a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                instead ofpassing the structure itself. Similarly, we might have a function return a
                pointer to a structure instead of returning an actual structure. Section 17.5 gives
                examples of functions that have a pointer to a structure as an argument and/or
                return a pointer to a structure.
                      There are other reasons to avoid copying structures besides efficiency. For
FiLEtypG>22.7   example, the < s t d i o . h > headerdefines a type named F IL E , which is typically a
                structure. Each F IL E structure stores information about the state of an open file
                and therefore must be unique in a program. Every function in < s t d i o . h > that
                opens a file returns a pointer to a F IL E structure, and every function that performs
                an operation on an open file requires a F IL E pointer as an argument.
                      On occasion, we may want to initialize a structure variable inside a function to
                match another structure, possibly supplied as a parameter to the function. In thc
                following example, thc initializer f o r p a r t 2 is the parameter passed to the f func­
                tion:

                void f(struct part partl>

                   struct part part2 = partl;
            C h a p te r 16
3 8 6 ZYXWVUTSRQPONMLKJIHGFEDCBA S tru c tu re s , U n io n s , a n d E n u m e r a t io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                     C permits initializers of this kind, provided that the structure w e’re initializing
  a u to m a tic s to r a g e d u r a tio n > w ./   ( p a r t 2 , in this case) has automatic storage duration (it’s local to a function and
                                                     hasn't been declared s t a t i c ) . The initializer can be any expression of the proper
                                                     type, including a function call that returns a structure.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       <^>           C o m p o u n d L ite r a ls
                                                     Section 9.3 introduced the C99 feature known as the cRQPONMLKJIHGFEDCBA
                                                                                                                     o m p o u n d l i t e r a l . In that sec­

                                                     tion, compound literals were used to create unnamed arrays, usually for the pur­
                                                     pose of passing the array to a function. A compound literal can also bc used to
                                                     create a structure “on the flv«*,” without first storingk^> ui,-t in a variable. The resulting
                                                     structure can be passed as a parameter, returned by a function, or assigned to a
                                                     variable. Let’s look at a couple ofcxam ples.
                                                          First, we can use a compound literal to create a structure that will be passed to
                                                     a function. For example, we could call the p r i n t _ p a r t function as follows:kjihgfedc

                                                     print_part((struct part) {528, "Disk drive", 10});

                                                     The compound literal (shown in bold) creates a p a r t structure containing the
                                                     members 528, " D i s k d r i v e ” , and 10, in that order. This structure is then passed
                                                     to p r i n t _ p a r t , which displays it.
                                                          H ere’s how a compound literal might be assigned to a variable:

                                                     pdiLl = (sLiuuL paiL)                 {528,     "Diak drive”, 10};

                                                     This statem ent resembles a declaration containing4^ an initializer, but it’s not the
                                                     same— initializers can appear only in declarations, not in statements such as this
                                                     one.
                                                           In general, a compound literal consists o f a type name within parentheses, fol­
                                                     lowed by a set of values enclosed by braces. In the case o f a compound literal thai
                                                     represents a structure, the type name can be a structure tag preceded by the word
                                                     s t r u c t — as in our exam ples— or a t y p e d e f name. A compound literal may
                                                     contain designators,just like a designated initializer:

                                                     print_part((struct part)                   {.on__hand = 10,
                                                                                                 .name = "Disk drive",
                                                                                                 .number = 528});

                                                     A compound literal may fail to provide full initialization, in which case any unini­
                                                     tialized members default to zero.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                    1 6 .3           N e s te d A rra y s a n d S tru c tu re s

                                                     Structures and arrays can be combined without restriction. Arrays may have struc­
                                                     tures as their elements, and structures may contain arrays and structures as mem­
                                                     bers. W c’vc already seen an example of an array nested inside a structure (the
                                     1 6 .3                                                              387
                                                N e s t e d A rra y s a n d S t r u c tu r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


nam e member of the p a r t structure). Let’s explore thc other possibilities: struc­
tures whose members are structures and arrays whose elements are structures.dcbaZYXWVUTSRQPONMLKJIH


N e s te d S tr u c t u r e s

Nesting one kind of structure inside another is often useful. For example, suppose
that we’ve declared the following structure, which can store a person's first name,
middle initial, and last name:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

struct person_name {
  char first[FIRST_NAME_LEN+l];
  char middle_initial;
  char last[LAST_NAME_LEN+l];


We can use the p e r s o n _ n a m e structure as part o fa larger structure:

struct student {
  struct person_name name;
  int id, age;
  char sex;
} studentl, student2;

Accessing s t u d e n t l ’s first name, middle initial, or last name requires two appli­
cations of the . operator:

strcpy(studentl.name.first,                   "Fred");

       One advantage of making n am e a structure (instead of having f i r s t ,
m i d d l e _ i n i t i a l . and l a s t be members of the s t u d e n t structure) is that
we can more easily treat names as units of data. For example, if we were to
write a function that displays a name, we could pass it just onc argument— a
p e r s o n _ n a m e structure— instead o fth ree arguments:
display_name(studentl.name);

Likewise, copying the information from a p e r s o n _ n a m e structure to the n am e
                                                       e^nment instead of three:
member o fa s t u d e n t structure would take one assi<

struct person_name new_name;

studentl.name = new_name;


A r r a y s o f S tr u c t u r e s

One of the most common combinations of arrays and structures is an array whose
elements are structures. An array of this kind can serve as a simple database. For
example, the following array o f p a r t structures is capable of storing information
about J00 parts:

struct part inventory[100];
3 8 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 16      S tr u c tu re s , U n io n s , a n d E n u m e r a tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            To access onc ol'the parts in the array, w e'd use subscripting. To print the part
                                       stored in position i , for example, we could write kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       print_part(inventory[i] );

                                             Accessing a m em ber within a p a r t structure requires a com bination o f sub­
                                       scripting and member selection. To assign 883 to the n u m b e r m em ber of
                                       i n v e n t o r y [ i ] . wc could write

                                       inventory[i].number = 883;

                                       Accessing a single character in a part name requires subscripting (to select a par­
                                       ticular part), followed by selection (to select the n am e member), followed by sub­
                                       scripting (to select a character within the part name). To change the nam e stored iit
                                       i n v e n t o r y [ i ] to an em pty siring, we could write

                                       inventory[i].name[0] = '\0';dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       I n it ia liz in g a n A r r a y o f S t r u c t u r e s

                                       Initializing an array of structures is done in much the same way as initializing a
                                       multidim ensional array. Each structure has its own brace-enclosed initializer: the
                                       initializer for lhc array sim ply wraps another set o fb raccs around the structure ini­
                                       tializers.
                                             Onc reason for initializing an array ofstructurcs is that w c’re planning lo treat
                                       it as a database of inform ation that w on't change during program execution. For
                                       exam ple, suppose that w e're working on a program that will need access to the
                                       counlrycodcs used when making international ielcphonccalls. First, w e ’ll set upa
                                       structure that can store the name o f a country along witli its code:

                                       struct dialing_code {
                                          char *country;
                                          int code;
                                       };
                                       Note that c o u n t r y is a pointer, not an array ofcharacters. Thal coukl be a prob­
                                       lem ifw e were planning to use d i a l i n g _ c o d e structures as variables, but we're
                                       not. When we initialize a d i a l i n g _ c o d e structure, c o u n t r y will end up
                                       pointing to a string literal.
                                            Next, w c’ll declare an array of these structures and initialize it to contain the
                                       codes for some o fth e w orld’s most populous nations:

                                       const struct dialing__code country_codes[] =
                                           "Argentina",             54'cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                               "Bangladesh",         880'
                                                                                                      i                                  ।

                                           "Brazil",                55        ’"Burma (Myanmar)", 95^ .   ■                                  »

                                           "China",                 86         "Colombia",            57^
                                                                                                      t                                  /

                                           "Congo, Dem. Rep. of", 243         ’’’Egypt",              20
                                                                                                      t                                  /

                                           "Ethiopia",             251         "France",          >   331
                                                                                                      /
                                                                                                          I
                                                                                                                                         /

                                           "Germany",               49         "India",           * , 91' 1
                                                                                                                                         /
                                                                    1 6 .3   N e s te d A rr a y s a n d S tr u c tu r e s hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                                    3 8 9 kjihgfedcbaZYXWVUTS


                        [”Indonesia",                                    62},       "Iran",                                98},
                        ["Italy” ,                                       39},       "Japan” ,                              81},
                        [’’M e x i c o ” ,                               52),       "Nigeria",                            234},
                        ’"Pakistan” ,                                    92},       "Philippines",                         63},
                         "Poland” ,                                      48},     ["Russia” ,                               7},
                        ["South Africa",                                 27},       "South Korea",                         82} ,
                        ["S p a i n ” ,                                  34},     ["S u d a n ” ,                         249} ,
                        [’’Tha i l a n d " ,                             66},     • "Turkey” ,                             90},
                         "Ukraine” ,                                    380},     • "United Kingdom",                      44},
                         "United S t a t e s " ,                          1}.     ["Vietnam",                              84 } } ;onmlkjihgfedcbaZYXWVUTSRQ

                 The inner braces around each structure value are optional. As a matter of style,
                 however. I prefer not to omit them.
                     Because arrays of structures (and structures containing arrays) are so com ­
                 mon, C99's designated initializers allow an item to have more than one designator.
                 Suppose that we want to initialize the i n v e n t o r y array to contain a single part.
                 The part number is 528 and the quantity on hand is 10, but the name is to be left
                 empty for now:

                  struct part inventory[100] =
                    { [0] .number = 52 8, [0] .on_hand = 10,                                   [0] .n a m e [0] = '\0 '} ;

                 The first two items in the list use two designators (one to select array element 0—
                 a p a r t structure— and one to select a member within the structure). The last item
                 uses three designators: one to select an array element, one to select the nam e
                 member within that element, and one to select element 0 o fn a m e .


                  M a in ta in in g a P a r ts D a ta b a s e
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                 To illustrate how nested arrays and structures are used in practice, w e’ll now
                 develop a fairly long program that maintains a database of information about parts
                 stored in a warehouse. The program is built around an array of structures, with
                 each structure containing inform ation— part number, name, and quantity— about
                 one part. Our program will support the following operations:RQPONMLKJIHGFEDCBA
                                                                                               The pro­
                   ■ A d d a n e w p a r t n u m b er^ p a r t n a m e , a n d in itia l q u a n tity o n h a n d .
                        gram must print an error message if thc part is already in the database or if the
                        database is full.
                   ■ G iv e n a p a r t n u m b e r , p r in t th e n a m e o f th e p a r t a n d th e c u r r e n t q u a n tity o n
                       h a n d . The program must print an error message if the part number isn’t in the
                        database.
                                                                               The program must print
                    ■ G iv e n a p a r t n u m b e r , c h a n g e th e q u a n tity o n h a n d .
                        an error message ifth e part number isn’t in the database.
                    ■ P r in t a ta b le s h o w in g a ll in fo r m a tio n      in t h e d a t a b a s e .   Parts must be dis­
                        played in the order in which they were entered.
                    ■ T e r m in a te p r o g r a m e x e c u tio n .
3 9 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 16      S tru c tu re s , U n io n s , a n d E n u m e r a tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      We’ll usc the codes i (insert), s (search), u (update), p (print), and q (quit) to rep­
                                      resent these operations. A session with the program might look like this:kjihgfedcbaZYXWVUT

                                      Enter operation code: i_
                                      Enter part number: 528
                                      Enter part name: Disk drive
                                      Enter quantity on hand: 10

                                      Enter operation code: £
                                      Enter u
                                            Vart nu^
                                                   m^^b e^^r: 528
                                                      ^^^
                                      Part name: Disk drive
                                      Quantity on hand: 10

                                      Enter operation code: s
                                      Enter part number: 914
                                      Part not found.

                                      Enter operation code: _i
                                      Enter part number: 914
                                      Enter part name: Printer cable
                                      Enter quantity on hand: j5

                                      Enter operation code: u
                                      Enter part number: 528
                                      Enter change in quantity on hand: -2

                                      Enter operation code: s
                                      Enter part number: 528
                                      Part name: Disk drive
                                      Quantity on hand: 8

                                      Enter on*•eration code: p**—
                                      Part Number     Part Name                                                      Quantity on Hand
                                          528         Disk drive                                                             8
                                          914         Printer cable                                                          5

                                      Enter oneration code: a
                                                    *•                           <_^B




                                           The program will store information about each part in a structure. We'll limit
                                      the size of the database to 100 parts, making it possible to store the structures in an
                                      array, which I’ll call i n v e n t o r y , (lf this limit proves to be loo small, we can
                                      always change it later.) To keep track of the number of parts currently stored in the
                                      array, w e'll use a variable named n u m _ p a r t s .
                                           Since this program is menu-driven, it's fairly easy to sketch the main loop:

                                       for (;;) {PONMLKJIHGFEDCBA
                                         prompt user to enter operation code;
                                         read code;
                                         switch (code) {
                                            case 'i': performinsertoperation; break;
                                            case 's': pcrfornisearclioperation; break;
                                            case ’u 1 : perform update operation; break ;
                                            case 'p': performprintoperation; break;
                                                             16.3                                                            391 kjihgfedcbaZYX
                                                                       N e s te d A rr a y s a n d S tr u c tu re s hgfedcbaZYXWVUTSRQPONMLKJIH

                     case ’q ’: terminate program;
                     de fau 1t : print error message;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                    11 will be convenient to have separate functions perform the insert, search,
              update, and print operations. Since these functions will all need access to
              i n v e n t o r y and n u m _ p a r t s , we might want to make these variables external.
              As an alternative, wc could declare the variables inside m a in , and then pass them
              to the functions as arguments. From a design standpoint, it’s usually better to make
              variables local to a function rather than making them external (see Section 10.2 if
              you’ve forgotten why). In this program, however, putting i n v e n t o r y and
              n u m _ p a r t s inside m a in would merely com plicate matters.
                    For reasons that I’ll explain later, I’vc decided to split the program into three
              files: i n v e n t o r y . c . which contains the bulk of the program; r e a d l i n e . h ,
              which contains the prototype for the r e a d _ l i n e function; and r e a d l i n e . c ,
              which contains the definition of r e a d _ l i n e . We’ll discuss the latter two files
              later in this section. For now, let’s concentrate on i n v e n t o r y , c.

inventory.c   /★    Maintains a parts database                         (array version)               */

              #include <stdio.h>
              #include ’’readline.h”

              #define NAME_LEN 25
              #define MAX_PARTS 100

              struct part {
                int number;
                char name[NAME_LEN+l];
                int on_hand;
              } inventory[MAX_PARTS] ;

              int num_parts = 0;                      /* number of parts currently stored */

              int find__part(int number);
              void insert(void);
              void search(void);
              void update(void);
              void print(void);

              !★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ * ★ ★ ★ ★ ★ ★ * ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★
                * main: Prompts the user to enter an operation code,                                                               *
                *            then calls a function to perform the requested                                                    *
                *              action. Repeats until the user enters the                                                           *
                *              command 'q*. Prints an error message if the user *
                *              enters an illegal code.                                                                             *
                *              ★ * *★ * * * * * * * * ** * ** ** * * * ★ * * * * * * * * * ★ * * * ★ * ★ ★ * ★ * * * * ★ ★ ★ * * ★ ★ ★ * * *
              int main(void)

                   char code;
3 9 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 16      S tru c tu re s . U n io n s , a n d E n u m e ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                for (;;) {
                                                  printf("Enter operation code: ”);
                                                  scanf(” %c", &code);
                                                  while (getchar() != '\n')   /* skips to end of line */

                                                        switch (code) {
                                                          case 'i': insert();
                                                                     break;
                                                          case 's ': search();
                                                                     break;
                                                          case 'u': update();
                                                                     break;
                                                          case 'p': print();
                                                                     break;
                                                          case 'q': return 0;
                                                          default:   printf("Illegal code\n");

                                                        printf(”\n”);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                        4       4   4   4   4   4   4   4   4   4   4   4   +   4   4   4   ★       4   4   4   *Ar 4   4   4   4   4   *   4   4   4   4   4   4   4   *   *   4   4   4   4   4   4   *   4   4   * 4     *Ar *   4   4   4   *   4   4   4- 4        4


                                        * find_part: Looks up a part number in the inventory                                                                                                                                                                                            *
                                        *            array. Returns the array index if the part
                                        *            number is found; otherwise, returns -1.                                                                                                                                                                                            *
                                        ★       4   4   *   4   £   4   4   *   4   4   4   4   *   4   *   4       4   *   4   *   4   4   4   4   4   4   4   4   4   4   4   4   RQPONMLKJIHGFEDCBA
                                                                                                                                                                                    -k 4 4 4 4 4 4 4 4 4 4                      4   4* 4    4   4   4   4: 4    4   *A* 4   4* 4* 4


                                      int find_part(int number)

                                                int i;

                                                for (i = 0; i < num__parts; i+ + )
                                                  if (inventory[i].number == number)
                                                    return i;
                                                return -1,-


                                        4       4r 4* 4r 4r 4r 4        4* - k 4    4r 4r 4     4 4     4r 4r 4         4   4   4r 4 : 4    4r 4    4r 4    + 4     4 r 4 4 ; 4* 4r 4       4   4r 4r 4r 4      4   4* 4    4- 4    4   4   4   4   4   4   4   4   4   4   4   4 4


                                            * insert: Prompts the user for information about a new                                                                                                                                                                                      *
                                                      part and then inserts the oart into the                                                                                                                                                                                           *
                                                      database. Prints an error message and returns                                                                                                                                                                                     *
                                                      prematurely if the part already exists or the                                                                                                                                                                                     *
                                                      database is full.                                                                                                                                                                                                             ★
                                            *   4   4   4   4   4   4   4   4* 4    4   4   4   4* 4    4       4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4       4


                                      void insert(void)

                                                int part_number;

                                                if (numj?arts == MAX_PARTS) {
                                                  printf("Database is full; can't add more parts.\n");
                                                  return;


                                                printf("Enter part number: ii
                                                scanf("%d", &part_number);
                                                1 6 .3                                                           393
                                                           N e s te d A rr a y s a n d S tr u c tu r e s kjihgfedcbaZYXWVUTSRQPONMLK


       if (find_part(part_number) >= 0) {
         printf("Part already exists.\n");
         return;


       inventory[num_parts].number = part_number;
       printf("Enter part name: ");
       read_line(inventory[num_parts] .name, NAME__LEN) ;
       printf("Enter quantity on hand: ");
       scanf("%d", &inventory[num_parts] .on_hand) ;
       num_jparts + + ;


।* * * * * * * * * * * * * * ** * * ** * * * * * * * * * * * * * *★ * * * * * * * ** * * * * * * * * * * * * * *
 * search: Prompts the user to enter a part number, then *
 *                looks up the part in the database. If the part *
 *                  exists, prints the name and quantity on hand;                                                *
 *                  if not, prints an error message.                                                             *
 *                  ★ ★ ★ *★ * 7                          ★ * ★ * ★ ★ ★ * ★ ★ ★ ± ★ * ★ ★ ★ ★ ★ ★ ★ * * ★ * * * -k ★ ★ * * + * ★ *
                                T★ ** * ★ * ★ ★ * ★ ** ^KcbaZYXWVUTSRQPONMLKJIHGFEDCBA
void search(void)

       int i, number;

       printf("Enter part number: ");
       scanf("%d", &number);
       i = find_part(number);
       if (i >= 0) {
         printf("Part name: %s\n", inventory[i].name);
         printf("Quantity on hand: %d\n", inventory[i].on_hand);
       } else
         printf("Part not found.\n");


    I **★
     ★ ★ -k * * * * ★ ★ * * * * x ★ ★ ★ ★ ★ ★ ★ ★ ★ * * ★ ★ ★ * ★ ★ ★ * * ★ ★ ★ ★ ★ ★ ★ * ★ ★ * ★ ★ * * ± * ★ ★ * ★
 * update: Prompts the user to enter a part number.                                                             *
   *                Prints an error message if the part doesn't                                                   *
 *                  exist; otherwise, prompts the user to enter                                                     *
 *                  change in quantity on hand and updates the                                                    *
 *                  database.                                                                                       *
 ★               ★ ★ * ★ ★ ★ ★ ★ ★ ★ ★ * ★ ★ * ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ * ★ * * ★ ★ ★ * * ★ * ★ ★ ★ ★ * ★ ★ ★ ★ ★ ★ ** ★ * ★ ★
void update(void)

       int i, number, change;

       printf("Enter part number: ");
       scanf("%d", &number);
       i = find_part(number);
       if (i >= 0) {
         printf("Enter change in quantity on hand:                                        ");
         scanf("%d", &change);
         inventory[i].on_hand += change;
       } else
         printf("Part not found.\n");
            C h a p te r 1 6
3 9 4 ZYXWVUTSRQPONMLKJIHGFEDCBA S tr u c tu r e s ,U n io n s ,a n d E n u m e r a tio n s PONMLKJIHGFEDCBA

                                     I* 9r ★ k vV * *• ★ 4r * ^c ★ ★ 'kk* kkkkkk kkkkkkkkkkk kkkk kk kk kk★ ★ ^k-kkkkk ^fc★ kkk★ ★ kjihg
                                      * print: Prints a listing of all parts in the database,                                     *
                                      *                  showing the part number, part name, and                               *
                                      *                     quantity on hand. Parts are printed in the                           *
                                      *                     order in which they were entered into the                             *
                                      *                     database.                                                             *
                                      kkkk kkkkkkkk ★ kk★ kkkk kk*k k★ k★ k ★ kk ★ kkk kkk+kkkk★ k kk*★ k kk ★ ★ k *kj
                                     void print(void)

                                         int i;

                                         printf("Part Number   Part Name                  ”
                                                "Quantity on Hand\n");
                                         for (i = 0; i < num_parts; i++)
                                           printf("%7d     %~25s%lld\n", inventory[i].number,
                                                  inventory[i].name, inventory[i].on_hand);onmlkjihgfedcbaZYXWVUTS


                                          In the m a in function, the format string " % c” allows s c a n f to skip over
                                     white space before reading the operation code. The space in the format string is
                                     crucial; without it. s c a n f would sometimes read the new-linc character that ter­
                                     minated a previous line of input.
                                          The program contains one function, f i n d _ p a r t . that isn’t called from
                                     m a in . This “h elp er' function helps us avoid redundant code and sim plify the
                                     more important functions. By calling f i n d _ p a r t . the i n s e r t , s e a r c h , and
                                     u p d a t e functions can locate a part in the database (or simply determ ine if the
                                     part exists).
                                          T here\sjust one detail left: the r e a d _ l i n e function, which the program uses
                                     to read the part name. Section 13.3 discussed the issues that are involved in writing
                                     such a function. Unfortunately, the version of r e a d _ l i n e in that section woni
                                     work properly in the current program. Consider what happens when the user
                                     inserts a part:

                                      Enter part number: 528
                                      Enter part name: Disk drive

                                     The user presses the Enter key after entering the part number and again after enter­
                                     ing the part name, each time leaving an invisible new-line character that the pro­
                                     gram must read. For the sake ofdiscussion. let’s pretend that these characters are
                                     visible:

                                      Enter part number: 528Q
                                      Enter part name: Disk driveQ

                                      When wc call s c a n f to read the part number, it consumes the 5. 2. and 8. but
                                      leaves the a character unread. If we try to read the part name using our original
                                      r e a d _ l i n e function, il will encounter the a character im mediately and stop
                                      reading. This problem is common when numerical input is followed by character
                                      input. Our solution will be to write a version of r e a d _ l i n e that skips white-
                                                                                                                              1 6 .3                                                                  3 9 5 onmlkjihgfedcbaZYXWVUTSR
                                                                                                                                              N e s t e d A r r a y s a n d S tr u c tu r e s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB


                                     space characters before it begins storing characters. Not only will this solve the
                                     new-line problem, but it also allows us lo avoid storing any blanks that precede the
                                     part name.
                                           Since r e a d _ l i n e is unrelated to the other functions in i n v e n t o r y . c, and
                                     since it’s potentially reusable in other programs, I ’ve decided to separate ir from
                                     i n v e n t o r y . c . The prototype for r e a d _ l i n e will go in the r e a d l i n e . h
                                     header file:

                                      #ifndef READLINE H
             r e a d l i n e . h kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     #define READLINE_H

                                     [       +. *   *   * Mr *   * *   *   * Mr * -k *   * 4 Mr *          *    * Mr * Mr *   * Mr * ★    4 * M- * * *      * *   * *   * *    * ★   *   *   Mr *   *   *   * * *   * *   *   *   * * *


                                         * read_line: Skips leading white-space characters, then   *
                                         *           reads the remainder of the innut line and   *
                                         *            stores it in str. Truncates the line if its *
                                         *            length exceeds n. Returns the number of      *
                                         *            characters stored.                           *
                                         ★                                        * ★    *   4r ★   4r ★       Mr * *   * Mr 4: Mr *   * Mr Mr Mr *   *   * *   Mr * Mr *   4r * Mr Mr Mc Mr Mr Mr Mr Mr Mr Mr Mr Mr Mr 4 ' Mr Mr 'k ^k Mr Mr Mr M' Mr Mr Mr Mr Mr Mr


                                     int read_line(char str[],                                                                   int n);

                                     #endif

                                     W e'll put the definition of r e a d _ l i n e in thc r e a d l i n e . c file:

              r e a d lin e .c       #include <ctype.h>
                                     #include <stdio.h>
                                     #include "readline.h"

                                     int read_line(char str[],                                                                   int n)

                                                int ch,                    i = 0;

                                               while                   (isspace(ch = getchar()))
                                                        t

                                                while (ch 1= ‘\ n ’ a& ch                                                         != EOF)                 {
                                                  if (i < n)




                                                str [i] = ’\ 0 • ;
                                                return i;


                                     The expression

                                     isspace(ch = getchar())

                                     controls lhc f i r s t w h i l e statement. This expression calls g e t c h a r to read ach ar-
is s p a c e iu n c t io n > 2 a 5   actcr, stores the character into c h , and then uses the i s s p a c e function to lest
                                     whether c h is a white-space character. Ifnot, the loop term inates with c h contain­
                                     ing a character that’s not white space. Section 15.3 explains why c h has type i n t
                                     instead of c h a r and why it’s good to test for EOF.
3 9 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 1 6     S tr u c tu r e s ,U n io n s ,a n d E n u m e r a tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA




                       1 6 .4        U n io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        u n io n , like a structure, consists o f one or more members, possibly o fdifferent
                                     A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     types. However, the com piler allocates only enough space for the largest of the
                                     members, which overlay each other within this space. As a result, assigning a ncw
                                     value to one member alters the values of the other members as well.
                                           To illustrate the basic properties of unions, le t’s declare a union variable, u.
                                     with two members:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     union {
                                       int i ;
                                       double d;
                                     } u;

                                     Notice how the declaration of a union closelve* resem bles a structure declaration:

                                     struct {
                                       int i;
                                       double d;
                                     } s;

                                     ln fact, the structure s and the union u differ in jtist one way: the m em bers of s are
                                     stored at different addresses in memory, while the members of u are stored at the
                                     sa m e address. H ere’s wha( s and u will look like in memory (assuming that i n t
                                     values require four bytes and d o u b l e values take eight bytes):
                                                                          16.4    U n io n s hgfedcbaZYXWVUTSRQPONMLK
                                                                                                      3 9 7 aZYXWVUTSR


        In the s structure, i and d occupy different memory locations: the total size of s is
        12 bytes. In the u union. i and d overlap ( i is really lhc first four bytes of d), so u
        occupies only eight bytes. Also, i and d have the same address.
             Members of a union arc accessed in the same way as members of a structure.
        To store the number 82 in the i member of u. wc would write kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

        u.i = 82;

        To store the value 74.8 in the d member, we would write

        u.d = 74.8;

        Sincc lhc compiler overlays storage for the members of a union, changing one
        member alters any value previously stored in any o fth e other members. Thus, if
        we store a value in u . d . any value previously stored in u . i will be lost. (If wc
        examine the value o f u . i . il will appear to be meaningless.) Similarly, changing
        u . i corrupts u . d. Because of this property, we can think of u as a place to store
                  or d. not both. (Thc structure s allows us to store i and d.)
        cither i cbaZYXWVUTSRQPONMLKJIHGFEDCBA
             The properties of unions arc almost identical to lhc properties of structures.
        We can declare union tags and union types in the same way we declare structure
        lags and types. Like structures, unions can be copicd using the = operator. passed
        to functions, and returned by functions.
              Unions can even bc initialized in a manner similar to structures. However,
        only the first member of a union can be given an initial value. For example, wc can
        initialize the i member of u to 0 in the following way:

        union {
          int i ;
          double d;
        } U = {0} ;

              Notice the presence of the braces, which are required. The expression inside the
              braces must bc constant. (The rules arc slightly different in C99. as wc'll see in
              Section l8.5.)
                       Designated initializers, a C99 feature that we've previously discussed in the
C 9 9 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
              context of arrays and structures, can also bc used with unions. A designated initial­
              izer allows us to specify which member o fa union should be initialized. For exam­
              ple. wc can initialize the d member o f u as follows:

        union {
          int i;
          double d;
        } u = {.d = 10.0};

        Onlv* one member can be initialized, but it doesn't have to be the first one.
             There are several applications for unions. Wc'll discuss two o f these now.
        Another application— viewing storage in different ways— is highly machine-
        dependent, so I'll postpone il unlil Section 20.3.
            C h a p te r 16
3 9 8 ZYXWVUTSRQPONMLKJIHGFEDCBA S tru c tu re s , U n io n s , a n d E n u m e r a tio n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     U s in g U n io n s to S a v e S p a c e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     We'll often use unions as a way to save space in structures. Suppose that wc'rc
                                     designing a structure that will contain information about an item that\s sold
                                     through a gift catalog. Thc catalog carries only thrcc kinds of merchandise: books,
                                     mugs, and shirts. Each item has a stock number and a price, as well as other infor­
                                     mation that depends on the type ofthe item:cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           Books: Title, author, number of pages
                                           Mugs: Design
                                           Shirts: Design, colors available, sizes available

                                     Our first design attempt might result in the following structure:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     struct catalog_item {
                                       int stock_number;
                                       double price;
                                       int item_type;
                                       char title[TITLE_LEN+l];
                                       char author[AUTHOR_LEN+l];
                                       int num_pages;
                                       char design[DESIGN_LEN+l];
                                       int colors;
                                       int sizes;
                                     }/

                                     The i t e m _ t y p e member would have onc of lhe values BOOK. MUG. or SHIRT.
                                     The c o l o r s and s i z e s members would store encoded combinations ofcolors
                                     and sizes.
                                          Although this structure is perfectly usable, it wastes space, since only part of
                                     the information in the structure is common to all items in the cataloak^-. If an item is
                                     a book, for example, there\s no necd to store d e s i g n , c o l o r s , and s i z e s . By
                                     putting a union inside the c a t a l o g _ i t e m structure, wc can reduce the space
                                     required by the structure. The members o fth e union will be structures, each con­
                                     taining the data that's needed for a particular kind ofcatalog item:

                                     struct catalog_item {
                                       int stock_number;
                                       double price;
                                       int item_type;
                                       union {
                                         struct {
                                           char title[TITLE_LEN+l] ;
                                           char author(AUTHOR_LEN+l];
                                           int num_pages;
                                         } book;
                                         struct {
                                           char design[DESIGN_LEN+l];
                                         } mug;
                                                                     16.4                       399
                                                                              U n io n s kjihgfedcbaZYXWVUTSRQPONMLKJI

      struct {
         char design[DESIGN_LEN+l];
         int colors;
         int sizes;
      } shirt;
    } i te m ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
} i onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

     Notice, that the union (named i t e m ) is a member o f th e c a t a l o g _ i t e m
structure, and the b o o k , mug, and s h i r t structures are m em bers of i t e m . If c is
a c a t a l o g _ i t e m structure that represents a book, we can print the book's title in
the following way:

printf("%s", c .item.book.title);

As this exam ple shows, accessing a union that’s nested inside a structure can be
awkward: to locate a book title, \vc had to specify the nam e of a structure (c). the
name of the union member of the structure ( i t e m ) , the name o f a structure meni-
b e ro f the union (b o o k ), and then thc name o fa m em b ero f tliat structure ( t i t l e ) .
      We can use the c a t a l o g _ i t e m structure to illustrate an interesting aspect o f
unions. Normally, it's not a good idea to store a value into one member of a union
and then access the data through a different member, because assigning to one
member o f a union causes thc values o fth e other m em bers to be undefined. H ow ­
ever, the C standard mentions a special case: two or more of the members of the
union are structures, and the structures begin with one or more matching members.
(These members need to bc in the same order and have com patible types, but need
not have the same name.) Ifo n c o fth e structures is currently valid, then the m atch­
ing members in the other structures will also be valid.
      Consider the union em bedded in the c a t a l o g _ i t e m structure. It contains
three structures as members, two ofw hich (mug and s h i r t ) begin with a m atch­
ing m em ber ( d e s i g n ) . Now, suppose that we assign a value to one of the
d e s i g n members:

strcpy(c.item.mug.design,                       "Cats11) ;

The d e s i g n member in the other structure will be defined and have thc same value:

printf(”%s”, c.item.shirt.design);                           /* prints "Cats” */dcbaZYXWVUTSRQPONMLKJIH


U s in g U n io n s to B u ild M ix e d D a ta S tr u c tu r e s

Unions have another im portant application: creating data structures that contain a
mixture o fd a ia ofdilTerent types. Let s say that we need an array whose elem ents
are a m ixture of i n t and d o u b l e values. Since the elem ents o fa n array must be
of the same type, it seem s im possible to create such an array. Using unions,
though, it's relatively easy. First, we define a union type whose members represent
thc different kinds o f data to bc stored in the array:
400 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 16      S tru c tu re s , U n io n s , a n d E n u m e ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     typedef union {
                                       int i ;
                                       double d;
                                     } Number;

                                     Next, wc create an array• whose elements are N um ber values:
                                     Number number_array[1000];

                                     Each element of n u m b e r_ _ a rra y is a N um ber union. A N um ber union can
                                     store either an i n t value or a d o u b l e value, making it possible to store a mixture
                                     of i n t and d o u b l e values in n u m b e r _ a r r a y . For example, suppose that we
                                     want element 0 o f n u m b e r _ _ a r r a y to store 5, while clement 1 stores 8.395. The
                                     following assignments will have the desired effect:
                                     number_array[0].i = 5;
                                     number_array[l].d = 8.395;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     A d d in g a “ T a g F ie ld ” to a U n io n

                                     Unions suffer from a major problem: there’s no easy way to tell which memberof
                                     a union was last changed and therefore contains a meaningful value. Consider the
                                     problem of writing a function that displays the value currently stored in a Number
                                     union. This function migoht have the followingo outline:

                                     void print_number(Number n)

                                                PONMLKJIHGFEDCBAinteger)
                                         if (n conlainsan
                                           printf("%d”, n .i);
                                         else
                                           printf("%g", n .d);


                                     Unfortunately, there's no way for p rin t_ _ _ n u m b er to determine whether n con­
                                     tains an integer or a floating-point number.
                                          In order to keep track of this information, we can embed the union within a
                                     structure that has one other member: a “tag field" or "discrim inant" whose pur­
                                     pose is to remind us what’s currently stored in the union. In the c a t a l o g _ i t e m
                                     structure discussed earlier in this section, i t e m _ t y p e served this purpose.
                                          Let’s convert the N um ber type into a structure with an embedded union:

                                     #define INT_KIND 0
                                     #define DOUBLE_KIND 1

                                     typedef struct {
                                       int kind;   /* tag field */
                                       union {
                                         int i ;
                                         double d;
                                       } u;
                                     } Number;
                                                                 1 6 .5                                   401
                                                                          E n u m e r a tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFED


         N u m b er has two members, k i n d and u. The value of k i n d will be either
         INT_K IN D or DOUBLE_KIND.
              Each time we assign a value to a member of u , we’ll also change k i n d to
         remind us which member o f u we modified. For example, if n is a N u m b e r vari­
         able, an assignment to the i in e m b e ro fu would have the following appearance:kjihgfedcbaZYXWVUTSRQPONMLK

         n.kind = INT_KIND;
         n.u.i = 82;

         Notice that assigning to i requires that we first select the u member o f n , then the
         i member o fu .
                W hen we need to retrieve the number stored in a N u m b e r variable, k i n d will
         tell us which member of the union was the last to be assigned a value. The
         p r i n t _ n u m b e r function can take advantage o fth is capability:

         void print_number(Number n)

            if (n.kind == INT_KIND)
              printf(”%d”, n.u.i);
            else
              printf("%g", n.u.d);hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



         lt’s the program ’s responsibility to change the tag field each time an assignment is
 A       made to a member of the union.aZYXWVUTSRQPONMLKJIHGFEDCBA




1 6 .5   E n u m e r a t io n s

         In many programs, w e’ll need variables that have only a small set of meaningful
         values. A Boolean variable, for example, should have only two possible values:
         “true” and “false.” A variable lhai stores the suit of a playing card should have only
         four potential values: “clubs,” “diamonds,” “hearts,” and “spades.” The obvious
         way to deal with such a variable is to declare it as an integer and have a set of codes
         that represent the possible values of the variable:

         int s;       /* s will store a suit */
         •••
         s = 2;       /* 2 represents "hearts” */

         Although this technique works, it leaves much to be desired. Someone reading the
         program can’t tell that s has only four possible values, and the significance of 2
         isn’t immediately apparent.
              Using macros to define a suit “type” and names for the various suits is a step
         in the right direction:
4 0 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p t e r 16    S tr u c tu re s , U n io n s , a n d E n u m e ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     #define         SUIT     int
                                     #define         CLUBS    0
                                     #define         DIAMONDS 1
                                     #define         HEARTS   2
                                     #define         SPADES   3onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     Our previous exam ple now becomes easier to read:

                                     SUIT S;

                                     S = HEARTS;

                                     This technique is an improvement, but it’s still not the best solution. T here's no
                                     indication to someone reading the program that the macros represent values o f the
                                     same “type.” If the number of possible values is more than a few, defining a sepa­
                                     rate macro for each will be tedious. Moreover, the names w e’ve defined— CLUBS,
                                     DIAMONDS, HEARTS, and SPADES— will be removed by the preprocessor, so
                                     they w on’t be available during debugging.
                                           C provides a special kind of type designed specifically for variables that have
                                                                                   e n u m e r a te d type is a type whose values are
                                     a small num ber of possible values. An cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     listed (“enum erated”) by the programmer, who must create a name (an e n u m e r a ­
                                     tio n c o n sta n t) for each o f the values. The following exam ple enum erates the val­
                                     ues (CLUBS, DIAMONDS, HEARTS, and SPADES) that can be assigned to the
                                     variables s l and s 2 :

                                     enum {CLUBS, DIAMONDS, HEARTS, SPADES} sl, s2;

                                     Although enum erations have little in com m on with structures and unions, they’re
                                     declared in a sim ilar way. Unlike the members of a structure or union, however, the
                                     names ofenum eration constants must be different from other identifiers declared
                                     in the enclosing scope.
                                            Enum eration constants are sim ilar to constants created with the # d e f i n e
                                     directive, but they're not equivalent. For one thing, enum eration constants are sub­
                                     je c t to C ’s scope rules: ifa n enum eration is declared inside a function, its constants
                                     w on’t be visible outside the function.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     E n u m e r a t io n T a g s a n d T y p e N a m e s

                                     W e’ll often need to create names for enum erations, for the same reasons that we
                                     name structures and unions. As with structures and unions, there are two ways to
                                     name an enum eration: by declaring a tag or by using t y p e d e f to create a genuine
                                     type name.
                                          Enumeration tags resemble structure and union tags. To define the tag s u i t ,
                                     for exam ple, we could write

                                     enum suit {CLUBS, DIAMONDS, HEARTS, SPADES};

                                     s u i t variables would be declared in the following way:

                                     enum suit sl, s2;
                                                        1 6 .5                                403KJIHGFEDCBA
                                                                 E n u m e ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJI


As an alter native, we could use t y p e d e f to make S u i t a type name:

typedef enum {CLUBS, DIAMONDS, HEARTS, SPADES} Suit;
Suit sl, s2;

    Tn C8 9 , using t y p e d e f to name an enumer ation is an excellen t way to create
a Boolean type:

typedef enum {FALSE, TRUE} Bool;

C9 9 has a built-in Boolean type, o f cour se, so there's no need for a C9 9 pr ogr am­
mer to define a B o o l type in this way.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


E n u m e r a t io n s a s I n te g e r s
Behind the scenes, C treats enumeration var iables and constants as integer s. By
default, the com p iler assigns the integers 0, 1,2 , ... to the constants in a par ticular
enumeration. In our s u i t enumer ation, for exam p le, CLUBS, DIAMONDS,
HEARTS, and SP ADES represent 0, l. 2, and 3, r esp ectively.
       We’re free to choose differ ent values for enumeration constants if we like.
Le t ’s say that we want CLUBS, DIAMONDS, HEARTS, and SP ADES to stand for I,
2, 3, and 4. We can sp ecify these numbers when declar in g the enumeration:

enum suit {CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4};

The values ofen u m er ation constants may be arbitrary integers, listed in no par ticu­
lar order:

enum dept {RESEARCH = 20, PRODUCTION = 10, SALES = 25};

lt ’s even legal for two or more enumeration constants lo have the sam e value.
       When no value is specified for an enumeration constant, its value is one
greater than the value o ft h e previous constant. (The fir st enumeration constant has
the value 0 by default.) In the follow in g enum er ation, BLACK has the value 0,
LT _GRAY is 7. DK_GRAY is 8, and WHITE is 15:

enum EGA_colors {BLACK, LT_GRAY = 7, DK_GRAY, WHITE = lS};

     Sin ce enumeration values are nothing but thinly disguised integer s, C allow s
us to m ix them with or dinary integers:

int i ;
enum {CLUBS, DIAMONDS, HEARTS, SPADES} s;

                     /*       iis now 1
i = DIAMONDS;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA     */
S = 0 ;              /*       sis now 0 (CLUBS)     */
S++ ;                /*       sis now 1 (DIAMONDS) */
i = S + 2 ;          /*       iis now 3             */

The com piler treats s as a var iable o f some integer type; CLUBS, DIAMONDS,
HEARTS, and SP ADES ar eju st names for the integer s 0, 1, 2, and 3.
404 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r1 6     S t r u c t u r e s , U n io n s , a n d E n u m e r a t io n s




                                      Althougv7h it’s convenient to be able to use an enumeration value as oan integer, it’s
                                      dangerous to use an integer as an enumeration value. For example, we might acci­
                                      dentally store the num ber4— which doesn't correspond to any suit— into s.dcbaZYXWVUTSRQPONM




                                      U s i n g E n u m e r a ti o n s to D e c la r e “ T a g F ie ld s ”

                                      Enumerations are perfect for solving a problem that we encountered in Section
                                      l6.4: determining which member of a union was the last to be assigned a value. In
                                      the N u m b er structure, for example, we can make the k i n d member an enum era­
                                      tion instead of an i n t :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      typedef struct {
                                        enum {lNT_KIND, DOUBLE_KIND} kind;
                                        union {
                                          int i ;
                                          double d;
                                        } u;
                                      } Number;

                                     The new structure is used in exactly the same way as the old one. The advantages
                                     are that w e’ve done away with the INT_KIND and DOUBLE_KIND macros
                                     (they’re now enumeration constants), and w e’ve clarified the meaning o f k i n d —
                                     it’s now obvious that k i n d has only two possible values: INT_KIN D and
                                     DOUBLE_KIND.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                      Q & A

                             Q:       W h e n I tr ie d u s in g th e s i z e o f o p e r a to r to d e te r m in e th e n u m b e r o f b y te s in
                                     a s tr u c tu r e , I g o t a n u m b e r th a t w a s la r g e r th a n th e s iz e s o f th e m e m b e r s
                                     a d d e d to g e th e r . H o w c a n th is b e ?
                              A:     Let's look at an example:

                                      struct {
                                        char a;
                                        int b;
                                      } s;

                                     If c h a r values occupy one byte and i n t values occupy four bytes, how large is
                                     s ? The obvious answer— five bytes— may not be the correct one. Some computers
                                     require that the address ofcertain data items be a multiple ofsom e number ofbytes
                                     (typically two, four, or eight, depending on the item’s type). To satisfy this require­
                                     ment, a compiler will “align” the members of a structure by leaving “holes”
                                     (unused bytes) between adjacent members. If we assume that data items must
                                                                                                  Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                                4 0 5 onmlkjihgfedcbaZYXWVUT


     begin on a multiple of four bytes, the a member of the s structure will be followed
     by a three-byte hole. As a result, s i z e o f ( s ) will be 8.
          By the way, a structure can have a hole at the end, as well as holes between
     members. For example, the structure

     s tru c t {
        in t a ;
        char b;
     } S/'
     might have a three-byte hole after the b member.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q:   C a n th e r e b e a “ h o le ” at th e b e g in n in g o f a s tr u c tu r e ?
A:   No. The C standard specifies that holes are allowed only betw   een members or after
                                                              cbaZYXWVUTSRQPONMLKJIHGFEDCBA

     the last member. One consequence is that a pointer to the first member of a struc­
     ture is guaranteed to be lhc same as a pointer to the entire structure. (Note, how­
     ever. that the two pointers won’t have the same type.)

Q:   W h y is n ’t it leg a l to u s e th e = = o p e r a to r to te st w h e th e r tw o s t r u c t u r e s a r e
     e q u a l? [p . 3 8 2 ]
A:   This operation was left out o fC because there’s no way to implement it that would
     be consistent with the language's philosophy. Comparing structure members one
     by one would be too inefficient. Comparing all bytes in the structures would be
     better (many computers have special instructions that can perform such a compari­
     son rapidly). If the structures contain holes, however, comparing bytes could yield
     an incorrect answer; even ifcorresponding members have identical values, leftover
     data stored in the holes might be different. The problem could be solved by having
     the compiler ensure that holes always contain the same value (zero, say). Initializ­
     ing holes would impose a performance penalty on all programs that use structures,
     however, so it’s not feasible.

Q:   W h y d o e s C p r o v id e tw o w a y s to n a m e s tr u c t u r e ty p e s (ta g s a n d t y p e d e f
     n a m e s)? [p. 3 8 2 ]
A:   C originally lacked t y p e d e f , so tags were the only technique available for nam­
     ing structure types. When t y p e d e f was added, il was too late to remove tags.
     Besides, a tag is still necessary when a member of a structure points to a structure
     of the same type (see the n o d e structure of Section 17.5).

Q:   C a n a s tr u c tu r e h a v e b o th a ta g a n d a t y p e d e f n a m e ? [p . 3 8 4 ]
A:   Yes. In fact, the tag and the t y p e d e f name can even be the same, although that’s
     not required:

     ty p e d e f s t r u c t p a r t {
        i n t n u m b e r;
        c h a r n a m e [N M E _L E N + 1] ;
        in t on_hand;
     } p a rt;
            C h a p te r 16    S tr u c tu r e s , U n io n s , a n d E n u m e r a t io n s
4 0 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                           Q:       H o w c a n I s h a r e a s tr u c tu r e ty p e a m o n g s e v e r a l file s in a p r o g r a m ? onmlkjihgfedcbaZYXWVUTSRQPON
                                            A:      Put a declaration of the structure tag (or a t y p e d e f , if you prefer) in a header file,
                                                    then include the header file where the structure is needed. To share the p a r t struc­
                                                    ture, for example, w e’d put the following lines in a header file:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                    struct part {
                                                      int number;
                                                      char name[NAME_LEN+1] ;
                                                      int on_hand;
                                                    ]   /




                                                    Notice that w e’re declaring only the structure /flg, not variables of this type.
                                                          Incidentally, a header file that contains a declaration of a structure tag or struc- hgfedcbaZYX
      p r o te c tin g h e a d e r fiie s > /5 .2   ture type may need protection against multiple inclusion. Declaring a tag or
                                                    t y p e d e f name twice in the same file is an error. Sim ilar remarks apply to unions
                                                    and enumerations.

                                           Q:       I f I in c lu d e th e d e c la r a tio n o f th e p a r t s tr u c tu r e in to tw o d iff e r e n t file s , w ill
                                                    p a r t v a r ia b le s in o n e file b e o f th e s a m e ty p e a s p a r t v a r i a b le s in th e o t h e r
                                                    file ?
                                                    Technically, no. However, the C standard says that the p a r t variables in one file
                                                    have a type thal’s compatible with the type of the p a r t variables in the other file.
                                                    Variables with compatible types can be assigned to each other, so there’s little
                                                    practical diffcrcncc between types being “com patible” and being “the same.”
                                                         The rules for structure compatibility in C89 and C99 are slightly different. In
                                                    C89, structures defined in different files are compatible if their members have the
                                                    same names and appear in the same order, with corresponding members having
                                                    compatible types. C99 goes one step further: it requires that either both structures
                                                    have the same tag or neither has a tag.
                                                         Similar compatibility rules apply to unions and enumerations (with the same
                                                    difference between C89 and C99).

                                           Q:       Is it le g a l to h a v e a p o in te r to a c o m p o u n d lite r a l?
                                            A:      Yes. Consider the p r i n t _ p a r t function ofS eclion l6.2. Currently, the param e­
                                                    ter to this function is a p a r t structure. The function would be more efficient if il
                                                                                 p o inter to a p a r t structure instead. Using the function
                                                    were modified to accept a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                    to print a compound literal would then be done by prefixing the argument with the
                                                    & (address) operator:

                                                    print_part(&(struct part)                         {528, "Disk drive", 10});

                                           Q:       A l lo w in g a p o in te r to a c o m p o u n d lite r a l w o u ld s e e m to m a k e it p o s s ib le to
                                     <*ffi>         m o d ify th e lite r a l. Is th a t th e c a se ?
                                            A:      Yes. Compound literals are lvalues that can be modified, although doing so is rare.

                                           Q:       I s a w a p r o g r a m in w h ic h th e la s t c o n s ta n t in a n e n u m e r a ti o n w a s fo llo w e d b y
                                                    a c o m m a , lik e th is:
                                                                                                                                           407onmlkjihgfedcbaZYXWVU
                                                                                                                    E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG

                            enum g r a y _ v a l u e s {
                              BLACK = 0 ,
                              DARK_GRAY = 6 4 ,
                              GRAY = 1 2 8 ,
                              LIG H T_G R A Y = 1 9 2 ,dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                            Is th is p r a c tic e le g a l?
                      A:    This practice is indeed legal in C99 (and is supported by some pre-C99 compilers as
                   <^ £ >   well). Allowing a “trailing comma” makes enumerations easier to modify, because
                            we can add a constant lo the end of an enumeration without changing existing lines
                            ofcode. For example, we might want to add WHITE to our enumeration:

                            enum g ra y _ _ v a lu e s {
                              BLACK = 0 ,
                              DARK_GRAY = 6 4 ,
                              GRAY = 1 2 8 ,
                              LIGHT__GRAY = 1 9 2 ,
                              W HITE = 2 5 5 ,


                            The comma after the definition of LIGHT_GRAY makes it easy to add WHITE to
                            the end of the list.
                                                                                    l”ingK^ commas in initializers,*
                                 One reason for this change is that C89 allows tra^iK
                            so it seemed inconsistent not to allow the same flexibility in enumerations. Inci-
                   <ffi>    dentally, C99 also allows trailing commas in compound literals.aZYXWVUTSRQPONMLKJIHGFEDCBA

                      Q:    C a n th e v a lu e s o f a n e n u m e r a te d ty p e h e u se d a s s u b s c r ip ts ?
                      A:    Yes, indeed. They are integers and have— by default— values that start at 0 and
                   JC99'    count upward, so they make great subscripts. In C99, moreover, enumeration con­
                            stants can be used as subscripts in designated initializers. Here’s an example:

                            e n u m w e e k d a y s {MONDAY, TUESDAY, WEDNESDAY,                             THURSDAY,          F R ID A Y } ;
                            c o n s t c h a r * d a i l y _ s p e c i a l s [] = {
                                 [MONDAY] = " B e e f r a v i o l i " ,
                                 [TUESDAY] = " B L T s " ,
                                 [WEDNESDAY] = " P i z z a " ,
                                 [THURSDAY] = " C h i c k e n f a j i t a s " ,
                                 [F R ID A Y ] = " M a c a r o n i a n d c h e e s e "
                            }«•




                            E x e r c is e s

S e c tio n 16.1       1.   In the following declarations, the x and y structures have members named x and y:
                            s tru c t        in t    x,            x;
                            s tru c t        in t    x,            y;
                            Arc these declarations legal on an individual basis? Could both declarations appear as
                            shown in a program? Justify your answer.
4 0 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 16    S tru c tu re s , U n io n s , a n d E n u m e r a tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                        ©      2.    (a) Declare structure variables named c l . c 2 , and c 3 . each having members r e a l and
                                     i m a g i n a r y o fty p e d o u b l e .
                                     (b) Modify the declaration in part (a) so that c l ' s members initially have the values 0.0 and
                                     l.0, while c 2 's members are l.0 and 0.0 initially, (c3 is not initialized.)
                                     (c) Write statements that copy the members o f c2 into c l . Can this be done in one state­
                                     ment, or does it require two?
                                     (d) Write statements that add the corresponding members of c l and c 2 , storing the result
                                     in c 3 .

S e c tio n 16.2               3.    (a) Show how to declare a tag named c o m p le x for a structure with two members, r e a l
                                     and i m a g i n a r y , of type d o u b l e .
                                     (b) Use the c o m p le x tag to declare variables named c l . c 2 , and c 3 .
                                     (c) Write a function named m a k e _ c o m p le x that stores its two arguments (both o f type
                                     d o u b l e ) in a c o m p le x structure, then returns the structure.
                                     (d) W rite a function named a d d _ c o m p le x that adds the corresponding members o f its
                                     arguments (both c o m p l e x structures), then retums the result (another c o m p l e x structure).

                        ©      4.                                             type named C o m p le x .
                                     Repeal Exercise 3, but this lime using a cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                               5.    Write the following functions, assuming that ihe d a t e structure contains three members:
                                     m o n th , d a y . and y e a r (all ofiype i n t ) .
                                     (a) i n t    d a y _ o f_ y e a r(s tru c t d a te        d );
                                     Returns the day of the year (an integer between l and 366) that corresponds to the dale d.
                                     (b) i n t    c o m p a re _ d a te s (s tru c t d a te        d l,    s tru c t    d a te   d 2 );
                                     Retums - l if d l is an earlier date than d 2 . +l if d l is a later date than d 2 . and 0 if d l and
                                     d2 are the same.

                               6.    Write the following function, assuming that the t i m e structure contains three members:
                                     h o u r s , m i n u t e s , and s e c o n d s (all o fty p e i n t ) .
                                      s tru c t    tim e    s p lit_ tim e (lo n g        to ta l_ s e c o n d s );
                                     t o t a l _ s e c o n d s is a time represented as the number of seconds since midnight. The
                                     function returns a structure containing the equivalent time in hours (0-23), minutes (0-59).
                                     and seconds (0-59).

                               7.    Assume that the f r a c t i o n structure contains two members: n u m e r a t o r and d e n o m i ­
                                     n a t o r (both o fly p c i n t ) . Write functions thai perform the following operations on frac­
                                     tions:
                                      (a) Reduce the fraclion f to lowest terms. H im : To reduce a fraction to lowest terms. first
                                          compute ihe greatest common divisor (GCD) of the numerator and denominator. Then
                                          divide boih the num eratorand denominator by the GCD.
                                      (b) Add the fractions f l and f 2 .
                                      (c) Subtract ihe fraction f 2 from the fraction f l .
                                      (d) Multiply lhc fractions f l and f 2 .
                                      (e) Divide the fraction f l by the fraction f 2 .
                                     The fractions f , f l , and f 2 will be arguments of type s t r u c t f r a c t i o n : each function
                                     will return a value of type s t r u c t f r a c t i o n . The fractions reiurned by the functions in
                                     parts (b)-(e) should be reduced to lowest terms. H im : You may use the function from pan
                                     (a) to help write the functions in parts (b)-(e).
                                                                                                                                     409onmlkjihgfedcbaZYXWVUT
                                                                                                              E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF

                           Let c o l o r bc the following structure:
                           s tr u c t c o lo r    {
                               in t red ;
                               in t g re e n ;
                               in t b lu e ;

                           (a) Write a declaration for a c o n s t variable named MAGENTA of type s t r u c t c o l o r
                           whose members have the values 255, 0, and 255, respectively.
                           (b) (C99) Repeat part (a), but use a designated initializer that doesn’t specify the value of
                           g r e e n , allowing it ro default to 0.

                      9.   Write the following functions. (The c o l o r structure is defined in Exercise <8.)
                           (a) s t r u c t c o l o r m a k e _ c o l o r ( i n t r e d , i n t g r e e n , i n t b l u e ) ;
                           Returns a c o l o r structure containing the specified red, green, and blue values. If any argu­
                           ment is less than zero, the corresponding member of the structure will contain zero instead.
                           If any argument is greater than 255, the corresponding member o fth e structure will contain
                           255.
                           (b) i n t g e t R e d ( s t r u c t c o l o r c ) ;
                           Returns the value o f c ’s r e d member.
                           (c) b o o l e q u a l _ c o l o r ( s t r u c t c o l o r c o l o r l , s t r u c t c o l o r c o l o r 2 ) ;
                           Returns t r u e if the corresponding members o f c o l o r l and c o l o r 2 are equal.
                           (d) s t r u c t c o l o r b r i g h t e r ( s t r u c t c o l o r c ) ;
                           Returns a c o l o r structure that represents a brighter version of the color c. The structure is
                           identical to c, except that each member has been divided by 0.7 (with the result truncated to
                           an integer). However, there are three special cases: (1) lf all members of c are zero, the
                           function returns a color whose members all have the value 3, (2) If any member of c is
                           greater than 0 but less than 3, it is replaced by 3 before die division by 0.7. (3) If dividing by
                           0.7 causes a member to exceed 255, il is reduced lo 255.
                           (c) s t r u c t c o l o r d a r k e r ( s t r u c t c o l o r c ) ;
                           Returns a c o l o r structure that represents a darker version of the color c. The structure is
                           identical to c, except that each member has bcen multiplied by 0.7 (with the result truncated
                           lo an integer).hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 1 6 .3   l0.   The following structures are designed to store information about objects on a graphics
                           screen:
                           s t r u c t p o i n t { i n t x , y ; };
                           s t r u c t r e c t a n g l e { s t r u c t p o in t u p p e r_ _ le ft,       lo w e r_ rig h t;      };
                           A p o i n t structure stores the .v and y coordinates of a point on the screen. A r e c t a n g l e
                           siniciure stores the coordinates of the upper left and lower right corners o fa rectangle. Write
                           functions that perform the following operations on a r e c t a n g l e structure r passed as an
                           arg<^ument:
                           (a) Cornpuie ihe area of r.
                           (b) Compute the cenier of r. returning il as a p o i n t value. If either the .v or v coordinate of
                                 the center isn’t an integer, store its truncated value in lhe p o i n t structure.
                           (c) Move r by x units in lhc .v direction and y uniis in the y direction, returning the modi­
                                 fied version of r. (x and y are additional arguments to lhe function.)
                           (d) Determine whether a point p lies within r , returning t r u e or f a l s e , (p is an addi­
                                 tional argument oftype s t r u c t p o i n t . )
             C h a p te r 16
4 1 0 ZYXWVUTSRQPONMLKJIHGFEDCBA S tru c tu re s , U n io n s , a n d E n u m e r a tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA


                             © 11. Suppose that s is the following structure:
S e c t io n 1 6 .4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     s tru c t {
                                        d o u b le a ;
                                        u n io n {
                                            c h a r b [4] ;
                                            d o u b le c ;
                                            in t d;
                                         } e;
                                        c h a r f [4] ;
                                     } s;
                                    If c h a r values occupy one byte, i n t values occupy four bytes, and d o u b l e values occupy
                                    eight bytes, how much space will a C compiler allocate for s ? (Assume that the compiler
                                    leaves no “holes" between members.)

                             l2.     Suppose that u is the following union:
                                    u n io n {
                                        d o u b le a ;
                                        s tru c t {
                                            c h a r b [4] ;
                                            d o u b le c ;
                                            in t d ;
                                        } e;
                                        c h a r f [4 ];
                                    } u;
                                    If c h a r values occupy one byte, i n t values occupy four bytes, and d o u b l e values occupy
                                    eight bytes, how much space will a C compiler allocate for u? (Assume that the compiler
                                    leaves no “holes" between members.)

                             l3.     Suppose that s is the following structure ( p o i n t is a structure tag declared in Exercise l0):
                                     s t r u c t shape {
                                          i n t s h a p e _ k in d ;               / * RECTANGLE o r CIRCLE * /
                                          s tr u c t p o in t c e n te r;          /* c o o r d i n a t e s o f c e n t e r * /
                                         u n io n {
                                              s tru c t {
                                                 i n t h e ig h t, w id th ;
                                              } re c ta n g le ;
                                              s tru c t {
                                                 in t ra d iu s ;
                                              } c irc le ;
                                          } U;
                                     } S;
                                     Ifthc value of s h a p e _ k i n d is RECTANGLE, the h e i g h t and w i d t h members store the
                                     dimensions of a rectangle. If the value of s h a p e _ k i n d is CIRCLE, the r a d i u s member
                                     stores the radius of a circle. Indicate which of the following statements are legal, and show
                                     how to repair the ones that aren't:
                                     (a)   s . s h a p e _ k i n d = RECTANGLE ;
                                     (b)   s .c e n t e r .x = 10;
                                     (c)   s .h e ig h t = 25;
                                     (d)   s . u . r e c t a n g l e . w i d t h = 8;
                                     (e)   s . u . c i r c l e = 5;
                                     (f)   s . u . r a d i u s = 5;
                                                                                                                                   411hgfedcbaZYXWVUT
                                                                                                            E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJ


                     ©   l4.    Let s h a p e be (he structure tag declared in Exercise I3. W rite functions that perforin lhc
                                following operations on a s h a p e structure s passed as an argument:
                                (a) Com pute the area of s.
                                (b) Move s by x units in the .v direction and y units in the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                y direction, returning the m odi­
                                    fied version of s . (x and y are additional argum ents to the function.)
                                (c) Scalc s by a factor of c (a d o u b l e value), returning (he modified version o f s . (c is an
                                    additional argument to the function.)

S e c tio n 16 .5 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                           © I5.         (a) Declare a tag for an enumeration whose values represent (he seven days o f the week.
                                (b) Use t y p e d e f to define a name for the enum eration of part (a).

                         16.    Which of the following statem ents about enum eration constants are true?
                                (a) An enumeration constant may represent any integer specified by the programmer.
                                (b) Enumeration constants have exactly the sam e properties as constants created using
                                    # d e fin e .
                                (c) Enumeration constants have the values 0. 1.2, ... by default.
                                (d) All constants in an enumeration must have different values.
                                (e) Enumeration constants may be used as integers in expressions.

                     ©   17.    Suppose that b and i are declared as follows:
                                enum {FALSE,         TRUE} b ;
                                in t i ;
                                Which o f the following statem ents are legal? W hich ones are “safe’1 (always yield a m ean­
                                ingful result)?
                                (a) b = FALSE;
                                (b) b = i ;
                                (c) b + + ;
                                (d) i = b ;
                                (e) i = 2 * b 4- 1 ;

                         18.    (a) Each square of a chessboard can hold one piece— a pawn, knight, bishop, rook, queen,
                                or king— or it may be empty. Each piece is either black or white. Define two enum erated
                                types: P i e c e , which has seven possible values (one of which is “em pty”), and C o l o r ,
                                which has two.
                                (b) Using the types from part (a), define a structure type named S q u a r e that can store both
                                the type of a piece and its color.
                                (c) Using the S q u a r e type from part (b), declare an 8 x 8 array named b o a r d that can
                                store thc entire contents o f a chessboard.
                                (d) Add an initializer to (he declaration in part (c) so that b o a r d 's initial value corresponds
                                to the usual arrangement of pieces at the start of a chess game. A square that\s not occupied
                                by a piece should have an “em pty" piece value and the color black.

                         19.    Declare a structure with the following members whose tag is p i n b a l l _ m a c h i n e :
                                n a m e - a string o f up to 40 characters
                                y e a r - an integer (representing the year of m anufacture)
                                t y p e - an enumeration with the values EM (electrom echanical) and SS (solid state)
                                p l a y e r s - an integer (representing the maximum num ber o fp layers)

                         20.   Suppose that the d i r e c t i o n variable is declared in the following way:
                                en u m   {NORTH,     SOUTH,     EAST,     WEST} d i r e c t i o n ;
            C h a p te r 16    S tru c tu re s , U n io n s , a n d E n u m e r a tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
4 1 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                     Let x and y be i n t variables. Wrilc a s w i t c h statement that tests the value of d i r e c ­
                                     t i o n , incrementing*^- x if d i r e c t i o n is EAST, decrementin *g—x if d i r e c t i o n is WEST,
                                     incrementing y i f d i r e c t i o n is SOUTH, and decrementing y if d i r e c t i o n is NORTH.

                             2I.     What are the integer values of the enumeration constants in cach of the following declara­
                                     tions?
                                     (a)   enum      {NUL, SOH, STX, ETX};
                                     (b)   enum      {VT = 1 1 , F F , C R };
                                     (c)   enum      {SO = 1 4 , S I , DLE, CAN = 2 4 , EM};
                                     (d)   enum      {ENQ = 4 5 , ACK, BEL, LF = 3 7 , ETB,                           E S C };

                             22.     Let c h e s s _ p i e c e s be the following enumeration:
                                     e n u m c h e s s _ p ie c e s     {KING, QUEEN,            ROOK,       B ISH O P,     KNIGHT,   PAWN};
                                     (a) Write a declaration (including an initializer) for a constant array of integers named
                                     p i e c e _ _ v a l u e that stores the numbers 200, 9, 5, 3, 3, and 1. representing lhc value of cach
                                     chess piece, from king to pawn. (The king’s value is actually infinite, since “capturing" the
                                     king (checkmate) ends the game, but some chess-playing software assigns the king a large
                                     value such as 200.)
                                     (b) (C99) Repeat part (a), but use a designated initializer to initialize the array. Use the enu­
                                                                                                                        (Hint: Scc the last
                                     meration constants in c h e s s _ _ p i e c e s as subscripts in the designators. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     question in Q&A for an example.) aZYXWVUTSRQPONMLKJIHGFEDCBA




                                      P r o g r a m m in g P r o je c ts

                        ©      1.    Write a program that asks the user lo enter an international dialing code and then looks il up
                                     in the c o u n t r y _ c o d e s array (see Section 16.3). Ifit finds the code, the program should
                                     display the name of the corresponding country: if not. the program should print an error
                                     messagc e,

                               2.    Modify the i n v e n t o r y . c program of Section 16.3 so that the p (print) operation displays
                                     the parts sorted by part number.

                         ©     3.    Modify the i n v e n t o r y . c program of Section 16.3 by making i n v e n t o r y                  and
                                     n u m _ p a r t s local to the m a in function.

                               4.    Modify the i n v e n t o r y . c program of Section 16.3 by adding a p r i c e member to the
                                     p a r t struclure. The i n s e r t function should ask the user for the price o f a new item. The
                                     s e a r c h and p r i n t functions should display the price. Add a ncw command that allows
                                     the user to ehangc the price of a part.

                               5.    Modify Programming Projecl 8 from Chapter 5 so that the times are stored in a single array.
                                     The elements of the array will be structures, each containing a departure time and the corre­
                                     sponding arrival time. (Each time will be an integer, representing the number of minutes
                                     since midnight.) The program will use a loop to search lhe array for die departure time clos­
                                     est to the iime entered by the user.

                               6.    Modify Programming Project 9 from Chapter 5 so that cach dale eniercd by lhc user is
                                     stored in a d a t e struclure (see Exercise 5). Incorporate the c o m p a r e _ d a t e s function of
                                     Exercise 5 into your program.
A d v a n c e d U s e s o f P o in t e r s                                                                        ZYXWVUTSRQPONMLKJIHG




                                       O n e c a n o n ly d is p la y c o m p le x in fo r m a tio n in th e m in d .
                                 L ik e s e e in g , m o v e m e n t o r flo w o r a lte r a tio n o f v ie w is m o r e
                                       im p o r t a n t th a n th e s t a t ic p ic tu re , n o m a t t e r h o w lo v e ly onmlkjihgfedcbaZYX




In previous chapters, we‘ve seen two important uses of pointers. Chapter 11
showed how using a pointer to a variable as a function argument allows the func­
tion to modify the variable. Chapter 12 showed how to process arrays by perform­
ing arithmetic on pointers to array elements. This chapter completes our coverage
of pointers by exannning two additional applications: dynamic storage allocation
and pointers to functions.
     Using dynamic storage allocation, a program can obtain blocks of memory as
needed during execution. Section 17.1 explains the basics ofdynam ic storage allo­
cation. Section 17.2 discusses dynamically allocated sirings, which provide more
flexibility than ordinary character arrays. Section 17.3 covers dynamic storage
allocation forarrav*>s in ^g eneral. Section 17.4 deals withK>the issue ofstorage deallo-
cation— releasing blocks ofdynam ically allocated memory when they're no longer
needed.
     Dynamically allocated struclures play a big role in C programming, since they
can be linked together lo form lists, trees, and other highly flexible data structures.
Section 17.5 focuses on linked lists, the most fundamental linked data structure.
One of the issues that arises in this section— the concept of a “pointer to a
pointer”— is important enough to warrant a section o fils own (Section 17.6).
     Section 17.7 introduces pointers to functions, a surprisingly useful concept.
Some of C's most powerful library functions expect function pointers as argu­
ments. We’ll examine one ofthese functions, q s o r t , which is capable ofsorting
any array.
     The last two sections discuss pointer-related features that first appeared in
C99: restricted pointers (Section 17.8) and flexible array members (Section 17.9).
These features are primarily of interest to advanced C programmers, so both sec­
tions can be safely be skipped by the beginner.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                                    413
4 1 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 1 7    A d v a n c e d U s e s o f P o in te r s aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     17.1                D y n a m ic S t o r a g e A l l o c a t i o n

                                                         C ’s data structures are normally fixed in size. For example, the number of elements
                                                         in an array is fixed once the program has been compiled, (ln C99, the length of a hgfedcba
       v a r ia b ie - i e n g t h a r r a y s > 8 . 3   variable-length array is determined at run lime, but it remains fixed for the rest of
                                                         the array’s lifetime.) Fixed-size data structures can be a problem, since w e’re
                                                         forced to choose their sizes when writing a program; we can’t change the sizes
                                                         without modifying the program and compiling it again.
                                                               Consider the i n v e n t o r y program ofS ection l6.3, which allows the user lo
                                                         add parts to a database. The database is stored in an array of length l00. To en­
                                                         large the capacity of the database, we can increase the size of the array and recom­
                                                         pile the program. But no matter how large we make the array, there’s always the
                                                         possibility that it will fill up. Fortunately, all is not lost. C supports RQPONMLKJIHGFEDCBA
                                                                                                                                          d y n a m ic s to r ­
                                                         a g e a l l o c a t i o n : the ability to allocate storage during program execution. Using dy­
                                                         namic storage allocation, we can design data structures that grow (and shrink) as
                                                         needed.
                                                                Although it’s available for all types ofdata, dynamic storage allocation is used
                                                         most often for strings, arrays, and structures. Dynamically allocated structures are
                                                         ofparticular interest, since we can link them together to form lists, trees, and other
                                                         data structures.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                         M e m o r y A llo c a tio n F u n c t io n s

                                                         To allocate storage dynamically, w e'll need to call one of the three memory aLloca-
    < s td iib .h >           h e a d o r> 2 6 .?        tion functions declared in the < s t d l i b . h> header:

                                                           ■ m a l l o c — Allocates a block of memory but doesn’t in itialize il.
                                                           ■ c a l l o c — Allocates a block of memory and clears it.
                                                           ■ r e a l l o c — Resizes a previously allocated block of m emory.
                                                         Of the three, m a l l o c is the most used. It's more efficient than c a l l o c , since it
                                                         doesn’t have to clear the memory block that il allocates.
                                                              When we call a memory allocation function to request a block of memory, the
                                                         function has no idea what type of data we’re planning to store in the block, so it
                                                         can’t return a pointer to an ordinary type such as i n t or c h a r . Instead, the func­
                                                         tion returns a value of type v o i d *. A v o i d * value is a “generic” pointer—
                                                         essentially,just a memory address.


                                                         N u ll P o in t e r s

                                                         When a memory allocation function is called, there’s always a possibility that it
                                                         w on’t be able to locate a block of memory large enough to satisfy our request. If
                                                   17.1                                                      4 1 5 onmlkjihgfedcbaZYXWVUTSR
                                                            D y n a m ic S to ra g e A llo c a tio n hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC


                                                           n u l l p o i n t e r . A null pointer is a
         that should happen, the function will return a RQPONMLKJIHGFEDCBA
         “pointer to nothing”— a special value that can be distinguished from all valid
         pointers. After w e’ve siored the function’s return value in a pointer variable, we
         must test to see if it’s a null pointer.


         lt’s the program m er’s responsibility to test the return value of any memory alloca­
A        tion function and take appropriate action if it's a null pointer. The effect ofattem pt-
         ing to access memory through a null pointer is undefined: the program may crash
         or behave unpredictably.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


Q&A           The null pointer is represented by a macro named NULL, so we can test
         m a l l o c ’s return value in the following way:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         p = malloc(10000);
         if (p == NULL) {
           /* allocation failed; take appropriate action */


         Some program m ers combine the call o f m a l l o c with the NULL test:

         if ((p = malloc(10000)) == NULL) {
           /* allocation failed; take appropriate action */
         }

               The NULL macro is defined in six headers: < l o c a l e . h > , < s t d d e f .h > .
< ffi>   < s t d i o . h> , < s t d l i b . h> , < s t r i n g . h > , and < t i m e . h> . (The C99 header
         < w c h a r . h> also defines NULL.) As long as one of these headers is included in a
         program, the com piler will recognize NULL. A program that uses any o fth e m em ­
         ory allocation functions will include < s t d l i b . h > . of course, making NULL
         available.
               In C, pointers test true or false in the same way as numbers. All non-nuIl
         pointers test true; only null pointers are false. Thus, instead o fw ritin g

         if (p == NULL) ...

         we could write

         if (!p) ...

         and instead of writing

         if (p != NULL) ...

         we could write

         if (p) ...

         As a matter ofsty le, I prefer the explicit comparison with NULL.
416 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs aZYXWVUTSRQPONMLKJIHGFEDCBA




                         1 7 .2          D y n a m ic a lly A llo c a t e d S tr in g s

                                         Dynamic storage allocation is often useful for working with strings. Strings are
                                         stored in character arrays, and it can be hard to anticipate how long these arrays
                                         need to be. By allocating strings dynamically, we can postpone the decision until
                                         the program is running.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         U s in g m a l l o c to A llo c a te M e m o r y fo r a S tr in g

                                         The m a l l o c function has the following prototype:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         void *malloc(size_t size);

                                         m a l l o c allocates a block of s i z e bytes and returns a pointer to it. Note that
             e i z e _ t ty p e > 7 .6   s i z e has typc s i z e _ t , an unsigned integer type defined in the C library. Unless
                                         we’re allocating a very large block of memory, we can just think of s i z e as an
                                         ordinary integer.
                                               Using m a l l o c to allocate memory for a string is easy, because C guarantees
                                         that a c h a r value requires exactly one byte ofstorage ( s i z e o f ( c h a r ) is I. in
                                         other words). To allocate space for a string o f n characters, we'd write

                                         p = malloc(n + 1);

                                         where p is a c h a r * variable. (The argument is n + 1 rather than n to allow room
                                         for the null character.) The generic pointer that m a l l o c returns will be converted
                                         to c h a r * when the assignment is performed; no cast is necessary. (In general, we
                                         can assign a v o i d * value to a variable ofany pointer type and vice versa.) Never­
                             Q&A         theless, some programmers prefer to cast m a l l o c ’s return value:

                                         p = (char *) malloc(n 4- 1) ;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         When using m a l l o c lo allocate space for a siring, don't forget to include room for
                            A            the null character.


                                              Memory allocated using m a l l o c isn’t cleared or initialized in any way. sop
                                         will point to an uninitialized array o f n + 1 characters:
                                      1 7 .2                                                           417
                                               D y n a m ic a lly A llo c a t e d S tr in g s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGF


Calling s t r c p y is one way to initialize this array:

s trc p y (p ,   "abc”);

The first four characters in the array will now be a , b . c, and \ 0 :dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




U sin g D y n a m ic S to r a g e A llo c a tio n in S tr in g F u n c tio n s
Dynamic storage allocation makes it possible to write functions that return a
poinler to a “new” string— a string that didn't exist before the function was called.
Consider the problem of writing a function that concatenates two strings without
changing either one. C ’s standard library doesn’t include such a function ( s t r c a t
isn't quite what we want, since it modifies one of the strings passed to it), but we
can easily write our own.
     Our function will measure the lengths of the two strings to be concatenated,
then call m a l l o c to allocate just the right amount of space for the result. The
function next copies the first siring into the new space and then calls s t r c a t to
concatenate the second string.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

char *concat(const char *sl, const char *s2)

    char *result;

    result = malloc(strlen(sl) + strlen(s2) + 1);
    if (result == NULL) {
      printf("Error: malloc failed in concat\n");
      exit(EXIT_FAILURE);

    strcpy(result, sl);
    strcat(result, s2);
    return result;
}

I f m a l l o c returns a null pointer, c o n c a t prints an error message and term inates
the program. T hat's not always the right action lo lake: some programs need to
recover from memory allocation failures and continue running.
      Here’s how the c o n c a t function might be called:

p = concat("abc",          "def”);

After the call, p will point to the string " a b c d e f " . which is stored in a dynam i­
cally allocated array. The array is seven characters long, including the null charac­
ter al the end.
4 1 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 1 7    A d v a n c e d U s e s o f P o in te rs




                                          Functions such as c o n c a t that dynam ically allocate storage must be used with
                                          care. When the string that c o n c a t returns is no longer needed, w e'll want to call
                      fu n c tio n > 17.4 the f r e e function to release the space that the string occupies. If we don’t, the
            f r e e hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                          program may eventually run out of memory.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                    A r r a y s o f D y n a m ic a lly A llo c a te d S tr in g s

                                    hi Section l3.7, we tackled the problem of storing strings in an array. We found
                                    that storing strings as rows in a two-dim ensional array of characters can waste
                                    space, so we tried setting up an array of pointers to string literaK T he techniques
                                    o fS ection l3.7 w o rk ju st as well ifth e elem ents o fa n array are pointers to dynam ­
                                    ically allocated strings. To illustrate this point; let’s rewrite the r e m i n d . c pro­
                                    gram of Section 13.5, which prints a one-m onth list o fd aily reminders.


               PR O G R A M         P r in tin g a O n e -M o n th R e m in d e r L is t (R e v is ite d )

                                    The original r e m i n d . c program stores the rem inder strings in a two-dim ensional
                                    array ofcharacters, with each row of the array containing one string. A fter the pro­
                                    gram reads a day and its associated reminder, it searches the array to determ ine
                                    where the day belongs, using s t r c m p to do com parisons. It then uses s t r c p y to
                                    move all strings below that point down one position. Finally, the program copies
                                    the day into the array and calls s t r c a t to append the rem inder to the day.
                                         In the new program ( r e m i n d 2 . c), the array will be one-dim ensional; its ele­
                                    ments will be pointers to dynamically allocated strings. Switching to dynamically
                                    allocated strings in this program will have two prim ary advantages. First, we can
                                    use space more efficiently by allocating the exact num ber of characters needed to
                                    store a reminder, rather than storingo the rem inder in a fixed num ber of characters
                                    as the original program does. Second, we w on't need to call s t r c p y lo move
                                    existingo rem indeor strings in order to make room for a new reminder. Instead, w e’ll
                                    merely move pcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                    o in ters to strings.
                                         H ere’s the new program, with changes in bold. Switching from a two-dim en­
                                    sional array to an array of pointers turns out to be rem arkably easy: w e’ll only need
                                    to change eight lines of the program.BA

                  remind2.c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                /* Prints a one-month reminder list (dynamic string version) */

                                    #include <stdio.h>
                                    #include <stdlib.h>
                                    #include <string.h>

                                    #define MAX_REMIND 50                  /* maximum number of reminders */
                                    #define MSG_LEN 60                     /* max length of reminder message */

                                    int read line(char str[], int n);
                           1 7 .2                                                        419
                                    D y n a m ic a lly A llo c a te d S trin g s kjihgfedcbaZYXWVUTSRQPONML

int main(void)

  char *reminders[MAX_REMIND];
  char day_str[3], msg_str[MSG_LEN+l];
  int day, i, j, num_remind = 0;

  for (;;) {
    if (num_remind == MAX_REMIND) {
      printf(”-- No space left --\n");
      break;


    printf("Enter day and reminder:            ”);
    scanf(”%2d”, &day);
    if (day == 0)
      break;
    sprintf(day_str, "%2d", day);
    read_line(msg_str, MSG_LEN);

    for (i = 0; i < num_remind; i++)
      if (strcmp(day_str, reminders[i]) < 0)
        break;
    for (j = num_remind; j > i; j--)
      reminders [j ] = reminders [j -1] ;

    reminders[i] = malloc(2 + strlen(msg_str) + 1);
    if (reminders[i] == NULL) {
      printf(”-- No space left --\n”);
      break;


    strcpy(reminders[i], day_str);
    strcat(reminders[i], msg_str);

   num_remind++;


 printf("\nDay Reminder\n");
 for (i = 0; i < num_remind; i++)
   printf(” %s\n”, reminders[i]);

 return 0;


int read_line(char str[], int n)

 int ch, i = 0;

 while ((ch = getchar())     != ‘\ n ’)
   if (i < n)
      str[i++] = ch;
 str [i] = •\0 ’;
 return i ;
             C h a p t e r 1 7 A d v a n c e d U s e s o f P o in te rs aZYXWVUTSRQPONMLKJIHGFEDCBA
4 2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA




                            1 7 .3          D y n a m ic a lly A llo c a t e d A r ra y s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            Dynamically allocated arrays have (he same advantages as dynamically allocated
                                                                                     are arrays). When w e’re writing a program,
                                            strings (not surprisingly, since strings cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            it’s often difficult to estimate the proper size for an array: it would be more conve­
                                            nient to wait until the program is run to decide how large the array should be. C
                                            solves this problem by allowing a program to allocate space for an array during
                                            execution, then access the array through a pointer to its first element. The close
                                            relationship between arrays and pointers, which we explored in Chapter l2, makes
                                            a dynamically allocated arrayjust as easy to use as an ordinary array.
                                                  Although m a l l o c can allocate space for an array, the c a l l o c function is
                                            sometimes used instead, since it initializes the memory that it allocates. The
                                            r e a l l o c function allows us to make an array '"grow” or “shrink” as needed.dcbaZYXWVUTSR


                                            U s in g m a l l o c to A llo c a te S to r a g e fo r a n A r r a y

                                            We can use m a l l o c to allocate space for an array in much the same way we used
                                            it to allocate space for a string. The primary difference is that the elements of an
                                            arbitrary array won’t necessarily be one byte long, as they are in a string. As a
          s iz e o fo p e r a to r > 7 .6   result, we’ll need to use the s i z e o f operator to calculate the amount of space
                                            required for each element.
                                                  Suppose we’re writing a program that needs an array of n integers, where n is
                                            to be computed during the execution of the program. We’ll first declare a pointer
                                            variable:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                            int *a;

                                            Once thc value of n is known, we’ll have the program call m a l l o c to allocate
                                            space for the array:

                                            a = malloc(n * sizeof(int));


                                            Always use s i z e o f when calculating how much space is needed for an array.
                               A            Failing to allocate enough memory can have severe consequences. Consider the
                                            following attempt to allocate space for an array o f n integers:
                                            a = malloc(n * 2);

                                            If i n t values are larger than two bytes (as they are on most computers), m a l l o c
                                            won’t allocate a large enough block of memory. When we later try to access ele­
                                            ments of the array, the program may crash or behave erratically.


                                                 Once it points to a dynamically allocated block of memory, we can ignore the
                                            fact that a is a pointer and use it instead as an array name, thanks to the relation-
                                              17.3                                                      421onmlkjihgfedcbaZYXWVUTS
                                                      D y n a m ic a lly A llo c a te d A rra y s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE


      ship between arrays and pointers in C. For example, we could use the following
      loop to initialize the array that a points to:dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      for (i = 0; i < n; i++)
        a[i] = 0;

      We also have the option of using pointer arithmetic instead of subscripting to
      access the elements of the array.


      T h e c a l l o c F u n c tio n

      Although the m a l l o c function can be used to allocate memory for an array. C
      provides an alternative— the c a l l o c function— that’s sometimes better, c a l l o c
      has the following prototype in < s t d l i b . h>:

      void *calloc(size_t nmemb, size_t size);

      c a l l o c allocates space for an array with nmemb elements, each of which is
      s i z e bytes long; it returns a null pointer if the requested space isn’t available.
Q&A   After allocating the memory, c a l l o c initializes it by setting all bits to 0. For
      example, the following call of c a l l o c allocates space for an array o f n integers,
      which are all guaranteed to be zero initially:

      a = calloc(n, sizeof(int));

           Since c a l l o c clears the memory that it allocates but m a l l o c doesn’t, we
      may occasionally want to use c a l l o c to allocate space for an object other than an
      array. By calling c a l l o c with 1 as its first argument, we can allocate space for a
      data item of any type:

      struct point { int x, y; } *p;

      p = calloc(l, sizeof(struct point));

      After this statement has been executed, p will point to a structure whose x and y
      members have been set to zero.


      T h e r e a l l o c F u n c tio n

      Once w e’ve allocated memory for an array, we may later find that it’s too large or
      too small. The r e a l l o c function can resize the array to better suit our needs. The
      following prototype for r e a l l o c appears in < s t d l i b . h>:

      void *realloc(void *ptr, size_t size);

      When r e a l l o c is called, p t r must point to a memory block obtained by a previ­
      ous call of m a l l o c , c a l l o c , or r e a l l o c . The s i z e parameter represents the
      new size of the block, which may be larger or sm aller than the original size.
      Although r e a l l o c doesn't require t h a t p t r point to memory that’s being used as
      an array, in practice it usually does.
C h a p te r 1 7    A d v a n c e d U s e s o f P o in te rs hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                            Be sure that a pointer passed to r e a l l o c came from a previous call of m a l l o c ,
            A              c a l l o c , or r e a l l o c . If it didn’t, calling r e a l l o c causes undefined behavior.
                   onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                             The C standard spells out a number of rules concerning the behavior of
                        re a llo c :

                           ■               When it expands a memory block, r e a l l o c doesn’t initialize the bytes that
                                           are added to the block.
                               ■           If r e a l l o c can’t enlarge the memory block as requested, it returns a null
                                           pointer; the data in the old memory block is unchanged.
                                   ■       If r e a l l o c is called with a null pointer as its first argument, it behaves like
                                           m a llo c .
                                   ■ I f r e a l l o c is called with 0 as its second argument, it frees the memory
                                      block.
                             The C standard stops short of specifying exactly how r e a l l o c works. Still,
                       we expect it to be reasonably efficient. When asked to reduce the size of a memory
                       block, r e a l l o c should shrink the block “in place,’’ without moving the data
                       stored in the block. By the same token, r e a l l o c should always attempt to
                       expand a memory block without moving it. K it’s unable to enlarge the block
                       (because the bytes following the block are already in use for some other purpose),
                       r e a l l o c will allocate a new block elsewhere, then copy the contents of the old
                       block into the new one.


                       Once r e a l l o c has returned, be sure to update all pointers to the memory block,
            A          since it’s possible that r e a l l o c has moved the block elsewhere.aZYXWVUTSRQPONMLKJIHGFEDCBA




          1 7 .4        D e a llo c a tin g S to r a g e

                       m a l l o c and the other memory allocation functions obtain memory blocks from a
                       storage pool known as the hRQPONMLKJIHGFEDCBA
                                                    e a p . Calling these functions too often— or asking them
                       for large blocks of memory— can exhaust the heap, causing the functions to return
                       a null pointer.
                            To make matters worse, a program may allocate blocks of memory and then
                       lose track ofthem , thereby wasting space. Consider the following example:kjihgfedcbaZYXWVUTSRQP
                       p               = m a l l o c (...) ;
                       q               =   m a l l o c (...) ;
                                                    1 7 .4   D e a llo c a tin g S to r a g e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                        423

A fter the first two statements have been executed, p points to one m em ory block,
while q points to another:




After q is assigned to p , both variables now point to the second mem ory block:




There are no pointers to the first block (shaded), so w e’ll never be able to use it
again.
     A block of memory that’s no longer accessible to a program is said to b e g a r-
bage. A program that leaves garbage behind has a m e m o ry leak. Some languages
provide a garb a g e co llecto r that autom atically locates and recycles garbage, but C
doesn’t. Instead, each C program is responsible for recycling its own garbage by
calling the f r e e function to release unneeded memory.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


T h e f r e e F u n c tio n

The f r e e function has the follow ing prototype in < s t d l i b . h> :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

void free(void *ptr);

Using f r e e is easy; we simply pass it a pointer to a m emory block that we no
    e^er need:
lon w

p = malloc(...);
q = malloc (...) ;
free(p);
P = Q;
Calling f r e e releases the block of memory that p points to. This block is now
available for reuse in subsequent calls of m a l l o c or other mem ory allocation
functions.


The argument to f r e e must be a pointer that was previously returned by a m em­
ory allocation function. (The argum ent may also be a null pointer, in which case
the call of f r e e has no effect.) Passing f r e e a pointer to any other object (such
as a variable or array element) causes undefined behavior.
424 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  T h e “ D a n g lin g P o in te r ” P r o b le m

                                  Although the f r e e function allows us to reclaim memory that’s no longer needed,
                                                                   d a n g liiig p o in te rs. The call f r e e (p ) deallocates
                                  using it leads lo a new problem: cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  the memory block that p points to. but doesn’t change p itself. If we forget that p
                                  no longer points to a valid memory block, chaos may ensue:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  char *p = malloc(4);
                                  •••
                                  free(p);hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  •••

                                  strcpy(p,         "abc");          /*** WRONG ***/

                                  Modifying the memory that p points to is a serious error, since our program no
                                  longer has control of that memory.


                                  Attempting to access or modify a deallocated memory block causes undefined

                       A          behavior. Trying to modify a deallocated memory block is likely to have disastrous
                                  consequences that may include a program crash.


                                             Dangling pointers can be hard to spot, since several pointers may point to
                                   the same block of memory. When the block is freed, all the pointers are left dan-
                                  o°l1i*n**°&- aZYXWVUTSRQPONMLKJIHGFEDCBA




                      1 7 .5      L in k e d L is t s

                                  Dynamic storage allocation is especially useful for building lists, trees, graphs, and
                                  other linked data structures. We’ll look at linked lists in this section; a discussion
                                  of other linked data structures is beyond the scope of this book. For more informa­
                                  tion. consult a book such as Robert Sedgewick’s A lg o rith m s in C, Parts l ^ f : Fun­
                                  dam entals. D ata Structures, Sorting, Searching, Third Edition (Reading, Mass.:
                                  Addison-Wesley, l998).
                                       A lin ked list consists of a chain of structures (called nodes), with each node
                                  containing a pointer to the next node in the chain:




                                  The last node in the list contains a null pointer, shown here as a diagonal line.
                                       In previous chapters, w e’ve used an am iy whenever w e’ve needed to store a
                                  collection of data items; linked lists give us an alternative. A linked list is more PONMLKJI
                                                                                  Cr^


                                  flexible than an array: we can easily insert and delete nodes in a linked list, allow­
                                  ing the list to grow and shrink as needed. On the other hand, we lose the “random
                                  access” capability o fan array. Any element o fan array can be accessed in the same
                                                                1 7 .5                              4 2 5 onmlkjihgfedcbaZYXWVUT
                                                                         L in k e d L is ts hgfedcbaZYXWVUTSRQPONMLKJIHGFED


      amount of time: accessing4^*» a node in a linked list is fast if the node is close to the
        g^inn^i*”ng of lhe li'st, slow if it’s near the end.
      beK
           This section describes how to set up a linked list in C. It also shows how to
      perform several common operations on linked lists: inserting a node at the begin­
      ning of a list, searching for a node, and deleting a node.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


      D e c la r in g a N o d e T y p e

      To set up a linked list, the first thing we'll need is a structure that represents a sin­
      gle node in the list. For simplicity, let's assume that a node contains nothing but an
      integer (the node’s data) plus a pointer to the next node in the list. Here’s what our
      node structure will look like:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      struct node {
        int value;                        /* data stored in the node */
        struct node *next;                /* pointer to the next node */


      Notice that the n e x t member has type s t r u c t n o d e *, which means that it can
      store a pointer to a n o d e structure. There’s nothing special about the name n o d e ,
      by the way; it’sjust an ordinary structure tag.
            One aspect of the n o d e structure deserves special mention. As Section l6.2
      explained, we normally have the option of using either a tag or a t y p e d e f name
      to define a name for a particular kind of structure. However, when a structure has a
      member that points to the same kind ofslructure, as n o d e does, we’re required to
      use a structure tag. Without the n o d e tag, we'd have no way to declare the type of
Q&A   n e x t.
            Now that we have the n o d e structure declared, we’ll need a way to keep track
      of where the list begins. In other words, we’ll need a variable that always points to
      the first node in the list. Let’s name the variable f i r s t :

      struct node *first = NULL;

      Setting f i r s t to NULL indicates that the list is initially empty.


      C r e a tin g a N o d e

      As we construct a linked list; we’ll want to create nodes one by one, adding each to
      the list. Creating a node requires three steps:
          1. Allocate memory for the node.
          2. Store data in the node.
          3. Insert the node into the list.
      We’ll concentrate on the first two steps for now.
          When we create a node, weTl need a variable that can point to the node tem­
      porarily. until it’s been inserted into the list. Let’s call this variable new__node:
      struct node *new node;
4 2 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                        W e’ll use m a l l o c to allocate memory for tlie new node, saving the return value in
                                                        n e w _ n o d e :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                        new_node = malloc(sizeof(struct node));

                                                        n e w _ n o d e now points to a block of memory just large enough to hold a n o d e
                                                        structure:


                                                                                     new_nodedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                       type to be allocated, not the name o f a
                                                        Be careful to give s i z e o f the name of the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                        p o in ter to that type:

                                                        new_node = malloc(sizeof(new_node));                      /*** WRONG ***/

                                                        The program will still compile, but m a l l o c will allocate only enough memory for
                                                        a p o in ter to a n o d e structure. The likely result is a crash later, when the program
                                         Q&A            attempts to store data in the node that n e w _ n o d e is presumably pointing to.


                                                             Next, w e’ll store data in the v a l u e mem ber of the new node:

                                                        (*new_node).value = 10;

                                                        H ere’s how the picture will look after this assignment:


                                                                                     new nodeaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                        ►  1 0 GFEDCBA


                                                                                                           valuo next


                                                        To access the v a l u e member of the node, w e’ve applied the indirection operator
                                                        * (to reference the structure to which n e w _ n o d e points), then the selection oper­
                                                        ator . (to select a m em berof the structure). The parentheses around * n e w _ n o d e
                                                        are mandatory because the . operator would otherw ise take precedence over the *
                                   > A p p e n d ix A
   t a b l e o f o p e r a t o r s BA                   operator.


                                                        T h e - > O p e r a to r

                                                        Before we go on to the next step, inserting a new node into a list, let's take a
                                                        moment to discuss a useful shortcut. Accessing a member of a structure using a
                                                        pointer is so common that C provides a special operatorjust for this purpose. This
                                                        operator, known as rig h t arrow selection, is a minus sign followed by >. Using the
                                                        - > operator, we can write

                                                        new_node->value = 10;

                                                        instead of
                                                                                    1 7 .5                                427
                                                                                                L in k e d L is ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB


                      (*new_node).value = 10;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      The - > operator is a com bination o fth e * and . operators; il perform s indirection
                      on n e w _ n o d e to locate the structure that it points to, then selects the v a l u e
                      m em ber of the structure.aZYXWVUTSRQPONMLKJIHGFEDCBA
lv a lu e s > 4 . 2        The -> operator produces an lvalue, so we can use it wherever an ordi­
                      nary variable would be allowed. W e’ve ju st seen an exam ple in which
                      n e w _ n o d e - > v a l u e appears on the left side of an assignm ent. It could just as
                      easily appear in a call of s c a n f :

                      scanf("%d", &new_node->value);

                      Notice that the & operator is still required, even though n e w _ n o d e is a pointer.
                                                                     value o f n e w _ n o d e - > v a l u e , which
                      W ithout the &, w e’d be passing s c a n f the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                      has type i n t .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                      I n s e r t in g a N o d e a t th e B e g in n in g o f a L in k e d L is t

                      One of the advantages o f a linked list is that nodes can be added at any point in the
                      list: at the beginning, at the end, or anywhere in the middle. The beginning o f a list
                      is the easiest place to insert a node, however, so let’s focus on that case.
                            l f n e w _ n o d e is pointing to the node to be inserted, and f i r s t is pointing to
                      the first node in the linked list, then w e’lJ need two statem ents to insert the node
                      into the list. First, w e’ll modify the new node’s n e x t m em ber to point to the node
                      that was previously at the beginning of the list:

                      new_node->next = first;

                      Second, w e’ll make f i r s t point to the new node:

                      first = new_node;

                           Will these statem ents work if the list is em pty when we insert a node? Yes,
                      fortunately. To make sure this is true, let’s trace the process o f inserting two nodes
                      into an em pty list. W e’ll insert a node containing the num ber lO first, followed by a
                      node containing 20. In the figures that follow, null pointers are shown as diagonal
                      lines.

                      first = NULL;                                                      f~7|
                                                                                 first



                                                                             new node


                      new node = malloc(sizeof(struct node));
                                                                                 first



                                                                             new node
4 2 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 7    A d v a n c e d U s e s o f P o in te r s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     new_node->value = 10;




                                     new_node->next = first;
                                                                                                          first



                                                                                                      new_node


                                     first = new_node;
                                                                                                          first



                                                                                                      new node


                                     new_node = malloc(sizeof(struct node));
                                                                                                          first



                                                                                                      new_node


                                     new_node->value = 20;
                                                                                                          first



                                                                                                      new node


                                     new_node->next = first;
                                                                                                          first



                                                                                                      new_node


                                     first = new'_node;
                                                                                                          firstonmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                                                                      new node



                                          Inserting a node into a linked list is such a com m on operation that w e'll probably
                                     want to w rite a function for that purpose. L et’s name the function a d d _ t o _ l i s t .
                                     Il will have two param eters: l i s t (a pointer to the first node in the old list) and n
                                     (the integer to be stored in the new node).

                                     struct node *add_to_list(struct node *list, int n)

                                        struct node *new_node;
                                        new_node = malloc(sizeof(struct node));
                                        if (new_node == NULL) {
                                          printf("Error: malloc failed in add_to_list\n");
                                          exit(EXIT_FAILURE);
                                                                          1 7 .5   L in k e d L is ts hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                              4 2 9 kjihgfedcbaZYXWVUTSRQP


              new_node->value = n,-
              new_node->next = list;
              return new_node;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          }
          Note that a d d _ t o _ l i s t doesn’t modify the l i s t pointer. Instead, it retum s a
          pointer to the newly created node (now at the beginning o fth e list). When we call
          a d d _ t o _ l i s t , w e’ll need to store its return value into f i r s t :

          first = add_to_list(first, 10);
          first = add_to_list(first, 20);

          These statements add nodes containing 10 and 20 to the list pointed to by f i r s t .
          Getting a d d _ t o _ l i s t lo update f i r s t directly, rather than return a new value
          for f i r s t , turns out to be tricky. W e'll return to this issue in Section 17.6.
               The following function us^e*'s a d d «M         l i s t to create a linked list containing^^
                                                       ^t o -^^—
          numbers entered by the user:

          struct node *read_numbers(void)

              struct node *first = NULL;
              int n;

              printf("Enter a series of integers (0 to terminate): ”);
              for (;;) {
                scanf("%d*', &n);
                if (n == 0)
                  return first;
                first = add_to_list(first, n);



          The numbers will be in reverse order within the hst, since f i r s t always points to
          the node containing the last number entered.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



          S e a r c h in g a L in k e d L is t

          Once w e’ve created a linked list, we may need to search it for a particular piece of
          data. Although a w h i l e loop can be used to search a list, the f o r statem ent is
          often superior. We’re accustom ed to using the f o r statement when writing loops
          that involve counting, but its flexibility makes the f o r statement suitable for other
          tasks as well, including operations on linked lists. H ere’s the customary way to
          visit thc nodes in a linked list, using a pointer variable p to keep track of the “cur­
          rent” node:

id io m   for (p = first; p != NULL; p - p->next)


          The assi^g-nment

          p = p->next
4 3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 1 7   A d v a n c e d U s e s o f P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     advances the p pointer from one node to the next. An assignment of this form is
                                     invariably used in C when writing a loop that traverses a linked list.
                                          Let’s write a function named s e a r c h _ l i s t that searches a list (pointed to
                                     by the parameter l i s t ) for an integer n. If it finds n. s e a r c h _ l i s t will return
                                     a pointer to the node containing n; otherwise, it will return a null pointer. Our first
                                     version o f s e a r c h _ l i s t relies on the “Jist-traversal” idiom:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     struct node *search_list(struct node *list, int n)

                                         struct node *p;

                                         for (p = list; p >= NULL; p - p->next)
                                           if (p->value == n)
                                             return p;
                                         return NULL;


                                          Of course, there are many other ways to write s e a r c h _ l i s t . One alterna­
                                     tive would be to eliminate the p variable, instead using l i s t itself to keep track of
                                     the current node:

                                     struct node *search_list(struct node *list, int n)

                                         for (; list != NULL; list = list->next)
                                           if (list->value == n)
                                             return list;
                                         return NULL;


                                     Since l i s t is a copy of the original list pointer, there’s no harm in changing it
                                     within the function.
                                           Another alternative is to combine the l i s t - > v a l u e == n test with the
                                     l i s t ! = NULLtest:

                                     struct node *search_list(struct node *list, int n)

                                         for (; list != NULL && list->value != n; list = list->next)
                                             ।
                                         return list;


                                     Since l i s t is NULL ifw e reach the end of the list, returning l i s t is correct even
                                     if we don’t find n. This version of s e a r c h _ l i s t might be a bit clearer if we
                                     used a w h i l e statement:

                                     struct node *search_list(struct node *list, int n)

                                         while (list != NULL && list->value != n)
                                           list = list->next;
                                         return list;
                                     }
                                                                    1 7 .5                             431dcbaZYXWVUTSRQPONM
                                                                             L in k e d L is ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE


D e le ti n g a N o d e fr o m a L in k e d L i s t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

A big advantage of storing data in a linked list is that we can easily delete nodes
that we no longer need. Deleting a node, like creating a node, involves three steps:

     1. Locate the node to be deleted.
     2. Alter the previous node so that it “bypasses” the deleted node.
     3. Call f r e e to reclaim the space occupied by the deleted node.

Step I is harder than it looks. lf w e search the list in the obvious way, w e'll end up
with a pointer to the node to be deleted. Unforiunaiely, we w oift be able to per­
form step 2, which requires changing the previous            node.
                                               cbaZYXWVUTSRQPONMLKJIHGFEDCBA

       There are various solutions to this problem . WeTl use the “trailing pointer”
technique: as we search the list in step I, w e'll keep a pointer to the previous node
( p r e v ) as well as a pointer to the current node ( c u r ) . If l i s t points to the list to
be searched and n is the integer to be deleted, the following loop implem ents step
 1:

for (cur = list, prev = NULL;
     cur != NULL && cur->value 1= n;
     prev = cur, cur = cur->next)
  /

Here we see the power of C ’s f o r statement. This rather exotic example, with its
empty body and liberal use of the comma operator, perform s all the actions needed
to search for n. When the loop term inates, c u r points to the node to be deleted,
while p r e v points to the previous node (if there is one).
     To see how this loop works, let's assume that l i s t points to a list containing
30, 40, 20, and 10, in that order:


                                                               * 20      —


L et’s say that n is 20, so our goal is to delete the third node in the list. After
c u r = l i s t , p r e v = NULL has been executed, c u r points to the first node in
the list:




The test c u r 1= NULL && c u r - > v a l u e 1= n is true, since c u r is pointing to a
node and the node doesn't contain 20. After p r e v = c u r , c u r = c u r - > n e x t
has been executed, we begin to see how the p r e v pointer will trail behind c u r :
4 3 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 1 7   A d v a n c e d U s e s o f P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                     Again, the test c u r != NULL && c u r - > v a l u e != n is true. so p r e v = c u r ,
                                     c u r = c u r - > n e x t is executed once more:




                                     Since c u r now points to the node containing 20, the condition c u r - > v a l u e ’ =
                                     n is false and the loop term inates.
                                          Next, w e’ll perform the bypass required by step 2. The statem entkjihgfedcbaZYXWVUTSRQPONMLKJI

                                     prev->next = cur->next;

                                                                                              a fter the current node:
                                     makes the pointer in the previous node point to the node cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                     W e’re now ready for step 3. releasing the mem ory occupied by thc cu n en t node:

                                     free(cur);

                                         The following function, d e l e t e _ f r o m _ l i s t , uses the strategy that w e’ve
                                    just outlined. When given a list and an in teg ern . the function deletes the first node
                                    containing»- n. If no node contains n . d e l e t e —f r o m —l i s t does nothing«—   ■ . In
                                    either case, the function returns a pointer to the list.

                                     struct node *delete_from_list(struct node *list,                               int n)

                                         struct node *cur,                *prev;

                                         for     (cur = list, prev = NULL;
                                                  cur != NULL && cur->value != n;
                                                  prev = cur, cur = cur->next)
                                                                             17.5   L in k e d L is ts hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                               4 3 3 kjihgfedcbaZYXWVUTSRQP


             if (cur == NULL)
               return list;                                /* n was not found */
             if (prev == NULL)
               list = list->next;                          /* n is in the first node */
             else
               prev->next = cur->next;                     /* n is in some other node */
             free{cur);
             return list;
          }onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

          Deleting the first node in the list is a special case. The p r e v == NULL test checks
          for this case, which requires a different bypass step.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


          O r d e r e d L is ts

          When the nodes of a list are kept in order— sorted by the data stored inside the
                                          o r d e r e d . Inserting a node into an ordered list is more
          nodes— we say that the list is RQPONMLKJIHGFEDCBA
          difficult (the node w on't always be put at lhe beginning o fth e list), but searching is
          faster (we can stop looking after reaching the point al which the desired node
          would have been located). The following program illustrates both the increased
          difficulty of inserting a node and the faster search.


PROGRAM   M a in ta in in g a P a r ts D a t a b a s e ( R e v is it e d )

          Let’s redo the parts database program o fS ectio n l6.3. this time storing the data­
          base in a linked list. Using a linked list instead o fa n array has two m ajor advan­
          tages: (1) We don’t need to put a preset limit on the size of the database; it can
          grow until there's no more memory lo store parts. (2) We can easily keep the data­
          base sorted by part num ber— when a new part is added to the database, we simply
          insert it in its proper place in the list. In the original program , the database w asn’t
          sorted.
               In the new program, the p a r t structure will contain an additional m em ber (a
          pointer to the next node in the linked list), and the variable i n v e n t o r y will be a
          pointer to the first node in the list:

          struct part {
             int number;
             char name[NAME_LEN+1] ;
             int on_hand;
             struct part *next;
          };

          struct part *inventory = NULL;                        /* points to first part */

               Most of the functions in the new program will closely resemble their counter­
          parts in the original program. The f i n d _ p a r t and i n s e r t functions will be
          m orecom plcx. however, since we'U keep the nodes in the i n v e n t o r y list sorted
          by part number.
4 3 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          ln the original program, f i n d _ p a r t returns an index into the i n v e n t o r y
                                    array. In the new program, f i n d _ p a r t will return a pointer to the nodc that con­
                                    tains the desired part number. If it doesn’t find the part number, f i n d _ p a r t will
                                    return a null pointer. Since the i n v e n t o r y list is sorted by part number, the new
                                    version of f i n d _ p a r t can save time by stopping its search when it finds a node
                                    containing a part number that’s greater than or equal to the desired part number.
                                    f i n d _ p a r t ’s search loop will have the form kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    for (p = inventory;
                                         p != NULL && number > p->number;
                                         p = p->next)
                                      /

                                    The loop will terminate when p becomes NULL (indicating that the part number
                                    wasn’t found) or when n u m b e r > p - > n u m b e r is false (indicating that the part
                                    number we’re looking for is less than or equal to a number already stored in a
                                    node). In the latter case, we still don’t know whether or not the desired number is
                                    actually in the list, so we’ll need another test:

                                    if (p ’= NULL && number == p->number)
                                      return p;

                                          The original version of i n s e r t stores a new part in the next available array
                                    element. The new version must determine where the new part belongs in the list
                                    and insert it there. We’ll also have i n s e r t check whether thc part number is
                                    already present in the list, i n s e r t can accomplish both tasks by using a loop sim­
                                    ilar to the one in f i n d _ p a r t :

                                    for (cur = inventory, prev = NULL;
                                         cur ’= NULL && new_node->number > cur->number;
                                         prev - cur, cur = cur->next)
                                         r



                                    This loop relies on two pointers: c u r , which points to the current node. and p r e v ,
                                    which points to the previous node. Once the loop terminates, i n s e r t will check
                                    whether c u r isn’t NULL and n e w _ n o d e - > n u m b e r equals c u r - > n u m b e r : if
                                    so, the part number is already in the list. Otherwise i n s e r t will insert a new node
                                    between the nodes pointed to by p r e v and c u r . using a strategy similar to the one
                                    we employed for deleting a node. fThis strategy works even ifth e new part number
                                    is larger than any in the list: in that case, c u r will be NULL but p r e v will point to
                                    the last node in the list.)
                                          Here’s the new program. Like the original program, this version requires the
                                    r e a d _ l i n e function described in Section 16.3; I assume that r e a d l i n e . h
                                    contains a prototype for this function.BA

              in v e n to ry 2 .c   /★       Maintains a parts database                   (linked list version)    */

                                    #include <stdio.h>
                                    #include <stdlib.h>
                                    #include "readline.h"
                                                                                                          1 7 .5                                       435
                                                                                                                            L in k e d L is t s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDC


#define NAME_LEN 25

struct part {
  int number;
  char name[NAME_LEN+1];
  int on_hand;
  struct part *next;


struct part *inventory = NULL;                                                     /* points to first part */

struct part *find_part(int number);
void insert(void);
void search(void);
void update(void);
void print(void);
I ****************★                   ★ **★ ★ *★ ★ ★ **★ ***★ **★ ********★ *★ ****★ ****★ ★
 * main: Prompts the user to enter an operation code,                                      *
 *      then calls a function to perform the requested                                   *
 *       action. Repeats until the user enters the                                         *
 *       command 'q’. Prints an error message if the user *
 *       enters an illegal code.                                                           *
 *      ** * ** *★ ★ ★ ★ * **** ★ ** **★ * ** *★ * *★ * * *** -fc★ ★ ★ ** ** * *★ * *★ * * ** ** ** *
int main(void)
{
  char code;

      for (;;) {
        printfP’Enter operation code: ”);
        scanf(" %c”, &code);
        while (getchar() != ’\n')        /* skips to end of line */
          •cbaZYXWVUTSRQPONMLKJIHGFEDCBA
          t

        switch (code) {
          case 'i 1 -    . insert () ;
                            break;
          case 's ': search();
                            break;
          case 'u': update();
                            break;
          case ’p ’: print();
                            break;
          case 1q ’: return 0;
          default: printf("Illegal code\n");

        printf(”\n”);



I ★   ★ *★ *★ *********★ ******★ ★ **★ ★ *★ ★ ★ *****★ *★ *★ ★ ★ ★ ★ *★ **★ *****★ *
  * find_part: Looks up a part number in the inventory                                                                                                             *
  *           list. Returns a pointer to the node                                                                                                              *
  *            containing the part number; if the part                                                                                                             *
  *            number is not found, returns NULL.                                                                                                                  *
  *                   * * ★   ★   ★    * ★   * ★   ★   ★   * ★   ★   * * ★   * ★   * ★   * * * *■ ★   ★    ★   ★   ★   ★   * * * * * *   ★   ★   * * ★   * ★   ★   ★   ★   * * ★   ★   ★   ★   ★   * ★   *
4 3 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 17 A d v a n c e d U s e s o f P o in te rs kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    struct part *find_part(int number)

                                                struct part *p;

                                          for (p = inventory;
                                               p != NULL && number > p->number;
                                               p = p->next)

                                          if (p != NULL && number == p->number)
                                            return p;
                                          return NULL;


                                      * ★        ★    ★   ★           ★       ★   ★         ★   ★     ★       ★       ★       ★       ★   ★     ★   ★   ★   * ★       * * * * ★     * * * ★       ★     ★   ★     ★   ★   ★   * ★       ★       ★       ★       * ★     ★   ★   ★   * * ★         ★       ★       ★       ★       ★       ★   ★     ★   ★

                                      * insert: Prompts the user for information about a new                                                                                                                                                                                                                                                            *
                                                part and then inserts the part into the                                                                                                                                                                                                                                                                 *
                                                inventory list; the list remains sorted by                                                                                                                                                                                                                                                              *
                                                part number. Prints an error message and                                                                                                                                                                                                                                                                *
                                                returns prematurely if the part already exists                                                                                                                                                                                                                                                          *
                                                or space could not be allocated for the part.                                                                                                                                                                                                                                                           *
                                      ★     ★   * ★           ★   ★       ★           * ★       * ★       ★       ★       ★       ★       * ★       * * * ★       ★     * * ★   ★   * ★   ★   ★   * ★       * ★       * * ★     ★   ★       ★       ★       ★     * ★       * * ★     ★   ★   ★       ★       ★       ★       ★       ★       * ★       *

                                    void insert(void)

                                          struct part *cur, *prev, *new_node;

                                          new_node = malloc(sizeof(struct part));
                                          if (new_node == NULL) {
                                            printf("Database is full; c a n ’t add more parts.\n");
                                            return;


                                          printf("Enter part number: ");
                                          scanf("%d", &new_node->number);

                                          for (cur = inventory, prev = NULL;
                                               cur 1= NULL && new_node->number > cur->number;
                                               prev = cur, cur = cur->next)

                                          if (cur 1= NULL && new_node->number == cur->number)                                                                                                                                                                                                                                 {
                                            printf("Part already exists.\n");
                                            free(new_node);
                                            return;


                                          printf("Enter part name: ”);
                                          read_line(new_node->name, NAME_LEN);
                                          printf("Enter quantity on hand: ”);
                                          scanf(”%d”, &new_node->on_hand);

                                          new_node->next = cur;
                                          if (prev == NULL)
                                            inventory = new_node;
                                          else
                                            prev->next = new node;
                                                                                                            17.5                                        437PONMLKJIHGFEDCBA
                                                                                                                              L in k e d L is ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGF

I* ★ ★ **++ *+ ★ +** ★ *+ + ++★ ★ +★ ★ * + ★ + **+ + + ★ ★ + +★ + + ★ ★ +★ +★ + +4r★ *★ + ** + + +
 * search: Prompts the user to enter a part number, then *
 *           looks up the part in the database. If the part *
 *               exists, prints the name and quantity on hand;                                   *
 *               if not, prints an error message.                                                *
 ★               *★ ★ *★ ★ **+ **★ ★ ** ★ **+ ★ *★ ★ ★ +k* * *★ ★ ** * ** ★ ★ *★ +** ★ ★ *★ * * *★ -k** ★ ★ ★
void search(void)
{
   int number;
   struct part *p;

   printf("Enter part number: ");
   scanf("%d", &number);
   p = find_part(number);
   if (p != NULL) {
     printf("Part name: %s\n", p->name);
     printf("Quantity on hand: %d\n", p->on_hand);
   } else
     printf("Part not found.\n");


I ★ ★ *★ ★ ★ * ★ ★ ★ ★ ★ ★ * kk* ★ ★ *★ ★ ★ ★ iAr★ ** ★ ★ * ★ ★ ★ ★ ★ ★ ★ ★ ★ ** ★ ★ +★ ★ ★ * ★ ★ *★ ★ ★ ★ ★ ★
   * update: Prompts the user to enter a part number.                                                       *
   *                 Prints an error message if the part doesn't                                             *
   *                 exist; otherwise, prompts the user to enter                                             *
   *                 change in quantity on hand and updates the                                              *
   *                 database.                                                                                 *
   ★ aZYXWVUTSRQPONMLKJIHGFEDCBA
                  *  ★ ★         ★ ★
                        Ar Ar Ar *   Ar   *   Ar *   *   Ar *   ★
                                                                Ar Ar *   *   A: * ★ Ar Ar   Ar Ar *   * -kAr *   Ar *   Ar   *   Ar *   Ar Ar Ar *   Ar Ar *   *   Ar *   Ar Ar Ar Ar *   Ar   ★   k
void update(void)

   int number, change;
   struct part *p;

   printf("Enter part number: ");
   scanf("%d", &number);
   p = find_part (number) ;
   if (p •= NULL) {
     printf("Enter change in quantity on hand: ");
     scanf("%d", &change);
     p->on_hand += change,-
   } else
     printf("Part not found.\n");


/ **★ * *** *** ★ *★ **+* *★ *★ *★ ★ * *★ *★ *★ *** ★ ★ * *★ *★ ★ ★ * * * ** + -fc-k* ** *** *
  * print: Prints a listing of all parts in the database,                                    *
  *          showing the part number, part name, and                                       *
  *           quantity on hand. Part numbers will appear in                                  *
  *           ascending order.                                                               *
  *           **★ -A*★ *★ **+★ * ★ * ★ * ** ic* *★ *★ + ★ +* *+*+ +★ * *+*+ + ★ ‘ kk★ kk★ k k *★ kk★ kk k
void print(void)
{
    struct part *p;
4 3 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r1 7     A d v a n c e d U s e s o f P o in t e r s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         printf("Part Number      Part Name                               "
                                                 ’’Quantity on Hand\n");
                                         for (p = inventory; p != NULL; p = p->next)
                                           printf(*'%7d        %-25s%lld\n", p->number, p->name,
                                                    p->on_hand);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          Notice the use of f r e e in the i n s e r t function, i n s e r t allocates memory
                                     for a part before checking to see if the pan already exists. If it does, i n s e r t
                                     releases the space to avoid a memory leak.aZYXWVUTSRQPONMLKJIHGFEDCBA




                        1 7 .6       P o in te r s to P o in te r s

                                                                                     v f& p o in te r to a pointer. In that section,
                                     ln Section 13.7, \ve came across the notion cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     we used an array whose elements were of type c h a r *: a pointer to one of the
                                     array elements itself had type c h a r **. The concept of “pointers to pointers” also
                                     pops up frequently in the context of linked data structures. In particular, when an
                                     argum ent to a function is a pointer variable, we*lI sometimes want the function to
                                     be able to modify the variable by making it point som ewhere else. Doing so
                                     requires the use of a pointer to a pointer.
                                          Consider the a d d _ t o _ l i s t function o fS ectio n l7.5, which inserts a node
                                     at the beginning of a linked list. When we call a d d _ t o _ l i s t , we pass it a
                                     pointer to the first node in the original list; it then returns a pointer to the first node
                                     in the updated list:

                                     struct node *add_to_list(struct node *list, int n)
                                     {
                                       struct node *new_node;

                                         new_node = malloc(sizeof(struct node));
                                         if (new_node == NULL) {
                                           printf("Error: malloc failed in add_to_list\n");
                                           exit(EXIT_FAILURE) ;
                                         }
                                         new_node->value = n;
                                         new_node->next = list;
                                         return new_node;
                                     }

                                     Suppose that we modify the function so that it assigns n e w _ n o d e to l i s t
                                     instead of returning n e w _ n o d e . In other words, let’s remove the r e t u r n state­
                                     ment from a d d _ t o _ l i s t and replace it by

                                     list = new_node;

                                     Unfortunately, this idea doesn’t work. Suppose that we call a d d _ t o _ l i s t in the
                                     following way:

                                     add_to_list(first, 10);
                                                               1 7 .7   P o in te rs to F u n c tio n s hgfedcbaZYXWVUTSRQPONMLK
                                                                                                                4 3 9 onmlkjihgfedcbaZ


         At the point of the call, f i r s t is copied into l i s t . (Pointers, like all arguments,
         are passed by value.) The last line in the function changes the value of l i s t , mak­
         ing it point to the new node. This assignment doesn't affect f i r s t , however.
              Getting a d d _ t o _ l i s t to modify f i r s t is possible, but it requires pass­
                                          p o in ter to f i r s t . Here’s the correct version o f the func­
         ing a d d _ t o _ l i s t a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         tion:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         void add_to__list(struct node **list, int n)

            struct node *new_node;

            new_node = malloc(sizeof(struct node));
            if (new_node == NULL) {
              printf("Error: malloc failed in add_to_list\n");
              exit(EXIT_FAILURE);

            new_node->value = n;
            new_node->next = *list;
            *list = new_node;


         When we call the new version of a d d —t o _^l i s t , the first ar^g^ument will be the
                                               ^—
         address of f i r s t :

         add_to_list(&first, 10);

         Since l i s t is assig^^'ned the address of f i r s t , * we can use * l i s t as an alias for
         f i r s t . In particular, assigning n e w _ n o d e to * l i s t will modify f i r s t .aZYXWVUTSRQPONMLKJIH




1 7 .7   P o in te r s to F u n c tio n s

         We’vc seen that pointers may point to various kinds of data, including variables,
         array elements, and dynamically allocated blocks of memory. But C doesn’t
         require that pointers point only to data; it’s also possible to have pointers to fu n c ­
         tions. Pointers to functions aren't as odd as you might think. After all, functions
         occupy memory locations, so every function has an address, just as each variable
         has an address.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



         F u n c ti o n P o i n te r s a s A r g u m e n t s

         We can use function pointers in much the same way we use pointers to data. In par­
         ticular, passing a function pointer as an argument is fairly common in C. Suppose
         that we’re writing a function named i n t e g r a t e that integrates a mathematical
         function f between points a and b. W e’d like to make i n t e g r a t e as general as
         possible by passing it f as an argument. To achieve this effect in C, w e’ll declare f
         to be a pointer to a function. Assuming that we want to integrate functions that have
440 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 1 7   A d v a n c e d U s e s o f P o in te rs


                                  a d o u b l e parameter and return a d o u b l e result, the prototype for i n t e g r a t e
                                  will look like this:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  double integrate(double (*f)(double), double a, double b);

                                  The parentheses around * f indicate that f is a pointer to a function, not a function
                                  that returns a pointer. It’s also legal to declare f as though it were a function:

                                  double integrate(double f(double), double a, double b);

                                  From the com piler’s standpoint, this prototype is identical to the previous one.
                                        When we call i n t e g r a t e , w e’ll supply a function name as the first argu-
             siniunction>23.3     ment. For exam ple, the following call will integrate the s i n (sine) function from 0
                                  to 7t/2:

                                  result = integrate(sin, 0.0, PI / 2);

                                  Notice that there arc no parentheses after s i n . When a function name isn’t fol­
                                  lowed by parentheses, the C com piler produces a pointer to the function instead of
                                  generating code for a function call. In our example, w e’re not calling s i n ; instead,
                                  w e’re passing i n t e g r a t e a pointer to s i n . If this seem s confusing, think of how
                                  C handles arrays. I f a is the name o fa n array, then a [ i ] represents one elem ent of
                                  the array, while a by itself serves as a pointer to the array. In a sim ilar way, if f is a
                                                                    call of the function but f by itself as a p o in te r to the
                                  function, C treats f (x ) as a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  function.
                                       Within the body of i n t e g r a t e , we can call the function that f points to:

                                          (*f) (x) ;

                                  * f represents the function that f points to: x is the argum ent to the call. Thus, dur­
                                  ing the execution of i n t e g r a t e ( s i n , 0 . 0 z P I / 2 ) . each call o f * f is actu­
                                  ally a call of s i n . As an alternative to ( * f ) ( x ) , C allows us to write f (x ) to
                                  call the function that f points to. Although f (x ) looks more natural, I’ll stick
                                  with ( * f ) (x ) as a rem inder that f is a pointer to a function, not a function name.dcbaZYXW


                                  T h e q s o r t F u n c tio n

                                  Although it might seem that pointers to functions aren’t relevant to the average
                                  programmer, that couldn’t be further from the truth. In fact, some o fth e m ost use­
                                  ful functions in the C library require a function pointer as an argument. One of
                        Q&A       these is q s o r t , which belongs to the < s t d l i b . h > header, q s o r t is a general­
                                  purpose sorting function th at’s capable of sorting any array, based on any criteria
                                  that we choose.
                                       Since the elements of the array that it sorts may be of any type— even a struc­
                                  ture or union type— q s o r t must be told how to determ ine which of two array ele­
                                  ments is “smaller." W e’ll provide this information to q s o r t by writing a
                                  co m p a riso n fu n c tio n . When given two pointers p and q to array elem ents, the
                                  comparison function must return an integer that is negative if * p is “less than” *q,
                                                       7 7 .7 ZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                 P o in t e r s t o F u n c t io n s   441 dcbaZYXWVUTSRQPONM


              if *p is ‘‘equal to” *q. and positive if *p is “greater than" *q. The terms “less
        zero onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
        than,” “equal to,” and “greater than” are in quotes because it’s our responsibility to
        determine how *p and * q are compared.
              q s o r t has the following prototype:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

        void qsort(void *base, size_t nmemb, size_t size,
                   int (*compar)(const void *, const void *));

         b a s e must point to the first element in the array. (Ifonly a portion o fth e array is
         to be sorted, we’ll make b a s e point to the first element in this portion.) In the sim ­
          plest case, b a s e isjust the name of the array, nmemb is the number ofelem ents to
         be sorted (not necessarily the number of elements in the array), s i z e is the size of
         each array element, measured in bytes, c o m p a r is a pointer lo the comparison
         function. When q s o r t is called, it sorts the array into ascending order, calling the
         comparison function whenever it needs to compare array elements.
                To sort the i n v e n t o r y array of Section 16.3. we’d use the following call of
          q s o rt:
Q&A cbaZYXWVUTSRQPONMLKJIHGFEDCBA

        qsort(inventory, num_parts, sizeof (structpart) , compare__parts) ;

        Notice that the second argument is n u m _ p a r t s , not MAX_PARTS: we don’t want
        to sort the entire i n v e n t o r y array, just the portion in which parts are currently
        stored. The last argument, c o m p a r e _ p a r t s , is a function that compares two
        p a r t structures.
              Writing the c o m p a r e _ p a r t s function isn’t as easy as you might expect,
        q s o r t requires that its parameters have type v o i d *. but we can’t access the
        members of a p a r t structure through a v o i d * pointer; we need a pointer of type
        s t r u c t p a r t * instead. To solve the problem, we’ll have c o m p a r e _ p a r t s
        assign its parameters, p and q, to variables of type s t r u c t p a r t *, thereby con­
        verting them to the desired type, c o m p a r e _ p a r t s can now use these variables to
        access the members o fth e structures that p and q point to. Assuming that we want
        to sort the i n v e n t o r y array into ascending order by part number, here’s how the
        c o m p a r e _ p a r t s function might look:

        int compare_parts(const void *p, const void *q)

           const struct part *pl = p;
           const struct part *ql = q;

           if (pl->number < ql->number)
             return -1;
           else if (pl->number == ql->number)
             return 0 ;
           else
             return 1;


        The declarations o f p l and q l include the word c o n s t to avoid getting a warning
        from the compiler. Since p and q are c o n s t pointers (indicating thai the objects
442 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs


                                 to which they point should not be modified), they should be assigned only to
                                 pointer variables that are also declared to be c o n s t .
                                      Although this version of c o m p a r e _ p a r t s works, most C programmers
                                 would write the function more concisely. First, notice that we can replace p l and
                                 q l by cast expressions:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                 int compare_parts(const void *p, const void *q)

                                     if (((struct part *) p)->number <
                                          ((struct part *) q)->number)
                                       return -1;
                                     else if (((struct part *) p)->number ==
                                               ((struct part *) q)->number)
                                       return 0;
                                     else
                                       return 1;
                                 }
                                 T heparenthesesaround ( ( s t r u c t p a r t * ) p ) arenecessary;w itlw utthem ,the
                                 compiler would try to cast p - > n u m b e r to type s t r u c t p a r t *.
                                     We can make c o m p a r e _ p a r t s even shorter by removing the i f statements:

                                 int compare_parts(const void *p, const void *q)

                                     return ((struct part *) p)->number -
                                            ((struct part *) q)->number;


                                 Subtracting q ’s pail number from p ’s part number produces a negative result i f p
                                 has a smaller part number, zero if the part numbers are equal, and a positive result
                                 if p has a larger part number. (Note that subtracting two integers is potentially
                                 risky because of the danger ofoverflow. I’m assuming that part numbers are posi­
                                 tive integers, so that shouldn’t happen here.)
                                      To sort the i n v e n t o r y array by part name instead of part number, w e’d use
                                 the following version of c o m p a r e _ p a r t s :

                                 int compare_parts(const void *p, const void *q)

                                     return strcmp(((struct part *) p)->name,
                                                   ((struct part *) q)->name);


                                 All c o m p a r e _ p a r t s has to do is call s t r c m p , which conveniently returns a
                                 negative, zero, or positive result.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                 O th e r U s e s o f F u n c t io n P o in te r s

                                 Although I’ve emphasized the usefulness of function pointers as arguments to
                                 other functions, that’s not all they’re good for. C treats pointers to functions just
                                 like pointers to data: we can store function pointers in variables or use them as ele-
                                                                             17 .7      P o in te rs to F u n c tio n s
                                                                              hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA          4 4 3 onmlkjihgfedcbaZYXWVU

                        ments o f an array or as m em bers of a structure or union. We can even write func­
                        tions that return function pointers.
                             H ere’s an exam ple of a variable that can store a pointer to a function:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE

                        void (*pf)(int);

                        p f can point to any function with an i n t param eter ancl a return type o f v o i d . If
                        f is such a function, we can m a k e p f point to f in the following way:

                        pf = f;

                        Notice that there’s no am persand preceding f . Once p f points to f , we can call f
                        by writing either

                         (*pf) (i) ;

                        or

                        pf(i) ;

                            Arrays whose elem ents are function pointers have a surprising num ber o f
                        applications. For example, suppose that w e’re writing a program that displays a
                        menu of com m ands for the user to choose from. We can w rite functions that im ple­
                        ment these com m ands, then store pointers to the functions in an array:

                        void (*file_cmd[]) (void) = {new__cmd,
                                                     open_cmd,
                                                     close_cmd,
                                                     close_all_cmd,
                                                     save_cmd,
                                                     save_as_cmd,
                                                     save_all_cmd,
                                                     print_cmd,
                                                     exit_cmd
                                                    };

                        If the user selects com m and n , where n falls between 0 and 8, we can subscript the
                        f i l e _ c m d array and call the corresponding function:

                         (*file_cmd[n]) ();              /* or file_cmd[n] (); */

                        O f course, we could get a sim ilar effect with a s w i t c h statem ent. Using an array
                        of function pointers gives us more flexibility, however, since the elem ents of the
                        array can be changed as the program is running.


                       T a b u la ti n g th e T r ig o n o m e t r ic F u n c t i o n s
     P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                        The following program prints tables showing the values o f the c o s , s i n , and t a n
<math.h> header>23.s    functions (all three belong to < m a t h . h> ). The program is built around a function
                        named t a b u l a t e that, when passed a function pointer f , prints a table showing
                        the values of f .
44 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 1 7 A d v a n c e d U s e s o f P o in te r s BA


                 tabulate.C kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                /* Tabulates values of trigonometric functions */

                                  #include <math.h>
                                  #include <stdio.h>

                                  void tabulate(double (*f)(double), double first,
                                                          double last, double incr);

                                  int main(void)
                                  {
                                    double final,             increment,   initial;

                                      printf("Enter initial value:              ");
                                      scanf("%lf", &initial);

                                      printf("Enter final value:             '1 );
                                      scanf("%lf", &final);

                                      pr i n t f ("Enter increment: ");
                                      scanf("%lf", &increment);

                                      p r i n t f (”\n          x          c o s (x)"
                                                   "\n        ------      -------\n");
                                      tabulate(cos            initial,   final, increment);

                                      printf("\n      x                    sin(x)"
                                             "\n   -------                ------- \n") ;
                                      tabulate(sin, initial,             final, increment);

                                      printf("\n      x                    tan (x) "
                                             "\n   -------                  ------\n " ) .
                                      tabulate(tan, initial,             final, increment);

                                      return 0;
                                  }

                                  void tabulate(double (*f)(double), double first,
                                                double last, double incr)
                                  {
                                    double x;
                                    int i, num_intervals;

                                      num__intervals = ceil((last - first) / incr);
                                      for (i = 0; i < = num_intervals; i++) {
                                        x = first + i * incr;
                                        printf("%10.5f %10.5f\n", x, (*f)(x));

                                  }

                                  t a b u l a t e uses the c e i l function, which also in < m a t h .h > . When 4g^-iven an
                                  argument x o f d o u b l e type, c e i l returns the sm allest integer that’s greater than
                                  or equal to x.
                                        H ere’s whal a session with t a b u l a t e . c m iaht look like:
                                                     1 7 .8                                                         4 4 5 kjihgfedcbaZYXWVUTS
                                                              R e s t r ic t e d P o in t e r s ( C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


         Enter initial value: £
         Enter final value: .5
         Enter increment: .1

                  x             c o s (x)

             0.00000          1.00000
             0.10000          0.99500
             0.20000          0.98007
             0.30000          0.95534
             0.40000          0.92106
             0.50000          0.87758

                  x             s i n (x)

             0.00000          0.00000
             0.10000          0.09983
             0.20000          0.19867
             0.30000          0.29552
             0.40000          0.38942
             0.50000          0.47943

                  x             tan (x)

             0.00000          0.00000
             0.10000          0.10033
             0.20000          0.20271
             0.30000          0.30934
             0.40000          0.42279
             0.50000          0.54630aZYXWVUTSRQPONMLKJIHGFEDCBA




1 7 .8   R e s tr ic t e d P o in t e r s ( C 9 9 )

         This section and the next discuss two of C99’s pointer-related features. Both are
         primarily of interest to advanced C programmers: most readers will want to skip
         these sections.
              In C99, the keyword r e s t r i c t may appear in the declaration o f a pointer:
         int * restrict p;

         A pointer that’s been declared using r e s t r i c t is called a restricted     pointer. The
                                                                          cbaZYXWVUTSRQPONMLKJIHGFEDCBA

         intent is that if p points to an object that is later modified, then that object is not
         accessed in any way other than through p. (Alternative ways to access the object
         include having another pointer lo the same object or having p point to a named
         variable.) Having more than one way to access an object is often called aliasing.
              Let’s look at an example of the kind of behavior that restricted pointers are
         supposed to discourage. Suppose that p and q have been declared as follows:

         int * restrict p;
         int * restrict q;
446 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs


                                 Now suppose that p is m ade to point to a dynam ically allocated block of memory:kjihgfedc

                                 p = malloc(sizeof(int));

                                 (A sim ilar situation would arise i f p were assigned the address of a variable or an
                                 array element.) Norm ally it would be legal to copy p into q and then modify the
                                 integer through q:

                                 q = p;
                                 *q = 0;          /* causes undefined behavior */

                                                 Because p is a restricted pointer, however, the effect of executing the statem ent
                                                 * q = 0 ; is undefined. By making p and q point to the same object, we caused *p
                                                 and * q to be aliases.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                          18.2         If a restricted pointer p is declared as a local variable without the e x t e r n
    e x t e r n s to ra g e c la s s > cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                            b io c k s > / 0 . 3 storage class, r e s t r i c t applies only to p when the block in which p is declared
                                                 is being executed. (Note that the body o f a function is a block.) r e s t r i c t can be
                                                 used with function param eters of pointer type, in which case it applies only when
                                                 the function is executing. W hen r e s t r i c t is applied to a pointer variable with
                       fiie s c o p e > 10.2     file scope, however, the restriction lasts for the entire execution of the program.
                                                       The exact rules for using r e s t r i c t are rather complex; see the C99 stan­
                                                 dard for details. There are even situations in which an alias created from a
                                                 restricted pointer is legal. For example, a restricted p o in te rp can be legally copied
                                                 into another restricted pointer variable q, provided that p is local to a function and
                                                 q is defined inside a block nested within the function’s body.
                                                       To illustrate the use o f r e s t r i c t , let’s look at the m em cpy and mem move
    < s t r in g . h > h e a d e r > 2 3 . 6     functions, which belong to the < s t r i n g . h > header, m em cpy has the following
                                                 prototype in C99:

                                 void *memcpy(void * restrict sl,                        const void * restrict s2,
                                              size__t n) ;

                                 m em cpy is sim ilar to s t r c p y , except that it copies bytes from one object to
                                 another ( s t r c p y copies characters from one string into another), s 2 points to the
                                 data to be copied, s l points to the destination of the copy, and n is the num ber of
                                 bytes to be copied. The use of r e s t r i c t with both s l and s 2 indicates that the
                                 source of the copy and the destination shouldn’t overlap. (It doesn't guarantee, that
                                 they don’t overlap, however.)
                                     In contrast, r e s t r i c t doesn’t appear in the prototype for memmove:

                                 void *memmove(void *sl,                  const voi d *s2,           size_t n);

                                 mem move does the same thing as m em cpy: it copies bytes from one place to
                                 another. The difference is that mem move is ^guaranteed
                                                                              ^
                                                                                         to work even if the source
                                 and destination overlap. For example, we could use memmove to shift the elements
                                 o f an array by one position:

                                 int a [100] ;
                                                                                  1 7 .9                                                        447
                                                                                           F le x ib le A r r a y M e m b e r s (C 9 9 ) kjihgfedcbaZYXWVUTSRQPONMLKJ


                                              memmove(&a[0],        &a[l], 99 * sizeof(int));onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              Prior to C99, there was no way to docum ent the difference between m em cp y and
                                              mem move. The prototypes for the two functions were nearly identical:

                                              void *memcpy(void *sl, const void *s2, size_t n);
                                              void *memmove(void *sl, const void *s2, size_t n);

                                              The use of r e s t r i c t in the C99 version of m e m c p y ’s prototype lets the pro­
                                              gram m er know that s l and s 2 should point to objects that d o n 't overlap, or else
                                              the function isn’t oguaranteed to work,
                                                     Although using r e s t r i c t in function prototypes is useful docum entation,
                                              that’s not the prim ary reason for its existence, r e s t r i c t provides inform ation to
                                              the com piler that may enable it to produce more efficient code— a process known
r e g is v e r s to r a g e c ia s s > j& 2       o p tim iza tio n . (The r e g i s t e r storage class serves the sam e purpose.) Not
                                              as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                              every com piler attempts to optimize program s, however, and Lhe ones that do nor­
                                              mally allow thc program m er to disable optim ization. As a result, the C99 standard
                                              guarantees that r e s t r i c t has no effect on the behavior o f a program that con­
                                              form s to the standard: if all uses o f r e s t r i c t are removed from such a program,
                                              it should behave the same.
                                                     Most program m ers w on’t use r e s t r i c t unless they’re fine-tuning a pro­
                                              gram to achieve the best possible perform ance. Still, it’s worth knowing about
                                              r e s t r i c t because it appears in the C99 prototypes for a num ber o f standard
                                              library functions.aZYXWVUTSRQPONMLKJIHGFEDCBA




                              1 7 .9          F le x ib le A r r a y M e m b e r s ( C 9 9 )

                                              Every once in a while, w e’ll need to define a structure that contains an array o fa n
                                              unknown size. For exam ple, we might want to store strings in a form that’s differ­
                                              ent from the usual one. Normally, a string is an array of characters, with a null
                                              character marking the end. However, there are advantages to storing strings in
                                              other ways. One alternative is to store the length o f the string along with the
                                              string’s characters (but with no null character). The length and the characters could
                                              be stored in a structure such as this one:

                                              struct vstring {
                                                int len;
                                                char chars[N];
                                              } !


                                              Here N is a macro that represents the m axim um length of a string. Using a fixed-
                                              length array such as this is undesirable, however, because it forces us to limit the
                                              length of the string, plus it wastes mem ory (since m ost strings w on’t need all N
                                              characters in the array).
                                                    C program m ers have traditionally solved this problem by declaring the length
                                              o f c h a r s to bc 1 (a dummy value) and then dynam ically allocating each string:
4 4 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   struct vstring {
                                       int len;
                                       char chars[1];
                                    };
                                   •««
                                   struct vstring *str = malloc(sizeof(struct vstring) + n - 1);
                                   str->len = n;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    We’re “cheating” by allocating more memory than the structure is declared to have
                                    (in this case, an extra n - 1 characters), and then using the memory to store addi­
                                    tional elements of the c h a r s array. This technique has become so common over
                                    the years that it has a name: the “struct hack.*'
                                          The struct hack isn’t limited to character arrays: it has a variety of uses. Over
                                    time, it has become popular enough to be supported by many compilers. Some
                                    (including GCC) even allow the c h a r s array to have zero length, which makes
                                    this trick a little more explicit. Unfortunately, the C89 standard doesn’t guarantee
                                    that the struct hack will work, nor does it allow zero-length arrays.
                                          In recognition of the struct hack's usefulness. C99 has a feature known as the cbaZYXWV
                                   fle x ib le array m e m b er that serves the same purpose. When Lhe last member of a
                                    structure is an array, its length may be omitted:

                                   struct vstring {
                                     int len;
                                     char chars[];                  /* flexible array member - C99 only */


                                   The length of the c h a r s array isn't determined until memory is allocated for a
                                   v s t r i n g structure, normally using a call o f m a l l o c :

                                   struct vstring *str = malloc(sizeof(struct vstring) + n);
                                   str->len = n;

                                   In this example, s t r points to a v s t r i n g structure in which the c h a r s array
                                   occupies n characters. The s i z e o f operator ignores the c h a r s member when
                                   computing the size of the structure. (A flexible array mem ber is unusual in that it
                                   takes up no space within a structure.)
                                        A few special rules apply to a structure that contains a flexible array member.
                                   The flexible array member must appear last in the structure, and the structure must
                                   have at least one other member. Copying a structure that contains a flexible array
                                   member will copy the other members but not the flexible array itself.
                                        A structure that contains a flexible array member is an in co m p lete type. An
                                   incomplete type is missing part o fth e information needed to determine how much
                                   memory it requires. Incomplete types, which are discussed further in one of the
                                   Q&A questions at the end of this chapter and in Section 19.3. are subject to various
                                   restrictions. In particular, an incomplete type (and hence a structure that contains a
                                   flexible array member) can’t be a member of another structure or an element of an
                                   array. However, an array may contain pointers to structures that have a flexible
                                   array member; Programming Project 7 al the end of this chapter is built around
                                   such an array.
                                                                                                                                               O & A dcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                                                            4 4 9 aZYXWVUTSRQPON




                                                  Q & A

                                        Q:        W h a t d o e s th c NULL m a c r o r e p r e se n t? [p. 4 1 5 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         A:       NULL actually stands for 0. W hen we use 0 in a context where a pointer would bc
                                                  required, C compilers treat it as a null pointer instead o f the integer 0. The NULL
                                                  macro is provided merely to help avoid confusion. The assignmentkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                  P = 0;

                                                  could bc assigning the value 0 to a numeric variable or assigning a null pointer to a
                                                  pointer variable; we can’t easily tell which. In contrast, the assignm ent

                                                  p = NULL;

                                                  makes it clear thai p is a pointer.

                                     *Q :         In th e h e a d e r file s th a t c o m e w ith m y c o m p ile r , NULL is d e fin e d a s fo llo w s:

                                                  #define NULL (void *) 0

                                                  W h a t’s th e a d v a n ta g e o f c a s tin g 0 to v o i d * ?
                                         A:       This trick, which is allowed by the C standard, enables com pilers to spot incorrect
                                                  uses of the null pointer. For exam ple, suppose that we try to assign NULL to an
                                                  integer variable:

                                                  i = NULL;

                                                   IfNULL is defmed as 0, this assignm ent is perfectly legal. But ifNULL is defined
                                                  as ( v o i d *) 0, the com piler can warn us that w e’re assigning a pointer to an inte­
                                                  cg>er variable,
                                                         Defining NULL as ( v o i d *) 0 has a second, more im portant, advantage,hgfedcbaZYXWVUTSR
v a r ia b ie - ie n g th a r g u m e n tiis ts   Suppose that we call a function with a variable-lensth argument list and pass NULL RQPONMLKJIHGFED
                                     ^^26 7                                            ^"
                                                  as one of the arguments. IfNULL is defined as 0, the com piler will incorrectly pass
                                                  a zero integer value. (Tn an ordinary function call, NULL works fine because the
                                                  com piler knows from the function’s prototype that it expects a pointer. W hen a
                                                  function has a variable-length argument list, however, the com piler lacks this
                                                  knowledge.) If NULL is defined as ( v o i d *) 0, the com piler will pass a null
                                                  pointer.
                                                        To make matters even m ore confusing, some header files define NULL lo be
                                                   0L (the l o n g version of 0). This definition, like the definition of NULL as 0, is a
                                                  holdover from C ’s earlier years, when pointers and integers were com patible. For
                                                  most purposes, though, it really d oesn’t m atter how NULL is defined; just think of
                                                  it as a name for the null pointer.

                                        Q:        S in c e 0 is u sed to r e p r e se n t th e n u ll p o in te r , I g u e ss a n u ll p o in te r is j u s t a n
                                                  a d d r e ss w ith all z e r o b its, r ig h t?
4 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 1 7 A d v a n c e d U s e s o f P o in te r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                             A:     Not necessarily. Each C com piler is allowed to represent null pointers in a different
                                    way. and not all compilers use a zero address. For exam ple, som e com pilers use a
                                    nonexistent mem ory address for the null pointer; that way, attem pting to access
                                    memory through a null pointer can be detected by the hardware.
                                         How the null pointer is stored inside the com puter shouldn’t concern us; that’s
                                    a detail for com piler experts to worry about. The important thing is that, when used
                                    in a pointer context, 0 is converted to the proper internal form by the compiler.dcbaZYXWVUTS

                            Q:       Is it a c c e p ta b le to u s e N U L L a s a n u ll c h a r a c te r ?
                             A:                                                                    pointer, not the null char­
                                    Definitely not. NULL is a macro that represents the null cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    acter. Using NULL as a null character will work with some com pilers, but not with
                                    all (since some define NULL as ( v o i d *) 0). In any event, using NULL as any­
                                    thing other than a pointer can lead to a great deal ofconfusion. If you want a name
                                    for the null character, define the following<> macro:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    #define NUL ’\ 0 ’

                           *Q :     W h e n m y p r o g r a m te r m in a te s , I g e t th e m e s s a g e “N u ll p o in te r a ssig n m e n t.”
                                    W h a t d o c s th is m e a n ?
                             A:     This message, which is produced by programs compiled with som e older DOS­
                                    based C compilers, indicates that the program has stored data in mem ory using a
                                    bad pointer (but not necessarily a null pointer). Unfortunately, the m essage isn’t
                                    displayed until the program term inates, so there’s no clue as to which statement
                                    caused the error. The “N u llp o in te r a s s ig n m e n t" message can be caused by a miss­
                                    ing^* & in s c a n f :

                                    scanf("%d", i);                     /* should have been scanf("%d", &i); */

                                    Another possibility is an assignment involving a pointerthat’s uninitialized ornull:

                                    *p = i;             /* p is uninitialized or null */

                           *Q :     H o w d o e s a p r o g r a m k n o w th a t a “ n u ll p o in te r a s s ig n m e n t” h a s o c c u r r e d ?
                             A:     The message depends on the fact that, in the small and medium memory models,
                                    data is stored in a single segment, with addresses beginning at 0. The compiler
                                    leaves a “hole” at the beginning of the data segment— a small block of memory
                                    that’s initialized to 0 but otherw ise isn’t used by the program. When the program
                                    terminates, it checks to see if any data in the “hole” area is nonzero. If so, it must
                                    have been altered through a bad pointer.

                            Q:      Is th e r e a n y a d v a n ta g e to c a s ti n g th e r e tu r n v a lu e o f m a l l o c o r th e o th er
                                    m e m o r y a llo c a t io n fu n c t io n s ? [p . 4 1 6 ]
                             A:     Not usually. Casting the v o i d * pointer that these functions return is unnecessary,
                                    since pointers of type v o i d * are automatically converted to any pointer type
                                    upon assignment. The habit of casting the return value is a holdover from older
                                    versions of C, in which the memory allocation functions returned a c h a r * value,
                                    making the cast necessary. Programs that are designed to be compiled as C++ code
                                                                                                                                                     451
                                                                                                                                     Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


                                     may benefit from the cast, but that’s about the only reason to do it.
                                          In C89, there’s actually a sm all advantage to n o t perform ing the cast. Suppose
                                     that w e’ve forgotten to include the < s t d l i b . h > header in our program . W hen
                                     we call m a l l o c , the com piler will assum e that its return type is i n t (the default
                                     return value for any C function). If we don't cast the return value o f m a l l o c , a
                                     C89 com piler wiII produce an error (or at least a warning), since w e’re trying to
                                     assign an integer value to a pointer variable. On the other hand, if we cast the
                                     return value to a pointer, the program may com pile, but likely w on’t run properly.
                                     With C99, this advantage disappears. Forgetting to include the < s t d l i b . h >
                                     header will cause an error when m a l l o c is called, because C99 requires that a
                                     function be declared before it’s called.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      The c a l l o c       fu n c t io n in it ia liz e s a m e m o r y b lo c k b y s e t t in g its b its to z e r o .
                                     D o e s th is m e a n th a t a ll d a ta ite m s in th e b lo c k b e c o m e z e r o ? [p . 4 2 1 ]
                             A:      Usually, but not always. Setting an integer to zero bits always makes the integer
                                     zero. Setting a floating-point num ber to zero bits usually makes the num ber zero,
                                     but this isn’t guaranteed— it depends on how floating-point numbers are stored.
                                     The story is the same for pointers; a pointer whose bits are zero isn’t necessary a
                                     null pointer.

                          *Q :       I s e e h o w th e s tr u c t u r e ta g m e c h a n is m a ll o w s a s t r u c t u r e to c o n ta in a p o in t e r
                                     to its e lf. B u t w h a t i f tw o s t r u c t u r e s e a c h h a v e a m e m b e r th a t p o in ts to th e
                                     o th e r ? [p . 4 2 5 ]
                             A:      H ere’s how w e’d handle that situation:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     struct sl;                /* incomplete declaration of sl */

                                     struct s2 {
                                       •*•
                                       struct S1 *P;

                                     };

                                     struct sl {
                                       •••
                                       struct s2 *q;

                                     };aZYXWVUTSRQPONMLKJIHGFEDCBA

in c o m p ie te ty p e s > r s .s   The first declaration of s l creates an incomplete structure type, since we haven’t
                                     specified the members of s l . The second declaration of s l “com pletes” the type
                                     by describing the mem bers of the structure. Incom plete declarations o f a structure
                                     type are permitted in C, although their uses are limited. Creating a pointer to such a
                                     type (as we did when declaring p ) is one of these uses.

                            Q:       C a ll in g m a l l o c w ith th e w r o n g a r g u m e n t— c a u s in g it to a llo c a t e to o m u c h
                                     m e m o r y o r to o little m e m o r y — s e e m s to b e a c o m m o n e r r o r . Is th e r e a s a f e r
                                     w a y to u s e m a l l o c ? [p . 4 2 6 ]
           C h a p te r 1 7 A d v a n c e d U s e s o f P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
4 5 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                             A:     Yes, there is. Some programmers use the following idiom when calling m a l l o c to
                                    allocate memory for a single object:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    p = malloc(sizeof(*p));

                                    Since s i z e o f (* p ) is the size of the object to which p will point, this statement
                                    guarantees that the correct amount of memory will be allocated. At first glance,
                                    this idiom looks fishy: it's likely that p is uninitialized, making the value of *p
                                    undefined. However, s i z e o f doesn'tevaluate *p, it merely computes its size, so
                                    the idiom works even if p is uninitialized or contains a null pointer.
                                         To allocate memory for an array with n elements, we can use a slightly modi­
                                    fied version of the idiom:

                                    p = malloc(n * sizeof(*p));dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:     W h y is n ’t th e q s o r t fu n c tio n s im p ly n a m e d s o r t ? [p . 4 4 0 ]
                             A:     The name q s o r t comes from the Quicksort algorithm published by C. A. R.
                                    Hoare in l962 (and discussed in Section 9.6). Ironically, the C standard doesn't
                                    require that q s o r t use the Quicksort algorithm, although many versions of
                                    q s o r t do.

                             Q:     I s n ’t it n e c e ss a r y to c a st q s o r t ’s first a r g u m e n t to ty p e v o i d * , a s in th e fo l­
                                    lo w in g e x a m p le ? [p. 4 4 1 ]

                                    qsort((void *) inventory, num_parts, sizeof(struct part),
                                          compare_parts);

                             A:     No. A pointer of any type can be converted to v o i d * automatically.

                           *Q :     I w a n t to u se q s o r t to so r t an a r r a y o f in te g e r s , b u t IT n h a v in g tr o u b le w r it­
                                    in g a c o m p a r is o n fu n c tio n . W h a t’s th c s e c r e t?
                             A:      Here's a version that works:

                                     int compare_ints(const void *p, const void *q)

                                        return *(int *)p - *(int *)q;


                                    Bizarre, eh? The expression ( i n t * ) p casts p to type i n t *, so * ( i n t * ) p
                                    would be the integer that p points to. A word ofw arning, though: Subtracting two
                                    integers may cause overflow. If the integers being sorted are completely arbitrary,
                                    it’s safer to use i f statements to compare * ( i n t * ) p with * ( i n t *) q.

                           *Q :     I n e e d e d to s o r t a n a r r a y o f s tr in g s , so I fig u r e d I ’d ju s t u se s t r c m p a s th e
                                    c o m p a r is o n fu n c tio n . W h e n 1 p a sse d it to q s o r t , h o w e v e r , th e c o m p ile r g a v e
                                    m e a w a r n in g . I tried to lix th e p r o b lem b y e m b e d d in g s t r c m p in a c o m p a r i­
                                    so n fu n c tio n :
                                                                                                                                            453
                                                                                                                     E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJI


                               int compare_strings(const void *p, const void *q)

                                  return strcmp(p, q);


                               N o w in y p r o g r a m c o m p ile s , b u t q s o r t d o e s n ’t s e e m to s o r t th e a r r a y . W h a t
                               a m I d o in g w r o n g ? onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                          A:   First, you can’t pass s t r c m p itself to q s o r t , since q s o r t requires a comparison
                               function with two c o n s t v o i d * parameters. Your c o m p a r e _ s t r i n g s func­
                               tion doesn’t work because it incorrectly assumes that p and q are strings ( c h a r *
                               pointers). In fact, p and q point to array elements containing c h a r * pointers. To
                               fix c o m p a r e _ s t r i n g s , we’II cast p and q to type c h a r * *, then use the *
                               operator to remove one level of indirection:

                               int compare_strings(const void *p, const void *q)

                                  return strcmp(*(char **)p, *(char **)q);
                               }hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                               E x e rc is e s

                              I.    Having to check the return value o f m a l l o c (or any other memory allocation function)
S e c t io n 17.1 ZYXWVUTSRQPONMLKJIHGFEDCBA
                               each lime we call it can be an annoyance. Write a function named m y _ m a llo c that serves
                               as a “wrapper” for m a l l o c . When we call m y _ m a llo c and ask it to allocate n bytes, it in
                               turn calls m a l l o c . tests to make sure that m a l l o c doesn’t return a null pointer, and then
                               returns the pointer from m a l l o c . Have m y _ m a llo c print an error message and terminate
                               the program i f m a l l o c returns a null pointer.

S e c t io n 1 7 .2   ©   2.   Write a function named d u p l i c a t e that uses dynamic storage allocation to create a copy
                               of a string. For example, the call
                               p = duplicate(str);
                               would allocate space for a string o f the same length as s t r . copy the contents of s t r into
                               the new string, and return a pointer lo it. Have d u p l i c a t e return a null pointer if the
                               memory allocation fails.

S e c t io n 1 7 .3       3.   Write the following function:
                               int *create_array(int n, int initial_value);
                               The function should return a pointer to a dynamically allocated i n t array with n members,
                               each of which is initialized to i n i t i a l _ v a l u e . The return value should be NULL ifth e
                               array can’t be allocated.

S e c t io n 1 7 .5       4.   Suppose that the following declarations are in effect:
                               struct point { int PONMLKJIHGFEDCBA
                                                  x, y; };
                               struct rectangle { struct point upper_left, lower_right; };
                               struct rectangle *p;
4 5 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 1 7   A d v a n c e d U s e s o f P o in te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     Assume that we want p to point to a r e c t a n g l e structure whose upper left com er is al
                                     (l0 , 25) and whose lower right com er is at (20, l5). W rite a series ofstatem ents that allocate
                                     such a structure and initialize it as indicated.

                        ©     5.     Suppose that f and p are declared as follows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     struct {
                                       union {
                                         char a t b ;
                                         int c ;
                                         } d;
                                       int e [5] ;
                                     } £ t *p = &f;
                                     Which of the following statem ents are legal?
                                     (a) p->b = ’ ';
                                     (b) p->e [3] = 10;
                                     (c) (*p) .d.a = ’* ';
                                     (d) p->d->c = 20;
                              6.     Modify the d e l e t e _ f r o m _ l i s t function so that it uses only one pointer variable instead
                                     o ftw o ( c u r and p r e v ) .

                        ©     7.     The following loop is supposed to delete all nodes from a linked list and release the memory
                                     that they occupy. Unfortunately, the loop is inconect. Explain w hat's wrong with it and
                                     show how to fix the bug.
                                     for (p - first; p != NULL; p = p->next)
                                       free(p);
                        ©     8.     Section 15.2 describes a file, s t a c k . c , that provides functions for storing integers in a
                                     stack. In that section, the stack was implemented as an array. M odify s t a c k , c so that a
                                     stack is now stored as a linked list. Replace the c o n t e n t s and t o p variables by a single
                                     variable that points to the first node in the list (the “top” of the slack). W rite the functions in
                                     s t a c k . c so that ihey use this pointer. Remove the i s _ f u l l function, instead having
                                     p u s h return either t r u e (if mem ory was available to create a node) or f a l s e (ifnoi).

                              9.    True or false: If x is a structure and a i.s a mem ber o f that structure, then (&x) - > a is the
                                     same as x . a . Justify your answer.

                             10.                                                                                          p o in te r to a
                                    Modify the p r i n t _ j o a r t function of Section 16.2 so that its param eter is a cbaZYXWVUTSRQPONMLKJIHGFED
                                    p a r t slructure. Use the -> operator in your answer.

                             11.    Write lhe following function:
                                     int count_occurrences(struct node *list, int n);
                                     The l i s t parameter points to a linked list: the function should return the num ber of times
                                     that n appears in this list. Assum e that the n o d e slructure is lhe one defined in Section 17.5.

                             12.    W rite the following function:
                                     struct node *find_last(struct node *list, int n);
                                     The l i s t param eter points to a linked list. The function should return a pointer to Lhe last
                                     node that contains n ; it should return NULL i f n doesn't appear in the list. Assum e that the
                                     n o d e structure is the one defined in Section 17.5.

                             13.    The following function is supposed lo insert a new node into its proper place in an ordered
                                     list, returning a pointer to the first node in lhe modified list. Unfortunately, lhe function
                                                                                                                 E x e r c is e s hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                                          4 5 5 onmlkjihgfedcbaZYXWVU


                                doesn’t work correctly in all cases. Explain what’s wrong with it and show how to fix it.
                                Assume that the n o d e structure is the one defined in Section 17.5.
                                s tr u c t node * in s e r t_ in to _ o r d e r e d _ lis t( s tr u c t node * l i s t ,
                                {                                                           s t r u c t n o d e *new _node)
                                   s t r u c t n o d e * c u r = l i s t , * p r e v = NULL;
                                   w h i l e ( c u r - > v a l u e <= n e w _ n o d e - > v a l u e ) {
                                       p rev = c u r;
                                       c u r = c u r-> n e x t;

                                   p re v -> n e x t = new _node;
                                   new _node- > next = c u r ;
                                   r e t u r n l i s t ;aZYXWVUTSRQPONMLKJIHGFEDCBA


S e c t io n 1 7 .6       l4.   Modify the d e l e t e _ f r o m _ l i s t function (Section l7.5) so that its first parameter has
                                type s t r u c t n o d e ** (a pointer to a pointer to the first node in a list) and its return type is
                                v o i d , d e l e t e _ f r o m _ l i s t must modify its first argument to point to the list after the
                                desired node has been deleted.

S e c t io n 1 7 .7   ©   l5.   Show the output of the following program and explain what it does.
                                # in c lu d e   < s td io .h >




                                i n t m a in (v o id )
                                {
                                    p rin tf(" A n s w e r:         % d \n " ,   fl(f2 ));
                                    r e t u r n 0;




                                   i n t n = 0;
                                   w h ile ( ( * f ) ( n ) )        n++;
                                   r e t u r n n,-


                                i n t f 2 (i n t     i)
                                {
                                    re tu rn i       * i      + i    - 12;


                          16.   Write the following function. The call sum ( g , i , j ) should rctum g ( i ) 4-... + g ( j ).
                                in t   s u m (in t        ( * f) (in t),     in t   s ta rt,   in t   e n d );

                      ©   17.                                                                                    last 50 elements
                                Let a be an array of 100 integers. Write a call of q s o r t that sorts only the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                in a. (You don’t need to write the comparison function).

                          18.   Modify the c o m p a r e _ p a r t s function so that parts are sorted with their numbers in
                                descending order.

                          19.   Write a function that, when given a su*ing as its argument, searches the following array of
                                structures for a matching command name, then calls the function associated with that name.
4 5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 17    A d v a n c e d U s e s o f P o in te r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      s tru c t {
                                         c h a r *cm d_nam e;
                                         v o id (* c m d _ p o in te r)( v o id ) ;
                                         f i l e _ c m d []
                                           • ’’n e w ” ,      new _cm d},
                                            ’" o p e n " ,    open_cm d},
                                            ’" c l o s e " ,  c lo s e _ c m d } ,
                                             " c lo s e a l l c lo s e _ a ll_ c m d } ,
                                         "■ s a v e " ,       save_cm d},
                                             "save a s " ,    save_as_cm d},
                                             "save a ll"      s a v e _ a ll_ c m d } ,
                                             " p r i n t ",   p rin t_ c m d } ,
                                             " e x i t ",     e x it_ c m d }
                                           t   aZYXWVUTSRQPONMLKJIHGFEDCBA




                                      P r o g r a m m in g P r o je c t s
                         ©     1.    M odify ihc i n v e n t o r y . c program o f Section 16.3 so that the i n v e n t o r y array is allo­
                                     cated dynamically and later reallocated when it fills up. Usc m a l l o c initially to allocate
                                     enough space for an array of 1 0 p a r t structures. When the array has no more room for new
                                     parts, use r e a l l o c to double its size. Repeat the doubling step each lime the array
                                     becomes full.

                         ©     2.    M odify the i n v e n t o r y . c program of Section 16.3 so that the p (print) com m and calls
                                     q s o r t to sort the i n v e n t o r y array before it prints the parts.
                               3.    M odify lhe i n v e n t o r y 2 . c program o fS eu lio n 17.5 by adding an e (erase) command
                                     that allows the user to remove a part from the database.

                               4.    M odify lhe j u s t i f y program of Section 15.3 by rcwriling the l i n e . c file so that il
                                     stores lhe current line in a linked lisi. Each node in lhe lisl will store a single word. The
                                     l i n e array will be replaced by a variable that points to lhe node containing the first word.
                                     This variable will store a null pointer whenever the line is empty.

                               5.    W rite a program lhat sorts a series of words entered by lhe user:
                                     E n te r        w o rd :   fo o
                                     E n te r        w o rd :   bar
                                     E n te r        w o rd :   baz
                                     E n te r        w o rd :   quux
                                     E n te r        w o rd :

                                      In        s o rte d   o rd e r:   b a r baz    fo o quux
                                     Assume thal each word is no more lhan 20 characters long. Slop reading when the user
                                     enters an empty word (i.e., presses Enter wiihoul entering a word). Store each word in a
                                     dynam ically allocated siring, using an array of pointers lo keep track o f the strings, as in lhe
                                     r e m i n d 2 . c program (Section 17.2). After all words have been read, son the array (using
                                     any sorting technique) and then use a loop to print the words in sorted order. cbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                        H int: Use lhe
                                     r e a d _ l i n e function to read each word, as in r e m i n d 2 . c.

                               6.    Modify Program ming Project 5 so lhat it uses q s o r t to sort the array ofpointers.

                               7.    (C99) Modify the r e m i n d 2 . c program o f Section 17.2 so that each elem ent of lhe
                                     r e m i n d e r s array is a pointer to a v s t r i n g su*ucture (see Section 17.9) raiher lhan a
                                     pointer lo an ordinary siring.
1 8       D e c la r a t io n s                 ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                      M a k in g s o m e th in g v a ria b le is easy.
                                                         C o n tro llin g d u ra tio n o f c o n s ta n c y is th e trick. onmlkjihgfedcbaZYXW




          Declarations play a central role in C programming. By declaring variables and
          functions, we furnish vital information that the compiler will need in order to
          check a program for potential errors and translate it into object code.
               Previous chapters have provided examples of declarations without going into
          full details: this chapter Fills in the gaps. It explores the sophisticated options that
          can be used in declarations and reveals that variable declarations and function dec­
          larations have quite a bit in common. It also provides a firm grounding in the
          important concepts ofstorage duration, scope, and linkage.
               Section l8.l examines the syntax ofdeclarations in their most general form,
          a topic that w e’ve avoided up to this point. The next four sections focus on the
          items that appear in declarations: storage classes (Section 18.2). type qualifiers
          (Section l8.3), declarators (Section l8.4). and initializers (Section l8.5). Section
           l8.6 discusses the i n l i n e keyword, which can appear in C99 function declara­
          tions.




 1 8 .1   D e c la r a tio n S y n ta x

          Declarations furnish information to the compiler about the meaning of identifiers.
          When we write kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

          int i;

          we're informing the compiler that, in the current scope, the name i represents a
          variable of type i n t . The declaration

          float f (float);hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                                                                                    457
             C h a p te r 18 D e c la ra tio n s
4 5 8 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     tells the com piler that f is a function that returns a f l o a t value and has one argu­
                                     ment, also of type f l o a t .
                                           In general, a declaration has the following appearance:aZYXWVUTSRQPONMLKJIHGFEDCBA


               d e c la r a t io n                             declaratio n-specifiers decla ra to rs                      ;


                                     D eclaration sp ecifiers describe the properties of the variables or functions being
                                     declared. D ecla rato rs give their names and may provide additional information
                                     about their properties.
                                          Declaration specifiers fall into three categories:
                                      ■ S torage classes. There are four storage classes: a u t o , s t a t i c , e x t e r n ,
                                        and r e g i s t e r . At most one storage class may appear in a declaration: if
                                        present, it should come first.
                                      ■ Type qualifiers. Tn C89, there are only two type qualifiers: c o n s t and v o l ­
                                        a t i l e . C99 has a third type qualifier, r e s t r i c t . A declaration may con­
                                        tain zero or more type qualifiers.
                                      ■ Type specifiers. The keywords v o i d , c h a r , s h o r t , i n t , l o n g , f l o a t ,
                                        d o u b l e , s i g n e d , and u n s i g n e d are all type specifiers. These words may
                                        be combined as described in Chapter 7: the order in which they appear doesn’t
                                        matter ( i n t u n s i g n e d l o n g is the same as l o n g u n s i g n e d i n t ) . Type
                                        specifiers also include specifications of structures, unions, and enum erations
                                        ( f o r e x a m p l e . s t r u c t p o i n t { i n t x , y ; } . s t r u c t { i n t x , y ; } .o r
                                        s t r u c t p o i n t ) . Type names created using t y p e d e f are type specifiers as
                                        well.
                         <*ffi>      (C99 has a fourth kind of declaration specifier, th s fu n c tio n specifier, which is
                                     used only in function declarations. This category has just one member, the key­
                                     word i n l i n e . ) Type qualifiers and type specifiers should follow the storage class,
                                     but there are no other restrictions on their order. As a matter of style. I’ll put type
                                     qualifiers before type specifiers.
                                          Declarators include identifiers (names of simple variables), identifiers fol­
                                     lowed by [] (array names), identifiers preceded by * (pointer names), and identifi­
                                     ers followed by () (function names). Declarators are separated by commas. A
                                     declarator that represents a variable may be followed by an initializer.
                                          L et’s look at a few examples that illustrate these rules. H ere’s a declaration
                                     with a storage class and three declarators:hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                   s to ra g e c la s s              d e c la ra to rs kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                            iPONMLKJIHGFEDCBA            / t \
                                                                      static float x, y, *p;
                                                                               t
                                                                                  typ e s p e c ifie r


                                     The following declaration has a type qualifier but no storage class. Tt also has an
                                     initializer:
                                                                                            1 8 .2                                       459hgfedcbaZYXWVUTSRQ
                                                                                                        S to r a g e C la s s e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                      ty p e q u a lifie r            d e c la ra to r
                                               |                              A
                                            const char month[]                            = “January”;
                                                             T
                                                  ty p e s p e c ifie r
                                                                                                        t
                                                                                                  in itia liz e r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


          The following declaration has both a storage class and a type qualifier. It also has
          three type specifiers; their order isn’t important:

                               s to ra g e c la s s                        typ e s p e c ifie rs
                                        i

                                  extern const unsigned long int a[10];
                                                        T
                                              typ e q u a lifie r
                                                                                                                  t
                                                                                                          d e c la ra to r


          Function declarations, like variable declarations, may have a storage class, type
          qualifiers, and type specifiers. The following declaration has a storage class and a
          type specifier:

                                               s to ra g e c la s s                 d e c la ra to r
                                                         i                                  !
                                                  extern int square(int);
                                                                     A
                                                                      I
                                                             typ e s p e c ifie r


               The next four sections cover storage classes, type qualifiers, declarators, and
          initializers in detail.aZYXWVUTSRQPONMLKJIHGFEDCBA




1 8 .2    S t o r a g e C la s s e s

          Storage classes can be specified for variables and— to a lesser extent— functions
          and parameters. We’ll concentrate on variables for now.
               Recall from Section 10.3 that the term RQPONMLKJIHGFEDCBA
                                                            b l o c k refers to the body of a function
          (the part enclosed in braces) or a compound statement, possibly containing decla-
 <*ffi>   rations. In C99, selection statements ( i f and s w i t c h ) and iteration statements
          ( w h i l e , do, and f o r ) — along with the “inner” statements diat they control— are
 Q&A      considered to be blocks as well, although this is primarily a technicality.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


          P r o p e r t ie s o f V a r ia b le s
          Every variable in a C program has three properties:
                                      The storage duration of a variable determines when mem­
            ■ S to r a g e d u r a tio n .
                ory is set aside for the variable and when that memory is released. Storage for
                a variable with a u t o m a t i c s t o r a g e d u r a t i o n is allocated when the surrounding
4 6 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18    D e c la r a tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA


                         Q&A               block is executed: storage is deallocated when oth e block term inates. causingo
                                                                                           static sto ra g e d u ra tio n stays at
                                           the variable to lose its value. A variable with cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           the same storage location as long as the program is running, allowing it to
                                           retain its value indefinitely.
                                        ■ Scope. The scope of a variable is the portion of the program text in which the
                                          variable can be referenced. A variable can have either b lo ck scope (the vari­
                                          able is visible from its point of declaration to the end o f the enclosing block)
                                          o v file scope (the variable is visible from its point of declaration to the end of
                                          the enclosing file).
                                          ■ L in ka g e. The linkage
                         Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBAo f a variable determ ines the extent to which it can be
                                           shared by different parts of a program. A variable with e x te rn a l lin k a g e may
                                           be shared by several (perhaps all) files in a program. A variable with in te rn a l
                                           lin k a g e is restricted to a single file, but may be shared by the functions in that
                                           file. (If a variable with the same name appears in anotherfile, it’s treated as a
                                           different variable.) A variable with no lin k a g e belongs to a single function and
                                           can’t be shared at all.
                                          The default storage duration, scope, and linkage o f a variable depend on where
                                    it’s declared:

                                        ■ Var iables declared insid e a block (including a function body) have a u to m a tic
                                           storage duration, block scope, and no linkage.
                                        ■ Var iables declared outside any block, at the outerm ost level of a program , have
                                           static storage d u r a t i o n , ^ scope, and external linkage.

                                    The following exam ple shows the default properties o fth e variables i and j :

                                                   _ ^ - s ta tic s to ra g e d u ra tio n
                                    in t     i;^ ~ file s c o p e
                                                         e x te rn a l lin k a g e

                                    v o id      f ( v o id )
                                    {                 ^ _ ^ a u to m a tic s to ra g e d u ra tio n

                                         in t     j;- b lo c k s c o p e
                                                      ^ ^ n o lin k a g e
                                    }

                                         For many variables, the default storage duration, scope, and linkage are satis­
                                    factory. When they aren’t, we can alter these properties by specifying an explicit
                                    storage class: a u t o , s t a t i c , e x t e r n , or r e g i s t e r .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    T h e a u t o S to r a g e C la s s

                                    The a u t o storage class is legal only for variables that belong to a block. An a u t o
                                    variable has automatic storage duration (not surprisingly), block scope, and no
                                    linkage. The a u t o storage class is almost never specified explicitly, since it’s the
                                    default for variables declared inside a block.
                                                                                                                    1 8 .2                                   461dcbaZYXWVUTSRQPO
                                                                                                                             S to ra g e C la s s e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                      T h e static S t o r a g e C la s s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      The s t a t i c storage class can be used with all variables, regardless of where
                                      they’re declared, but it has a different effect on a variable declared outside a block
                                                                                                        outside a block, the
                                      than it does on a variable declared inside a block. When used cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      word s t a t i c specifies that a variable has internal linkage. When used inside, a
                                      block, s t a t i c changes the variable's storage duration from automatic to static.
                                      The following figure shows the effect ofdeclaring i and j lo be s t a t i c :

                                                                  ^ ^ - static storage duration
                                      s ta tic           i n t i/~ ^ file s c Q p e aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                      ^ in t e r n a l lin k a g e


                                      v o i d f (v o id )
                                      {                               ^ ^ . s ta t ic s to r a g e d u r a t io n

                                                  s ta tic   i n t j;^~ ~ blockscope
                                                                      ^ ^ no linkage
                                      }

                                           When used in a declaration outside a block, s t a t i c essentially hides a vari­
                                      able within the file in which it’s declared: only functions that appear in the same
                                      file can see the variable. In the following example, the functions f l and f 2 both
                                      have access to i . but functions in other files don’t:

                                      s ta tic           in t i;

                                      v o id f l( v o i d )
                                      {
                                          /* h a s a c c e s s t o i * /


                                      v o i d f 2 (v o id )

                                                  /* h a s a c c e s s t o i * /
                                      }

                                      This use of s t a t i c can help implement a technique known as information hid- hgfedcbaZYXWVUTSRQ
in fo rm a tio n h id in g >   19.2   ing.
                                           A s t a t i c variable declared within a block resides at the same storage loca­
                                      tion throughout program execution. Unlike automatic variables, which lose their
                                      values each time the program leaves the enclosing block, a s t a t i c variable will
                                      retain its value indefinitely, s t a t i c variables have som e interesting properties:

                                          ■         A s t a t i c variable in a block is initialized only once, prior to program execu­
                                                    tion. An a u t o variable is initialized every time it comes into existence (pro­
                                                    vided, of course, that it has an initializer).
                                              ■    Each time a function is called recursively, il gets a new set of a u t o variables.
                                                   If it has a s t a t i c variable, on the other hand, that variable is shared by all
                                                   calls o fth e function.
4 6 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18     D e c la ra tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          ■ A Jthough a function shouldn’t return a pointer to an a u t o variable, there’s
                                             nothing wrong with il returning a pointer to a s t a t i c variable.
                                           Declaring one of its variables to be s t a t i c allows a function to retain infor­
                                      mation between calls in a “hidden” area lhat the rest of the program can’t access.
                                      More often, however, we’ll use s t a t i c to make programs more efficient. Con­
                                      sider the following^^ function:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      char digit_to_hex_char(int digit)

                                          const char hex_chars[16] = "0123456789ABCDEF";
                                          return hex_chars [digit] ;


                                      Each time the d i g i t _ t o _ h e x _ c h a r function is called, the characters
                                      0123456789A B C D E F will be copied into the h e x _ c h a r s array to initialize it.
                                      Now, let’s make the array s t a t i c :

                                      char digit__to_hex_char(int digit)

                                          static const char hex_chars[16] = '*0123456789ABCDEF";
                                          return hex_chars[digit] ;
                                      }
                                      Since s t a t i c variables are initialized only once, we’ve improved the speed of
                                      d i g i t _ t o _ h e x _ c h a r .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      T h e e x t e r n S to r a g e C la s s

                                      The e x t e r n storage class enables several source files to share the same variable.
                                      Section l5.2 covered the essentials of using e x t e r n , so 1 won’t devote much
                                      space to it here. Recall that the declaration

                                      extern int i ;

                                      informs the compiler that i is an i n t variable, but doesn't cause it to allocate
                                                                                                       definition of i ; it merely
                                      memory for i . In C terminology, this declaration is not a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      informs the compiler that we need access to a variable that’s defined elsewhere
                                      (perhaps later in the same file, or— more often— in another file). A variable can
                                      have many declarations in a program but should have only one definition.
                                           There’s one exception to the rule that an e x t e r n declaration of a variable
                                      isn’t a definition. An e x t e r n declaration that initializes a variable serves as a def­
                                      inition of the variable. For example, the declaration

                                      extern int i = 0 ;

                                      is effectively the same as

                                      int i = 0;
                                                                                   1 8 .2                                    4 6 3 dcbaZYXWVUTSRQPON
                                                                                            S to ra g e C la s s e s hgfedcbaZYXWVUTSRQPONMLKJIHGFE


         This rule prevents multiple e x t e r n declarations from initializing a variable in
          different ways.
                   A variable in an e x t e r n declaration always has static storage duration. The
          scope of the variable depends on the declaration’s placement. If the declaration is
          inside a block, the variable has block scope; otherwise, it has file scope:
Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                ^ ^ static storage duration
        e x te rn    i n t i ; ^ ~ f i l e s c o p e aZYXWVUTSRQPONMLKJIHGFEDCBA
                                ^ ^    ? lin k a g e


        v o i d f ( v o id )
         {                            _ ^ s t a t ic s t o r a g e d u r a tio n

             e x te rn   i n t j ;^ ^       block scope
                                      ^ ^   ? lin k a g e
         }

        Determining the linkage o fa n e x t e r n variable is a bit harder. If the variable was
        declared s t a t i c earlier in the file (outside of any function definition), then it has
        internal linkage. Otherwise (the normal case), the variable has external linkage.


        T h e r e g i s t e r S t o r a g e C la s s

        Using the r e g i s t e r storage class in the declaration of a variable asks the com ­
        piler to store the variable in a register instead of keeping it in main memory like
                                register is a storage area located in a com puter’s CPU. Data
        other variables. (A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
        stored in a register can be accessed and updated faster than data stored in ordinary
        memory.) Specifying the storage class o f a variable to be r e g i s t e r is a request,
        not a command. The compiler is free to store a r e g i s t e r variable in memory if
        it chooses.
             The r e g i s t e r storage class is legal only for variables declared in a block. A
        r e g i s t e r variable has the same storage duration, scope, and linkage as an a u t o
        variable. However, a r e g i s t e r variable lacks one property that an a u t o vari­
        able has: since registers don’t have addresses, it’s illegal to use the & operator to
        take the address of a r e g i s t e r variable. This restriction appbes even ifth e com ­
        piler has elected to store the variable in memory.
             r e g i s t e r is best used for variables that are accessed and/or updated fre­
        quently. For example, the loop control variable in a f o r statement is a good candi­
        date for r e g i s t e r treatment:

        i n t s u m _ a rra y (in t a [ ] ,            i n t n)

             re g is te r in t i;
             i n t sum = 0 ;

             f o r ( i = 0; i < n ;               i+ + )
                 sum += a [ i ] ;
             r e t u r n sum ;
464 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 18     D e c la ra tio n s


                                       r e g i s t e r isn’t nearly as popular among C programmers as it once was.
                                  Today’s compilers are much more sophisticated than early C compilers; many can
                                  determine automatically which variables would benefit ihe most from being kept in
                                  registers. Still, using r e g i s t e r provides useful information that can help the
                                  compiler optimize the performance of a program. In particular, the compiler knows
                                  that a r e g i s t e r variable can’t have its address taken, and therefore can’t be
                                  modified through a pointer. In this respcct. the r e g i s t e r keyword is related to
                                  C99’s r e s t r i c t keyword.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                   T h e S t o r a g e C la s s o f a F u n c tio n

                                  Function declarations (and definitions), like variable declarations, may include a
                                  storage class, but the only options are e x t e r n and s t a t i c . The word e x t e r n
                                  at the beginning of a function declaration specifies that the function has external
                                        *-e. allV
                                  linkagK       o^wing it to be called from other files, s t a t i c indicates internal link-
                                  age, limiting use of the function's name to the file in which it’s defined. If no stor­
                                  age class is specified, the function is assumed to have external linkage.
                                       Consider the following4v* function declarations:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  extern int f(int i);
                                  static int g(int i);
                                  int h (int i);

                                  f has external linkage, g has internal linkage, and h (by default) has external link­
                                  age. Because it has internal linkage, g can't be called directly from outside the file
                                  in which it's defined. (Declaring g to be s t a t i c doesn’t completely prevent it
                                  from being called in another file: an indirect call via a function pointer is still pos­
                                  sible.)
                                       Declaring functions to be e x t e r n is like declaring variables to be a u t o — it
                                  serves no purpose. For that reason, I don’t use e x t e r n in function declarations.
                                  Be aware, however, that some programmers use e x t e r n extensively, which cer­
                                  tainly does no harm.
                                       Declaring functions to be s t a t i c , on the other hand, is quite useful. In fact. I
                                  recommend using s t a t i c when declaring any function that isn’t intended to be
                                  called from other files. The benefits ofdoing so include:RQPONMLKJIHGFEDCBA
                                                                                                   c^




                                     ■                                 Declaringk^ a function f to be s t a t i c ^g>uarantees that f
                                               E a s ie r m a in te n a n c e .
                                               isn’t visible outside the file in which its definition appears. As a result, some­
                                               one modifying the program later knows that changes to f won’t affect func­
                                               tions in other files. (One exception: a function in another file that’s passed a
                                               pointer to f might be affected by changes to f . Fortunately, that situation is
                                               easy to spot by examining the file in which f is defined, since the function that
                                               passes f must also be defined there.)
                                         ■ R     edu ced      i(
                                                                                    Since functions declared s t a t i c have
                                                                   n a m e space p o llu tio n ”
                                               internal linkage, their names can be reused in other files. Although we proba-
                                                                                            1 8 .2   S to ra g e C la s s e s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                                                      4 6 5 onmlkjihgfedcbaZYXWVUTS


                                 bly wouldn't deliberately reuse a function name for some other purpose, it can
                                 be hard lo avoid in large programs. An excessive number ofnam es with exter­
                                 nal linkage can result in what C programmers call “name space pollution'':
                                 names in different files accidentally conflicting with each other. Using
                                 s t a t i c helps prevent this problem.
                                 Function parameters have the same properties as a u t o variables: automatic
                            storage duration, block scope, and no linkage. The only storage class that can be
                            specified for parameters is r e g i s t e r .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                            Sum m ary

                            Now that we’ve covered the various storage classes, let’s summarize what we
                            know. The following program fragment shows all possible ways to include— or
                            omit— storage classes in declarations ofvariables and parameters.

                            in t a ;
                            e x te rn i n t b;
                            s ta tic in t c ;

                            v o id f ( i n t   d,   re g is te r    i n t e)

                                a u to i n t g;
                                in t h;
                                s ta tic in t i;
                                e x te rn in t j ;
                                r e g is te r in t k;
                            }
                            Table 18.1 shows the properties ofeach variable and parameter in this example.RQPONMLKJIHGFEDCBA

            T a b le 18.1                           N am e     S to r a g e D u ra tio n   S copc    L in k a g e
Properties o f Variables                              a                static               file     external
       and Parameters                                                                       file         j.
                                                      b                static                             i
                                                      c                static               file     internal
                                                      d              autom atic            block       none
                                                      e              autom atic            block       none
                                                      g              autom atic            block       none
                                                      h              autom atic            block       none
                                                      i                static              block       none
                                                      j                static              block          t
                                                      Jr             autom atic            block        none
                                                    r The definitions of b and j aren’t shown, so il’s not
                                                    possible to determ ine the linkage o fth e s e variables. In
                                                    most cases, the variables will bc defined in another file
                                                    and will have external linka^a_e.

                                  Of the four storage classes, the most important are s t a t i c and e x t e r n .
                            a u t o has no effect, and modern compilers have made r e g i s t e r less impor­
                            tant.
4 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18 D e c la ra tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA




                      1 8 .3       T y p e Q u a l i f i e r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                        <*ffi>     There are two type qualifiers: c o n s t and v o l a t i l e . (C99 has a third type qual-
         restrictedpointers>7 zs   ifier, r e s t r i c t , which is used only with pointers.) Since the use of v o l a t i l e
                                   is limited to low-level programming, I ’ll postpone discussing it until Section 20.3.
                                   c o n s t is used to declare objects that resemble variables but are “read-only”: a
                                   program may access the value o f a c o n s t object, but can’t change it. For exam­
                                   ple, the declaration kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   const int n = 10;

                                   creates a c o n s t object named n whose value is 10. The declaration
                                   const int tax__brackets[]                           = {750,     2250,     3750,    5250,     7000};

                                   creates a c o n s t array named t a x _ _ b r a c k e t s .
                                        Declaring an object to be c o n s t has several advantages:
                                                 ■   It’s a form of documentation: it alerts anyone reading the program to the read­
                                                     only nature of the object.
                                                 ■ The compiler can check that the program doesn’t inadvertently attempt to
                                                    change the value of the object.
                                             ■       When programs are written for certain types of applications (embedded sys­
                                                     tems, in particular), the compiler can use the word c o n s t to identify data to
                                                     be stored in ROM (read-only memory).

                                        At first glance, it might appear that c o n s t serves the same role as the
                                   # d e f i n e directive, which we’ve used in previous chapters to create names for
                                   constants. There are significant differences between # d e f i n e and c o n s t , how­
                                   ever:

                                     ■               We can use # d e f i n e to create a name for a numerical, character, or string
                                                     constant, c o n s t can be used to create read-only objects of any    type, including
                                                                                                                    cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     arrays, pointers, structures, and unions.
                                         ■           c o n s t objects are subject to the same scope rules as variables; constants cre­
                                                     ated using # d e f i n e aren’t. In particular, we can’t use # d e f i n e to create a
                                                     constant with block scope.
                                     ■ Tli e value of a c o n s t object, unlike the value oi’a macro, can be viewed in a
                                        debugger.   GFEDCBA
                                             o^*dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                         Q&A         ■ Un like macros, c o n s t objects can’t be used in constant expressions. For
                                        example, we can’t write
                                                     const int n = 10;
                                                     int a [n] ;                    /*** W RO NG ***/

                         C 99                        since array bounds must be constant expressions. (In C99, this example would
                                                                      1 8 .4                            467onmlkjihgfedcbaZYXW
                                                                               D e c la ra to rs kjihgfedcbaZYXWVUTSRQPONMLKJIH


                  be legal i f a has automatic storage duration— it would be treated as a variable­
                  length array— but not if it has static storage duration.)
              ■ I t’s legal to apply the address operator (&) to a c o n s t o b jec t since it has an
                 address. A macro doesn't have an address.
              There are no absolute rules that dictate when to use # d e f i n e and when to
         use c o n s t . 1 recommend using # d e f i n e for constants that represent numbers or
         characters. That way. you’ll be able to use the constants as array dim ensions, in
         s w i t c h statements, and in other places where constant expressions are required.aZYXWVUTSRQPONML




1 8 .4   D e c la r a t o r s

         A declarator consists of an identifier (the name of the variable or function being
         declared), possibly preceded by the * symbol or followed by [] or ( ) . By com ­
         bining *, [ ] , and ( ) , we can create declarators of mind-num bing complexity.
              Before we look at the more complicated declarators, let's review the declara­
         tors that w e've seen in previous chapters. In the simplest case, a declarator isju st
         an identifier, like i in the following example:

         int i ;

         Declarators may also contain the symbols *, [ ] , and ( ) :

              ■ A     declarator that begins with * represents a pointer:
                    int *p;

          ■       A declarator that ends with [] represents an array:
                    int a [10] ;
                  The brackets may be left empty ifth e array is a parameter, if it has an initial­
                  izer, or if its storage class is e x t e r n :
                    extern int a [] ;
                  Since a is defined elsewhere in the program, the com piler doesn't need to
                  know its length here. fIn the case o f a multidimensional array, only the first set
                  of brackets can be empty.) C99 provides two additional options for what goes
                  between the brackets in the declaration of an array parameter. One option is
                  the keyword s t a t i c . foUowed by an expression that specifies the array’s
                  minimum length. The other is the * symbol, which can be used in a function
                  prototype to indicate a variable-length array argument. Section 9.3 discusses
                  both C99 features.
              ■     A declarator that ends with () represents a function:
                  int abs(int i);
                  void swap(int *a, int *b);
                  int find largest(int a[], int n);
             C h a p te r 18 D e c la ra tio n s
4 6 8 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        C allows parameter names to be omitted in a function declaration:kjihgfedcbaZYXWVUTSRQPONMLK
                                       int abs(int);
                                       void swap(int ★ , int *);
                                       int find_largest(int [], int);
                                       The parentheses can even be left empty:
                                       int abs();
                                       void swap();
                                       int find_largest();

                                       The declarations in the last group specify the return types of the a b s , sw a p ,
                                       and f i n d _ l a r g e s t functions, but provide no information about their argu­
                                       ments. Leaving the parentheses empty isn’t the same as putting the word
                                       v o i d between them, which indicates that there are no arguments. The empty-
                                       parentheses style of function declaration has largely disappeared. It?s inferior
                                       to the prototype style introduced in C89. since it doesn't allow the compiler to
                                       check whether function cafis have the right arguments.

                                       If all declarators were as simple as these, C programming would be a snap.
                                  Unfortunately, declarators in actual programs often combine the *, [ ] , and 0
                                  notations. We've seen examples ofsuch combinations already. We know that

                                  int *ap[10];

                                  declares an array of l0 pointers to integers. We know that

                                  float *fp(float);

                                  declares a function that has a f l o a t argument and retum s a pointer to a f l o a t .
                                  And, in Section l7.7, we learned that

                                  void (*pf)(int);

                                  declares a pointer to a function with an i n t argument and a v o i d return type.dcbaZYXWVUTSR


                                  D e c ip h e r in g C o m p le x D e c la r a tio n s

                                  So far, we haven’t had loo much trouble understanding<^- declarators. But whal about
                                  declarators like the one in the following declaration?

                                  int *(*x[10])(void);

                                  This declarator combines *, [ ] , and ( ) . so it’s not obvious whether x is a pointer,
                                  an array, or a function.
                                       Fortunately, there are two simple rules that will allow us lo understand any
                                  declaration, no matter how convoluted:

                                    ■ A lw ays read d e c la ra to rsfro m th e insid e out. In other words, locate the identi­
                                      fier that's being declared, and start deciphering the declaration from there.
                                                                    1 8 .4                               469 cbaZYXWVUTSRQPONMLKJI
                                                                              D e c la ra to rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGF


 ■ W hen th e r e ’s a choice, alw ays fa v o r [] a n d () over *, If * precedes the
   identifier and [] follows it, the identifier represents an array, not a pointer.
   Likewise, if * precedes the identifier and () follows it, the identifier repre­
   sents a function, not a pointer. (Of course, we can always use parentheses to
   override the normal priority o f [] and () over *.)

    Let’s apply these rules to our simple examples first. In the declaration kjihgfedcbaZYXWVUTSRQPONMLKJIHGFED

int *ap[10];

the identifier is ap . Since * precedes a p and [] follows it. we give preference to
 [ ] , so a p is an array o fp o in te rs. In the declaration

float *fp(float);

the identifier is f p . Since * precedes f p and () follows it, we give preference to
 ( ) , so f p is & function that returns a pointer.
       The declaration

void (*pf)(int);

is a little trickier. Since * p f is enclosed in parentheses, p f must be a pointer. But
 ( * p f ) is followed by ( i n t ) , so p f must point lo a function with an i n t argu­
ment. The word v o i d represents the return type of this function.
       As the last example shows, understanding a complex declarator often involves
zi<a>zagog^ i ng<> from one side o fth e identifier to the other:

                  void (*pf)(int);hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                              "/               T ype of p f :
                              1- ^ ^        1. p o in te r to
                             ^___^3 2       2. fu n c tio n w ith i n t a rg u m e n t
                     3 x                    3. re tu rn in g v o i d


    L et’s use this zigzagging technique to decipher the declaration given earlier:

int * (*x[10] ) (void) ;

First, we locate the identifier being declared (x). We see that x is preceded by *
and followed by [ ] ; since [] have priority over *, we go right (x is an array).
Next, we go left to find out the type of the elements in the array (pointers). Next,
we go right to find out what kind of data the pointers point to (functions with no
arguments). Finally, we go left to see what each function returns (a pointer to an
i n t ) . Graphically, here’s what the process looks like:

               int * (*x[10])(void);
                           ^ X^                   T yp e o f x:
                             ^ 1               1. a rra y o f
                           2 ^ ^ ^ ^           2. p o in te rs to
                             ^_ _ _ _ ^ 3      3. fu n c tio n s w ith n o a rg u m e n ts
                  4 *^^~                       4. re tu rn in g p o in te r to i n t
4 7 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18    D e c la ra tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          M astering C declarations lakes time and practice. The only good news is that
                                     there are certain things that can't be declared in C. Functions can’t return arrays:kjihgfedc

                                     int f (int) [] ;                     /*** WRONG ***/

                                     Functions can’t return functions:

                                      int g ( i n t ) (int);             /*** WRONG ***/

                                     Arrays offunctions aren’t possible, either:

                                     int a [ 1 0 ] (int);                /*** WRONG ***/

                                     In each case, wc can use pointers to get the desired effect. A function can’t return an
                                     array, but it can return a pcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                    o in te r to an array. A function canT return a function, but
                                     it can return a p o in ter to a function. Arrays of functions aren't allowed, but an array
                                     may contain pointers to functions. (Section l7.7 has an exam ple o f such an array.) dcbaZYX


                                     U s in g T y p e D e fin itio n s to S im p lify D e c la r a tio n s
                                     Some programmers use type definitions to help simplify complex declarations.
                                     Consider the declaration o f x that we examined earlier in this section:

                                     int *(*x [10]) (void) ;

                                     To make x ’s type easier to understand, we could use the follow ing series of type
                                     definitions:

                                     typedef int *Fcn(void);
                                     typedef Fcn *Fcn_ptr;
                                     typedef Fcn_ptr Fcn_ptr_array[10];
                                     Fcn_ptr_array x;

                                     If we read these lines in reverse order, we see that x has type F c n _ p t r _ a r r a y . a
                                     F c n _ p t r _ a r r a y is an array of F c n _ p t r values, a F c n _ p t r is a pointer to
                                     type F c n , and a F c n is a function that has no argum ents and returns a pointer to an
                                     i n t value.aZYXWVUTSRQPONMLKJIHGFEDCBA




                        1 8 .5        In it ia liz e r s

                                     For convenience, C allows us to specify initial values for variables as w e’re declar­
                                     ing them. To initialize a variable, we write the = symbol after its declarator, then
                                     follow that with an iniLializer. (D on't confuse the = symbol in a declaration with
                                     the assignment operator: initialization isn’t the same as assignm ent.)
                                          We’ve seen various kinds of initializers in previous chapters. The initializer
                                     for a simple variable is an expression of the same type as the variable:

                                      int i = 5 / 2;                  /* i is initially 2 */
                                                                                                                           1 8 .5                           471onmlkjihgfedcbaZYXWV
                                                                                                                                    In itia liz e rs kjihgfedcbaZYXWVUTSRQPONMLKJIH


                                                           If the types don't match, C converts the initializer using the same rules as for hgfedcbaZYXWVUTSR
c o n v e r s io n d u r in g a s s ig n m e n t > 7 . 4   aSSignmeilt.'

                                                           int j = 5.5;                /* converted to 5 */

                                                           The initializer for a pointer variable must be a pointer expression of the same type
                                                           as the variable or of type v o i d *:

                                                           int *p = &i;

                                                           The initializer for an array, structure, or union is usually a series of values enclosed
                                                           in braces:

                                                           int a[5] = {1,        2 ,   3 ,   4, 5};dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                           <^p>             In C99, brace-enclosed initializers can have other forms, thanks to designated ini-
    d e s ig n a te d in itia liz e r s > 8 . 1 , 1 6 .1   tializerS.
                                                                 To complete our coverage ofdeclarations, let’s take a look at some additional
                                                            rules that o
                                                                       govern initializers:
                                                             ■ An initializer for a variable with static storag ^ e duration must be constant:

                                                                #define FIRST 1
                                                                #define LAST 100

                                                                static int i = LAST - FIRST + 1;

                                                                Since LAST and F IR S T are macros, the compiler can compute the initial
                                                                value of i (100 - 1 4- 1 = 100). If LAST and F IR S T had been variables, the
                                                                initializer would be illegal.
                                                             ■ If a variable has automatic storage duration, its          initializer need not be con­
                                                                 stant:

                                                                int f (int n)
                                                                {
                                                                  int last = n - 1;
                                                                  •••

                                                             ■ A brace-enclosed initializer for an array, struct ure, or union must contain only
                                                                constant expressions, never variables or function calls:

                                                                #define N 2

                                                                int powers[5] = {1, N, N * N, N * N * N, N * N * N * N};

                                                                Since N is a constant, the initializer for p o w e r s is legal; if N were a variable,
                                            <4jE>               the program wouldn’t compile. In C99, this restriction applies only ifth e vari­
                                                                able has static storage duration.
                                                             ■ The initializer for an automatic structure or uni on can be another structure or
                                                                union:
4 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18    D e c la r a tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 void g(struct part partl)

                                                    struct part part2 = partl;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                 The initializer d oesn't have to be a variable or param eter name, although it
                                                 does need to be an expression of the proper type. For example, p a r t 2 \ s ini­
                                                 tializer could be *p, where p is of type s t r u c t p a r t *, or f ( p a r t l ) ,
                                                 where f is a function that returns a p a r t structure.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            U n in itia liz e d V a r ia b le s

                                            hi previous chapters, w e've implied that uninitialized variables have undefined val­
                                            ues. T h a fs not always true; the initial value of a variable depends on its storage
                                            duration:

                                                                  auiom cuic storage duration have no default initial value. The
                                              ■ Va riables with cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 initial value of an autom atic variable can't be predicted and may be different
                                                 each time the variable comes into existence.
                                              ■ Var iables with staiic storage duration have the value zero by default. Unlike
          c a iio c iu n c tio n > 7 7 .3        memory allocated by c a l l o c , which is simply set to zero bits, a static vari­
                                                 able is correctly initialized based on its type: integer variables are initialized to
                                                 0, floating variables are initialized to 0.0, and pointer variables contain a null
                                                 pointer.
                                                 As a matter of style, it’s better to provide initializers for static variables rather
                                            than rely on the fact that they’re guaranteed to be zero. If a program accesses a
                                            variable that hasn’t been initialized explicitly, someone reading the program later
                                            can’t easily determ ine w hether the variable is assumed to be zero or whether it’s
                                            initialized by an assignm ent somewhere in the program.aZYXWVUTSRQPONMLKJIHGFEDCBA




                             1 8 .6         ln lin e F u n c tio n s (C 9 9 )

                                            C99 function declarations have an additional option that doesn’t exist in C89: they
                                            may contain the keyword i n l i n e . This keyword is a new breed of declaration
                                            specifier, distinct from storage classes, type qualifiers, and type specifiers. To
                                            understand the effect of i n l i n e , w e’ll need to visualize the machine instructions
                                            that are generated by a C com piler to handle the process o fcalIin g a function and
                                            returning^ from a function.
                                                 At the machine level, several instructions may need to be executed to prepare
                                            for the call, the call itself requiresjum ping to the first instruction in the function,
                                            and there may be additional instructions executed by the function itself as it begins
                                            to execute. If the function has arguments, they’ll need to be copied (because C
                                            passes its argum ents by value). Returning from a function requires a sim ilar
                                                                                              1 8 .6   ln lin e F u n c t io n s ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                                                   4 7 3 onmlkjihgfedcbaZYXWVU


                                               amount of effort on both the part of the function that was called and the one that
                                               called it. The cumulative work required to call a function and later return from it is
                                               often referred to as ‘’overhead:’ since it’s extra work above and beyond what the
                                               function is really supposed to accomplish. Although the overhead o f a function call
                                               slows the program by only a tiny amount, it may add up in certain situations, such
                                               as when a function is called millions or billions of times, when an older, slower
                                               processor is in use (as might be the case in an embedded system), or when a pro­
                                               gram has lo meet very strict deadlines (as in a real-time system).
                                                     In C89, the only way to avoid the overhead o fa function call is to use a param-
p a r a m e t e r iz e d m a c r o s > M . 3   elerized macro. Parameterized macros have certain drawbacks, though, C99 offers
                                                                                               in lin e fu n c tio n . The word “inline” sug­
                                               a better solution to this problem: create an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                               gests an implementation strategy in which the compiler replaces each call of thc
                                               function by the machine instructions for the function. This technique avoids the
                                               usual overhead of a function call, although it may cause a minor increase in the
                                               size of the compiled program.
                                                     Declaring a function (o be i n l i n e doesn't actually force the compiler to
                                               “ inline" the function, however. It merely suggests that the com piler should try to
                                               make calls of the function as fast as possible, perhaps by performing an inline
                                               expansion when the function is called. The compiler is free to ignore this sugges­
                                               tion. In this respect, i n l i n e is similar lo the r e g i s t e r and r e s t r i c t key­
                                               words, which the compiler may use to improve the performance o f a program but
                                               may also choose to ignore.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               I n lin e D e fin itio n s

                                               An inline function has the keyword i n l i n e as one of its declaration specifiers:kjihgfedcbaZYXWVUTSRQP

                                               inline double average(double a, double b)

                                                   return (a + b) / 2;
                                               }

                                               H ere’s where things get a bit complicated, a v e r a g e has external linkage, so other
                                               source files may contain calls of a v e r a g e . However, the definition of a v e r a g e
                                               isn’t considered to be an external definition by the compiler (it’s an in lin e d e fin i­
                                               tion instead), so attempting to call a v e r a g e from another file will be considered
                                               an error.
                                                    There are two ways to avoid this error. One option is to add the word s t a t i c
                                               to the function definition:

                                               static inline double average(double a, double b)

                                                   return (a + b) / 2;


                                               a v e r a g e now has internal linkage, so it can’t be called from other files. Other
                                               files may contain lheir own definitions of a v e r a g e , which might be the same as
                                               this definition or mi^gjht be different,
474 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 18     D e c la ra tio n s


                                        The other option is to provide an external definition for a v e r a g e so that calls
                                   are permitted from other files. One way to do this is to write the a v e r a g e func­
                                   tion a second time (without using i n l i n e ) and put the second definition in a dif­
                                   ferent source file. Doing«* so is le^g^al, but it’s not a ^g^ood idea to have two versions of
                                   the same function, because wc can't guarantee that they’ll remain consistent when
                                   the program is modified.
                                        Here’s a better approach. First, w e’ll put the inline definition o f a v e r a g e in a
                                   header file (let’s name it a v e r a g e . h):kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   #ifndef AVERAGE_H
                                   #define AVERAGE_H

                                   inline double average(double a, double b)

                                      return (a + b) / 2;


                                   #endif

                                   Next, we’ll create a matching source file, a v e r a g e . c:

                                   #include "average.h"

                                   extern double average(double a, double b),-

                                   Now. any file that needs lo call the a v e r a g e function may simply include a v e r ­
                                   a g e . h, which contains the inline definition of a v e r a g e . The a v e r a g e . c lilc
                                   contains a prototype for a v e r a g e that uses the e x t e r n keyword, which causes
                                   the definition of a v e r a g e included from a v e r a g e . h to be treated as an exter­
                                   nal definition in a v e r a g e , c.
                                        The general rule in C99 is that if all top-level declarations of a function in a
                                   particular file include i n l i n e but not e x t e r n , then the definition of the function
                                   in that file is inline. If the function is used anywhere in the program (including the
                                   file that contains its inline definition), then an external definition of the function
                                   will need to be provided by some other lile. When the function is called, the com­
                                   piler may choose to perform an ordinary call (using the function’s external defini­
                                   tion) orperform inline expansion (using the function’s inline definition). T here’s no
                                   way to tell which choice Lhe compiler will make, so it’s crucial that the two defini­
                                   tions be consistent. The technique that w eju st discussed (using the a v e r a g e . h
                                   and a v e r a g e . c files) guarantees that the definitions are the same.dcbaZYXWVUTSRQPONMLKJIHG


                                   R e s tr ic ti o n s o n I n li n e F u n c t io n s

                                   Since inline functions are implemented in a way that’s quite different from ordi­
                                   nary functions, they’re subject to different rules and restrictions. Variables with
                                   static storage duration are a particular problem for inline functions with external
                                   linkage. Consequently, C99 imposes the following restrictions on an inline func­
                                   tion with external linkage (but not on one with internal linkage):
                                                                                                                                                      475
                                                                                                                                      Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


                                                ■ The function may not define                a modifiable s t a t i c variable.
                                                ■ The function may not contain references t o variables with internal linkage.
                                              Such a function is allowed to define a variable that is both s t a t i c and c o n s t ,
                                              but each inline definition of the function may create its own copy of the variable.dcbaZYXWVUTSRQPONML


                                              U s in g I n lin e F u n c tio n s w ith G C C

                                              Some compilers, including GCC, supported inline functions prior lo the C99 stan­
                                              dard. As a result, their rules for using inline functions may vary from the stan­
                                              dard. In particular, the scheme described earlier (using the a v e r a g e . h and
                                              a v e r a g e . c files) may not work with these compilers. Version 4.3 of GCC (not
                                              available at the time this book was written) is expected to support inline func­
                                              tions in the way described in the C99 standard.
                                                    Functions that are specified to be both s t a t i c and i n l i n e should work
                                              fine, regardless o fth e version ofG C C . This strategy is legal in C99 as well, so it’s
                                              the safest bet. A s t a t i c i n l i n e function can be used within a sin C   g-le file or
                                              placed in a header file and included into any source file that needs to call the func­
                                              tion.
                                                    There’s another way to share an inline function among multiple files that
                                              works with older versions of GCC but conflicts with C99. This technique involves
                                              putting a definition of the function in a header file, specifying that the function is
                                              both e x t e r n and i n l i n e , then including the header file into any source file that
                                              contains a call of the function. A second copy of the definition— without the words
                                              e x t e r n and i n l i n e — is placed in one of the source files. (That way, if the com­
                                              piler is unable to “inline” the function for any reason, it will still have a definition.)
                                                    A final note about GCC: Functions are “inlined” only when optimization is
                                              requested via the - 0 command-line option.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                              Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              W h y a r e s e le c tio n s ta te m e n ts a n d ite r a tio n s ta t e m e n ts (a n d th e ir “ in n e r ”
                                              s ta te m e n ts ) c o n sid e r e d to b e b lo c k s in C 9 9 ? [p . 4 5 9 ]
                                              This rather surprising rule stems from a problem that can occur when compound
c o m p o u n d lite ra ls > 9 . 3 , 1 6 .2   literals are used in selection statements and iteration statements. The problem has
                                              to do with the storage duration of compound literals, so let’s take a moment to dis­
                                              cuss that issue first.
                                                   The C99 standard states that the object represented by a compound literal has
                                              static storage duration if the compound literal occurs outside the body of a func­
                                              tion. Otherwise, it has automatic storage duration; as a result, the memory occu­
                                              pied by the object is deallocated at the end of the block in which the compound
                                              literal appears. Consider the following function, which returns a p o i n t structure
                                              created using a compound literal:
476 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 18     D e c la ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     struct point create_point(int x, int y)
                                     {
                                       return (struct point) {x, y};


                                     This function works correctly, because the object created by the compound literal
                                     will be copied when the function returns. The original object will no longer exist,
                                     but the copy will remain. Now suppose that we change the function slightly:

                                     struct point *create_point(int x, int y)

                                         return &(struct point)                    {x, y};


                                     This version of c r e a t e _ p o i n t suffers from undefined behavior, because it
                                     returns a pointer to an object that has automatic storage duration and won’t exist
                                     after the function returns.
                                          Now lefs return to the question we started with: Why are selection statements
                                     and iteration statements considered to be blocks? Consider the following example:

                                     /* Example 1 - if statement without braces */

                                     double *coefficients, value;

                                     if (polynomial_selected == 1)
                                       coefficients = (double[3]) {1.5, -3.0, 6.0};
                                     else
                                       coefficients = (double[3]) (4.5, 1.0, -3.5};
                                     value = evaluate_polynomial(coefficients);

                                     This program fragment apparently behaves in the desired fashion (but read on),
                                     c o e f f i c i e n t s will point to one of two objects created by compound literals,
                                     and this object will still exist at the time e v a l u a t e _ p o l y n o m i a l is called.
                                     Now consider what happens if we put braces around the “inner” statements— the
                                     ones controlled by the i f statement:

                                     /* Example 2 - if statement with braces */

                                     double *coefficients, value;

                                     if (polynomial_selected == 1) {
                                       coefficients = (double[3]) {1.5, -3.0, 6.0};
                                     } else {
                                       coefficients = (double[3]) {4.5, 1.0, -3.5};

                                     value = evaluate_polynomial(coefficients);

                                     Now we’re in trouble. Each compound literal causes an object to be created, but
                                     that object exists only within the block formed by the braces that enclose the
                                     statement in which the literal appears. By the time e v a l u a t e _ p o l y n o m i a l is
                                     called, c o e f f i c i e n t s points to an object that no longer exists. The result:
                                     undefined behavior.
                                                                                                                             477
                                                                                                             Q & A onmlkjihgfedcbaZYXWVUTSRQPON


                The creators of C99 were unhappy with this state of affairs, because program ­
           mers were unlikely to expect that simply adding braces within an i f statement
           would cause undefined behavior. To avoid the problem, they decided that the inner
           statements would always be considered blocks. As a result, Example 1 and Exam­
           ple 2 are equivalent, with both exhibiting undefined behavior.
                A similar problem can arise when a compound literal is part of the controlling
           expression of a selection statement or iteration statement. For this reason, each
           entire selection statement and iteration statement is considered to be a block as
           well (as though an invisible set of braces surrounds the entire statement). So, for
           example, an i f statement with an e l s e clause consists of three blocks: each of
           the two inner statements is a block, as is the entire i f statement.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

    Q:     Y ou s a id th a t s to r a g e fo r a v a r ia b le w ith a u to m a t ic s to r a g e d u r a t io n is a llo -
<f f i >   c a te d w h e n th e s u r r o u n d in g b lo c k is e x e c u te d . I s th is tr u e fo r C 9 9 ’s v a r i a b le -
           le n g th a r r a y s? [p . 4 6 0 ]
    A:     No. Storage for a variable-length array isn't allocated at the beginning of the sur­
           rounding block, because the length of the array isn’t yet known. Instead, it’s allo­
           cated when the declaration of the array is reached during the execution of the
           block. In this respect, variable-length arrays are different from all other automatic
           variables.

    Q:     W h a t e x a c t ly is th e d iff e r e n c e b e tw e e n “ s c o p e ” a n d “ lin k a g e ” ? [p . 4 6 0 ]
    A:     Scope is for the benefit of the compiler, while linkage is for the benefit of the
           linker. The compiler uses the scope of an identifier to determ ine whether or not it’s
           legal to refer to the identifier at a given point in a file. When the compiler translates
           a source file into object code, it notes which names have external linkage, eventu­
           ally storing these names in a table inside the object file. Thus, the linker has access
           to names with external linkage; names with internal linkage or no linkage are
           invisible to the linker.

    Q:     I d o n ’t u n d e r s t a n d h o w a n a m e c o u ld h a v e b lo c k s c o p e b u t e x te r n a l lin k a g e .
           C o u ld y o u e la b o r a te ? [p . 4 6 3 ]
     A:    Certainly. Suppose that one source file defines a variable i :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
           int i ;
           Let’s assume that the definition of i lies outside any function, so i has external
           linkage by default. In another file, there's a function f that needs to access i , so
           the body of f declares i as e x t e r n :
           void f (void)

               extern int i ;
               •••


           ln the first file, i has file scope. Within f , however, i has block scope. If other
           functions besides f need access to i , they’ll need to declare il separately. (Or we
4 7 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18    D e c la ra tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     can simply move the declaration of i outside f so that i has file scope.) W hat’s
                                     confusing about this entire business is that each declaration or definition of i
                                     establishes a different scope; sometimes it’s file scope, and som etim es it’s block
                                     scope.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                            *Q :     W h y c a n ’t c o n s t o b je c ts b e u se d in c o n s t a n t e x p r e s s io n s ? c o n s t m e a n s
                                     “ c o n s t a n t,” r ig h t? [p . 4 6 6 ]
                              A:     In C, c o n s t means “read-only,” not “constant.” Let’s look at a few examples that
                                     illustrate why c o n s t objects can’t be used in constant expressions.
                                                                                                               lifetim e, not
                                          To start with, a c o n s t object might only be constant during its cbaZYXWVUTSRQPONMLKJIHGFED
                                     throughout the execution o fth e program. Suppose tha( a c o n s t object is declared
                                     inside a function:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     void f(int n)

                                          const int m = n / 2 ;



                                     When f is called, m will be initialized to the value of n / 2. The value of m will
                                     then remain constant until f returns. When f is called the next time, m will likely
                                     be given a different value. That’s where the problem arises. Suppose that m appears
                                     in a s w i t c h statement:

                                     void f (int n)
                                     {
                                       const int m = n / 2;
                                       •••
                                       switch (...) {

                                             case m: ...              /*** WRONG ***/



                                      }
                                     The value of m won’t be known until f is called, which violates C ’s rule that the
                                     values of case labels must be constant expressions.
                                          Next, let’s look at c o n s t objects declared outside blocks. These objects have
                                     external linkage and can be shared among files. If C allowed the use of c o n s t
                                     objects in constant expressions, we could easily find ourselves in the following sit­
                                     uation:

                                      extern const int n;
                                      int a[n];   /*** WRONG ***/

                                     n is probably defined in another file, making it impossible for the com piler to
                                     determine a ’s length. (I’m assuming that a is an external variable, so it can’t be a
                                     variable-length array.)
                                                                                                                                             479hgfedcbaZYXWVUTSR
                                                                                                                      E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJIH


                                                               If that’s not enough to convince you. consider this: If a c o n s t object is also
                                                      declared to be v o l a t i l e . its value may change at any time during execution.
  v o l a t i l e !y p e q u a lifie r > 2 0 . 3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                       Here’s an example from the C standard:

                                   extern const volatile int real_time_clock;

                                   The r e a l _ t i m e _ c l o c k variable may not be changed by the program (because
                                   it’s declared c o n s t ) , yet its value may change via some other mechanism
                                   (because it’s declared v o l a t i l e ) .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                           Q:      W h y is th e s y n ta x o f d e c la r a to r s s o o d d ?
                           A:      Declarations are intended to mimic use. A pointer declarator has the form *p,
                                   which matches the way the indirection operator will later be applied to p. An array
                                   declarator has the form a [ .. . ] , which matches the way the array will later be sub­
                                   scripted. A function declarator has the form f ( . . . ) , which matches the syntax of a
                                   function call. This reasoning extends to even the most complicated declarators.
                                   Consider the f i l e _ c m d array of Section l7.7, whose elements are pointers to
                                   functions. The declarator for f i l e _ c m d has the form

                                    (*file_cmd[] ) (void)

                                   and a call o fo n e of the functions has the form

                                    (*file_cmd[n])();

                                   The parentheses, brackets, and * are in identical positions.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                   E x e r c is e s

S e c t i o n 1 8 .1         l.    Foreach of the following declarations, identify the storage class, type qualifiers, type speci­
                                   fiers, declarators, and initializers.
                                   (a) static char **lookup(int level);
                                   (b) volatile unsigned long io_flags;
                                   (c) extern char *file_name[MAX_FILES], path[];
                                   (d) static const char token_buf[] = ’"';

S e c tio n 1 8 .2     ©     2.    Answer each of the following questions with auto, extern. register, and/or
                                   static.
                                   (a) Which storage class is used primarily to indicate that a variable or function can be
                                       shared by several files?
                                   (b) Suppose that a variable x is to be shared by several functions in one file but hidden from
                                       functions in other files. Which storage class should x be declared to have?
                                   (c) Which storage classes can alTcci the slorage duration of a variable?

                                   List the storage duration (static or automatic), scope (block or file), and linkage (internal,
                                   external, or none) ofeach variable and parameter in the following tile:
4 8 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 18    D e c la ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     extern float a;
                                     void f (register double b)

                                           static int c;
                                           auto char d;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                        ©      4.    Let f be the following function. Whal will bc the value of f (1 0 ) if f has never been called
                                     before? What will be the value of f (1 0 ) if f has been called five times previously?
                                     int f (int i )

                                           static int j = 0;
                                           return i * j++;


                               5.    State whether each of the following statements is true or false. Justify each answer.
                                     (a)    Every variable with static storage duration has file scope.
                                     (b)    Every variable declared inside a function has no linkage.
                                     (c)    Every variable with internal linkage has static storage duration.
                                     (d)    Every parameter has block scope.

                               6.    The following function is supposed to print an error message. Each m essage is preceded by
                                     an integer, indicating the num ber of times the function has been called. Unfortunately, the
                                     function always displays 1 as the number of the error message. Locate the error and show
                                     how to fix it without making any changes outside the function.
                                     void print_error(const char *message)
                                     {
                                       int n - 1;
                                       printf("Error %d: %s\n”, n++, message);


S e c t io n 1 8 .3            7.    Suppose that we declare x to be a c o n s t object. Which one o f the following statements
                                             \sfalse'?
                                     about x cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     (a)    I f x is of type i n t , it can be used as the value o f a case label in a s w i t c h statem ent.
                                     (b)    The compiler will check that no assignm ent is made to x.
                                     (c)    x is subject to the same scope rules as variables.
                                     (d)    x can be of any type.

S e c tio n 1 8 .4       ©     8.    Write a complete description o f the type of x as specified by each o f the following declara­
                                     tions.
                                     (a) char (*x[10]) (int);
                                     (b) int (*x(int) ) [5] ;
                                     (c) float *(*x(void)) (int);
                                     (d) void (*x(int, void (*y)(int)))(int);

                               9.    Use a series of type definitions to simplify each of the declarations in Exercise 8.

                         ©    l0.    Write declarations for the followingtr” variables and functions:
                                      (a) p is a pointer to a function with a character pointer argument that relurns a character
                                          pointer.
                                                                                                                                       481onmlkjihgfedcbaZYXWVU
                                                                                                               E x e r c is e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                 (b) f is a function with two arguments: p. a pointer to a structure with tag t , and n, a long
                                     integer, f returns a pointer to a function that has no arguments and returns nothing.
                                 (c) a is an array of four pointers to functions that have no arguments and retum nothing.
                                     The elements o f a initially point to functions named i n s e r t , s e a r c h , u p d a t e , and
                                     p rin t.
                                 (d) b is an array of 10 pointers to functions with two i n t arguments that retum structures
                                     with tag t .

                          11.    In Section 18.4, we saw that the following declarations arc illegal:
                                 in t f ( i n t ) [];             /* f u n c t i o n s c a n ’t r e t u r n    a rra y s          */
                                 in t g ( in t ) (in t);          /* f u n c t i o n s c a n ’ t r e t u r n fu n c tio n s       */
                                 in t a [1 0 ](in t);             /* a r r a y e le m e n ts c a n ’t b e f u n c t i o n s       */
                                 We can, however, achieve similar effects by using pointers: a function can return a pcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                           o in te r to
                                 the first clement in an array, a function can return a p o in te r to a function, and the elements
                                 of an array can bc pointers to functions. Revise each of these declarations accordingly.

                         * 12.   (a) Write a complete description of the type of the function f . assuming that it*s declared as
                                 follows:
                                 in t     (* f(flo a t     (* )(lo n g ),   c h a r * ))(d o u b le );
                                 (b) Give an example showing how f would be called.aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 1 8 .5   ©    l3.    Which of the following declarations are legal? (Assume that P I is a macro that represents
                                 3.14l59.)
                                 (a)    c h a r c = 65;
                                 (b)    s t a t i c i n t i = 5, j = i * i ;
                                 (c)    d o u b le d = 2 * P I ;
                                 (d)    d o u b le a n g l e s [ ] = {0, P I / 2 ,      P I,   3 * PI /       2};

                          l4.    Which kind of variables cannot be initialized?
                                 (a)    Array variables
                                 (b)    Enumeration variables
                                 (c)    Structure variables
                                 (d)    Union variables
                                 (e)    None of the above

                     ©    15.    Which property of a variable determines whether or not it has a default initial value?
                                 (a)    Storage duration
                                 (b)    Scope
                                 (c)    Linkage
                                 (d)    Typc
1 9       P r o g r a m D e s ig n                                         ZYXWVUTSRQPONMLKJIHGFEDCBA




                              W h e re v e r th e re is m o d u la rity th e re is th e p o te n tia l fo r m is u n d e rs ta n d in g :
                                                 H id in g in fo rm a tio n im p lie s a n e e d to c h e c k c o m m u n ic a tio n . dcbaZYXWVUTSRQPON




           It’s obvious thai real-world programs are larger than the examples in this book, but
           you may not realizcjust how much larger. Faster CPUs and larger main memories
           have made it possible to write programs that would have been impractical just a
           few years ago. The popularity of graphical user interfaces has added greatly to the
           average length of a program. Most full-featured programs today are at least
             100,000 lines long. Million-line programs are commonplace, and it’s not unheard-
           o f for a program to have 10 million lines or more.
                     Although C wasn’t designed for writing large programs, many large programs
  Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
           have in fact been written in C. It’s tricky, and it requires a great deal o fcare, but it
           can be done. In this chapter. I’ll discuss techniques that have proved lo be helpful
            for writing large programs and show which C features (the s t a t i c storage class,
            for example) are especially useful.
                     Writing large programs (often called “programming-in-the-large”) is quite dif­
           ferent from writing small ones— it’s like the difference between writing a term
           p a p e r(l0 pages double-spaced, ofcourse) and a 1000-page book. A large program
           requires more attention to style, since many people will be working on it. It
           requires careful documentation. It requires planning for maintenance, since it will
            likely bc modified many times.
                     Above all, a large program requires careful design and much more planning
           than a small program. As Alan Kay, the designer of the Smalltalk programming
           language, puts it, “You can build a doghouse out ofanything.’’ A doghouse can be
           built without any particular design, using whatever materials are at hand. A house
           for humans, on the odier hand, is too complex tojust throw together.
                     Chapter 15 discussed writing large programs in C, but it concentrated on lan­
           guage details. In this chapter, we'll revisit the topic, this time focusing on tech­
            niques for good program design. A complete discussion of program design issues
            is obviously beyond the scope of this book. However, I'll try to cover— briefly— hgfedcbaZYXWVUTSRQ



                                                                                                                                 483
484 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 19     P ro g ra m D e s ig n


                                 some important concepts in program design and show how to use them to create C
                                 programs that are readable and maintainable.
                                      Section l9.1 discusses how to view a C program as a collection of modules
                                 that provide services to each other. We’ll then see how the concepts of information
                                 hiding (Section 19.2) and abstract data types (Section 19.3) can improve modules.
                                 By focusing on a single example (a stack data type), Section 19.4 illustrates how
                                 an abstract data type can be defined and implemented in C. Section 19.5 describes
                                 some limitations of C for defining abstract data types and shows how to work
                                 around them.aZYXWVUTSRQPONMLKJIHGFEDCBA




                     19.1        M o d u le s

                                 When designing a C program (or a program in any other language, for that matter),
                                                                                                m odules. A module is a col­
                                 it’s often useful to view it as a number of independent cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 lection of services, some of which are made available to other parts o fth e program
                                 (the clients). Each module has an in terfa ce that describes the available services.
                                 The details of the module— including the source code for the services them­
                                 selves— are stored in the m odule’s im plem entation.
                                       In the context of C, "services” are functions. The interface of a module is a
                                 header file containing prototypes for the functions that will be made available to
                                 clients (source files). The implementation o fa module is a source file that contains
                                 definitions of the module’s functions.
                                       To illustrate this terminology, let’s look at the calculator program that was
                                 sketched in Sections l5.l and l5.2. This program consists of the file c a l c . c .
                                 which contains the m a in function, and a stack module, which is stored in the files
                                 s t a c k . h and s t a c k . c (see the figure at lhc top of the next page), c a l c . c is a
                                 client of the stack module, s t a c k . h is thc interface of the stack module; it sup­
                                 plies everything the client needs to know about the module, s t a c k . c is the
                                 im plem entation o fth e module: it contains definitions o fth e stack functions as well
                                 as declarations of the variables that make up the stack.
                                       The C library is itself a collection of modules. Each header in the library'
                                 serves as the interface to a module, < s t d i o . h>, for example, is the interface to a
                                 module containing I/O functions, while < s t r i n g .h > is the interface to a module
                                 containing strins-handlins
                                             c^    ^<           s^ functions.RQPONMLKJIHGFEDCBA
                                       DividingO a Ip ro og ram into modules has several a*~2dvantages:
                                    ■ A bstraction. If modules are properly designed, we can treat them as abstrac­
                                      tions'. we know what they do, but we don't worry about the details of how
                                      they do it. Thanks to abstraction, it’s not necessary to understand how the
                                      entire program works in order to make changes to one part of it. W hat's more,
                                      abstraction makes it easier for several members of a team to work on the
                                      same program. Once the interfaces for the modules have been agreed upon,
                                      the responsibility for implementing each module can be delegated to a partic-
                                                              19.1                         485
                                                                       M o d u le s kjihgfedcbaZYXWVUTSRQPONMLKJIH




                                                           stack.conmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

    iiIar person. Team m em bers can then work largely independently of one
    another.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
 ■ R eusability, Any module that provides services is potentially reusable in other
   programs. Our stack module, for example, is reusable. Since it’s often hard to
   anticipate the future uses of a module, it’s a good idea to design m odules for
   reusability.
 ■ M a in ta in a b ility, A small bug will usually affect only a single m odule im ple­
   mentation. making^J the bug4«^> easier to locate an<M>d fix. Once the bug has been
   fixed, rebuilding the program requires only a recom pilation of the m odule
   implementation (followed by linking the entire program). On a larger scale,
   we could replace an entire m odule implementation, perhaps to improve per­
   form ance or when transporting the program to a different platform.

     Although all these advantages are important, m aintainability is the most criti­
cal. Most real-world programs are in service over a period of years, during which
bugs are discovered, enhancem ents are made, and m odifications are made to meet
changing requirements. Designing a program in a m odular fashion makes m ainte­
nance much easier. M aintainingO a *p rogOram should be like m aintainingC5 a car— fixing^
a flat tire shouldn’t require overhauling the engine.
4 8 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 19    P ro g ra m D e s ig n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 For an example, we need look no further lhan the i n v e n t o r y program of
                                           Chapters 16 and 17. The original program (Section 16.3) stored part recordsin an
                                           array. Suppose that, after using this program for a while, the custom er objects to
                                           having a fixed limit on the number of parts that can be stored. To satisfy the cus­
                                           tomer, we might switch to a linked list (as we did in Section 17.5). Making this
                                           change required going through the entire program, looking for all places that
                                           depend on the way parts are stored. Ifw e ’d designed the program differently in the
                                           first place— with a separate module dealing with part storage— we would have
                                           only needed to rewrite the implementation of that module, not the entire program.
                                                 Once we’re convinced that m odular design is the way to go, the process of
                                           designing a program boils down to deciding what modules it should have, what
                                           services each module should provide, and how the modules should be interrelated.
                                           W e’ll now look at these issues briefly. For more information about design, consult
                                                                                       F undam entals o fS o ftw a r e Engineering, Sec­
                                           a software engineering text, such as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           ond Edition, by Ghezzi, Jazayeri, and Mandrioli (Upper Saddle River, N.J.: Pren­
                                           tice-Hall. 2003).dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           C o h e s io n a n d C o u p lin g

                                           Good module interfaces aren't random collections of declarations. In a well-
                                           designed program, modules should have two properties:

                                             ■ H ig h cohesion. The elements o feach module should be closely related to one
                                               another; we might think o fth em as cooperating toward a common goal. High
                                               cohesion makes modules easier to use and makes the entire program easier to
                                               understand.
                                             ■ Low coupling. Modules should be as independent o fe a c h other as possible.
                                               Low coupling makes it easier to modify the program and reuse modules.
                                                Does the calculator program have these properties? The stack module is
                                           clearly cohesive: its functions represent operations on a slack. T here’s little cou­
                                           pling in the program. The c a l c . c file depends on s t a c k . h (and s t a c k . c
                                           depends on s t a c k . h , of course), but there are no other apparent dependencies.


                                           T y p e s o f M o d u le s

                                           Because of the need for high cohesion and low coupling, modules tend to fall into
                                           certain typical categories:

                                             ■ A      data p o o l is a collection of related variables and/or constants. In C, a mod­
                                                   ule of this type is often just a header file. From a design standpoint, putting
                                                   variables in header files isn’t usually a good idea, but collecting related con-
      < fio a t.h > h e a d e r > 2 3 .j           stants in a header file can often be useful. In the C library, < f l o a t .h > and
     < iim its .h > h e a d e r > 2 3 .2           < l i m i t s .h > are both data pools.
                                             ■ A     library is a collection of related functions. The < s t r i n g . h > header, for
                                                   example, is the interface to a library ofstring-handling functions.
                                                                                              1 9 .2                                     487onmlkjihgfedcbaZYXWV
                                                                                                       In fo rm a tio n H id in g kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                           ■ An RQPONMLKJIHGFEDCBA
                                                  a b s t r a c t o b j e c t is a collection of functions that operate on a hidden data
                                              structure, (ln this chapter, the term “object" has a different meaning than in
                                              the rest of the book. In C terminology, an object is simply a block of mem­
                                              ory that can store a value. In this chapter, however, an object is a collection
                                              of data bundled with operations on the data, lf the data is hidden, the object
                                              is “abstract.”) The stack module we’ve been discussing belongs to this cate­
                                              gory.
                                           ■ An a b s t r a c t d a t a t y p e ( A D T ) is a type whose representation is hidden. Client
                                              modules can use the type to declare variables, but have no knowledge o f the
                                              structure of those variables. For a client module to perform an operation on
                                              such a variable, it must call a function provided by the abstract data type mod­
                                              ule. Abstract data types play a significant role in modern programming; w e’ll
                                              retum to them in Sections l9 .3 -l9 .5 .aZYXWVUTSRQPONMLKJIHGFEDCBA




                         1 9 .2          In f o r m a t i o n H id in g

                                         A well-designed module often keeps some information secret from its clients. Cli­
                                         ents of our stack module, for example, have no need to know whether the stack is
                                         stored in an array, in a linked list, or in some other form. Deliberately concealing
                                         information from the clients of a module is known as i n f o r m a t i o n h i d i n g . Infor­
                                         mation hiding has two primary advantages:

                                                          lfclients don’t know how the stack is stored, they w on’t be able to
                                           ■ S e c u r ity ,
                                               corrupt it by tampering with its internal workings. To perform operations on
                                               the stack, they’ll have to call functions that are provided by the module
                                               itself— functions that w e’ve written and tested.
                                                           Making changes— no matter how large— to a m odule’s internal
                                           ■ F le x ib ility .
                                               workings won’t be difficult. For example, we could implement the stack as
                                               an array at first, then later switch to a linked list or other representation.
                                               We’ll have to rewrite the implementation of the module, of course, but— if
                                               the module was designed properly— we won't have to alter the m odule’s
                                               interface.
                                              In C, the major tool for enforcing information hiding is the s t a t i c storage hgfedcbaZYXWVUTSR
s ta tic s to r a g e c ia s s > /8 .2   class. Declaring a variable with file scope to be s t a t i c gives it internal linkage,
                                         thus preventing it from being accessed from other files, including clients of the
                                         module. (Declaring a function lo be s t a t i c is also useful— the function can be
                                         directly called only by other functions in the same file.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         A S ta c k M o d u le

                                         To see the benefits of information hiding, let's look at two implementations of a
                                         stack module, one using an array and the other a linked list. The m odule’s header
                                         file will have the following appearance:
4 8 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p t e r 19    P ro g ra m D e s ig n BA


                     Stack.hkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 #ifndef STACK H
                                   #define STACK_H

                                   #include <stdbool.h>                     /* C99 only */

                                   void make_empty(void) ;
                                   bool is_empty(void);
                                   bool is_full(void);
                                   void push(int i);
                                   int pop(void);

                                   #endifonmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   Tve included C99's < s t d b o o l .h > headerso that the i s _ e m p t y and i s
                                   functions can return a b o o l result rather than an i n t value.
                                       Let's First use an array to implement the stack:

                   stack1.c        #include <stdio.h>
                                   #include <stdlib.h>
                                   #include "stack.h"

                                   #define STACK_SIZE 100

                                   static int contents[STACK_SIZE];
                                   static int top = 0;

                                   static void terminate(const char *message)

                                      p r i n t f ("%s\n", message);
                                      exit (EXIT_FAILURE) ;


                                   void make__empty(void)

                                       top = 0;


                                   bool is_empty(void)
                                   {
                                     return top == 0;


                                   bool is_full(void)

                                       return top == STACK_SIZE;


                                   void push(int i)
                                   {
                                     if (is_full())
                                       terminate("Error in push: stack is full.");
                                     contents[top++] = i;
                                                              1 9 .2                                      4 8 9 kjihgfedcbaZYXWVUTS
                                                                       In fo rm a tio n H id in g hgfedcbaZYXWVUTSRQPONMLKJIHGFED


           int pop(void)

              if (is_emptyO)
                terminate("Error in pop: stack is empty.");
              return contents[--top];onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


           The variables that make up the stack ( c o n t e n t s and t o p ) are both declared
           s t a t i c , since there’s no reason for the rest of the program to access them
           directly. The t e r m i n a t e function is also declared s t a t i c . This function isn’t
           part of the m odule’s interface; instead, it’s designed for use solely within the
           implementation of the module.
                 As a matter of style, some programmers use macros to indicate which func­
           tions and variables are “public" (accessible elsewhere in the program) and which
           are “private" (limited to a single file):

           #define PUBLIC /* empty */
           #define PRIVATE static

           The reason for writing PRIVATE instead of s t a t i c is that the latter has more
           than one use in C; PRIVATE makes it clear that w e’re using it to enforce informa­
           tion hiding. Here’s what the stack implementation would look like if we were to
           use PUBLIC and PRIVATE:

           PRIVATE int contents[STACK_SIZE];
           PRIVATE int top = 0;

           PRIVATE void terminate(const char *message)                         { ... }

           PUBLIC void make_empty(void)               { ... }

           PUBLIC bool is_empty(void)               { ... }

           PUBLIC bool is_full (void) { ... }

           PUBLIC void push(int i) { ... }

           PUBLIC int pop(void)           { ... }

                Now w e’Il switch to a linked-list implementation o fth e stack module:BA

Stack2.c   #include <stdio.h>
           #include <stdlib.h>
           #include "stack.h"

           struct node {
              int data;
              struct node *next;
           jt

           static struct node *top = NULL;
490 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 19    P ro g r a m D e s ig n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    static void terminate(const char *message)
                                    {
                                      printf("%s\n", message);
                                      exit(EXIT_FAILURE);


                                   void make_empty(void)

                                        while (*is_empty () )
                                          p o p ();
                                    }

                                   bool is_empty(void)
                                   {
                                     return top == NULL;
                                   }

                                   bool is_full(void)
                                   {
                                     return false;


                                   void push(int i)
                                   {
                                     struct node *new_node = malloc(sizeof(struct node));
                                     if (new_node == NULL)
                                       terminate("Error in push: stack is full.");

                                        new_node->data = i;
                                        new_node->next = top;
                                        top = new_node;


                                    int pop(void)
                                    {
                                      struct node *old_top;
                                      int i ;

                                        if (is_emptyO)
                                          terminate("Error in pop: stack is empty.");

                                        old_top = top;
                                        i = top->data;
                                        top = top->next;
                                        free(old_top);
                                        return i;
                                    }
                                   Note that the i s _ f u l l function returns f a l s e every time it’s called. A linked
                                   list has no limit on its size, so the stack will never be full. It’s possible (but not
                                   likely) that the program might run out of memory, which will cause the p u s h
                                   function to fail, but there’s no easy way to test for that condition in advance.
                                        Our stack example shows clearly the advantage of inform ation hiding: it
                                                         1 9 .3                                           491onmlkjihgfedcbaZYXW
                                                                  A b s t r a c t D a ta T y p e s kjihgfedcbaZYXWVUTSRQPONMLKJI


         doesn’t matter whether we use s t a c k l . c or s t a c k 2 . c to implement the stack
         module. Both versions match the module’s interface, so we can switch from one to
         the other without having to make changes elsewhere in the program.aZYXWVUTSRQPONMLKJIHGFEDCBA



1 9 .3   A b s t r a c t D a ta T y p e s
         A module that serves as an abstract object, like the stack module in the previous
         section, has a serious disadvantage: there’s no way to have multiple instances of
         the object (more than one stack, in this case). To accomplish this, w e’ll need to go
                                         type.
         a step further and create a new cbaZYXWVUTSRQPONMLKJIHGFEDCBA
              Once we've defined a S t a c k type, w e’ll be able to have as many stacks as we
         want. The following fragment illustrates how we could have two stacks in the same
         program:
         Stack sl, s2;

         make_empty(&sl);
         make_empty(&s2);
         push(&sl, 1);
         push(&s2, 2) ;
         if (!is_empty(&sl))
           printf("%d\n", pop(&sl));                 /* prints ”1" */

         We’re not really sure what s l and s 2 are (structures? pointers?), but it doesn’t
         matter. To clients, s l and s 2 are abstractions that respond to certain operations
         (m a k e _ e m p ty , i s _ e m p t y , i s _ f u l l , p u s h , and p o p ).
               Let's convert our s t a c k . h header so that it provides a S t a c k type, where
         S t a c k is a structure. Doing so will require adding a S t a c k (or S t a c k *) param­
         eter to each function. The header will now look like this (changes to s t a c k . h are
         in bold; unchanged portions o fth e header arenT shown):
         #define STACK_SIZE 100

         typedef struct {
           int contents[STACK_SIZE];
           int top;
         } Stack;

         void make_empty(Stack *s);
         bool is_empty(const Stack *s);
         bool is_full(const Stack *s);
         void push(Stack *s, int i);
         int pop(Stack *s);

         The stack parameters to m a k e _ e m p ty , p u s h , and p o p need to be pointers, since
         these functions modify the stack. The parameter to i s _ e m p t y and i s _ f u l l
         doesn’t need to be a pointer, but I’ve made it one anyway. Passing these functions a
         S t a c k poin ter instead of a S t a c k value is more efficient, since the latter would
         result in a structure being copied.
492 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 19    P ro g r a m D e s ig n dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                  E n c a p s u la tio n
                                                                             abstract data type, since s t a c k . h reveals what
                                  Unfortunately, S t a c k isn't an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  the S t a c k type really is. Nothing prevents clients from using a S t a c k variable as
                                  a structure:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  Stack sl;

                                  Sl.top = 0;
                                  sl.contents[top++] = 1;

                                  Providing access to the t o p and c o n t e n t s mem bers allows clients to corrupt the
                                  stack. Worse still, we w on’t be able to change the way stacks are stored without
                                  having to assess the effect o f the change on clients.
                                       What we need is a way to prevent clients from knowing how the S t a c k type
                                  is represented. C has only lim ited support for e n c a p su la tin g types in this way.
                                  Newer C-based languages, including C++, Java, and C#, are better equipped for
                                  this purpose.


                                  I n c o m p le te T y p e s aZYXWVUTSRQPONMLKJIHGFEDCBA
                                  The only tool that C gives us for encapsulation is the in co m p lete type. (Incom plete
                                  types were mentioned briefly in Section 17.9 and in the Q&A section at the end of
                                  Chapter 17.) The C standard describes incomplete types as “types that describe
                        Q&A       objects but lack inform ation needed to determ ine their sizes.’’ For exam ple, the
                                  declaration

                                  struct t;            /* incomplete declaration of t ★ /

                                  tells the com piler that t is a structure tag but doesn’t describe the members of the
                                  structure. As a result, the com piler doesn’t have enough inform ation to determ ine
                                  the size ofstich a structure. The intent is that an incomplete type will be com pleted
                                  elsewhere in the program.
                                        As long as a type rem ains incomplete, its uses are limited. Since the com piler
                        Q&A       doesn’t know the size o fa n incom plete type, it can’t be used to declare a variable:

                                  struct t S;              /*** WRONG ***/

                                  However, it’s perfectly legal to define a pointer type that references an incom plete
                                  type:

                                  typedef struct t *T;

                                  This type definition states that a variable of type T is a pointer to a structure with
                                  tag t . We can now declare variables of type T. pass them as argum ents to func­
                                  tions, and perform other operations that are legal .for pointers. (The size of a
                                  pointer doesn’t depend on what it points lo. which explains why C allows this
                                  behavior.) W hat wc can’t do. though, is apply the - > operator to one of these vari­
                                  ables. since the com piler knows nothing about the members of a t structure.
                                                           19.4    A S ta c k A b s tr a c tD a ta T y p e hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                   4 9 3 aZYXWVUTSRQPONML




      1 9 .4      A S t a c k A b s t r a c t D a ta T y p e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  To illustrate how abstract data types can be encapsulated using incom plete types,
                  w e’ll develop a stack ADT based on the stack module described in Section l9.2. In
                  the process, we*ll explore three different ways to implement the stack.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                  D e fin in g th e I n te r fa c e fo r th e S ta c k A D T
                  First, w e’ll need a header file that defines our stack ADT type and gives prototypes
                  for the functions that represent slack operations. L et's name this file s t a c k -
                  A D T. h. The S t a c k type will be a pointer to a s t a c k _ t y p e structure that stores
                  the actual contents of the stack. This structure is an incom plete type that will be
                  completed in the file that im plem ents the stack. The m em bers o f this structure will
                  depend on how the stack is im plemented. H ere’s what the s t a c k A D T .h file will
                  look like:BA

stackADT.h #ifndef STACKADT_H
 (version 1)kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                #define STACKADT H

                  #include <stdbool.h>               /* C99 only */

                  typedef struct stack_type *Stack;

                  Stack create(void);
                  void destroy(Stack s);
                  void make_empty(Stack s);
                  bool is_empty(Stack s);
                  bool is_full(Stack s);
                  void push(Stack s, int i ) ;
                  int pop(Stack s);

                  #endif

                  Clients that include s t a c k A D T .h will be able to declare variables o f type
                  S t a c k , each ofw hich is capable ofpointing to a s t a c k _ t y p e structure. Clients
                  can then caH the functions declared in s t a c k A D T .h to perform operations on
                  stack variables. However, clients can’t access the mem bers of the s t a c k _ t y p e
                  structure, since that structure will be defined in a separate file.
                         Note that each function has a S t a c k param eter or returns a S t a c k value.
                  The stack functions in Section 19.3 had parameters of type S t a c k *. The rea­
                  son for the difference is that a S t a c k variable is now a pointer; it points to a
                  s t a c k _ t y p e structure that stores the contents of the stack. If a function needs
                  to modify the stack, it changes the structure itself, not the poinler to the struc­
                  ture.
                         Also note the presence of the c r e a t e and d e s t r o y functions. A m odule
494 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 19     P ro g ra m D e s ig n


                                 generally doesn’t need these functions, but an A D T does, c r e a t e will dynam i­
                                 cally allocate m em ory for a stack (including the m em ory required for a
                                 s t a c k _ t y p e structure), as well as initializing the stack to its “em pty” state,
                                 d e s t r o y will release the stack ’s dynam ically allocated memory.
                                        The following client file can be used lo test the stack ADT. It creates two
                                 stacks and perform s a variety of operations on them.BA

             stackclient.ckjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                               #include <stdio.h>
                                 #include "stackADT.h"

                                 int main(void)

                                    Stack sl, s2;
                                    int n;

                                    sl = create ();
                                    s2 = create ();

                                    push(sl, 1);
                                    push(sl, 2);

                                    n = pop(sl);
                                    printf("Popped %d from sl\n”z n);
                                    push(s2, n);
                                    n = pop(sl) ;
                                    printf(*'Popped %d from sl\n”, n);
                                    push(s2, n) ;

                                    destroy(sl);

                                    while (!is_empty(s2))
                                      printf("Popped %d from s2\n"z pop(s2));

                                    push(s2, 3);
                                    make_empty(s2);
                                    if (is__empty(s2))
                                      printf("s2 is empty\n");
                                    else
                                      printf("s2 is not empty\n");

                                    destroy(s2);

                                    return 0;


                                 Tf the stack A D T is im plem ented correctly, the program should produce the follow ­
                                 ing output:

                                 Popped 2 from sl
                                 Popped 1 from sl
                                 Popped 1 from s2
                                 Popped 2 from s2
                                 s2 is empty
                                                        19,4                                                    495
                                                                 A S ta c k A b s tra c tD a ta T y p e kjihgfedcbaZYXWVUTSRQPONMLKJ
                                                                                                                      dcbaZYXWVUTSR




             h n p le m e n ti n g th e S t a c k A D T U s in g a F ix e d -L e n g th A r r a y onmlkjihgfedcbaZYXWVUTSRQPON
             There are several ways to implement the stack ADT. Our first approach is the sim ­
             plest. We’ll have the s ta c k A D T . c file define the s t a c k _ t y p e structure so that
             it contains a fixed-length array (to hold the contents of the stack) along with an
             integer that keeps track of the top of the stack:

             struct stack_type {
               int contents[STACK_SIZE];
               int top;


             Here’s what s ta c k A D T . c will look like:BA

stackADT.C   #include <stdio.h>
             #include <stdlib.h>
             #include "stackADT.h"

             #define STACK SIZE 100

             struct stack_type {
               int contents[STACK_SIZE];
               int top;


             static void terminate(const char *message)

                printf("%s\n", message);
                exit(EXIT_FAILURE);


             Stack create(void)

                Stack s = malloc(sizeof(struct stack_type));
                if (s == NULL)
                  terminate("Error in create: stack could not be created.");
                S->top = 0;
                return s ;


             void destroy(Stack s)

                free(s);


             void make_empty(Stack s)

                s->top = 0;


             bool is_empty(Stack s)

                return s->top == 0;
496 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 19     P ro g ra m D e s ig n kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    bool is_full(Stack s)

                                        return s->top == STACK_SIZE;
                                    }

                                    void push(Stack s, int i)

                                        if (is_full(s))
                                          terminate("Error in push: stack is full.");
                                        s->contents[s->top++] = i;
                                    }

                                    int pop(Stack s)
                                    {
                                      if (is_empty(s))
                                        terminate("Error in pop; stack is empty.");
                                      return s->contents[--s->top];


                                    The most striking thing about the functions in this file is that they use the - > oper­
                                    ator, not the . operator, to access the c o n t e n t s and t o p members of the
                                    s t a c k _ t y p e structure. The s parameter is a pointer to a s t a c k _ t y p e struc­
                                    ture. not a structure itself, so using the . operator would be illegal.dcbaZYXWVUTSRQPONMLKJIHGFEDCB


                                    C h a n g in g th e I te m T y p e in th e S ta c k A D T

                                    Now that we have a working version of the stack ADT, let’s try to improve it. First,
                                    note that items in the stack must be integers. T hat’s too restrictive; in fact, the item
                                    type doesn’t really matter. The stack items could just as easily be other basic types
                                    ( f l o a t , d o u b l e , l o n g , etc.) or even structures, unions, or pointers, for that
                                    matter.
                                           To make the stack ADT easier to modify for different item types, let’s add a
                                    type definition to the s t a c k A D T .h header. It will define a type named I t e m ,
                                    representing the type of data to be stored on the stack.RQPONMLKJIHGFEDCBA

               S ta c k A D T .h    #ifndef STACKADT_H
                (v e r s io n 2 )   #define STACKADT_H

                                    #include <stdbool.h>                    /* C99 only */

                                    typedef int Item;

                                    typedef struct stack_type *Stack;

                                    Stack create(void);
                                    void destroy(Stack s);
                                    void make_empty(Stack s);
                                    bool is_empty(Stack s);
                                    bool is full(Stack s);
                                                                                                          1 9 ,4                                                     497
                                                                                                                   A S t a c k A b s t r a c t D a ta T y p e kjihgfedcbaZYXWVUTSRQPONMLKJI


                                                        void push(Stack s, Item i);
                                                        Item pop(Stack s);

                                                        #endifonmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                        The changes to ihe file are shown in bold. Besides the addition of the I t e m type,
                                                        the p u s h and p o p functions have been modified, p u s h now has a param eter of
                                                        type I t e m , and p o p returns a value of type I t e m . We’ll use this version of
                                                        s t a c k A D T . h from now on; it replaces the earlier version.
                                                               The s ta c k A D T . c file will need to be modified to match the new s t a c k ­
                                                        ADT . h. The changes are minimal, however. The s t a c k _ t y p e structure will now
                                                        contain an array whose elements have type I t e m instead of i n t :

                                                        struct stack_type {
                                                           Item contents[STACK_SIZE];
                                                           int top;
                                                        };

                                                        The only other changes are to p u s h (the second param eter now has type I t e m )
                                                        and p o p (which returns a value of type I te m ) . The bodies o f p u s h and p o p are
                                                        unchanged.
                                                               The s t a c k c l i e n t . c file can be used to test the new s t a c k A D T .h and
                                                        s t a c k A D T .c to verify that the S t a c k type still works (it does!). Now we can
                                                        change the item type any time we want by simply modifying the definition of the
                                                        I t e m type in s ta c k A D T .h . (Although we w on’t have to change the s t a c k ­
                                                        ADT . c file, w e’ll still need to recom pile it.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                        I m p le m e n tin g th e S ta c k A D T U s in g a D y n a m ic A r r a y

                                                        Another problem with the stack ADT as it currently stands is that each stack has a
                                                        fixed maximum size, which is currently set at 100 items. This limit can be
                                                        increased to any number we wish, of course, but all stacks created using the
                                                        S t a c k type will have the same limit. T here’s no way to have stacks with different
                                                        capacities or to set the stack size as the program is running.
                                                              There are two solutions to this problem. One is to implement the stack as a
                                                        linked list, in which case there’s no fixed limit on its size. We’ll investigate this
                                                        solution in a moment. First, though, let's try the other approach, which involves aZYXWVUTSRQPON
d y n a m ic a iiy a iio c a te d a r r a y s > iz .s   storing stack items in a dynamically allocated array.
                                                              The crux of the latter approach is to modify the s t a c k _ t y p e structure so
                                                        that the c o n t e n t s m em ber is a pcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                  o in ter to the array in which the items are stored,
                                                        not the array itself:

                                                        struct stack_type {
                                                           Item *contents;
                                                           int top;
                                                           int size;
                                                        };
           C h a p te r 19    P ro g ra m D e s ig n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
4 9 8 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                    I’ve also added a new member, s i z e , that stores the stack’s maximum size (the
                                    length of the array that c o n t e n t s points to). We’Il use this member to check for
                                    the “stack full” condition.
                                         The c r e a t e function will now have a parameter that specifies the desired
                                    maximum stack size:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    Stack create(int size);

                                    When c r e a t e is called, it will create a s t a c k _ t y p e structure plus an array of
                                    length s i z e . The c o n t e n t s member of the structure will point to this array.
                                          The s ta c k A D T .h file will be the same as before, except that we’Il need to
                                    add a s i z e parameter to the c r e a t e function. (Let’s name the new version
                                    sta c k A D T 2 .h .) The s ta c k A D T . c file will need more extensive modification,
                                    however. The new version appears below, with changes shown in b o ld .

              s ta c k A D T 2 .c   #include <stdio.h>
                                    #include <stdlib.h>
                                    #include "stackADT2.h"

                                    struct stack_type {
                                      Item *contents;
                                      int top;
                                      int size;
                                    };

                                    static void terminate(const char *message)

                                         printf("%s\n", message);
                                         exit(EXIT_FAILURE);


                                    Stack create(int size)
                                    {
                                         Stack s = malloc(sizeof(struct stack_type));
                                         if (s == MULL)
                                           terminate("Error in create: stack could not be created.");
                                         s->contents = malloc(size * sizeof(Item));
                                         if (s->contents == NULL) {
                                           free(s);
                                           terminate("Error in create: stack could not be created.");

                                         s->top = 0;
                                         s->size = size;
                                         return s ;
                                    }

                                    void destroy(Stack s)

                                         free(s->contents);
                                         free (s) ;
                                        19.4                                                      499 kjihgfedcbaZYXWV
                                                A S ta c k A b s tr a c tD a ta T y p e onmlkjihgfedcbaZYXWVUTSRQPONMLK

void make_empty(Stack s)

   s->top = 0;


bool is_empty(Stack s)

   return s->top == 0;


bool is_full(Stack s)

   return s->top == s->size;


void push(Stack s, Item i)

   if (is_full (s))
     terminate("Error in push: stack is full.”);
   s->contents[s->top++] = i;


Item pop(Stack s)
{
  if (is_empty(s))
    terminate(*'Error in pop: stack is empty.");
  return s->contents[--s->top];


The c r e a t e function now calls m a l l o c twice: once to allocate a s t a c k _ t y p e
structure and once to allocate the array that will contain the stack items. Either call
of m a l l o c could fail, causing t e r m i n a t e to be called. The d e s t r o y function
must call f r e e tw ice to release all the mem ory allocated by c r e a t e .
     The s t a c k c l i e n t . c file can again be used to test the stack ADT. The calls
of c r e a t e will need to be changed, however, since c r e a t e now requires an
argument. For exam ple, we could replace the statem ents

sl = create();
s2 = create();

with the following statements:

sl = create(100);
s2 = create(200);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


I m p le m e n tin g th e S ta c k A D T U s in g a L in k e d L is t
Im plem enting the stack AD T using a dynam ically allocated array gives us more
flexibility than using a fixed-size array. However, the client is still required to spec­
ify a m axim um size for a stack at the time it’s created. If we use a linked-lisl im ple­
mentation instead, there w on’t be any preset limit on the size o f a stack.
5 0 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p t e r 19   P r o g r a m D e s ig n


                                        Our im plem entation will be sim ilar to the one in the s t a c k 2 . c file of Sec­
                                   tion l9.2. The linked list will consist of nodes, represented by the follow ing struc­
                                   ture:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   struct node {
                                      Item data;
                                      struct node *next;
                                   };

                                   The type of the d a t a m ember is now I t e m rather than i n t . but the structure is
                                   otherw ise the same as before.
                                       The s t a c k _ t y p e structure will contain a pointer to the first node in the list:

                                   struct stack_type {
                                      struct node *top;
                                   );

                                   At first glance, the s t a c k _ t y p e structure seems superfluous; we could just
                                   define S t a c k to be s t r u c t n o d e * and let a S t a c k value be a pointer to the
                                   first node in the list. However, we still need the s t a c k _ t y p e structure so that
                                   the interface to the slack remains unchanged, (lf we did away with it. any func­
                                   tion that modified the stack would need a S t a c k * param eter instead o f a
                                   S t a c k parameter.) Moreover, having the s t a c k _ t y p e structure will make il
                                   easier to change the im plem entation in the future, should we decide to store addi­
                                   tional inform ation. For example, if we later decide that the s t a c k _ t y p e struc­
                                   ture should contain a count of how many items are currently stored in the slack,
                                   we can easily add a member to the s t a c k _ t y p e structure to store this inform a­
                                   tion.
                                         We w on’i need io make any changes to the s t a c k A D T .h header. (W e'll
                                   use this header file, not s ta c k A D T 2 .h .) We can also use lhe original s t a c k -
                                   c l i e n t . c file for testing. All the changes will be in the s t a c k A D T . c file.
                                   H ere’s the new version:RQPONMLKJIHGFEDCBA

             S ta c k A D T 3 .c   #include <stdio.h>
                                   #include <stdlib.h>
                                   #include "stackADT.h"

                                   struct node {
                                      Item data;
                                      struct node *next;
                                   };

                                   struct stack_type {
                                      struct node *top;
                                   };

                                   static void terminate(const char *message)

                                       printf("%s\n", message);
                                       exit(EXIT_FAILURE);
                                   }
                             19.4   A S ta c k A b s tr a c tD a ta T y p e hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                    501 kjihgfedcbaZYXWVUTS

Stack create(void)

  Stack s = malloc(sizeof(struct stack_type));
  if (s == NULL)
    terminate("Error in create: stack could not be created.");
  s->top = NULL;
  return s;


void destroy(Stack s)

  make_empty(s);
  free(s);


void make_empty(Stack s)

  while (!is_empty(s))
    p o p (s );


bool is_empty(Stack s)

  return s->top == NULL;


bool is_full(Stack s)

  return false;


void push(Stack s, Item i)

  struct node *new_node = malloc(sizeof(struct node));
  if (new_node == NULL)
    terminate("Error in push: stack is full.");
  new_node->data = i;
  new_node->next = s->top;
  s->top = new_node;


Item pop(Stack s)

  struct node *old_top;
  Item i;

  if (is_empty(s))
    terminate("Error in pop: stack is empty.");
  old_top = s->top;
  i = old_top->data;
  s->top = old_top->next;
  free(old_top);
  return i ;
5 02 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 19    P r o g ra m D e s ig n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        Note that the d e s t r o y function calls m a k e _ e m p ty (to release the memory
                                        occupied by the nodes in the linked list) before it calls f r e e (to release the mem ­
                                        ory for the s t a c k _ t y p e structure).aZYXWVUTSRQPONMLKJIHGFEDCBA




                          1 9 .5        D e s ig n Is s u e s f o r A b s t r a c t D a t a T y p e s

                                        Section l9.4 described a stack ADT and showed several ways to implement it.
                                        Unfortunately, this ADT suffers from several problems that prevent it from being
                                        industrial-strength. L et’s look at each of these problem s and discuss possible solu­
                                        tions.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        N a m in g C o n v e n tio n s

                                        The stack ADT functions currently have short, easy-to-understand names: c r e ­
                                        a t e , d e s t r o y , m a k e _ e m p ty , i s _ e m p t y . i s _ f u l l , p u s h , and p o p . If we
                                        have more than one ADT in a program , name clashes are likely, with functions
                                        in two modules having the same name. (Each ADT will need its own c r e a t e
                                        function, for example.) Therefore, w e’ll probably need to use function names
                                        that incorporate the name of the ADT itself, such as s t a c k _ c r e a t e instead of
                                        c re a te .


                                        E r r o r H a n d lin g

                                        The stack ADT deals with errors by displaying an error message and terminating
                                        the program. T hat’s not a bad thing to do. The programmer can avoid popping an
                                        empty stack or pushing data onto a full stack by being careful to call i s _ e m p t y
                                        prior to each call of p o p and i s _ f u l l prior to each call of p u s h , so in theory
                                        there’s no reason for a call o f p u s h o r p o p to fail. (In the linked-list im plem enta­
                                        tion, however, calling i s _ f u l l isn’t foolproof; a subsequent call o f p u s h can
                                        still fail.) Nevertheless, we might want to provide a way for a program to recover
                                        from these errors rather than term inatinafc_^.
                                              An alternative is to have the p u s h and p o p functions return a b o o l value to
                                        indicate whether or not they succeeded, p u s h currently has a v o i d return type, so
                                        il would be easy to modify it to return t r u e if the p u s h operation succeeds and
                                        f a l s e if the stack is full. Modifying the p o p function would be more difficult,
                                        since p o p currently returns the value that was popped. However, if p o p were to
                                                    p o in ter to this value, instead of the value itself, then p o p could return
                                        return a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        NULL lo indicate that the stack is empty.
                                              A final comment about error handling: The C standard library contains a
           a s s e rtm a c ro > 2 < /   parameterized macro named a s s e r t that can terminate a program i f a specified
                                        condition isn’t satisfied. We could use calls o f this macro as replacem ents for the
                                        i f statements and calls of t e r m i n a t e that currently appear in the stack ADT.
                                 1 9 .5                                                                            5 0 3 dcbaZYXWVUTSRQPO
                                           D e s i g n ls s u e s f o r A b s t r a c t D a t a T y p e s hgfedcbaZYXWVUTSRQPONMLKJIHGFE


G e n e r ic A D T s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

M idway through Section 19.4, we improved the stack ADT by making it easier to
change the type of items stored in a stack— all we had to do was modify the defini­
tion of the I t e m type. Il’s still somewhat of a nuisance to do so; it would be nicer
if a stack could accom m odate items o f any type, without the need to modify the
s t a c k . h file. Also note that our stack A D T suffers from a serious flaw: a pro­
gram can't create two stacks whose items have different types. It’s easy to create
multiple stacks, but those stacks must have items with identical types. To allow
stacks with different item types, w e’d have to make copies o f the stack A D T ’s
header file and source file and modify one set o f files so that the S t a c k type and
its associated functions have different names.
      W hal w e’d like to have is a single ‘‘generic” stack type from which we could
create a stack o f integers, a stack of strings, or any other stack that we might need.
There are various ways to create such a type in C. but none are com pletely satisfac­
tory. The most common approach uses v o i d * as the item type, which allows
arbitrary pointers to be pushed and popped. Witli this technique, the s t a c k -
AD T. h file would be sim ilar to ouroriginal version; however, the prototypes of the
p u s h and p o p functions would have the following appearance:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

void push(Stack s, void *p);
void *pop(Stack s);
p o p returns a pointer to the item popped from the stack; if the stack is empty, it
returns a null pointer.
     There are two disadvantages to using v o i d * as the item type. One is that this
approach doesn’t work for data that can ’t be represented in pointer form. Items
could be strings (which are represented by a pointer lo the first character in the
string) or dynam ically allocated structures but not basic types such as i n t and
d o u b l e . The other disadvantage is that error checking is no longer possible. A
stack that stores v o i d * items will happily allow a mixture o f pointers o fd iiferen t
types: there’s no way to detect an error caused by pushing a pointer o f the wrong
type.


A D T s in N e w e r L a n g u a g e s

The problems that w e’ve just discussed are dealt with much more cleanly in newer
C-based languages, such as C++. Java, and C#. Name clashes are prevented by
                                     class. A stack ADT would be represented by a
defining function names within a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
S t a c k class; the stack functions would belong to this class, and would only be
recognized by the com piler when applied to a S t a c k object. These languages
have a feature known as exception h a n d lin g that allows functions such as p u s h
and p o p lo “throw” an exception when they detect an error condition. Code in the
client can then deal with the error by “catching” the exception. C++, Java, and C#
also provide special features for defining generic ADTs. In C++, for exam ple, we
would define a stackteznptae, leaving the item type unspecified.
5 0 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 19      P r o g ra m D e s ig n aZYXWVUTSRQPONMLKJIHGFEDCBA




                                    Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                            Q:      Y ou s a id th a t C w a s n ’t d e s ig n e d fo r w r it in g la r g e p r o g r a m s . I s n ’t U N I X a
                                    la r g e p r o g r a m ? [p . 4 8 3 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                            A:      Not at the time C was designed. In a 1978 paper. Ken Thom pson estimated that the
                                    UNIX kernel was about 10,000 lines of C code (plus a small am ount of assembler).
                                    Other components of UNIX were ofcom parable size; in another 1978 paper, Den­
                                    nis Ritchie and colleagues put the size of the PD P -11 C com piler at 9660 lines. By
                                    today's standards, these are indeed small programs.

                            Q:      A r e th e r e a n y a b s tr a c t d a ta ty p e s in th e C lib r a r y ?
                        A:          Technically there aren’t, but a few come close, including the F IL E type (defined in
               FiLEtype>22j         < s t d i o . h > ) . Before performing an operation on a file, we must declare a vari­
                                    able of type F IL E *:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    FILE *fp;

                                    The f p variable will then be passed to various file-handling functions.
                                         Programmers are expected to treat F IL E as an abstraction. It’s not necessary
                                    to know what a F IL E is in order to use the F IL E type. Presumably F IL E is a
                                    structure type, but the C standard doesn’t even guarantee that. In fact, it’s better not
                                    to know too much about how F IL E values are stored, since the definition of the
                                    F IL E type can (and often does) vary from one C com piler to another.
                                         Of course, we can always look in the s t d i o . h file and see whal a F IL E is.
                                    Having done so, there’s nothing lo prevent us from writing code to access the inter­
                                    nals of a F IL E . For example, we might discover that F IL E is a structure with a
                                    member named b s i z e (the file’s buffer size):
                                    typedef struct {

                                        int bsize;                /* buffer size */

                                    } FILE;

                                    Once we know about the b s i z e member, there’s nothing to prevent us from
                                    accessing the buffer size for a particular file:
                                    printf("Buffer size: %d\n”, fp->bsize);

                                    Doing so isn’t a good idea, however, because other C com pilers might store the
                                    buffer size under a different name, or keep track of il in some entirely different
                                    way. Changing the b s i z e member is an even worse idea:
                                    fp->bsize = 1024;

                                    Unless we know all the details about how files are stored, this is a dan cbaZYXWVUTSRQPONMLKJIHGFEDCB
                                                                                                             g erous thing<>
                                                                                                             C
                                    to do. Even if we do know the details, they may change with a different com piler or
                                    the next release of the same compiler.
                                                                                                                                                     505dcbaZYXWVU
                                                                                                                              E x e rc is e s kjihgfedcbaZYXWVUTSRQPONM


                         Q:    W h a t o t h e r in c o m p le t e ty p e s a r e th e r e b e s id e s in c o m p l e t e s t r u c t u r e ty p e s ? [p .
                               4 9 2 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         A:    One of the most common incomplete types occurs when an array is declared with
                               no specified size:

                               extern int a [];

                               After this declaration (which we first encountered in Section 15.2), a has an
                               incomplete type, because the com piler doesn’t know a ’s length. Presumably a is
                               defined in another file within the program; that definition will supply the missing
                               length. Another incomplete type occurs in declarations that specify no length for
                               an array but provide an initializer:

                               int a [] = {1, 2, 3} ;

                                ln this example, the array a initially has an incomplete type, but the type is com ­
                                pleted by the initializer.
                                     Declaring a union tag without specifying the members of the union also cre-
                        <*Ep> ates an incomplete type. Flexible array members (a C99 feature) have an incom-
     iiexibiearrayrnembers>tz.9 plete type. Finally, v o i d is an incomplete type. The v o i d type has the unusual
                                property that it can never be completed, thus making it impossible to declare a
                                variable of this type.

                         Q:    W h a t o t h e r r e s tr ic tio n s a r e th e r e o n th e u se o f in c o m p l e t e ty p e s ? [p . 4 9 2 ]
                         A:    The s i z e o f operator can't be applied to an incomplete type (not surprisingly,
                               since the size of an incomplete type is unknown). A member of a structure or
                               union (other than a flexible array member) canT have an incomplete type. Sim i­
                               larly, the elements of an array can’t have an incomplete type. Finally, a parameter
                               in a function definition can’t have an incomplete type (although this is allowed in
                                           declaration). The compiler “adjusts” each array parameter in a function
                               a function cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                               definition so that it has a pointer type, thus preventing it from having an incom­
                               plete type.aZYXWVUTSRQPONMLKJIHGFEDCBA




                               E x e r c is e s

S e c t io n 19.1         l.     q u e u e is similar to a stack, except that items are added at one end but removed from the
                               A RQPONMLKJIHGFEDCBA
                               other in a F I F O (first-in, first-out) fashion. Operations on a queue might include:
                                     Inserting an item at the end of the queue
                                     Removing an ilcm from the beginning of the queue
                                     Returning the first item in the queue (without changing the queue)
                                     Returning the last item in the queue (without changing the queue)
                                     Testing whether the queue is empty
                               Write an interface for a queue module in thc form of a header file named q u e u e . h.

S e c tio n 1 9 .2   ©   2.    Modify the s t a c k 2 . c file to use the PUBLIC and PRIVATE macros.
5 0 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p t e r 19    P ro g ra m D e s ig n aZYXWVUTSRQPONMLKJIHGFEDCBA


                             3.    (a) W rite an array based implementation o fth c qucuc module described in Exercise l. Use
                                   three integers to keep track of the queue’s status, with one integer storing the position o fth e
                                   first empty slot in the array (used when an item is inserted), the second storing the position
                                   o f the next item to be removed, and the third storing the num ber o f item s in the queue. An
                                   insertion or removal that would cause either of the first two integers to be incremented past
                                   the end of the array should instead reset the variable to zero, thus causing it to “wrap
                                   around’’ to the beginning of the array.
                                   (b) W rite a linked-list implementation of the queue m odule described in Exercise l. Use
                                   two pointers, one pointing lo the first node in the list and the other pointing to the last node.
                                   When an item is inserted into the queue, add it to the end o f the list. When an item is
                                   removed from the queue, delete the first node in the list.

S e c t i o n 1 9 .3   ©     4.    (a) W rite an im plementation of the S t a c k type, assuming that S t a c k is a structure con­
                                   taining a fixed-length array.
                                   (b) Redo the S t a c k lypc. this time using a linked-list representation instead o f an array.
                                   (Show both s t a c k . h and s t a c k . c.)

                             5.   Modify the q u e u e . h header of Exercise l so that il defines a Q u e u e type, where Q u e u e
                                  is a structure containing a fixed-length array (see Exercise 3(a)). M odify the functions in
                                  q u e u e . h to take a Q u e u e * parameter.

                                     6.    (a) Add a p e e k function to s t a c k A D T .c . This function will have a param eter o f type
S e c t io n 1 9 .4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   S t a c k . When called, it returns the top item on the stack but doesn’t modify the stack.
                                   (b) Repeat part (a), modifying s ta c k A D T 2 . c this lime.
                                   (c) Repeal pan (a), modifying s ta c k A D T 3 . c this time.

                             7.   Modify s ta c k A D T 2 . c so that a stack autom atically doubles in size when il becom es full.
                                  Have the p u s h function dynamically allocate a new array that’s tw ice as large as the old
                                  one and then copy the slack contents from the old array io the new one. Be sure lo have
                                  p u s h deallocate the old array once the data has been copied.




                                   P r o g r a m m in g P r o je c t s

                             l.    Modify Program ming Project l from Chapter 10 so that it uses the stack ADT described in
                                   Section l9.4. You may use any o flh e implem entations o fth c A D T described in that section.

                             2.    Modify Programming Project 6 from Chapter 10 so that it uses the stack ADT described in
                                   Section J9.4. You may use any o fth e implem entations o fth e ADT described in that section.

                             3.   Modify the s ta c k A D T 3 . c file of Section l9.4 by adding an i n t m em ber named l e n to
                                  the s t a c k _ t y p e structure. This m em ber will keep track o fh o w many items are currently
                                  stored in a stack. Add a new function named l e n g t h that has a S t a c k param eter and
                                  returns the value of the l e n member. (Some of ihe existing functions in s ta c k A D T 3 . c
                                  will need to be modified as well.) Modify s t a c k c l i e n t . c so that it calls the l e n g t h
                                  function (and displays the value that il returns) after each operation that modifies a stack.

                            4.    Modify the s t a c k A D T . h and s ta c k A D T 3 . c files of Section l9.4 so that a stack stores
                                  values of type v o i d *, as described in Seclion l9.5; ihc I t e m type will no longer be used.
                                  Modify s t a c k c l i e n t . c so that il stores pointers lo strings in thc s l and s 2 slacks.
                                                                                                             507onmlkjihgfedcbaZYXWV
                                                                     P ro g ra m m in g P r o je c ts kjihgfedcbaZYXWVUTSRQPONMLKJIHG


5.   Starling from the q u e u e . h header of Exercise 1. create a file named q u e u e A D T .h that
     defines the following Q u e u e type:
     ty p e d e f   s tru c t   q u e u e _ ty p e   *Q ueue;
     q u e u e _ t y p e is an incomplete structure type. Create a file named q u e u e A D T . c that con­
     tains the full definition of q u e u e _ t y p e as well as definitions for all the functions in
     q u e u e . h. Use a fixed-length array to store the items in a queue (see Exercise 3(a)). Create
     a file named q u e u e c l i e n t . c (sim ilar lo the s t a c k c l i e n t . c fileo fS eclio n 19.4) that
     creates two queues and performs operations on them. Be sure to provide c r e a t e and
     d e s t r o y functions for your ADT.

6.   Modify Programming Project 5 so that the items in a queue arc stored in a dynamically allo-
     caled.array whose length is passed to the c r e a t e function.

7.   Modify Program ming Project 5 so that the items in a queue are stored in a linked list (see
     Exercise 3(b)).
2 0       L o w - L e v e l P r o g r a m m in g                                                   ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                      A p ro g ra m m in g la n g u a g e is lo w le v e l w h e n its
                                                         p ro g r a m s re q u ire a t te n tio n to th e irre le v a n t. onmlkjihgfedcbaZYXWVU




           Previous chapters have described C's high-level, machine-independent features.
           Although these features are adequate for many applications, some programs need
           to perform operations at the bit level. Bit manipulation and other low-level opera­
           tions are especially useful for writing systems programs (including compilers and
           operating systems), encryption programs, graphics programs, and programs for
           which fast execution and/orefficient use ofspacc is critical.
                 Section 20.1 covers C\s bitwise operators, which provide easy access to both
           individual bits and bit-fields. Section 20.2 then shows how to declare structures
           that contain bit-fields. Finally. Section 20.3 describes how certain ordinary C fea­
           tures (type definitions, unions, and pointers) can help in writing low-level pro­
          vg^rams,
                 Some of the techniques described in this chapter depend on knowledge ofhow
           data is stored in memory, which can vary depending on the machine and the com­
           piler. Relying on these techniques will most likely make a program nonportable, so
           it’s best to avoid them unless absolutely necessary. Ifyoti do need them, try to limit
           their use to certain modules in your program; dona spread them around. And,
           above all, be sure to document what you’re doing!




 2 0 .1   B it w is e O p e r a t o r s

                             bitwise operators, which operate on integer data at the bit level.
          C provides six cbaZYXWVUTSRQPONMLKJIHGFEDCBA
          W e’ll discuss the two bitwise shift operators first, followed by the four other bit­
          wise operators (bitwise complement, bitwise and. bitwise exclusive or. and bitwise
          inclusive or). kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                                  509
5 1 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 0   L o w - L e v e l P r o g r a m m in g dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    B itw ise S h ift O p e r a to r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    The bitwise shift operators can transform the binary representation of an integer by
                                    shifting its bits to the left or right. C provides two shift operators, which are shown
                                    in Table 20.1.

                  T a b le 2 0 .1                                             Sym bol       M e a n i n g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
   Bitwise Shift Operators RQPONMLKJIHGFEDCBA                                    <<         left shift
                                                                                 >>         right shift

                                    The operands for << and >> may be of any integer type (including c h a r ) . The
                                    integer promotions are performed on both operands: the result has the type of the
                                    left operand after promotion.
                                         The value of i << j is the result when the bits in i are shifted left by j places.
                                    For each bit that is “shifted o f f ’ the left end of i , a zero bit enters at the right. The
                                    value of i >> j is the result when i is shifted right by j places. If i is of an
                                    unsigned type or if the value of i is nonnegative, zeros are added at the left as
                                    needed. If i is a negative number, the result is implementation-defined: some
                                    implementations add zeros at the left end. while others preserve the sign bit by
                                    adding ones.aZYXWVUTSRQPONMLKJIHGFEDCBA

                                                ForportcibiUty, i t ’s best to perform shifts only on unsig ned numbers.
             p o r t a b ilit y t ip cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         The following examples illustrate the effect of applying the shift operators to
                                    the number 13. (For simplicity, these examples— and others in this section— use
                                    short integers, which are typically 16 bits.)

                                    unsigned short i, j;

                                    i = 13;                    * i is now 13 (binary 0000000000001101)
                                    j = i << 2;                * j is now 52 (binary 0000000000110100)
                                    3 = 1 ^*^* 2;              * j is now  3 (binary 0000000000000011)

                                    As these examples show, neither operator modifies its operands. To modify a vari­
                                    able by shifting its bits, w e’d use the compound assignment operators <<= and
                                    >>=:

                                    i = 13;                  /* i is now 13              (binary 0000000000001101)                          */
                                    i <<= 2 ;                /* i is now 52              (binary 0000000000110100)                          */
                                    i >>= 2;                 /* i is now 13              (binary 0000000000001101)                          */


                                    The bitwise shift operators have lower precedence than the arithmetic operators,
                                    which can cause surprises. For example, i << 2 + 1 means i << (2 + 1 ) . not
                                    ( i << 2) + 1.
                                                                                               2 0 .1                                     511 dcbaZYXWVUTSRQPON
                                                                                                        B itw is e O p e ra to rs hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                               B itw is e C o m p le m e n t, A n d , E x c lu s i v e O r , a n d I n c lu s iv e O r
                                                              RQPONMLKJIHGFEDCBA



                               Table 20.2 lists the remaining bitwise operators.cbaZYXWVUTSRQPONMLKJIHGFEDCBA

            T a b le 2 0 .2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   Sym b o l        M e a n in g
Other Bitwise Operators                                                     *%rf
                                                                                    bitwise complement
                                                                           6c       bitwise and
                                                                                    bitwise exclusive or
                                                                                    bitwise inclusive or

                               The ~ operator is unary; the integer prom otions are performed on its operand. The
                               other operators are binary; the usual arithmetic conversions are performed on their
                               operands.
                                    The - . &. ^. and | operators perform Boolean operations on all bits in their
                               operands. The ~ operator produces the complement of its operand, with zeros
                               replaced by ones and ones replaced by zeros. The & operator performs a Boolean
                               a nd operation on all corresponding bits in its two operands. The ^ and | operators
                               are sim ilar (both perform a Boolean or operation on the bits in their operands);
                               however. ^ produces 0 whenever both operands have a 1 bit, whereas | produces
                               1.


                               D on'tconfusetheW nv7.v6'operators& and | w iththe/o#zcw /operators& & and | |.
                               The bitwise operators sometimes produce the same results as the logical operators,
                               but they’re not equivalent.


                                     The following examples illustrate the effect of the ~. &, ^, and | operators:kjihgfedcbaZYXWVUTSRQPO

                               unsigned short i, j, k;
                                                               «
                               i = 21;                   / *   1 is now    21            (binary 0000000000010101)
                               j = 56;                   /*    j is now    56            (binary 0000000000111000)
                               k = ~i;                   / *   k is now 65514            (binary 1111111111101010)
                               k = i & j;                /*    k is now    16            (binary 0000000000010000)
                               k = i   j;                / *   k is now    45            (binary 0000000000101101)
                               k = i | j;                /*    k is now    61            (binary 0000000000111101)

                               The value shown for ~ i is based on the assumption that an u n s i g n e d s h o r t
                               valueoccupies 16bits.
                                    The ~ operator deserves special mention, since wc can use it to help make
                               even low-level programs more portable. Suppose that we need an integer whose
                               bits are all 1. The preferred technique is to write ~0, which doesn't depend on the
                               number of bits in an integer. Similarly, if we need an integer whose bits are all 1
                               except for the last five, we could write ~ 0 x l f .
512 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 2 0   L o w -L e v e l P ro g ra m m in g onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                              Each o fth e ~, &, ^, and | operators has a different precedence:

                                                              Higohest:



                                                              Lowest:

                                                        As a result, we can combine these operators in expressions without having to usc
                                                        parentheses. Forexam ple, we could write i & - j | k instead of ( i & ( ~ j ) ) | k
                                                        and i ^ j & ~k instead of i ^ ( j & (~ k ) ). Of course, il doesn’t hurt to use
                                                        parentheses to avoid confusion.aZYXWVUTSRQPONMLKJIHGFEDCBA


                                                        The precedence of &. ^, and | is lower than the precedence of the relational and
                                                        equality operators. Consequently, statements like the following one won’t have lhe
                                   > A p p e n d ix A
   t a b l e o f o p e r a t o r s BA                   desired effect:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                        if    (status & 0x4000          l= 0) ...

                                                        Instead of testing whether s t a t u s & 0 x 4 0 0 0 isn’t zero, this statement will
                                                        evaluate 0x4 00 0 1= 0 (which has the value 1), then test whether the value of
                                                        s t a t u s & 1 isn’t zero.


                                                            The compound assignment operators &=,               =, and   = correspond to the bit­
                                                        wise operators &. x , and | :

                                                             = 21;        /*   1 is   now   21   (binary   0000000000010101)        ★
                                                             = 56;        /*   j is   now   56   (binary   0000000000111000)        *
                                                             &= j ;       /*   1 is   now   16   (binary   0000000000010000)        *
                                                             ^= j ;       /*   1 is   now   40   (binary   0000000000101000)        *
                                                             1= j;        /*   1 is   now   56   (binary   0000000000111000)        * dcbaZYXWVUTSRQPONMLKJIH


                                                        U s in g th e B itw is e O p e r a to r s to A c c e s s B its
                                                        When we do low-level programming, w e’ll often need to store information as sin­
                                                        gle bits or collections o fb its. In graphics program ming, forexam ple, we may want
                                                        to squeeze two or more pixels into a single byte. Using the bitwise operators, we
                                                        can extract or modify data that’s stored in a small number of bits.
                                                             L et's assume that i is a 16-bit u n s i g n e d s h o r t variable. L et’s see how to
                                                        perform the most common single-bit operations on i :cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                          ■ S e ttin g a bit. Suppose that we want to set bit 4 of i . (W e'll assume that the
                                                            leftmost— or m o st sig n ific a n t— bit is numbered 15 and the least significant is
                                                            numbered 0.) The easiest way to set bit 4 is to or the value of i with the con­
                                                            stant 0 x 0 0 1 0 (a "m ask” that contains a 1 bit in position 4):
                                                              i = 0x0000;                    /* i is now 0000000000000000 */
                                                              i |= 0x0010;                   /* i is now 0000000000010000 */

                                                              M ore generally, if the position of the bit is stored in the variable j , we can use
                                                              a shift operator to create the mask:
                                                               2 0 .1                                       513aZYXWVUTSRQPONM
                                                                        B it w is e O p e r a to r s kjihgfedcbaZYXWVUTSRQPONMLKJIHG

id io m        i |= 1 << j ;                  /* sets bit j */onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

               Forexam ple, if j has the value 3. then 1 << j is 0 x 0 0 0 8 .cbaZYXWVUTSRQPONMLKJIHGFEDCBA
            ■ C lea rin g a bit. To clear bit 4 of i . w e'd use a mask with a 0 bit in position 4
              and 1 bits everywhere else:
               i = 0x00ff;                    /* i is now 0000000011111111 */
               i &= -0x0010;                  /* i is now 0000000011101111 */

               Using the same idea, we can easily write a statement that clears a bit whose
               position is stored in a variable:
id io m        i &= ~ (1 << j ) ;             /* clears bit j */

            ■ T estin g a bit. The following i f statem ent tests whether bit 4 of i is sei:

               if   (i & 0x0010)       ... /* tests bit 4 */

               To test whether bit j is set, w e’d use the following statement:
id io m        if   (i & 1 << j) ...          /* tests bit j */

               To make working with bits easier, w e'll often give them names. For example,
          suppose that we want bits 0, 1. and 2 o f a num ber to correspond to the colors blue,
          green, and red. respectively. First, we define names that represent Lhe three bit
          positions:
          # define BLUE  1
          # define GREEN 2
          # define RED   4

          Setting, clearing, and testing the BLUE bit would be done as follows:
          i |= BLUE;                  /* sets BLUE bit             */
          i &= -BLUE;                 /* clears BLUE bit           */
          if (i & BLUE)        ...    /* tests BLUE bit            */

          It’s also easy to set. clear, or test several bits at time:
          i |= BLUE | GREEN;                        /* sets BLUE and GREEN bits                             */
          i &= ~(BLUE | GREEN);                     /* clears BLUE and GREEN bits                          */
          if (i & (BLUE | GREEN))               ... /* tests BLUE and GREEN bits                           ★ /

          The i f statement tests whether either the BLUE bit o r the GREEN bit is set.dcbaZYXWVUTSRQPONMLKJIHGFE


          U sin g th e B itw is e O p e r a to r s to A c c e s s B it-F ie ld s
          Dealing with a group of several consecutive bits (a b it-field ) is slightly more com ­
          plicated than working with single bits. Here are examples of the two most common
          bit-field operations:

           ■ M o d ify in g a bit-field. M odifying a bit-field requires a bitwise a n d (to clear the
             bit-field), followed by a bitwise o r (to store new bits in the bit-field). The fol­
             lowing statement shows how we might store the binary value 101 in bits 4 -6
             of the variable i :
5 1 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 0    L o w -L e v e l P ro g ra m m in g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           i = i & -0x0070 | 0x0050;                          /* stores 101 in bits 4-6 */onmlkjihgfedc

                                          The & operator clears bits 4 -6 of i ; the | operator then sets bits 6 and 4.
                                          N otice that i | = 0 x 0 0 5 0 by itself w ouldn’t always work: il would set bits 6
                                          and 4 but not change bit 5. To generalize the example a little, let’s assum e that
                                          the variable j contains the value to be stored in bits 4 -6 of i . We’ll need to
                                                                                                 or:
                                          shift j into position before perform ing the bitwise cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           i = (i & -0x0070)                | (j << 4);              /* stores j in bits 4-6 */

                                          The | operator has lower precedence than & and <<. so we can drop the paren­
                                          theses if we wish:
                                           i = i & -0x0070 | j << 4;

                                       ■ R etrievin g a hit-field. When the bit-field is at the right end of a num ber (in the
                                         least significant bits), fetching its value is easy. For example, the following
                                         statement retrieves bits 0 -2 in the variable i :
                                           j = i & 0x0007;                              /* retrieves bits 0-2 */

                                          if the bit-field isn’t at the right end o f o f i , then we can first shift the bit-field
                                          to the end before extracting the field using the & operator. To extract bits 4—6
                                          of i , for example, we could use the following statement:
                                           j = (i >> 4) & 0x0007;                       /* retrieves bits 4-6 */


                                   X O R E n c r y p tio n
                P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      One of the simplest ways to encrypt data is to excIusive-or (XOR) each character
                                      with a secret key. Suppose that the key is the & character. Ifw e XOR this key with
                                      the character z, w e’lI gel the \ character (assuming that w e’re using the ASCII
 ASCIIcharacterset >AppendixE         character set):

                                          00100110 (A S C U co d efo r& )
                                      XOR 01111010 (ASCII code for z)
                                          01011100 ( A S C lI c o d e f o r \)

                                          To decrypt a message, we ju st apply the same algorithm. In other words, by
                                      encrypting an already-encrypted message, w e’ll recover the original message. If
                                      we XOR the & character with the \ character, for example, w e’ll get the original
                                      character, z:

                                          00100110 (A S C IIco d efo r& )
                                      XOR 01011100 ( A S C llc o d e f o r \)
                                          01 11 1010 (ASCII code for z)

                                           The following program, x o r . c. encrypts a message by XORing each charac­
                                      ter with the & character. The original message can be entered by the user or read
                                      from a file using input redirection; the encrypted message can be viewed on the
 input and output redirection >22.1   screen or saved in a file using output redirection. For example, suppose that the file
                                                                                             2 0 .1                                        515
                                                                                                       B itw is e O p e r a to r s onmlkjihgfedcbaZYXWVUTSRQPONML


                                    m sg contains thc following lines;kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    Trust not him with your secrets, who, when left
                                    alone in your room, turns over your papers.
                                                --Johann Kaspar Lavater (1741-1801)

                                    To encrypt the m sg file, saving the encrypted message in new m sg, w e’d use the
                                    following command:

                                    xor <msg >newmsg

                                    new m sg will now contain these lines:

                                    rTSUR HIR NOK QORN _IST UCETCRU, QNI, QNCH JC@R
                                    GJIHC OH _IST TIIK, RSTHU IPCT _IST VGVCTU.
                                                --lINGHH mGUVGT jGPGRCT (1741-1801)

                                    To recover the original message, w e’d use the command

                                    xor <newmsg

                                    which will display it on the screen.
                                          As the example shows, our program won’t change some characters, including
                                    digits. XORing these characters with & would produce invisible control characters,
                                    which could cause problems with some operating systems. In Chapter 22, w c’ll see
                                    how to avoid problems when reading and writing files that contain control charac-
is p r in tf u n c iio n > 2 3 .5   tors. Until then, w e’ll play it safe by using the i s p r i n t function to make sure
                                    that both the original character and the new (encrypted) character are printing char­
                                    acters (i.e., not control characters). Ifeith er character fails this test, w e’ll have the
                                    program write the original character instead of the new character.
                                         Here’s the finished program, which is remarkably short:BA

                       xor.c        /* Performs XOR encryption */

                                    #include <ctype.h>
                                    #include <stdio.h>

                                    #define KEY ’& ’

                                    int main(void)

                                       int orig_char, new_char ;

                                      while ((orig_char = getchar()) 1= EOF) {
                                        new_char = orig_char ^ KEY;
                                        if (isprint(orig__char) && isprint(new_char))
                                          putchar(new_char);
                                        else
                                          putchar(orig_char);


                                      return 0;
5 1 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 0    L o w - L e v e l P r o g r a m m in g aZYXWVUTSRQPONMLKJIHGFEDCBA




                       2 0 .2       B it - F ie ld s in S t r u c t u r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    Although the techniques of Section 20.l allow us to work with bit-fields, these
                                    techniques can be tricky to use and potentially confusing. Fortunately, C provides
                                    an alternative: declaring structures whose members represent bit-fields.
                                         As an example, let’s look at how the M S-DOS operating system (often just
                                    called DOS) stores the date at which a file was created or last modified. Since
                                    days, months, and years are small numbers, storing them as norm al integers would
                                    waste space. Instead, DOS allocates only 16 bits for a date, with 5 bits for the day,
                                    4 bits for the month, and 7 bits for the year:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                               year                            month                      day

                                             15     14    13    12    11    10     9     8     7    6      5    4     3     2     1     0

                                    Using bit-fields, we can define a C structure with an identical layout:

                                    struct file_date {
                                      unsigned int day: 5;
                                      unsigned int month: 4;
                                      unsigned int year: 7;


                                    The num ber after each mem ber indicates its len ogth in bits. Since the m em bers all
                                    have the same type, we can condense the declaration if we want:

                                    struct file_date {
                                      unsigned int day: 5, month: 4, year: 7;


                                    The type of a bit-field must be either i n t , u n s i g n e d i n t , or s i g n e d i n t .
                                    Using i n t is am biguous; some com pilers treat the field’s high-order bit as a sign
                                    bit, but others don’t.

                                              D eclare a ll bit-fields to be e ith e r u n s i g n e d
             p o r ta b ility tip cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                          i n t or s i g n e d i n t .

                         <@ >       ln C99, bit-fields may also have type _ B o o l . C99 com pilers may allow additional
                                    bit-field types.
                                         We can use a bit-field just like any other m em ber of a structure, as the follow­
                                    ing exam ple shows:

                                     struct file_date fd;

                                     fd.day = 28;
                                     fd.month = 12;
                                     fd.year = 8;                    /* represents 1988 */

                                    Note that the y e a r member is stored relative to 1980 (the year the world began.
                                                                2 0 ,2                                                 5 1 7 onmlkjihgfedcbaZYXWVU
                                                                           B it - F ie ld s in S tru c tu re s hgfedcbaZYXWVUTSRQPONMLKJIHGFE


according to M icrosoft). After these assignments, the f d variable will have the fol­
lowing appearance:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


        0       0      0      1      0        0      0      1      1       0     0     1
            I        I_____ I_____ I_____ I        I___________ I_____ I       I___

       15       14    13     12     11        10     9      8      7       6     5     4      3      2      1      0

We could have used the bitwise operators to accomplish the same cffect; using
these operators might even make the program a little faster. However, having a
readable program is usually more im portant than gaining a few microseconds.
     Bit-fields do have one restriction that doesn't apply to other members of a
structure. Since bit-fields don’t have addresses in the usual sense, C doesn’t allow
us to apply the address operator (&) to a bit-field. Because of this rule, functions
such as s c a n f can’t store data directly in a bit-field:

scanf("%d", &fd.day);                              /*** WRONG ***/

O f course, we can always use s c a n f lo read input into an ordinary variable and
then assign it to f d . d a y .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


H o w B it-F ie ld s A r e S to r e d

Let’s lake a close look at how a com piler processes the declaration of a structure
that has bit-field members. As w e’Il see, the C standard allows the com piler con­
siderable latitude in choosing how it stores bit-fields.
     The rules concerning how the com piler handles bit-fields depend on the notion
of "storage units.” The size of a storage unit is implementation-defined: typical
values are 8 bits, 16 bits, and 32 bits. As it processes a structure declaration, the
compiler packs bit-fields one by one into a storage unit, with no gaps between the
fields, until there’s not enough room for the next field. At that point, som e com pil­
ers skip to the beginning of the next storage unit, while others split the bit-fiekl
across the storage units. (Which one occurs is implem entation-defined.) The order
in which bit-fields are allocated (left to right or right to left) is also im plem enta­
tion-defined.
     Our f i I e _ _ d a t e example assumes that storage units are 16 bits long. (An 8-
bit storage unit would also be acceptable, provided that the com piler splits the
m o n th field across two storage units.) We also assum e that bit-fields are allocated
from right to left (with the first bit-field occupying the low-order bits).
     C allows us to omit the name o fa n y bit-field. Unnamed bit-fields are useful as
"padding” to ensure that other bit fields are properly positioned. Consider the time
associated with a DOS file, which is stored in the following way:

struct file_time {
   unsigned int seconds: 5;
   unsigned int minutes: 6;
   unsigned int hours: 5;
};
5 1 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 0   L o w -L e v e l P ro g r a m m in g onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     (You may be wondering how it’s possible lo store the seconds— a number between
                                     0 and 59— in a field with only 5 bits. Well, DOS cheats: it divides the number of
                                     seconds by 2, so the s e c o n d s member is actually between 0 and 29.) If w e’re not
                                     interested in the s e c o n d s field, we can leave out its name:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     struct file_time {
                                       unsigned int : 5;                                   /* not used */
                                       unsigned int minutes: 6;
                                       unsigned int hours: 5;


                                     The remaining bit-fields will be aligned as if the s e c o n d s field were still present.
                                          Another trick that we can use to control the storage of bit-fields is to specify 0
                                     as the lengoth of an unnamed bit-field:

                                     struct s {
                                        unsigned int a: 4;
                                        unsigned int : 0;                       /* O-length bit-field */
                                        unsigned int b: 8;
                                     };

                                     A O-length bit-field is a signal to the compiler to align the following bit-field at the
                                     beginning of a storage unit. If storage units are 8 bits long, the com piler will allo­
                                     cate 4 bits for the a member, skip 4 bits to the next storage unit, and then allocate 8
                                     bits for b. If storage units are 16 bits long, the com piler will allocate 4 bits for a,
                                     skip 12 bits, and then allocate 8 bits for b.aZYXWVUTSRQPONMLKJIHGFEDCBA




                       2 0 .3        O t h e r L o w - L e v e l T e c h n iq u e s

                                     Some of the language features that w e’ve covered in previous chapters are used
                                     often in low-level programming. To wrap up this chapter, w e’lI take a look at sev­
                                     eral important examples: defining types that represent units of storage, using
                                     unions to bypass normal type-checking, and using pointers as addresses. W e’ll also
                                     cover the v o l a t i l e type qualifier, which we avoided discussing in Section 18.3
                                     because of its low-level nature.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     D e fin in g M a c h in e -D e p e n d e n t T y p es

                                     Since the c h a r type— by definition— occupies one byte, w e’ll sometimes treat
                                     characters as bytes, using them to store data that’s not necessarily in character
                                     form. When we do so, it’s a good idea to define a BYTE type:

                                     typedef unsigned char BYTE;

                                     Depending on the machine, we may want to define additional types. The x86 archi­
                                     tecture makes extensive use of 16-bit words, so the following definition would be
                                     useful for that platform:
                                        2 0 .3                                                       519
                                                 O th e r L o w - L e v e lT e c h n iq u e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


typedef unsigned short WORD;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

We’ll use the BYTE and WORD types in later examples.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


U s in g U n io n s to P r o v id e M u l t i p l e V ie w s o f D a ta

 Although unions can be used in a portable way— see Section l6.4 for exam ples—
 they’re often used in C for an entirely different purpose: viewing a block o fm e m -
 ory in two or more different ways.
        Here’s a simple example based on the f i l e _ d a t e structure described in
 Section 20.2. Since a f i l e _ d a t e structure fits into two bytes, we can think of
 any two-byte value as a f i l e _ d a t e structure. In particular, we could view an
u n s i g n e d s h o r t value as a f i l e _ d a t e structure (assuming that short inte­
 gers are 16 bits long). The following union allows us to easily convert a short inte­
£g□ er to a file date or vice versa:
union int_date {
   unsigned short i;
   struct file_date fd;
};

With the help of this union, we could fetch a file date from disk as two bytes, then
extract its m o n th , d a y , and y e a r fields. Conversely, we could construct a date as
a f i l e _ d a t e structure, then write it to disk as a pair ofbytes.
      As an exam ple of how we might use the i n t _ d a t e union, here’s a function
that, when passed an u n s i g n e d s h o r t argument, prints it as a file date:

void print_date(unsigned short n)

  union int_date u;

  u .i = n ;
  printf("%d/%d/%d\n", u.fd.month, u.fd.day, u.fd.year+ 1980);


     Using unions to allow multiple views o fd a ta is especially useful when work­
ing with registers, which are often divided into sm aller units, x86 processors, for
example, have 16-bit registers named AX. BX, CX, and DX. Each of these regis­
ters can be treated as two 8-bit registers. AX, for example, is divided into registers
named AH and AL. (The H and L stand for “high" and “low.")
     When writing low-level applications for x86-based computers, we may need
variables that represent the contents of the AX. BX, CX, and DX registers. We
want access to both the 16- and 8-bit reog isters: at the same lime,^ we need to take
thcir relationships into account (a change to AX affects both AH and AL; changing
AH or AL modifies AX). The solution is to set up two structures, one containing
members that correspond to the 16-bit registers, and the other containing mem bers
that match the 8-bit registers. We then create a union that encloses the two struc­
tures:
5 2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 0    L o w -L e v e l P ro g ra m m in g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     union {
                                       struct {
                                         WORD ax, bx, cx, dx;
                                       } word;
                                       struct {
                                         BYTE al, ah, bl, bh, cl, ch, dl, dh;
                                       } byte;
                                     } regs;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     The members of the w o rd structure will be overlaid with the members of the
                                     b y t e structure: for example, a x will occupy the same memory as a l and a h . And
                                     that, of course, is exactly what we wanted. Here’s an example showing how the
                                     r e g s union might be used:

                                     regs.byte.ah = 0x12;
                                     regs.byte.al = 0x34;
                                     printf("AX: %hx\n", regs.word.ax);

                                     Changing a h and a l affects a x , so the output will be

                                     AX: 1234aZYXWVUTSRQPONMLKJIHGFEDCBA

                                           Note that the b y t e structure lists a l before a h . even though the AL register
                                     is the “low” h a lfo f AX and AH is the “high’' half. Here’s the reason. When a data
                                     item consists of more than one byte, there are two logical ways to store it in mem­
                                     ory: with the bytes in the “natural” order (with the leftmost byte stored first) or
                                     with the bytes in reverse order (the leftmost byte is stored last). The first alternative
                          Q&A                   big-endian; the second is known as little-endian, C doesn’t require a spe­
                                     is called cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     cific byte ordering, since that depends on the CPU on which a program will be exe­
                                     cuted. Some CPUs use the big-endian approach and some use the little-endian
                                     approach. What does this have to do with the b y t e structure? It turns out that x86
                                     processors assume lhat data is stored in little-endian order, so the first byte of
                                     r e g s . w o r d . a x is the low byte.
                                           We don’t normally need to worry about byte ordering. However, programs that
                                     deal with memory at a low level must be aware of the order in which bytes are
                                     stored (as the r e g s example illustrates). It’s also relevant when working with files
                                     that contain non-character data.


                                     Be careful when using unions to provide multiple views ofdaia. Data that is valid
                         A           in its original format may be invalid when viewed as a different type, causing
                                     unexpected problems.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                     U s in g P o in te r s a s A d d r e s s e s

                                      We saw in Section 11.1 that a pointer is really some kind of memory address,
                                     although we usually don't need to know the details. When we do low-level pro­
                                     ^g rammingc^. however, the details matter.
                                                               2 0 .3   O t h e r L o w - L e v e lT e c h n iq u e s hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                              52 1 onmlkjihgfedcbaZYXWVU


                        An address often has the same number of bits as an integer (or long integer).
                   Creating a pointer that represents a specific address is easy: \vejust cast an integer
                   into a pointer. For example, here’s how we might store the address l000 (hex) in a
                   pointer variable:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                   BYTE *p;

                   p = (BYTE *) 0x1000;                   /* p contains address 0x1000 */


                   V ie w in g M e m o r y
 P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA   L o c a ti o n s

                   Our next program allows the user to view segments ofco m p u ter mem ory; it relies
                   on C ’s willingness to allow an integer to be used as a pointer. Most CPUs execute
                   programs in “protected mode," however, which m eans that a program can access
                   only those portions of memory that belong to the program. This prevents a pro­
                   gram from accessing (or changing) memory that belongs to another application or
                   to the operating system itself. As a result, w e’ll only be able to use our program to
                   view areas of memory that have been allocated for use by the program itself. Going
                   outside these regions will cause the program to crash.
                        The v ie w m e m o r y .c program begins by displaying the address of its own
                   m a in function as well as the address o fo n e of its variables. This will ogive the user
                   a clue as to which areas of memory can be probed. The program next prompts the
                   user to enter an address (in the form of a hexadecimal integer) plus the number of
                   bytes to view. The program then displays a block of bytes of the chosen length,
                   starting at the specified address.
                        Bytes are displayed in groups of 10 (except for the last group, which may have
                   fewer than 10 bytes). The address of a group of bytes is displayed at the beginning
                   of a line, followed by the bytes in the group (displayed as hexadecimal numbers).'
                   followed by the same bytes displayed as characters (just in case the bytes happen to
                   represent characters, as some of them may). Only printing characters (as deter­
                   mined by the i s p r i n t function) will be displayed: other characters wiII be
                   shown as periods.
                        W e'll assume that i n t values are stored using 32 bits and that addresses are
                   also 32 bits long. Addresses are displayed in hexadecim al, as is customary.BA

viewmemory.C       /★   Allows the user to view regions of computer memory */

                   #include <ctype.h>
                   #include <stdio.h>

                   typedef unsigned char BYTE;

                   int main(void)
                        unsigned int addr;
                        int i, n;
                        BYTE *ptr;
                        printf("Address of main function: %x\n", (unsigned int) main);
                        printf("Address of addr variable: %x\n”, (unsigned int) &addr);
5 2 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 0    L o w -L e v e l P ro g ra m m in g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        printf("\nEnter a (hex) address: ”);
                                        scanf("%x", &addr);
                                        printf("Enter number of bytes to view:                              ”);
                                        scanf("%d", &n);

                                        print f (”\n”);
                                        printf(” Address                                    Bytes                                         Characters\n");
                                        printf(” -------                                                                                  ---------- \n ”) .

                                        ptr = (BYTE *) addr;
                                        for (; n > 0; n -= 10) {
                                          printf("%8X  ", (unsigned int) ptr);
                                          for (i = 0; i < 10 && i < n; i++)
                                            printf("%.2X ”, *(ptr + i));
                                          for (; i < 10; i++)
                                            printf(”   ");
                                          printf(” ”);
                                          for (i = 0; i < 10 && i < n; i++) {
                                            BYTE ch = * (ptr + i ) ;
                                            if (’isprint(ch))


                                            }
                                            printf("\n");
                                            ptr += 10;


                                        return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          The program is complicated somewhat by the possibility that the value of n
                                     isn’t a multiple of 10, so there may be fewer than 10 bytes in the last group. Two of
                                     the f o r statements are controlled by the condition i < 10 && i < n. This condi­
                                     tion causes the loops to execute 10 times or n times, whichever is smaller. There’s
                                     also a f o r statement that compensates for any missing bytes in the last group by
                                     displaying three spaces for each missing byte. That way, the characters that follow
                                     the last group of bytes will align properly with the character groups on previous
                                     lines.
                                          The %X conversion specifier used in this program is similar to %x, which was
                                     discussed in Section 7.1. The difference is that %X displays the hexadecimal digits
                                     A, B } C, D, E, and F as upper-case letters; %x displays them in lower case.
                                          Here’s w hathappened when I compiled the program using GCC and tested it
                                     on an x86 system running Linux:

                                     Address of main function: 804847c
                                     Address of addr variable: bff41154

                                     Enter a (hex) address: 8048000
                                     Enter number of bytes to view: 40

                                      Address                                 Bytes                               Characters

                                       8048000          7F 45 4C 46 01 01 01 00 00                          00    .E L F .. • • • •
                                       804800A          00 00 00 00 00 00 02 00 03                          00
                                       8048014          01 00 00 00 C0 83 04 08 34                          00    •   •   •   •   ♦   •   ..4.
                                       804801E          00 00 C0 0A 00 00 00 00 00                          00
                                      2 0 .3                                                       523onmlkjihgfedcbaZYXWV
                                               O th e r L o w -L e v e l T e c h n iq u e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


I asked the program to display 40 bytes starting at address 8048000, which pre­
cedes the address o fth e m a in function. Note the 7F byte followed by bytes repre­
senting the letters E, L, and E These four bytes identify the form at (ELF) in which
the executable file was stored. ELF (Executable and Linking Format) is widely
used by UNIX systems, including Linux. 8048000 is the default address at which
ELF executables are loaded on x86 platforms.
     L efs run the program again, this time displaying a block of bytes that starts at
the address of the a d d r variable:

Address of main function: 804847c
Address of addr variable: bfec5484

Enter a (hex) address: bfec5484
Enter number of bytes to view: 64

 Address                         Bytes                           Characters

BFEC5484       84 54 EC BF B0 54 EC BF F4 6F                     .T...T...o
BFEC548E       68 00 34 55 EC BF C0 54 EC BF                     h.4U...T..
BFEC5498       08 55 EC BF E3 3D 57 00 00 00                     .U...=W...
BFEC54A2       00 00 A0 BC 55 00 08 55 EC BF                     ....U..U..
BFEC54AC       E3 3D 57 00 01 00 00 00 34 55                     .=W.... 4U
BFEC54B6       EC BF 3C 55 EC BF 56 11 55 00                     ..<U..V.U.
BFEC54C0       F4 6F 68 00                                       .o h .

None of the data stored in this region of memory is in character form, so it's a bit
hard lo follow. However, we do know one thing: the a d d r variable occupies the
first four bytes of this region. When reversed, these bytes form the number
BFEC5484, the address entered by the user. Why the reversal? Because x86 pro­
cessors store data in little-endian order, as we saw earlier in this section.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


T h e volatile T y p e Q u a l i f i e r

On some computers, certain memory locations are “volatile” : lhe value stored at
such a location can change as a program is running, even though the program itself
isn’t storing new values there. For example, some memory locations might hold
data coming directly from input devices.
     The v o l a t i l e type qualifier allows us to inform the com piler if any of the
data used in a program is volatile. v o l a t i l e typically appears in the declaration
of a pointer variable that will point to a volatile memory location:

volatile BYTE *p;             /* p will point to a volatile byte */

     To see why v o l a t i l e is needed, suppose that p points to a memory location
that contains the most recent character typed at the user’s keyboard. This location
is volatile: its value chang^v‘es each time the user e^^nters a character. We might use the
following loop to obtain characters from the keyboard and store them in a buffer
array:
5 2 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 0    L o w -L e v e l P ro g ra m m in g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              (buffer notfull) {
                                     wh i1e PONMLKJIHGFEDCBA
                                        waitfor input;
                                       buffer[i] = *p;
                                        if (buffer[i++] == ‘\ n ‘)
                                           break;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     A sophisticated compiler might notice that this loop changes neitherp nor *p. so it
                                     could optimize thc program by altering it so that *p is fetchcd just once:
                                     store *p in u registei",
                                     while {buffernotfull) {
                                        waitfor input;
                                        buf fer [i ] = value stored in register;
                                        if (buffer[i++] == '\n')
                                           break;


                                     The optimized program will fill the buffer with many copies of the same charac­
                                     ter— not exactly what we had in mind. Declaring that p points to volatile data
                                     avoids this problem by telling the compiler that *p must be fetched from memory
                                     each time it’s needed.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      W h a t d o y o u m e a n b y s a y in g th a t th e & a n d | o p e r a to r s s o m e tim e s p r o d u c e
                                     th e s a m e r e s u lts a s th e && a n d | | o p e r a to r s , b u t n o t a lw a y s ? [p . 5 1 1 ]
                             A:      Let’s compare i & j with i && j (similar remarks apply to | and | | ). As long as
                                     i and j have the value 0 or 1 (in any combination), the two expressions will have
                                     the same value. However, if i and j should have other values, the expressions may
                                     not always match. If i is 1 and j is 2, for example, then i & j has the value 0 ( i
                                     and j have no corresponding 1 bits), while i && j has the value I. If i is 3 and j
                                     is 2. then i & j has the value 2, while i && j has the value 1.
                                                                                                     alw ays increments j
                                           Side effects are another difference. Evaluating i & j+ + cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     as a side effect, whereas evaluating i && j ++ som etim es increments j .

                             Q:      W h o c a r e s h o w D O S s to r e s file d a te s ? I s n ’t D O S d e a d ? [p . 5 1 6 ]
                             A:      For the most part; yes. However, there are still plenty of files created years ago
                                     whose dates are stored in the DOS format. In any event, DOS file dates are a good
                                     example of how bit-fields are used.

                             Q:      W h e r e d o th e te r m s “ b ig -e n d ia n ” a n d “ lit tle -e n d ia n ” c o m e fr o m ? [p . 5 2 0 ]
                             A:      In Jonathan Swift's novel G ulliver’s Travels, the fictional islands of Lilliput and
                                     Blefuscu are perpetually at odds over whether to open boiled eggs on the big end
                                     or the little end. The choice is arbitrary, of course, just like the order of bytes in a
                                     data item.
                                                                                                                                      525hgfedcbaZYXWVUTSRQ
                                                                                                               E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG




                                 E x e rc is e s aZYXWVUTSRQPONMLKJIHGFEDCBA

                                     * l.   Show the output produced by each of the following program
S e c t i o n 2 0 .1 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                          fragments. A ssum e that i, j.
                                 and k are u n s i g n e d s h o r t variables.
                                 (a) i = 8; j = 9;
                                     printf("%d", i >> 1 + j >> 1);
                                 (b) i = 1;
                                     printf("%d", i & ~i);
                                 (C) i = 2; j = 1; k = 0;
                                     printf("%d", ~i & j ^ k);
                                 (d) i = 7; j = 8; k = 9;
                                     printf("%d", i A j & k);

                      ©    2.    Describe a sim ple way to ‘’toggle’* a bit (change it from 0 to 1 or from 1 to 0). Illustrate the
                                 technique by writing a statem ent that toggles bit 4 o f the variable i .

                          *3.    Explain what effect the following macro has on its argum ents. You may assum e that the
                                 argum ents have the same type.
                                 #define M(x,y)            ((x)^ = (y), (y)^ = (x), (x)^ = (y))

                      ©    4.    In com puter graphics, colors arc often stored as three num bers, representing red, green, and
                                 blue intensities. Suppose that each num ber requires eight bits, and w e’d like to store all three
                                 values in a single long integer. W rite a m acro named MK_COLOR with three param eters (the
                                 red, green, and blue intensities). MK_COLOR should return a l o n g in which the last three
                                 bytcs contain the red. green, and blue intensities, with the red value as the last byte and the
                                 green value as the next-to-last byte.

                           5.    W rite macros named GET_RED. GET_GREEN. and GET_BLUE that, when given a color as
                                 an argum ent (see Excrcise 4), return its 8-bit red. green, and bluc intensities.

                      ©    6.    (a) Use the bitwise operators lo write the following function:
                                 unsigned short swap_bytes(unsigned short i);
                                 s w a p _ b y t e s should retum lhc num ber that results from sw apping the two bytes in i .
                                 (Short integers occupy two bytes on most com puters.) For exam ple, if i has the value
                                 0 x 1 2 3 4 (00010010 00110100 in binary), then s w a p _ b y t e s should return 0 x 3 4 1 2
                                 (00110100 00010010 in binary). Test your function by writing a program that reads a num ­
                                 ber in hexadecim al, then writes the num ber with its bytes sw apped:
                                 Enter a hexadecimal number (up to four digits): 1234
                                 Number with bytes swapped: 3412cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 H int: Use the %hx conversion to read and writc the hex numbers.
                                 (b) C ondense the s w a p _ b y t e s function so that its body is a single statem ent.

                           7.    W rite the following functions:
                                 unsigned int rotate_left(unsigned int i, int n);
                                 unsigned int rotate_right(unsigned int i, int n);
                                 r o t a t e _ l e f t should return the result o f shifting the bits in i to the left by n places,
                                 with the bits that were ‘"shifted o f f ’ moved to the right end o f i . (For exam ple, the call
            C h a p te r2 0    L o w - L e v e lP r o g r a m m in g aZYXWVUTSRQPONMLKJIHGFEDCBA
5 2 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                   r o t a t e _ l e f t ( 0 x l 2 3 4 5 6 7 8 , 4) should return 0 x 2 3 4 5 6 7 8 1 ifin teg ers are 32 bits
                                   long.) r o t a t e _ r i g h t is similar, but it should “rotate” bits to the right instead of the left.

                       ©     8.     Let f be the following function:
                                   u n s ig n e d   in t    f(u n s ig n e d     i n t cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                         i , i n t m, i n t n)

                                         re tu rn    (i    >>   (m 4- 1 - n ) )         & ~ (~ 0      << n ) ;
                                    }
                                    (a) W h a tis th e v a lu c o f ~ ( ~ 0 << n ) ?
                                    (b) What does this function do?

                             9.    (a) W rite the following function:
                                    in t    c o u n t_ o n e s (u n s ig n e d c h a r c h ) ;
                                    c o u n t _ o n e s should retum the n u m b ero f 1 bits in c h .
                                   (b) W rite the function in parL (a) without using a loop.

                            10.    Write the following function:
                                   u n s ig n e d   in t    r e v e r s e _ b i t s (u n s ig n e d   in t n ) ;
                                   r e v e r s e _ b i t s should relum an unsigned integer whose bits are the same as those in n
                                   but in reverse order.

                            11.    Each of the following macros defines the position of a single bit within an integer:
                                   # d e f i n e S H IF T _ B IT 1
                                   # d e f i n e CTRL_B IT       2
                                   # d e f i n e A L T _B IT     4
                                   The following statement is supposed to test whether any o f the three bits have been set. but it
                                   never displays the specified message. Explain why the statement doesn’t work and show
                                   how to fix it. Assume that k e y _ c o d e is an i n t variable.
                                    if      ( k e y _ c o d e & (S H IF T _ B IT | C TRL_B IT | A L T _B IT )              == 0)
                                         p r in tf ( " N o m o d ifie r k ey s p r e s s e d \n " ) ;

                            12.    The following function supposedly combines two bytes to form an unsigned short integer.
                                   Explain why the function doesn’t work and show how to fix it.
                                   u n s ig n e d   s h o rt c re a te _ s h o rt(u n s ig n e d        c h a r h ig h _ b y te ,
                                                                                   u n s ig n e d       c h a r lo w _ b y te )

                                         re tu rn   h ig h _ b y te    << 8 + l o w _ b y t e ;
                                    }

                           *13.    If n is an u n s i g n e d i n t variable, what effect does the following statement have on the
                                   bits in n?
                                   n &= n - 1 ;
                                   H im : Consider the effect on n if this statement is executed more than once.

                               © 14.         When stored according to the.IEEE fioating-point standard, a f l o a t
S e c t i o n 2 0 . 2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                               value consists o f a 1-
                                   bit sign (the leftmost— or most significant— bit), an 8-bit exponent, and a 23-bit fraction, in
                                   tliat order. Design a structure type that occupies 32 bits, with bit-field members correspond­
                                   ing to the sign, exponent, and fraction. Declare the bit-fields to have type u n s i g n e d i n t .
                                   Check the manual for your compiler to determine the order of the bit-fields.
                                                                                                                              527onmlkjihgfedcbaZYXWV
                                                                                       P ro g ra m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLKJIH


                      * 15.   (a) Assume that the variable s has been declared as follows:
                              struct {
                                int flag: 1;
                              } s;
                              With some compilers, executing the following statements causes 1 to be displayed, but with
                              other compilers, the output is -1 . Explain the reason for this behavior.
                              s.flag = 1;
                              printf("%d\n", s.flag);
                              (b) How can this problem be avoided? aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c t io n 2 0 .3    16.    Starting with the 386 processor, x86 CPUs have 32-bit registers named EAX. EBX, ECX,
                              and EDX. The second half (the least significant bits) of these registers is the same as AX,
                              BX. CX, and DX, respectively. Modify the r e g s union so that it includes these registers as
                              well as the older ones. Your union should be set up so that modifying EAX changes AX and
                              modifying AX changes the second half of EAX. (The other new registers will work in a sim ­
                              ilar fashion.) You’ll need to add soine “dummy” members to the w o rd and b y t e structures,
                              corresponding to the other half of EAX. EBX, ECX. and EDX. Declare the type of the new
                              registers to be DWORD (double word), which should be defined as u n s i g n e d l o n g . D on’t
                              forget that the x86 architecture is little-endian.




                              P r o g r a m m in g P r o je c t s

                         1.   Design a union that makes it possible to view a 32-bit value as cither a f l o a t or the struc­
                              ture described in Exercise 14. Write a program that stores 1 in the structure’s sign field, 128
                              in the exponent field, and 0 in the fraction field, then prints the f l o a t value stored in the
                              union. (The answer should bc -2 .0 if you’ve set up the bit-fields correctly.)
             21                 T h e S t a n d a r d L ib r a r y                                                  ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                              E v e ry p ro g ra m is a p a r t o f s o m e o th e r p r o g r a m a n d r a r e ly fits. onmlkjihgfedcbaZYX




                                In previous chapters we’ve looked at the C library piecemeal: this chapter focuses
                                on the library as a whole. Section 2 1. 1 lists general guidelines for using the library.
                                It also describes a trick found in some library headers: using a macro to “hide” a
                                function. Section 2 1.2 gives an overview of each header in (he C89 library: Section
                                2 l.3 does the same for the new headers in the C99 library.
                                      Later chapters cover the library’s headers in depth, with related headers
                                grouped together into chapters. The < s t d d e f . h > and < s t d b o o l . h > headers
                                are very brief, so Tve chosen to discuss them in this chapter (in Sections 21.4 and
                                21.5. respectively).




                   2 1 .1       U s in g t h e L ib r a r y dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                The C89 standard library is divided into 15 parts, with each part described by a
                      C 99      header. C99 has an additional nine headers, for a total of 24 (see Table 2 1. 1).

               T a b le 2 L l       <assert.h>                 <inttypes.h>f             <signal.h>                       <stdlib.h>
Standard Library Headers kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    <complex.h>f               <iso646.h>+               <stdarg.h>                       <string.h>
                                    <ctype.h>                  <limits.h>                <stdbool.h>'                     <tgmath.h>1
                                    <errno.h>                  <locale.h>                <stddef.h>                       <time.h>
                                    <fenv.h>+                  <math.h>                  <stdint.h>f                      <wchar.h>'
                                    <float.h>                  <setjmp.h>                <stdio.h>                        <wctype.h>'hgfedcbaZYXWVUTSRQPO
                                     'C 9 9 o n !v*


                                    Most compilers come with a more extensive library that invariably has many
                                headers that don’t appear in Table 2 l .l . The extra headers aren't standard, of



                                                                                                                                                   529
5 3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 1    T h e S ta n d a rd L ib ra ry onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     course, so we can’t count on them to be available with other com pilers. These
                                     headers often provide functions that are specific on a particular com puter or oper­
                                     ating system (which explains why they’re not standard). They may provide func­
                                     tions that allow more control over the screen and keyboard. H eaders that support
                                     graphics or a window-based user interface are also com m on.
                                          The standard headers consist prim arily o f function prototypes, type defini­
                                     tions, and m acro definitions. If one of our files contains a call o f a function
                                     declared in a header or uses one of the types or macros defined there, w e’ll need to
                                     include the header at the beginning of the file. W hen a file includes several stan­
                                     dard headers, the order of # i n c l u d e directives doesn’t matter. It’s also le*g«»>al to
                                     include a standard header more than once.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     R e s tr ic tio n s o n N a m e s U se d in th e L ib r a r y

                                     Any file that includes a standard header must obey a couple o fru le s. First, it can ’t
                                     use the names of macros defined in that header for any other purpose. If a file
                                     includes < s t d i o . h > , for example, it can 't reuse NULL, since a m acro by that
                                     nam e is already defined in < s t d i o . h > . Second, library names with file scope
                                     ( t y p e d e f nam es, in particular) can’t be redefined at the file level. Thus, if a file
                                     includes < s t d i o . h> , it can’t define s i z e _ t as a identifier with file scope, since
                                     < s t d i o .h > defines s i z e _ t to be a t y p e d e f name.
                                            Although these restrictions are pretty obvious, C has other restrictions that you
                                     might not expect:cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       ■ Id e n tifie rs th a t begin with a n u n d e rsc o re fo llo w e d by a n u p p er-ca se lette r or
                                         a se c o n d u n d ersc o re are reserved for use within the library; program s should
                                         never use names of this form for any purpose.
                                       ■ Id e n tifie rs th a t b eg in with an u n d e rsc o re are reserved for use as identifiers
                                         and tags with file scope. You should never use such a name for your own pur­
                                         poses unless it’s declared inside a function.
                                       ■ E very id e n tifie r w ith e x te rn a l lin k a g e in th e sta n d a rd library is reserved for
                                         use as an identifier with external linkage. In particular, the names of all stan­
                                         dard library functions are reserved. Thus, even if a file d o e sn 't include
                                         < s t d i o . h > , it shouldn’t define an external function named p r i n t f , since
                                         there’s already a function with this name in the library.
                                     These rules apply to every file in a program, regardless o f which headers the file
                                     includes. Although these rules aren’t always enforced, failing to obey them can
                                     lead to a program that’s not portable.
                                          The rules listed above apply not ju st to names that are currently used in the
                                     library, but also to names that are set aside for future use. The com plete description
                                     o fw h ich names are reserved is rather lengthy; you’ll find it in the C standard under
                                     “ future library directions.” As an example, C reserves identifiers that begin with
                                     s t r followed by a lower-case letter, so that functions with such names can be
                                     added to the < s t r i n g . h> header.
                                                                                        2 1 .2                                              531 dcbaZYXWVUTSRQPO
                                                                                                  C 8 9 L ib r a r y O v e r v ie w hgfedcbaZYXWVUTSRQPONMLKJIHG


                                      F u n c t io n s H id d e n b y M a c r o s aZYXWVUTSRQPONMLKJIHGFEDCBA

                                      It’s common for C programmers to replace small functions by parameterized mac­
                                      ros. This practice occurs even in the standard library. The C standard allows head­
                                      ers to define macros that have the same names as library functions, but protects the
                         Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      programmer by requiring that a true function be available as well. As a result, it’s
                                                                                                   a n d define a macro with the
                                      not unusual for a library header to declare a function cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      same name.
                                              We’ve already seen an example of a macro duplicating a library function,
                                      g e t c h a r is a library function declared in the < s t d i o . h> header. It has the fol­
                                      lowing prototype:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      int getchar(void);

                                      < s t d i o . h> usually defines g e t c h a r as a macro as well:

                                      #define getchar() getc(stdin)

                                      By default, a call o f g e t c h a r will be treated as a macro invocation (since macro
                                      names are replaced during preprocessing).
                                           Most of the time, w e’re happy using a macro instead of a true function,
                                      because it will probably make our program run faster. Occasionally, though, we
                                      want a genuine function, perhaps to minimize the size of the executable code.
                                           If the need arises, we can remove a macro definition (thus gaining access to
# u n d e f d ir e c t iv e > M . 3   the true function) by using the # u n d e f directive. For example, we could undefine
                                      the g e t c h a r macro after including < s t d i o . h>:

                                      #include <stdio.h>
                                      #undef getchar

                                      If g e t c h a r isn't a macro, no harm has been done; # u n d e f has no effect when
                                      given a name that’s not defined as a macro.
                                           As an alternative, we can disable individual uses of a macro by putting paren­
                                      theses around its name:

                                      ch = (getchar)();                /* instead of ch = getchar();

                                      The preprocessor can’t spot a parameterized macro unless its name is followed by
                                      a left parenthesis. The com piler isn’t so easily fooled, however; it can still recog­
                                      nize g e t c h a r as a function.




                     2 1 .2           C 8 9 L ib r a r y O v e r v ie w

                                      We’ll now take a quick look at the headers in the C89 standard library. This section
                                      can serve as a “road map” to help you determine which part of the library you
                                      need. Each header is described in detail later in this chapter or in a subsequent
                                      chapter.
5 3 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 1    T h e S t a n d a r d L ib r a r y kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


    <assert.h>                                     Diagnostics         onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



     < a s s e r t . h > h e ad er > 2 4 .1        Contains only the a s s e r t macro, which alJows us to insert self-checks into a pro­
                                                   gram. If any check fails, the program terminates.


        <ctype.h>                                  Character Handling
       < c t y p e . h > header > 2 3 .5           Provides functions for classifying characters and for converting letters from lower
                                                   to upper case or vice versa.


        <errno.h> Errors
       < e r m o . h > header > 2 4 .2             Provides e r r n o (“error number”), an lvalue that can be tested after a call of cer­
                                                   tain library functions to see ifan error occurred during the call.


        <float.h>                                  Characteristics of Floating Types
       < f l o a t . h > hea de r > 2 3 .1         Provides macros that describe the characteristics of floating types, including their
                                                   range and accuracy.


    <limits.h>                                     Sizes of Integer Types
     < l i m i t s . h > header > 2 3 .2           Provides macros that describe the characteristics of integer types (including char­
                                                   acter types), including their maximum and minimum values.


    <locale.h> Localization
     < l o c a l e . h > h ea d er > 2 5 .1        Provides functions to help a program adapt its behavior to a country or other geo­
                                                   graphic region. Locale-specific behavior includes the way numbers are printed
                                                   (such as the character used as the decimal point), the format of monetary values
                                                   (the currency symbol, for example), the character set, and the appearance of the
                                                   date and time.


           <math.h>                                Mathematics
        < m a t h . h > header > 2 3 .3            Provides common mathematical functions, including trigonometric, hyperbolic,
                                                   exponential, logarithmic, power, nearest integer, absolute value, and remainder
                                                   functions.


    <setjmp.h> Nonlocal Jumps
    < s e t j m p . h > h e a d e r > 2 4 . 4 BA   Provides the s e t j m p and l o n g j m p functions, s e t j m p “marks” a place in a pro­
                                                   gram; l o n g j m p can then be used to return to that place later. These functions
                                                                                            2 1 .2                                            5 3 3 kjihgfedcbaZYXWVU
                                                                                                     C 8 9 L ib r a r y O v e rv ie w hgfedcbaZYXWVUTSRQPONMLKJIHG


                                               make it possible to jum p from one function into another, still-active function,
                                               bypassing the normaJ function-return mechanism, s e t j m p and l o n g j m p are
                                               used primarily for handling serious problems that arise during program execution.BA


    <signal.h>                                 Signal Handling
     < s i g n a l . h > header > 2 4 .3       Provides functions that deal with exceptional conditions (signals), including inter­
                                               rupts and run-time errors. The s i g n a l function installs a function to be called if a
                                               g^*iven si ^s^n al should occur later. The r a i s e function causes a sig^**nal to occur.


    <stdarg.h>                                 Variable Arguments
     < s t d a r g . h > hea de r > 2 6 .1     Provides tools for writing functions that, like p r i n t f and s c a n f . can have a
                                               variable number of arguments.


    <stddef.h>                                 Common Definitions
     < s t d d e f . h > h ea d er > 2 1 .4    Provides definitions of frequently used types and macros.


                                               Input/Output
< s t d i o . h > h e a d e r> 2 2 J -2 2 .5   Provides a huge assortment of input/output functions, including operations on both
                                               sequential and random-access files.


    <stdlib.h>                                 General Utilities
     < s C d l i b . h > header > 2 6 .2       A “catchall” header for functions that don't fit into any of the other headers. The
                                               functions in this header can convert strings to numbers, generate pseudo-random
                                               numbers, perform memory management tasks, communicate with the operating
                                               system, do searching and sorting, and perform conversions between multibyte
                                               characters and wide characters.


    <string.h>                                 String Handling
     < s t r i n g . h > header > 2 3 .6       Provides functions that perform string operations, including copying, concatena­
                                               tion. comparison, and searching, as well as functions that operate on arbitrary
                                               blocks of memory.


            <time.h>                           Date and Time
                                               Provides functions for determining the time (and date), manipulating times, and
         < t i m e . h > h e a d e r > 2 6 . 3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                               formatting times for display.
5 3 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 1    T h e S ta n d a rd L ib ra ry aZYXWVUTSRQPONMLKJIHGFEDCBA




                              2 1 .3          C 9 9 L ib r a r y C h a n g e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              Some of the biggest changes in C99 affect the standard library. These changes fall
                                              into three groups:RQPONMLKJIHGFEDCBA
                                               ■      A d d i t i o n a l h e a d e r s . The C99 standard library has nine headers that don’t exist
                                                       in C89. Three of these ( < i s o 6 4 6 . h > , < w c h a r .h > . and < w c t y p e .h > )
                                                       were actually added to C in 1995 when the C89 standard was amended. The
                                                       other six ( < c o m p l e x . h>. < f e n v . h>, < i n t t y p e s . h> , < s t d b o o l . h>,
                                                       < s t d i n t . h>, and < t g m a t h . h>) are new in C99.
                                                                                               The C99 standard adds macros and func­
                                                   ■ A d d itio n a l m a c r o s a n d f u n c tio n s .
                                                       tions to several existing headers, primarily < f l o a t . h > , < m a th .h > . and
                                                       < s t d i o . h > . The additions to the < m a th .h > header are so extensive that
                                                       they’re covered in a separate section (Section 23.4).
                                                                                                       Some existing functions, including
                                               ■ E n h a n c e d v e r s io n s o f e x is tin g f u n c tio n s .
                                                       p r i n t f and s c a n f , have additional capabilities in C99.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                   We’ll now lake a quick look at the nine additional headers in the C99 standard
                                              library, just as we did in Section 2 l.2 for the headers in the C89 library.BA


 <complex.h>                                  Complex Arithmetic
   < c o m p l e x . h > h ea de r > 2 7 .4   Defines the c o m p le x and I macros, which are useful when working with com ­
                                              plex numbers. Also provides functions for performing mathematical operations on
                                              complex numbers.


            <fenv.h>                          Floating-Point Environment
         < f e n v . h > header > 2 7 .6      Provides access to floating-point status flags and control modes. For example, a
                                              program might test a flag to see ifoverflow occurred during a floating-point opera­
                                              tion or set a control mode to specify how rounding should be done.


<inttypes.h> Format Conversion of Integer Types
  < i n t t y p e s . h > header > 2 7 .2     Defines macros that can be used in format sirings for input/output of the integer
                                              types declared in < s t d i n t .h > . Also provides functions for working with great­
                                              est-width integers.


    <iso646.h> Alternative Spellings
     < is o 6 4 6 .h > header > 2 5 .3        Defines macros that represent certain operators (the ones containing the characters
                                              &, | , ~, !, and ^). These macros are useful for writing programs in an environment
                                              where these characters might not be part of the local character set.
                                                                       2 1 .4                                                                                    535
                                                                                T h e < s t d d e f . h > H e a d e r : C o m m o n D e f i n i t i o n s kjihgfedcbaZYXWVUTSRQPONMLKJIH


 stdbool.h>                                      Boolean Type and Values
                                           hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                            onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



< s t d b o o l . h > h e a d e r > 2 1 . 5 BA   Defines the b o o l , t r u e , and f a l s e macros, as well as a macro that can be used
                                                 to test whether these macros have been defined.


 <stdint.h>                                      Integer Types
  < s t d i n c . h > h ea de r > 2 7 .1         Declares integer types with specified widths and defines related macros (such as
                                                 macros that specify the maximum and minimum values of each type). Also defines
                                                 parameterized macros that construct integer constants with specific types.


 <tgmath.h>                                      Type-Generic Math
  < t g m a t h . h > header > 2 7 .5            In C99, there are multiple versions of many math functions in ihe < m a th . h> and
                                                 < c o m p l e x .h > headers. The “type-generic” macros in < t g m a t h . h > can detect
                                                 the types of the arguments passed to them and substitute a call of the appropriate
                                                 < m a th .h > or < c o m p l e x .h > function.


     <wchar.h>                                   Extended Multibyte and Wide-Character Utilities
    < w c h a r . h > header > 2 5 .5            Provides functions for wide-character input/output and wide string manipulation.


 <wctype.h>                                      Wide-Character Classification and Mapping Utilities
  < w c t y p e . h > header > 2 5 .6            The wide-character version of < c t y p e . h > . Provides functions for classifying
                                                 and changing the case of wide characters.aZYXWVUTSRQPONMLKJIHGFEDCBA




                             2 1 .4              The             <stddef.h> H e a d e r : C o m m o n D e f i n i t i o n s
                                                 The < s t d d e f .h > header provides definitions offrequcntly used types and mac­
                                                 ros; it doesn’t declare any functions. The types are:

                                                      ■       p t r d i f f _ t . The type of the result when two pointers are subtracted.
                                                  ■           s i z e _ t . The type returned by the s i z e o f operator.
                                                          ■   w c h a r _ t . A type large enough to represent all possible characters in all sup­
                                                              ported locales.
                                                 All three are names for integer types: p t r d i f f _ t must be a signed type, while
                                                 s i z e _ t must be an unsigned type. For more information about w c h a r _ t , see
                                                 Section 25.2.
                                                       The < s t d d e f .h > header also defines two macros. One of them is NULL,
                                                 which represents the null pointer. The other macro, o f f s e t o f , requires two argu­
                                                           type (a structure type) and m em ber-d esignato r (a mem ber of the structure).
                                                 ments: cbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 3 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 1     T h e S t a n d a r d L ib r a r y onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              o f f s e t o f computes the number of bytes between the beginning of the structure
                                              and the specified member.
                                                    Consider the following structure:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              struct s {
                                                 char a;
                                                 int b [2] ;
                                                 float C;
                                              };

                                              The value of o f f s e t o f ( s t r u c t s , a ) must be 0: C guarantees that the first
                                              member of a structure has the same address as the structure itself. We can’t say for
                                              sure what the offsets o f b and c are. One possibility is that o f f s e t o f ( s t r u c t
                                              s , b ) is l (since a is one byte long), and o f f s e t o f ( s t r u c t s , c ) is 9
                                              (assuming 32-bit integers). However, some compilers leave "holes"— unused
                                              bytes— in structures (see the Q&A section at the end of Chapter 16), which can
                                              affect the value produced by o f f s e t o f . I f a compiler should leave a three-byte
                                              hole after a , for example, then the offsets o f b and c would be 4 and l2, respec­
                                              tively. But that’s the beauty of o f f s e t o f : it produces the correct offsets for any
                                              compiler, enabling us to write portable programs.
                                                    There are various uses for o f f s e t o f . For example, suppose that we want to
                                              save the first two members of an s structure in a file, if<c^*>norin^g^ the c member,
          fw r ite   fu n c tio n > 2 2 . 6   Instead ofhaving the f w r i t e function write s i z e o f ( s t r u c t s ) bytes, which
                                              would save the entire structure, w e’ll tell it to write only o f f s e t o f ( s t r u c t s ,
                                              c ) bytes.
                                                    A final remark: Some of the types and macros defined in < s t d d e f . h >
                                              appear in other headers as well. (The NULL macro, for example, is also defined in
                                              < l o c a l e . h > , < s t d i o . h > , < s t d l i b . h > , < s t r i n g . h > , and < t i m e . h > ,
                                              as well as in the C99 header < w c h a r .h > .) As a result, few programs need to
                                              include < s t d d e f . h>.aZYXWVUTSRQPONMLKJIHGFEDCBA




                            2 1 .5            T h e < s t d b o o l . h > H e a d e r (C 9 9 ): B o o le a n T y p e
                                              a n d V a lu e s

                                              The < s t d b o o l . h> header defines four macros:
                                                    ■ bool    (defined to be _ B o o l)
                                                    ■ t r u e (defined to be 1)
                                                    ■ f a l s e (defined to be 0)
                                                ■       b o o l _ t r u e _ f a l s e _ a r e _ d e f i n e d (defined to be 1)
                                              We’ve seen many examples o fh o w b o o l , t r u e , and f a l s e are used. Potential
                                              uses o f t h e __ b o o l _ t r u e _ f a l s e _ a r e _ d e f i n e d macro are more limited. A
                                              program could use a preprocessing directive (such as # i f or # i f d e f ) to test this
                                              macro before attempting to define its own version o f b o o l . t r u e , or f a l s e .
                                                                                                                                 A
                                                                                                                           0 &PONMLKJIHGFEDCBA
                                                                                                                                          537aZYXWVUTSRQPON




                         Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                   Q:    T n o tic e th a t y o u u se th e te r m “ s t a n d a r d h e a d e r ” r a th e r th a n “ s ta n d a r d
                         h e a d e r file .” Is th e r e a n y r e a s o n fo r n o t u s in g th e w o r d “ H le” ? onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                   A:    Yes. According^^ to the C standard, a “standard header" need not be a file. Althoug^*h
                         most compilers do indeed store standard headers as Illes, the headers could in fact
                         be built into the compiler itself.

                   Q:    S e c tio n 1 4 .3 d e s c r ib e d s o m e d is a d v a n ta g e s o f u s in g p a r a m e t e r i z e d m a c r o s in
                         p la c e o f fu n c tio n s . In lig h t o f th e s e p r o b le m s , i s n ’t it d a n g e r o u s to p r o v i d e a
                         m a c r o s u b s t it u te fo r a s ta n d a r d lib r a r y fu n c tio n ? [p . 5 3 1 ]
                   A:    According to the C standard, a parameterized macro that substitutes for a library
                         function must be “fully protected" by parentheses and must evaluate its arguments
                         exactly once. These rules avoid most o fth e problems mentioned in Section 14.3.




                         E x e r c is e s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

S e c tio n 21.1    l.   Locate where header files are kept on your system. Find thc nonstandard headers and deter­
                         mine the purpose ofeach.

                         Having located thc header files on your system (see Excrcise l ). find a standard header in
                         which a macro hides a function.

                    3.   When a macro hides a function, which must come first in the header file: lhc macro defini­
                         tion or the function prototype? Justify your answer.

                    4.   Make a list of all reserved identifiers in the “future library directions” section of the C99
                         standard. Distinguish between identifiers tliat arc reserved for use only when a specific
                         header is included versus identifiers that are reserved for use as external names.

                   *5.   Thc i s l o w e r function, which belongs to < c t y p e . h > , tests whether a character is a
                         lower-case letter. Why would the following macro version of i s l o w e r not be legal,
                         according to the C standard? (You may assume that the character set is ASC11.)
                         # d e fin e     is lo w e r(c )       ((c )    >=     'a *   && (c )       <=    ’z ’ )

                    6.   The < c t y p e . h > header usually defines most of its functions as macros as well. These
                         macros rely on a static array that’s declared in < c t y p e .h > but defined in a separate file. A
                         portion of a typical < c t y p e .h > header appears below. Use this sam ple to answer the fol­
                         lowing questions.
                         (a) Why do the names of the “bit” macros (such as _UPPER) and the _ c t y p e array begin
                         with an underscore?
                         (b) Explain what the _ c t y p e array will contain. Assuming that the character set is ASCH,
                         show the values of the array elements at positions 9 (the horizontal lab character). 32 (the
                         space character), 65 (the letter A), and 94 (the ^ character). Scc Section 23.5 for a descrip­
                         tion of what each macro should reium.
5 3 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 1    T h e S ta n d a r d L ib ra ry onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     (c) W hat’s the advantage ofusing an array to implement these macros? kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                     #define _UPPER                   0x01         /* upper-case letter */
                                     #define _LOWER                   0x02         /* lower-case letter */
                                     #define -DIGIT                   0x04         /* decimal digit */
                                     #define _CONTROL                 0x08         /* control character */
                                     #define _PUNCT                   0x10         /* punctuation character */
                                     #define _SPACE                   0x2 0        /* white-space character */
                                     #define -HEX                     0x4 0        /* hexadecimal digit */
                                     #define BLANK                    0x80         /* space character */
                                     #define         isalnum(c)             (_ctype[c] & (_UPPER_LOWER|_DIGIT))
                                     #define         isalpha(c)             (_ctype[c] & (_UPPER_LOWER))
                                     #define         iscntrl(c)             (_ctype[c] & _CONTROL)
                                     #define         isdigit(c)             (_ctype[c] & _DIGIT)
                                     #define         isgraph(c)             (_ctype[c] &
                                                                              (-PUNCT|_UPPER|-LOWER|_DIGIT))
                                     #define islower(c)                     (_ctype[c] & _LOWER)
                                     #define isprint(c)                     ( ctype[c] &
                                                                              (_BLANK|_PUNCT|-UPPER|_LOWER|_DIGIT))
                                     #define         ispunct(c)             (_ctype[c] & _PUNCT)
                                     #define         isspace(c)             (_ctype[c] & _SPACE)
                                     #define         isupper(c)             (_ctype[c] & _UPPER)
                                     #define         isxdigit(c)            (_ctype[c] & (_DIGIT|_HEX))

S e c t io n 2 1 .2     ©      7.    In which standard header would you expect to fmd each of the following?
                                     (a) A function that determines the current day of the week
                                     (b) A function that tests whether a character is a digit
                                     (c) A macro that gives the largest u n s i g n e d i n t value
                                     (d) A function that rounds a lloating-point number to the next higher integer
                                     (e) A macro that specifies the number of bits in a character
                                     (f) A macro that specifies the number of significant digits in a d o u b l e value
                                     (g) A function that searches a string for a particular character
                                     (h) A function that opens a file for reading aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     P r o g r a m m in g P r o je c t s

                               l.    Write a program that declares the s structure (see Section 2 1.4) and prints the sizes and off­
                                     sets of the a. b, and c members. (Use s i z e o f to find sizes; use o f f s e t o f to find off­
                                     sets.) Have the program print the size of the entire structure as well. From this information,
                                     determine whether or not the structure has any holes. If it docs, describe the location and
                                     size of each.
2 2   ln p u t /O u t p u t                     ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                   In m a n - m a c h in e s y m b io s is , it is m a n
                                                                 w h o m u s t a d ju s t: T h e m a c h in e s c a n 't. onmlkjihgfedcbaZYX




      C ’s input/output library is the biggest and most important part of the standard
      library. As befits its lofty status, we'll devote an entire chapter (the longest in the
      book) to the < s t d i o . h> header, the primary repository of input/output functions.
           W e've been using < s t d i o . h> since Chapter 2. and we have experience with
      the p r i n t f , s c a n f . p u t c h a r . g e t c h a r . p u t s , and g e t s functions. This
      chapter provides more information about these six functions, as well as introduc­
      ing a host of new functions, most ofw hich deal with files. Fortunately, many o fth e
      new functions are closely related to functions with which w e're already
      acquainted, f p r i n t f . for instance, is the “file version" o fth e p r i n t f function.
            W e’ll start the chapter with a discussion o fso m e basic issues: the stream con­
      cept, the F IL E type, input and output redirection, and the difference between text
      files and binary files (Section 22.1). W e’ll then tnrn to functions that are designed
      specifically for use with files, including functions that open and close files (Section
      22.2). After covering p r i n t f . s c a n f . and related functions for “ form atted”
      input/output (Section 22.3), w e'll look at functions that read and write unformatted
      data:
        ■ g e t c , p u t c . and related functions, which read and write one c h a r a c t e r at a
            time (Section 22.4).
        ■ g     e t s , p u t s , and related functions, which read and write one l i n e at a time
              (Section 22.5).
        ■ f r e a d and f w r i t e , which read and write b l o c k s of data (Section 22.6).
      Section 22.7 then shows how to perform random access operations on files.
      Finally, Section 22.8 describes the s p r i n t f , s n p r i n t f . and s s c a n f func­
      tions, variants o f p r i n t f and s c a n f that write to a string or read from a string.
           This chapter covers all but eight of the functions in < s t d i o . h > . One of
      these eight, the p e r r o r function, is closely related lo the < e r r n o . h> header, so hgfedcbaZYXWVUT


                                                                                                                   539
           C h a p te r 2 2
540 cbaZYXWVUTSRQPONMLKJIHGFEDCBA ln p u t/O u tp u t

                                            1’11 postpone il until Section 24.2, which discusses that header. Section 26.1 covers
                                            the remaining functions ( v f p r i n t f , v p r i n t f . v s p r i n t f . v s n p r i n t f ,
                                           v f s c a n f , v s c a n f , and v s s c a n f ) . Thcsc functions rely on the v a _ l i s t type,
                                            which is introduced in that section.
                                                    In C89, all standard input/output functions belong to < s t d i o . h> . but such is hgfedcb
                                .C99onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
      < w c h a r.h > h e a d e r> 2 5 .5   not the case in C99, where some I/O functions are declared in the < w c h a r .h >
                                            header. The < w c h a r . h> functions deal with wide characters rather than ordinary
                                           characters; the good news is that most of these functions closely resemble those of
                                            < s t d i o . h>. Functions in < s t d i o . h> that read or write data are known as byte
                                           in p u t/o id p u tfiu ic tio n s; sim ilarfunctions in < w c h a r .h > arecaIled w ide-charac­
                                           ter in p u t/o u tp u t fu n c tio n s. aZYXWVUTSRQPONMLKJIHGFEDCBA




                        2 2 .1       S tre a m s

                                     In C, the term stream means any source of input or any destination for output.
                                     Many small programs, like the ones in previous chapters, obtain all their input
                                     from one stream (usually associated with the keyboard) and write all their output to
                                     another stream (usually associated with the screen).
                                           Larger programs may need additional streams. These streams often represent
                                     files stored on various media (such as hard drives, CDs. DVDs, and flash memory),
                                     but they could just as easily be associated with devices that don’t store files: net­
                                     work ports, printers, and the like. We’ll concentrate on files, since they’re common
                                     and easy to understand. (I may even occasionally use the term file when I should
                                     say stream .) Keep in mind, however, that many o fth e functions in < s t d i o . h >
                                     work equally well with aII streams, not just the ones that represent files.dcbaZYXWVUTSRQPONMLK


                                     F ile P o in te r s

                                     Accessing a stream in a C program is done through a file po in ter, which has type
                                     F IL E * (the F IL E type is declared in < s t d i o . h > ) . Certain streams are repre­
                                     sented by file pointers with standard names; we can declare additional file pointers
                                     as needed. For example, ifa program needs two streams in addition to the standard
                                     ones, it might contain the following declaration:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     FILE *fpl, *fp2;

                                     A program may declare any number of F IL E * variables, although opcrating sys­
                                     tems usually limit the number ofstream s that can be open at one time.


                                     S ta n d a r d S tr e a m s a n d R e d ir e c tio n

                                     < s t d i o . h > provides three standard streams (Table 2 2 .l). These streams arc
                                     ready to use— we don’t declare them, and we don’t open or close them.
                                                                                                       22.1        StreamskjihgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                                 541dcbaZYXWVUTSRQPON

       T a b le 2 2 .1 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                      F ile P o in te r      S tr e a m     D e fa u lt M e a n in g
Standard Streams RQPONMLKJIHGFEDCBA                      stdin            Standard input         Keyboard
                                                        stdout            Standard output         Screen
                                                        stderr             Standard error         Screen aZYXWVUTSRQPONMLKJIHGFEDCBA

                                The functions lhat w e’ve used in previous chapters— p r i n t f , s c a n f ,
                          p u t c h a r . g e t c h a r . p u t s , and g e t s — obtain input from s t d i n and send out­
                          put to s t d o u t . By default, s t d i n represents the keyboard; s t d o u t and
                          s t d e r r represent the screen. However, many operating systems allow these
              Q&A         default meaning^^s to be chang^W                                         redirectio n.
                                                                  'ed via a mechanism known as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                Typically, we can force a program to obtain its input from a file instead of
                          from the keyboard by putting the name of the file on the command line, preceded
                          by the < character:
                          demo <in.dat

                          This technique, known as in put redirectio n, essentially makes the s t d i n stream
                          represent a file ( i n . d a t . in this case) instead of the keyboard. The beauty of redi­
                          rection is that the dem o program doesn’t realize that it's reading from i n . d a t ; as
                          far as it knows, any data il obtains from s t d i n is being entered at the keyboard.
                               O u tp u t redirection is similar. Redirecting the s t d o u t stream is usually done
                          by putting a file name on the command line, preceded by the > character:
                          demo >out.dat

                          All data written to s t d o u t will now go into the o u t . d a t file instead of appear­
                          ing on the screen. Incidentally, \ve can combine output redirection with input redi­
                          rection:
                          demo <in.dat >out.dat

                          The < and > characters don’t have to be adjacent to file names, and the order in
                          which the redirected files are listed doesn't matter, so the following examples
                          would w orkjust as well:
                          demo < in.dat > out.dat
                          demo >out.dat <in.dat

                               One problem with output redirection is that everything written lo s t d o u t is
                          put into a file. If the program goes off the rails and begins writing error messages,
                          we w on’t see them until we look at the file. This is where s t d e r r comes in. By
                          writing^v* error m
                                           ^» essages lo s t d e r r instead of s t d o u t , we^v^can guarantee that
                          those messages will appear on the screen even when s t d o u t has been redirected.
                          (Operating systems often allow s t d e r r itself to be redirected, though.)


                          T e x t F ile s v e r s u s B in a r y F ile s

                          < s t d i o . h > supports two kinds of files: text and binary. The bytes in a te x t f i l e
                          represent characters, making it possible for a human to examine the file or edit it.
5 4 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 2    ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                                                                               b in a ry
                                       T he source code for a C program is stored in a text file, for exam ple. In a cbaZYXWVUTSRQPONM
                                      f i l e , on the other hand, bytes d o n ’t necessarily represent characters; groups of
                                       bytes m ight represent other types o fd a ta . such as integers and floating-point num ­
                                       bers. An executable C program is stored in a binary file, as y ou’ll quickly realize if
                                       you try to look al the contents o f one.
                                                Text files have tw o characteristics that binary files d on’t possess:dcbaZYXWVUTSRQPONMLKJIHG
                                         ■ T e x t f ile s a re d iv id e d in to lines. Each line in a text file norm ally ends with
                                           one or two special characters; the choice of characters depends on the operat­
                                           ing system. In W indow s, the end-of-line m arker is a carriage-return character
                                           ( ' \ x O d ' ) followed im m ediately by a line-feed character ( ' \ x O a ' ) - In
                                           UN IX and new er versions o f the M acintosh operating system (M ac OS), the
                                           end-of-line m arker is a single line-feed character. O lder versions of M ac OS
                           Q&A             use a single carriage-return character.
                                         ■ T e x t f il e s m a y c o n ta in a sp e c ia l “e n d -o f-file ” m a rk e r. Som e operating sys­
                                           tems allow a special byte to be used as a m arker at the end o f a text file. In
                                           W indows, the m arker is ’ \ x l a ’ (Ctrl-Z). T here's no requirem ent that Ctrl-Z
                                           be present, but if it is, it m arks the end o f the file; any bytes after C trl-Z are to
                                           be ignored. The C trl-Z convention is a holdover from DOS, which in turn
                                           inherited it from CP/M , an early operating system for personal com puters.
                                           M ost other operating system s, including UNIX , have no special end-of-file
                                           character.

                                      Binary files aren’t divided into lines. In a binary file, there are no end-of-line or
                                      end-of-file m arkers; all bytes are treated equally.
                           Q&A             W hen we write data to a file, w e'll need to consider w hether to store it in text
                                      form or in binary form. To see the difference, consider how we m ight store the
                                      num ber 32767 in a file. O ne option would be to write the num ber in text form as
                                      the characters 3, 2, 7, 6, and 7. If the character set is ASCII, w e'd have the follow ­
                                      ing five bytes:

                                                                                                                 00110111|
                                                          00110011        00110010         00110111   00110110

                                                                                                        '6 '


                                      The other option is to store the num ber in binary, which would take as few as two
                                      bytes:




          Hitie-endianorder>20.3      (The bytes will be reversed on system s that store data in little-endian order.) As
                                      this exam ple shows, storing num bers in binary can often save quite a bit of
                                      space.
                                           W hen w e’re writing a program that reads from a file or w rites to a file, we
                                      need to take into account w hether it’s a text file or a binary file. A program that dis­
                                      plays the contents of a file on the screen will probably assum e it’s a text file. A file-
                                                                                                   2 2 .2                                      543
                                                                                                            F ile O p e r a t io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJ


                                      copying program , on the other hand, can ’t assume that the file to be copied is a text
                                      file. If it does, binary files containing an end-of-file character w on’t be copied
                                      completely. When we can’t say for sure whether a file is text or binary, it’s safer to
                                      assume that it’s binary.aZYXWVUTSRQPONMLKJIHGFEDCBA




                      2 2 .2          F ile O p e r a t io n s

                                      Simplicity is one o fth e attractions of input and output redirection; there’s no need
                                      to open a file, close a file, or perform any other explicit file operations. U nfortu­
                                      nately, redirection is too limited for many applications. When a program relies on
                                      redirection, it has no control over its files; it doesn’t even know their names. Worse
                                      still, redirection doesn’t help if the program needs to read from two files or write to
                                      two files at the same time.
                                            When redirection isn’t enough, w e’ll end up using the file operations that
                                      < s t d i o . h > provides. In this section, w e’ll explore these operations, which
                                      include opening a lile, closing a file, changing the way a file is buffered, deleting a
                                      file, and renaming a file.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      O p e n in g a F ile kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                 restrict filename,
                                       FILE *fopen(const char * PONMLKJIHGFEDCBA
                                                   const char * restrict mode);

                        fopen         Opening a file for use as a stream requires a call of the f o p e n function, f o p e n 's
                                      first argument is a string containing the name of the file to be opened. (A “file
                                      name” may include inform ation about the file’s location, such as a drive specifier
                                      orpath.) The second argument is a “mode string” that specifies what operations we
                                      intend to perform on the file. The string " r " , for instance, indicates that data will
                                      be read from the file, but none will be written to it.hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
r e s t r i c t k e y w o rd > 17.8         Note that restrict appears twice in the prototype for the fopen function.
                         <@ >         r e s t r i c t , which is a C99 keyword, indicates that f i l e n a m e and m ode should
                                      point to strings that don’t share memory locations. The C89 prototype for f o p e n
                                      doesn’t contain restrict but is otherwise identical, restrict has no effect
                                      on the behavior of f o p e n , so it can usuallyjust be ignored. In this and subsequent
                                      chapters, T’U italicize restrict as a rem inder that it’s a C99 feature.


                                      Windows programmers: Be careful when the file name in a call of f o p e n includes
                         A
    escape sequences > 7 .3
                                      the \ character, since C treats \ as the beginning o fa n escape sequence. The call
                                      fopen("c:\project\testl.dat", "r")

                                      will fail, because the com piler treats \ t as a character escape, ( \ p isn 't a valid
                                      character escape, but it looks like one. The C standard slates that its meaning is
544 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 2   ln p u t/O u tp u t


                                   undefined.) There are two ways to avoid the problem. One is to use \ \ instead of kjihgfedc


                                   fopen("c:\\project\\testl.dat", "r")

                                   The other technique is even easier—just use the / character instead of \ :
                                   fopen("c:/project/testl.dat", "r")

                                   Windows will happily accept / instead of \ as the directory separator.


                                        f o p e n returns a file pointer that the program can (and usually will) save in a
                                   variable and use later whenever it needs to perform an operation on the file. H ere’s
                                   a typical call of f o p e n . where f p is a variable of type F IL E *:

                                   fp = fopen("in.dat",             "r”);       /* opens in.dat for reading */

                                   When the program calls an input function to read from i n . d a t later, it will sup­
                                   ply f p as an argument.
                                        When it can't open a file, f o p e n returns a null pointer. Perhaps the file
                                   doesn't exist, or it’s in the wrong place, or we d o n't have perm ission to open it.


                                   Never assume that a file can be opened; always test the return value of f o p e n to

                        A          make sure it's not a null pointer.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                   M odes

                                   W hich mode string w e’ll pass to f o p e n depends not only on what operations we
                                   plan to perform on the file later but also on w hether the file contains text or binary
                                   data. To open a text file, w e’d use one of the mode strings in Table 22.2.

                 T a b le 2 2 .2                   String                         Meaning
               Mode Strinu^*s                       "r"     O p en fo rread in g
               forText Files aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                    "w"     Open for writing (fde need not exist)
                                                    "a"     Open for appending (file need nol exist)
                                                   "r + "   Open for reading and writing, staning at beginning
                                                   ”w + ”   Open for reading and writing (truncate if file exists)
                                                   "a+ "    Open for reading and writing (append if file exists)

                                          When we use f o p e n
                        Q & A cbaZYXWVUTSRQPONMLKJIHGFEDCBA      to open a binary file, w e’ll need to include the letter b in
                                   the mode string. Table 22.3 lists mode strings for binary files.
                                         From Tables 22.2 and 22.3, we see that < s t d i o . h > distinus^uishes between
                                   w riting data and appending data. When data is written to a file, it norm ally over­
                                   writes what was previously there. When a file is opened for appending, however,
                                   data written to the file is added at the end. thus preserving the file’s original contents.
                                         By the way, special rules apply when a file is opened for both reading and writ­
                                   ing (the mode string contains the + character). We can 't switch from reading to writ-
                                                                                                                2 2 .2      F ile O p e ra tio n s hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                                                           5 4 5 dcbaZYXWVUTSRQPO


                         T a b le 2 2 .3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                   S tr in g                                 M e a n i n g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
            Mode String<^s for                                 "rb"                    Open for reading
               Binary Files RQPONMLKJIHGFEDCBA                 "wb "                   Open for writing (file need not exist)
                                                               "ab"                    Open for appending (file need not exist)
                                                           "r+b"or"rb+"                Open for reading and writing, starting at beginning
                                                           "w+b"or"wb+"                Open for reading and writing (truncate if file exists)
                                                           "a+b"or"ab+"                Open for reading and writing (append if file exists) aZYXWVUTSRQPONMLKJIHGFEDCBA

fiie -p o s itio n in g fu n c iio n s > 2 2 .7   ing without first calling a file-positioning function unless the reading operation
                                                  encountered the end of the file. Also, we can’t switch from writingc^ to reading^> with-
                                                  out eithercalling f f l u s h (covered laterin this section) orcalling a file-positioning
                                                  function.


                                                  C lo s in g a F ile


                                                   in t   fc lo s e (F IL E          * s tre a m );

                                  fclose          The f c l o s e function allows a program to close a file that it’s no longer using.
                                                  The argument to f c l o s e must be a file pointer obtained from a call of f o p e n or
                                                  f r e o p e n (discussed later in this section), f c l o s e returns zero if the file was
                                                  closed successfully; otherwise, it returns the error code EOF (a macro defined in
                                    Q&A           < s t d i o . h>).
                                                        To show how f o p e n and f c l o s e are used in practice, here’s the outline o f a
                                                  program that opens the file e x a m p l e . d a t for reading, checks that it was opened
                                                  successfully, then closes it before terminating:

                                                  #include <stdio.h>
                                                  #include <stdlib.h>

                                                  #define FILE_NAME "example.dat"

                                                  int main(void)
                                                  {
                                                    FILE *fp;

                                                     fp = fopen(FILE_NAME, "r");
                                                     if (fp == NULL) {
                                                       printf("Can't open %-s\n", FILE_NAME);
                                                       exit(EXIT_FAILURE);

                                                    •••
                                                    fclose(fp);
                                                    return 0;


                                                  O fcourse, C programmers being the way they are, it’s not unusual to see the call of
                                                  f o p e n combined with the declaration of f p :

                                                  FILE *fp = fopen(FILE_NAME,                      "r");
           C h a p te r 2 2    ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 4 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                     or the test aogainst NULL:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     if ((fp = fopen(FILE_NAME,                         "r")) == NULL) ...


                                     A tt a c h in g a F ile to a n O p e n S tr e a m

                                       FILE *freopen(const char * PONMLKJIHGFEDCBA
                                                                   restrict filename,
                                                     const char * restrict mode,
                                                     FILE * restrict stream);

                                       f r e o p e n attaches a different file to a stream that’s already open. The most com ­
                      fre o p e n dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     mon use of f r e o p e n is to associate a file with one of the standard streams
                                     ( s t d i n , s t d o u t , or s t d e r r ) . To cause a program to begin writing to the file
                                     f o o , for instance, we could use the following call of f r e o p e n :
                                     if (freopen("foo", "w”, stdout) == NULL)                          {
                                       /* error; foo c a n ’t be opened */


                                     After closing any file previously associated with s t d o u t (by command-line redi­
                                     rection or a previous call of f r e o p e n ) , f r e o p e n will open f o o and associate it
                                     with s t d o u t .
                                          f r e o p e n ’s normal return value is its third argument (a file pointer), l f i t can’t
                                     open the new file, f r e o p e n returns a null pointer, ( f r e o p e n ignores the error if
                                     the old file can’t be closed.)
                                          C99 adds a new twist. If f i l e n a m e is a null pointer, f r e o p e n attempts to
                                     change the stream ’s mode to that specified by the m ode parameter. Implementa­
                                     tions aren’t required to support this feature, however: if they do, they may place
                                     restrictions on which mode changes are permitted.


                                     O b ta in in g F ile N a m e s fr o m t h e C o m m a n d L in e
                                     When we’re writing a program that will need to open a file, one problem soon
                                     becomes apparent: how do we supply the file name to the program? Building file
                                     names into the program itselfdoesn’t provide much flexibility, and prompting the
                          Q&A        user to enter file names can be awkward. Often, the best solution is to have the pro­
                                     gram obtain file names from the command line. When we execute a program
                                     named dem o, for example, we might supply it with file names by putting them on
                                     the command line:
                                     demo names.dat dates.dat

                                          In Section 13.7, we saw how to access command-line arguments by defining
                                     m a in as a function with two parameters:
                                     int main(int argc,                  char *argv[])
                                     {
                                                                          2 2 .2                                 547onmlkjihgfedcbaZYXWVU
                                                                                   F ile O p e ra tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                 a r g c is the number of com m and-line arguments; a r g v is an array of pointers to
                 the argument strings, a r g v [ 0 ] points to the program name, a r g v [ l ] through
                 a r g v [ a r g c - 1 ] point to the rem aining arguments, and a r g v [ a r g c ] is a null
                 pointer. In the example above, a r g c is 3, a r g v [0] points to a string containing
                 the program name, a r g v [1] points to the string " n a m e s . d a t ", and a r g v [2 ]
                 points to the string " d a t e s . d a t " :

                                      argvcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 *program name

                                                                               d   a    t   \0

                                                 ► d                           d   ahgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                  C h e c k in g W h e th e r a F ile C a n
P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA                   B e O pened
                 The following program determ ines if a file exists and can be opened for reading.
                 When the program is run, the user will give it a file name to check:

                 canopen file

                 The program will then print either file c a n b e o p e n e d o r J ile c a n ’ t b e
                 o p e n e d . If (he user enters the wrong num ber ofargum ents on the command line,
                 the program will print the m essage u s a g e : c a n o p e n f i l e n a m e to remind the
                 user that c a n o p e n requires a single file name.BA

 canopen.c       /* Checks whether a file can be opened for reading */

                 #include <stdio.h>
                 #include <stdlib.h>

                 int main(int argc, char *argv[])

                    FILE *fp;

                    if (argc 1= 2) {
                      printf("usage: canopen filename\n");
                      exit(EXIT_FAILURE);


                    if ((fp = fopen(argv[l], "r")) == NULL) {
                      printf("%s can't be opened\n", argv[l]);
                      exit(EXIT_FAILURE);


                    printf("%s can be opened\n", argv[l]);
                    fclose(fp);
                    return 0;
            C h a p te r 2 2   ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 4 8 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                     Note that we can use redirection to discard the output of c a n o p e n and sim ply test
                                     the status value it returns.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T e m p o r a r y F ile s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           FILE *tmpfile(void);
                                           char *tmpnam(char *s);

                                     Real-world programs often need to create temporary files— files that exist only as
                                     long as the program is running. C compilers, for instance, often create temporary
                                     files. A com piler might first translate a C program to some interm ediate form,
                                     which it stores in a file. The com piler would then read the file later as it translates
                                     the program to object code. Once the program is completely com piled, there's no
                                     need to preserve the file containing the program ’s intermediate form, < s t d i o . h>
                                     provides two functions, t m p f i l e and tm p n am , for working with temporary files,
                        tmpfile            t m p f i l e creates a temporary file (opened in ”w b + ” mode) that will exist
                                     until it’s closed or the program ends. A call of t m p f i l e returns a file pointer that
                                     can be used to access the file later:

                                     FILE *tempptr;

                                     tempptr = tmpfile();                        /* creates a temporary file */

                                     If it fails to create a file, t m p f i l e returns a null pointer.
                                           Although t m p f i l e is easy to use. il has a couple ofdraw backs: (1) we don’t
                                     know the name of the file that t m p f i l e creates, and (2) we can't decide later to
                                     make the file permanent. If these restrictions turn out to be a problem, the alterna­
                                     tive is to create a temporary file using f o p e n . O fcourse. we don’t want this file to
                                     have the same name as a previously existing file, so we need some way to generate
                                     new file names; that’s where the tm p n a m function comes in.
                      tmpnam               tm p n am generates a name for a temporary file. If its argument is a null
                                     pointer, tm p n am stores the file name in a static variable and returns a pointer to il:

                                     char *filename;
                                     ••A
                                     filename = tmpnam(NULL);                           /* creates a temporary file name */

                                     Otherwise, tm p n am copies the file name into a character array provided by the
                                     programmer:

                                     char filename[L_tmpnam];
                                     •••

                                      tmpnam(filename);                                /* creates a temporary file name */

                                     In the latter case, tm p n am also returns a pointer to the first character of this array.
                                     L _ tm p n a m is a macro in < s t d i o . h> that specifies how long to make a character
                                     array that will hold a temporary file name.
                                                                      2 2 .2   F ile O p e ra tio n s hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                              5 4 9 onmlkjihgfedcbaZYXWVUT




         Be sure that tm p n am ’s argument points to an array o fa t least L _ tm p n am charac­
         ters. Also, be careful not to call tm pnam too often; thc TMP_MAX macro (defined
         in < s t d i o . h>) specifies the maximum number of temporary file names that can
         potentially be generated by tm pnam during the execution o f a program. I:fit fails
         to generate a file name, tm pnam returns a null pointer.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



         F ile B u ffe r in g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


           int fflush(FILE *stream);
           void                  restrict stream,
                  setbuf(FILE * PONMLKJIHGFEDCBA
                        char * restrict buf);
           int setvbuf(FILE * restrict stream,
                        char * restrict buf,
                        int mode, size_t size);

             Transferring data to or from a disk drive is a relatively slow operation. As a result,
             it isn't feasible for a program to access a disk file directly each time it wants lo
                                                                                             buffering:
             read or write a byte. The secret to achieving acceptable performance is cbaZYXWVUTSRQPONMLKJIHGFEDCBA
             data written to a stream is actually stored in a buffer area in memory; when it’s full
             (or the stream is closed), the buffer is “flushed” (written to the actual output
             device). Input streams can be buffered in a similar way: the buffer contains data
             from the input device; input is read from this buffer instead o f the device itself.
             Buffering can result in enormous gains in efficiency, since reading a byte from a
             buffer or storing a byte in a buffer takes hardly any time at all. O f course, it takes
             time to transfer the buffer contents to or from disk, but one large “block move” is
             much faster than many tiny byte moves.
                   The functions in < s t d i o . h> perform buffering automatically when il seems
             advantageous. The buffering lakes place behind the scenes, and we usually don’t
             worry about it. On rare occasions, though, we may need to take a more active role.
             Ifso , we can use the functions f f l u s h . s e t b u f . and s e t v b u f .
                   When a program writes output lo a file, the data normally goes into a buffer
fflu s h aZYXWVUTSRQPONMLKJIHGFEDCBA
             first. The buffer is flushed automatically when it's full or the file is closed. By call­
 Q&A         ing f f l u s h , however, a program can flush a file's buffer as often as it wishes. The
             call

         fflush(fp);                 /* flushes buffer for fp ★ /

         flushes the buffer for the file associated with f p . The call

         fflush(NULL);               /* flushes all buffers */

         flushes all output streams, f f l u s h returns zero if it's successful and EOF if an
         error occurs.
            C h a p te r 2 2
5 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBAln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                        setvbuf            s e t v b u f allows us to change the way a stream is buffered and to control the
                                      size and location of the buffer. The function’s third argum ent, which specifies the
                                      kind ofbufferingc? desired, shoould bc one o fth e following macros:

                                             ■   __IOFBF (full buffering). Data is read from the stream when the buffer is
                                                 em pty or written to the stream when it's full.
                                             ■ _ _IOLBF (line buffering). Data is read from the stream or written to the stream
                                                onc line at a time.
                                         ■       _IO N B F (no buffering). Data is read from the stream or written to the stream
                                                 directly, without a buffer.
                                      (All three macros are defined in < s t d i o . h > . ) Full buflering is the default for
                                      stream s that aren’t connected lo interactive devices.
                                             s e t v b u f ’s second argument (if it’s not a null pointer) is the address of the
                                      desired buffer. The buffer might have static storage duration, autom atic storage
                                      duration, or even be allocated dynamically. M aking the buffer autom atic allows its
                                      space to be reclaim ed automatically at block exit: allocating it dynam ically enables
                                      us to free the buffer when it’s no longer needed, s e t v b u f ' s last argum ent is the
                                      num ber of bytes in the buffer. A larger buffer may give better perform ance; a
                                      sm aller buffer saves space.
                                             For example, the following call o f s e t v b u f changes the buffering of
                                      s t r e a m to full buffering, using the N bytes in the b u f f e r array as the buffer:kjihgfedcbaZYX

                                      char buffer[N];

                                      setvbuf(stream, buffer,                         IOFBF, N);


                                      s e t v b u f must be called after s t r e a m is opened but before any other operations

                          A           arc perform ed on it.


                                           It’s also legal to call s e t v b u f with a null pointer as the second argument,
                                      which requests that s e t v b u f create a buffer with the specified size, s e t v b u f
                                      returns zero if it’s successful. It returns a nonzero value if the m o d e arw       a»*um ent is
                                      invalid or the request can’t be honored.
                         setbuf            s e t b u f is an older function that assum es default values for the buffering
                                      mode and buffer size, l f b u f is a null pointer, the call s e t b u f ( s t r e a m , b u f )
                                      is equivalent to

                                       (void) setvbuf(stream, NULL, _IONBF, 0);

                                      Otherwise, it’s equivalent to

                                       (void) setvbuf(stream, buf, _IOFBF, BUFSIZ);

                                      where B U FSIZ is a macro defined in < s t d i o . h> . The s e t b u f function is con­
                                      sidered obsolete; it’s not recommended for use in new programs.
                                                                           2 2 .3     F o rm a tte d l/O hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                 551




             When usina°, s e t v b u f or s e t b u f , be sure to close the stream before its buffer is
 A           deallocated. In particular, ifthe buffer is local to a function and has automatic stor­
     onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
             age duration, be sure to close the stream before the function returns.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



         M is c e lla n e o u s F ile O p e r a tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           int remove(const char *filename);
           int rename(const char *old, const char *new);

         The functions re m o v e and r e n a m e allow a program to perform basic file man­
         agement operations. Unlike most other functions in this section, re m o v e and
                                       nam es instead of file pointers. Both functions return zero
         r e n a m e work with file cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         if they succeed and a nonzero value if they fail.
remove          re m o v e deletes a file:

         remove("foo");                            /* deletes the file named "foo" */

         lf a program uses f o p e n (instead of t m p f i l e ) to create a temporary file, it can
         use re m o v e to delete the file before the program terminates. Be sure that the file
         to be removed has been closed; the effect of removing a file that's currently open is
         imp lemen tation-defi ned.
rename        r e n a m e changes the name of a file:

         rename("foo", "bar");                      /* renames "foo" to "bar" */

         r e n a m e is handy for renaming a temporary file created using f o p e n if a program
         should decide to make it permanent. Ifa file with the new name already exists, the
         effect is implementation-defined.


         If the file to be renamed is open, be sure to close it before calling re n a m e : the
 A       function may fail ifasked to rename an open file.aZYXWVUTSRQPONMLKJIHGFEDCBA




2 2 .3   F o r m a t t e d I/O

         In this section, we’ll examine library functions that use format strings to control
         reading and writing. These functions, which include our old friends p r i n t f and
         s c a n f , have the ability to convert data from character form to numeric form dur­
         ing input and from numeric form to character form during output. None of the
         other I/O functions can do such conversions.
            C h a p te r 2 2
5 5 2 ZYXWVUTSRQPONMLKJIHGFEDCBAln p u t/O u tp u t dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              T h e . . . p r i n t f F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                in t  f p r in tf ( F I L E * r e s t r i c t s tre a m ,
                                                                       c o n s t c h a r * r e s t r i c t fo rm a t, . . . ) ;
                                                                                          r e s t r i c t fo rm a t, . . . ) ;
                                                i n t p r i n t f ( c o n s t c h a r * cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                               fprintf             The f p r i n t f and p r i n t f functions write a variable num ber o f data items
                                printf        to an output stream , using a format siring lo control the appearance o f the output.
                        e iiip s is > 2 6 j   The prototypes for both functions end with the . . . symbol (an ellip sis), which
                                              indicates a variable num ber o f additional arguments. Both functions return the
                                              num ber o f characters written: a negative^*»     return value indicates that an error
                                              occurred.
                                                   The only difference between p r i n t f and f p r i n t f is that p r i n t f always
                                              writes to s t d o u t (the standard output stream ), whereas f p r i n t f writes to the
                                              stream indicated by its first argument:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              printf("Total: %d\n", total);                                       /* writes to stdout */
                                              fprintf(fp, ’’Total: %d\n", total);                                 /* writes to fp */

                                              A call of p r i n t f is equivalent to a call of f p r i n t f witli s t d o u t as the first
                                              argument.
                                                   D on’t think of f p r i n t f as merely a function that writes data to disk files,
                                              though. Like many functions in < s t d i o . h> , f p r i n t f works fine with any out­
                                              put stream. In fact, one of the most com m on uses of f p r i n t f — writing error
                                              m essages to s t d e r r , the standard error stream — has nothing to do with disk files.
                                              H ere’s what such a call might look like:

                                              fprintf(stderr,               "Error: data file c an’t be opened.\n");

                                              W riting the message to s t d e r r guarantees that it will appear on the screen even
                                              if the user redirects s t d o u t .
                                                   There are two other functions in < s t d i o . h> that can write form atted output
     v ...p r in tffu n c tio n s > 2 6 j     to a stream. These functions, named v f p r i n t f and v p r i n t f , are fairly
                                              obscure. Both rely on the v a _ l i s t type, which is declared in < s t d a r g . h > , so
                                              they’re discussed along with that header.


                                              . . . p r i n t f C o n v e r sio n S p e c ific a tio n s

                                              Both p r i n t f and f p r i n t f require a form at string containing ordinary charac­
                                              ters and/or conversion specifications. Ordinary characters are printed as is; conver­
                                              sion specifications describe how the rem aining argum ents are to be converted to
                                              character form for display. Section 3.1 described conversion specifications briefly,
                                              and we added more details in later chapters. W e’ll now review what we know
                                              about conversion specifications and fill in the rem aining gaps.
                                                   A . . . p r i n t f conversion specification consists of the % character, followed by
                                              as many as five distinct items:
                                                                                                           2 2 .3                                      553
                                                                                                                          F o r m a t te d I/O hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                                                                                                            c o n v e rs io n
                                                                     fla g s              p re c is io n     s p e c ifie r kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                        I                         T                  I
                                                                                   12 |.5
                                                            o cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                     #0                                    L |g
                                                            ^o onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                     A                      A

                                                                                m in im u m            le n g th
                                                                               fie ld w id th         m o d ifie r


                  Here\s a detailed description o fth ese items, which must appear in the order shown:

                   ■ F lags (optional; more than one perm itted). The - flag causes left justification
                     within a field; the other flags affect the way num bers are displayed. Table 22.4
                     gives a com plete list of flags.

T a b le 2 2 .4    F la g                                                                M e a n in g                                                                  |
                      —        Left-justify within field. (The default is right justification.)
                            ^^_^^_^__^_^^^^___^^_^^^^^_^__^^__^^^^^^^____^_^_^^^^^^^__^^^^_^^^^^^^^^^_^^^^^^^^^^^^^^^^^^^^^^._^^^^_^_^^^^^^^^^_^^_^^^_^^^^^_^^^^_^^^_^_^

                     +         Num bers produced by signed conversions always begin with + or - . (Normally,
                               only
                                 --
                                    negative
                                     -- - -
                                             numbers
                                             - —  -
                                                     are —preceded
                                                           —    ---
                                                                    by--a - sign.)
                                                                               -   —
                                                                                                                                                                       ,
                                                                                                                                                                       f

                   space       Nonnegative numbers produced by signed conversions are preceded by a space.
                               (The + flag overrides the space flag.)
                     #         Octal numbers beein
                                                C7 with 0, nonzero hexadecim al numbers with 0 x or 0X.
                               Floating-point numbers always have a decimal point. Trailing zeros aren’t
                               removed from numbers primed with the g or G conversions.
                      0        Numbers arc padded with leading zeros up to lhc field width. The 0 flag is
                   (zero)      ignored ifth e conversion is d. i , o, u, x , orX and a precision is specified. (The
                               - fiag overrides the 0 flag.)


                   ■ M in iin iim fie ld w idth (optional). An item that's too small to occupy this num ­
                     ber of characters will be padded. (By default, spaces are added to the left of
                     the item, thus right-justifying it within the field.) An item that’s too large for
                     the field width will still be displayed in its entirety. The field width is either an
                     integer or the character *. If * is present, the field width is obtained from the
                     next argument. If this argum ent is negative, it\s treated as a positive num ber
                     preceded by a - flag.
                   ■ P recision (optional). The meaning o fth e precision depends on the conversion:

                      d, i , o, u , x. X: minim um number o fd ig its
                                          (leading zeros are added if the num ber has fewer digits)
                      a . A, e , E, f , F: num ber of digits after the decim al point
                                         q~JPONMLKJIHGFEDCBA
                                            , G: num ber ofsigon ificant diogits
                                            7


                                               s: maximum number of bytes
                      The precision is a period ( . ) followed by an integer or the character *. If * is
                      present, the precision is obtained from the next argument. (If this argum ent is
                      negative, the effect is the same as not specifying a precision.) If only the
                      period is present, the precision is zero.
5 5 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 2    ln p u tA D u tp u t RQPONMLKJIHGFEDCBA


                                           ■                                    (optional). The presence of a length modifier indicates that
                                                  L e n g t h m o d i f i e r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  the item lo be displayed has a type that’s longer or shorter than is normal for a
                                                  particular conversion specification. (For example, %d normally refers to an
                                                  i n t value; %hd is used to display a s h o r t i n t and % ld is used to display a
                                                  l o n g i n t . ) Table 22.5 lists each length modifier, the conversion specifiers
                                                  with which it may be used, and the type indicated by the combination of the
                                                  lwo. (Any combination of length modifier and conversion specifier not shown
                                                  in the table causes undefined behavior.)

                        Table 22.5             L e n g th
       Len<   a^th Modifiers for       M o d ifie r           C o n v e r s io n S p e c if ie r s                               M e a n in g
       . . . p r i n t f Functions               h i?         d, i . o, u. x. X                         s ig n e d c h a r, u n s ig n e d c h a r
                                                              n                                         s ig n e d c h a r *
                                                   h          d. i . o, u. x, X                         s h o r t i n t . u n s ig n e d s h o r t i n t
                                                              n                                         sh o rt in t *
                                                    i         d. i . o. u. x. X                         l o n g i n t , u n s i g n e d l o n g i n tcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                 (ell)        n                                         lo n g i n t *
                                                              c                                         w in t_ t
                                                              s                                      ----w c-h- -a-r--_-t-- -*- --- -- - -—                              1
                                                              a. A. e. E, f . F. g. G                    no effectaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                         4.

                                                 11'          d, i . o. u. x, X                         lo n g lo n g i n t . u n s ig n e d lo n g lo n g i n t
                                               (ell-eU)       n                                         lo n g lo n g i n t *
                                                                                                                                                                         I
                                                  jf                                                    i n-t m_ a~x_ _t_,_ u__in__tm
                                                              d. i . o. u. x. X                                                     __a~x_ _t_ __________________        -   ---
                                                              n                                          i n t m a x ~~t *
                                                                                                     ^ ^ _ ^^^ ^_ ^^^   ^^^ ^^_ ^ -^ ^_ ^_ ^_ ^ _ _ _ ^^^ _ ^^_ ^ _ ___ l
                                                  ?           d, i , o, u. x, X                      ___s_i_z_e_ = _t __________________________________
                                                                                                                                ^^^"^^^^^^^^“"^' — •»——■              I
                                                              n                                          s iz e _ t *
                                                   t ?


                                                              d, i , o. u, x, X                         p trd iff_ t
                                                              n                                         p trd iff_ t *
                                                    L         a, A, e. E. f , F, g. G                   lo n g d o u b le
                                       'C 9 9 o n ly



                                       ■          C o n v e r s i o n s p e c i f i e r . The conversion specifier must be one of the characters
                                                  listed in Table 22.6. Notice that f , F, e. E, g, G, a, and A are all designed to
                                                  write d o u b l e values. However, they work fine with f l o a t values as weil:
 default argument promotions > 9 .3               thanks to the default argument promotions, f l o a t arguments are converted
                                                  automatically to d o u b l e when passed to a function with a variable number of
                                                  arguments. Similarly, a character passed to . . . p r i n t f is converted automati­
                                                  cally to i n t , so the c conversion works properly.


                                      Be careful to follow the rules described here: the effect of usinoa an invalid conver-
                                      sion specification is undefined.
                                                                                                                      2 2 .3    F o r m a tte d I/O onmlkjihgfedcbaZYXWVUTSRQPONMLKJI
                                                                                                                                                             5 5 5 dcbaZYXWVUTSRQPON


                          T a b le 2 2 .6           C onversion
Conversion Specifiers for                            S p e c ifie r                                          M e a n in g
   . . . p r i n t f Functions                             d, i          Converts an i n t value to decimal lbrm.
                                                        o. u. x , X      Converts an u n s i g n e d i n t value to base 8 (o). base 10 (u). or base 16
                                                                         (x. X). x displays the hexadecimal digits a - f in lower case: X displays
                                                                         them in upper case.
                                                           f7 F          Converts a d o u b l e value to decimal form, putting the decimal point in
                                                                         the correct position, lfn o precision is specified, displays six digits after
                                                                         the decimal point.
                                                           e, E          Converts a d o u b l e value to scientific notation. If no precision is spcci-          ।
                                                                         fied, displays six digits after the decimal point. If e is chosen, the expo­
                                                                         nent is preceded by the letter e; if E is chosen, the exponent is preceded
                                                                         by E.
                                                           g .G          g converts a d o u b l e value to either f form or e form, e form is selected
                                                                         if the n u m b ers exponent is less than ^ l o r greater than or equal lo the
                                                                         precision. Trailing zeros are not displayed (unless the # Hag is used); a
                                                                         decimal point appears only when followed by a digit. G chooses between
                                                                         F and E forms.
                                                          a + .A f       Converts a d o u b l e value to hexadecimal scientific notation using the
                                                                         form [ -] O x h .h h h h p ±d , where | - | is an optional minus sign, the /?'s rep­
                                                                         resent hex digits. ± is either a plus or minus sign, and d is the exponent, d
                                                                         is a decimal number that represents a power o f2 . If no precision is speci­
                                                                         fied. enough digits are displayed after the decimal point to represent the
                                                                         exact value of the number (if possible), a displays the hex digits a - f in
                                                                         lower case; A displays them in upper case. The choice o f a or A also
                                                                         affects the case o f the letters x and p.
                                                             c           Displays an i n t value as an unsigned character.
                                                             s           W rites the characters pointed to by the argument. Stops writing when the
                                                                         num b ero fb y tes specified by the precision (ifpresent) is reached o ra null
                                                                         character is encountered.
                                                             p           Converts a v o i d * value to printable form.
                                                             n           The corresponding argument must point to an object of type i n t . Stores
                                                                         in this object the number of characters written so far by this call of
                                                                         . . . p r i n t f ; produces no output.
                                                             o.Q PONMLKJIHGFEDCBA
                                                                            W rites the character %.                                                             1 hgfedcbaZYXWVUTSRQ

                                                    f
                                                        C 9 9 o n ly aZYXWVUTSRQPONMLKJIHGFEDCBA




                                      C 99         C 9 9 C h a n g e s to . . . p r i n t f C o n v e r s io n S p e c if ic a ti o n s

                                                   The conversion specifications f o r p r i n t f and f p r i n t f have undergone a num ­
                                                   ber of changes in C99:

                                                        ■ A d d itio n a lle n g th m odifiers. C99 adds the h h . 1 1 , j , z. and t length m odifi­
                                                          ers. h h and 11 provide addilional length options, j allows greatest-width inte­
   g re a te s t- w id th in te g e rs > 2 7 . 7          gers to be written, and z and t make it easier to write values o f type s i z e _ t
                                                          and p t r d i f f _ t , respectively.
5 5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 2   ln p u t/O u tp u t cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                          ■ A d d itio n a l co n version specifiers. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                        C99 adds the F. a. and A conversion specifi­
                                                            ers. F is the same as f except for the way in which infinity and NaN (see
                                                            below) are written. The a and A conversion specifications are rarely used.
                                                            T hey’re related to hexadecimal floating constants, which are discussed in the
                                                            Q&A section at the end of Chapter 7.aZYXWVUTSRQPONMLKJIHGFEDCBA
                                              > 2 3.4
I E E E flo a tin g -p o in t s t a n d a r d BA          ■ A b ility to write in fin ity a n d N aN . The IEEE 754 floating-point standard
                                                            allows the result o f a floating-point operation to be infinity, negative infinity,
                                                            or NaN (“not a num ber”). For exam ple, dividing 1.0 by 0.0 yields positive
                                                            infinity, dividing -1 .0 by 0.0 yields negative infinity, and dividing 0.0 by 0.0
                                                            yields NaN (because the result is mathem atically undefined). In C99, the a. A,
                                                            e, E, f , F, g, and G conversion specifiers arc capable ofconverting these spe­
                                                            cial values to a form that can be displayed, a , e, f . and g convert positive
                                                            infinity to i n f or i n f i n i t y (cither one is legal), negative infinity to - i n f
                                                            or - i n f i n i t y , and NaN to n a n or - n a n (possibly followed by a series of
                                                            characters enclosed in parentheses). A, E. F. and G arc equivalent to a . e . f .
                                                            and g. except that upper-case letters are used (IN F. IN F IN IT Y . NAN).
                  w id e c h a r a c t e r s > 2 5 .2     ■ S u p p o r tfo r wide ch aracters. Another C99 feature is the ability o f f p r i n t f
                                                            to write wide characters. The % lc conversion specification is used to write a
                                                            single wide character; % ls is used for a string of wide characters.
                                                          ■ P reviously u n d e fin e d co n versio n sp ecifica tio n s now allow ed. In C89, the
                                                            effect of using % le, %lE, % lf, % lg. and %lG is undefined. These conversion
                                                            specifications are legal in C99 (the 1 length modifier is simply ignored).dcbaZYXWVUTSRQ


                                                        E x a m p le s o f . . . p r i n t f C o n v e r s i o n S p e c if ic a t io n s
                                                        Whew! Lt’s about time for a few examples. We*ve seen plenty ofeveryday conver­
                                                        sion specifications in previous chapters, so w e’ll concentrate here on illustrating
                                                        some of the more advanced ones. As in previous chapters. I’lI use • to represent
                                                        the space character.
                                                             L et’s start off by examining the effect of flags on the %d conversion (they have
                                                        a similar effect on other conversions). The first line ofT able 22.7 shows the effect
                                                        of %8d without any flags. The next four lines show the effect of the - , +. space.
                                                        and 0 flags (the # flag is never used with %d). The remaining lines show the effect
                                                        ofcom binations of flagc>s,

                               T a b le 2 2 .7                              C o n v e rs io n    R e s u lt o fA p p ly in g            R e s u lt o f A p p ly in g
                E ffect o f F lag s on                                    S p e c ific a tio n   C o n v e r s io n to 1 2 3            C o n v e r sio n to - 1 2 3
               th e %d C o n v ersio n RQPONMLKJIHGFEDCBA                         % 8d                •••••1 2 3                              ••••-1 2 3
                                                                                % -8 d                          . ...................         -1 2 3 « « * «
                                                                                % +8d                 ••••4 -1 2 3                            ••••-1 2 3
                                                                                % 8d                  ............. 1 2 3                     ••••-1 2 3
                                                                                % 08d                 00000123                                -0 0 0 0 1 2 3
                                                                               %—b 8 d                +123****                                -1 2 3 * * » ®
                                                                               %- 8 d                 •1 2 3 » * « «                          -1 2 3 * * « *
                                                                               % +08d                 +0000123                                -0 0 0 0 1 2 3
                                                                               % 08d                  •0 0 0 0 1 2 3                          -0 0 0 0 1 2 3
                                                                                               2 2 .3    F o rm a tted I/O hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                                   5 5 7 dcbaZYXWVUTSR


                                        Table 22.8 shows the effect o fth e # flag on the o. x, X. g, and G conversions.PONMLKJIHGFEDCBA

                                                            Conversion
               T a b le 2 2 .8 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   Result ofApplying    Result ofApplying
      Effect o f the # Flag                            Specification       Conversion to 123   Conversion to 123.0kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB
                                                            %8o                .... 173
                                                           %#8o                ••••0173
                                                            %8x                    ..... .
                                                           %#8x                ••**0x7b
                                                            %8X                ••••••7B
                                                           %#8X                ••••0X7B
                                                            %8g                                     .... 123
                                                           %#8g                                     •123.000
                                                            %8G                                     .....123
                                                           %#8G                                     •123.000

                                      In previous chapters, we’ve used the minimum field width and precision
                                  when displaying numbers, so there’s no point in more examples here. Instead,
                                  Table 22.9 shows the effect of the minimum field width and precision on the %s
                                  conversion.

               T a b le 2 2 .9                                             Result ofApplying   Result ofApplying
Effect o fM in in n im Field                             Conversion          Conversion to       Conversion to
 Width and Precision on                                 Specification          "bogus"           "buzzword"
       the %s Conversion                                       %6s              •bogus            buzzword
                                                             %-6s               bogus®            buzzword
                                                             %.4s               bogu              buzz
                                                            %6.4s               •«bogu             ••buzz
                                                          %-6.4s                bogu«•            buzz««

                                      Table 22.10 illustrates how the %g conversion displays some numbers in %e
                                  form and others in %f forrn. All numbers in the table were written using the %. 4 g
                                  conversion specification. The first two numbers have exponents of at least 4, so
                                  they’re displayed in %e form. The next eight numbers are displayed in %f form.
                                  The last two numbers have exponents less than ^4, so they’re displayed in %e
                                  form.

              T a b le 2 2 .1 0                                                       Result ofApplying %. 4g
          Exam ples o f the                                           Number           Conversion to Number
           %g Conversion                                     123456.                        1.235e+05
                                                              12345.6                       1.235e+04
                                                               1234.56                      1235
                                                                123.456                     123.5
                                                                 12.3456                    12.35
                                                                  1.23456                   1.235
                                                                    .123456                 0.1235
                                                                    .0123456                0.01235
                                                                    .00123456               0.001235
                                                                    .000123456              0.0001235
                                                                    .0000123456             1.235e-05
                                                                    .00000123456            1.235e-06
           C h a p te r 2 2    ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 5 8 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                          In the past, we’ve assumed that tlie minimum field width and precision were
                                     constants embedded in the format strin^s>. Puttincs? the * character where either num-
                                                                                                           after the format
                                     ber would normally go allows us lo specify it as an argument cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     string. For example, the following calls of p r i n t f all produce the same output:kjihgfedcbaZ

                                     p r i n t f (" %6.4 d " , i) ;
                                     p r i n t f ("%*.4 d " , 6, i);
                                     p r i n t f ("%6.* d " , 4 , i ) ;
                                     p r i n t f (”%*.* d ” , 6, 4, i) ;

                                     Notice that the values to be filled in for the * com ejust before the value to be dis­
                                     played. A inajor advantage of *. by the way. is that il allows us to use a macro lo
                                     specify the width or precision:

                                     printf("%*d",             WIDTH,       i);

                                     We can cven compute the width or precision during program execution:

                                     printf("%*d",             page_width / num_cols,                 i);

                                          The most unusual specifications are %p and %n. The %p conversion allows us
                                     to print the value of a pointer:

                                     printf("%p",             (void *) ptr);                   /* displays value of ptr */

                                     Although %p is occasionally useful during debugging, it’s not a feature that most
                                     programmers use on a daily basis. The C standard doesift specify what a pointer
                                     looks like when printed using %p, but it’s likely to be shown as an octal or hexa­
                                     decimal number.
                                          The %n conversion is used to find oul how many characters have been printed
                                     so far by a call o f . . . p r i n t f . For example, after the call

                                     printf("%d%n\n",                123,     &len);

                                     the value of l e n will be 3, since p r i n t f had written 3 characters (1 2 3 ) by the
                                     time it reached %n. Notice that & must precede l e n (because %n requires a
                                     pointer) and that l e n itself isn’t printed.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T h e . . . s c a n f F u n c tio n s

                                       int fscanf(FILE * restrict stream,
                                                  const char * PONMLKJIHGFEDCBA
                                                                restrict format, ...);
                                       int scanf(const char * restrict format, ...);

                        fscanf       f s c a n f and s c a n f read data items from an input stream, using a formal string to
                         scanf       indicate the layoui of the input. After the formal string, any number of pointers—
                                     each pointing to an object— follow as additional arguments. Input items are con­
                                     verted (according to conversion specifications in the format string) and stored in
                                     these objects.
                                                                                         2 2 .3                               5 5 9 onmlkjihgfedcbaZYXWVU
                                                                                                  F o r m a tte d I/O hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                                    s c a n f always reads from s t d i n (thc standard input stream ), whereas
                              f s c a n f reads frorn the stream indicated by its first argument:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              scanf("%d%d", &i, &j);                           /* reads from stdin */
                              fscanf(fp, "%d%d", &i, &j);                      /* reads from fp */

                              A call of s c a n f is equivalent to a call of f s c a n f with s t d i n as the first argu­
                              ment.
                                                                                         in p u t fa ilu r e occurs (no more
                                   The ...s c a n f functions return prematurely ifan cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                              input characters could be read) or if a m a tc h in g fa ilu r e occurs (the input charac­
                              ters didn’t match the format string), (ln C99. an input failure can also occur
                              because of an en co d in g error, which means that an attempt was made to read a
 mulUbyte characters >25.2    multibyte character, but the inpul characters didn’t correspond to any valid multi-
                              byte character.) Both functions return the number o fd a ia items that were read and
                              assigned to objects: they return EOF ifan input failure occurs before any data items
                              can be read.
                                   Loops that test s c a n f ’s return value are common in C programs. The follow­
                              ing loop, for example, reads a series of integers one by one. stopping at the first
                              sign of trouble:aZYXWVUTSRQPONMLKJIHGFEDCBA

                  id io m     while (scanf("%d", &i) == 1) {




                                              F o r m a t S tr in g s
                              . . . s c a n f dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Calls of the ...s c a n f functions resemble those of the . . . p r i n t f functions. That
                              similarity can be misleading, however; the ...s c a n f functions work quite differ­
                              ently from the . . . p r i n t f functions. It pays to think of s c a n f and f s c a n f as
                              “pattern-m atching” functions. The format string represents a pattern that a
                              ...s c a n f function attempts to match as it reads input. I f th e input doesn’t match
                              the format string, the function returns as soon as it detects the mismatch; the input
                              character that didn’t match is “pushed back” to be read in the future.
                                    A ...s c a n f formal string may contain three things:

                                ■ C onversion specifications. Conversion specifications in a ...s c a n f format
                                  string resemble those in a . . . p r i n t f format string. M ostconversion specifica­
white-space characters >3.2       tions skip white-space characters at the beginning o fa n input item (the excep­
                                  tions are % [. %c, and %n). Conversion specifications never skip trailing white­
                                  space characters, however. If the input contains * 1 2 3 ° , the %d conversion
                                  specification consum es •, 1, 2, and 3, but leaves a unread. (Tm using • to
                                  represent the space character and □ to represent th e new-line character.)
                                ■ W hite-space characters. One or more consecutive white-space characters in a
                                  ...s c a n f format string match zero or more white-space characters in the input
                                  stream.
                                ■ N on-\vhite~spacecharacters. A non-w hite-spacecharacterotherthan %matches
                                  the same character in the input stream.
5 6 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 2    ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         For example, the format string "IS B N % d -% d -% ld -% d " specifies that the
                                     input will consist of:
                                           the letters ISBN
                                           possibly some white-space characters
                                           an inteusTer
                                           the - character
                                           an integer (possibly preceded by white-space characters)
                                           the - character
                                           a long integer (possibly preceded by white-space characters)
                                           the - character
                                           an integer (possibly preceded by white-space characters) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     . . . s c a n f C o n v e r s io n S p e c if ic a tio n s
                                     Conversion specifications for ...s c a n f functions are actually a little simpler than
                                     those for . . . p r i n t f functions. A ...s c a n f conversion specification consists o fth e
                                     character % followed by the items listed below (in the ordershow n).
                                                                                           a ssig n m en t suppression: an input
                                        ■ * (opt ional). The presence of * signifies cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           item is read but not assigned to an object. Items matched using * aren’t
                                           included in the count that ...s c a n f returns.
                                       ■ M a x im u m fie ld width (optional). The maximum field width limits the number
                                         ofcharaciers in an input item: conversion of the item ends if this number is
                                         reached. W hite-space characters skipped at the beginning of a conversion
                                         don't count.
                                        ■ L en g th m odifier(op{\Q\wd). The presence o fa length modifier indicates that the
                                          object in which the input item will be stored has a type that's longer or shorter
                                          than is normal for a particular conversion specification. Table 22.11 lists each
                                          length modifier, the conversion specifiers with which it may be used, and the
                                          type indicated by the combination o fth e two. (Any combination oflength mod-
                                          ifierand conversion specifier not shown in the table causes undefined behavior.)

                 Table 22.11             L e n g th
      Lengoth Modifiers lbr             M o d if ie r      C o n v e rs io n S p e c ifie r s                 M e a n i n g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
       ...s c a n f Functions RQPONMLKJIHGFEDCBA
                                           hh'             d. i. o. u. x. X. n                  signed char *, unsigned char *
                                                 h         d. i. o. u. x. X. n                  short int *. unsigned short int *
                                                 1         d, i. o, u. x. X, n                  long int *, unsigned long int *
                                              ( e l l)     a.A. e. E. f. F.g.G                  double *
                                                           c. s, or [                           wchar_t *
                                               11'         d. i, o. u. x. X. n                  long long int *,
                                            ( e lL e ll)                                        unsigned long long int *
                                                T          d. i. o. u. x. X. n                  intmax_t *. uintmax_t *
                                                z+         d. i. o. u T x, X. n                 size_t *
                                                tf         d, i. o, u, x. X. n                  ptrdiff_t *
                                                 L         a.A. e. E. f.F.g.G                   long double *
                                           'C99 only
                                                                                                   2 2 .3    F o rm a tte d l/O hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                                        561 cbaZYXWVUTSRQPONM

                                       ■ C onversion specifier. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                  The conversion specifier must be one of the characters
                                         listed in Table 22.I2.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

               T a b le 2 2 J 2        Conversion
Conversion Specifiers for               Specifier                                         M eaning
    . . . s c a n f Functions                d        Matches a decimal integer; the corresponding argument is assumed to
                                                      have type i n t *.
                                              i       Matches an integer; the corresponding argument is assumed to have type
                                                      i n t *. The integer is assumed to be in base 10 unless it begins with 0
                                                      (indicating octal) or with Ox or OX (hexadecimal).
                                             o        Matches an octal integer; the corresponding argument is assumed to have
                                                      type u n s i g n e d i n t *.
                                             u        Matches a decimal integer; the corresponding argument is assumed to
                                                      have type u n s i g n e d i n t *.
                                           x. X       Matches a hexadecimal integer; the corresponding argument is assumed
                                                      to have type u n s i g n e d i n t *.                        (
                                   a f , A+ , e , E, Matches a floating-point number; the corresponding argument is
                                    f . F 1', g. G assumed to have type f l o a t *. In C99. the number can be infinity or
                                  _____________ NaN.________________________________________________________ ,
                                             c        Matches n characters, where n is the maximum field width, or one char­
                                                      acter ifn o field width is specified. The con*esponding argument is
                                                      assumed to be a pointer to a character array (or a character object, if no
                                                      field width is specified). Doesn't add a null character at the end.
                                             s        Matches a sequence of non-white-space characters, then adds a null char­
                                                      acter at the end. The corresponding argument is assumed to be a pointer
                                                      to a character array.
                                              [       Matches a nonempty sequence of characters from a scanset. then adds a
                                                      null character at the end. The corresponding argument is assumed to be a
                                                      pointer lo a character array.
                                             p        Matches a pointer value in the form that . . . p r i n t f would have written
                                                      it. The corresponding arguinent is assumed to be a pointer to a v o i d *
                                                      object.
                                             n        The corresponding argument must point to an object o f type i n t . Stores             '
                                                      in this object the num berof characters read so far by this call of
                                                      . . . s c a n f . No input is consumed and the return value of . . . s c a n f isn’t
                                                      affccted.
                                             %        Matches the character %.                                                               1

                                   f
                                       C 9 9 o n ly


                                       Numeric data items can always begin with a sign (+ or -). The o. u. x, and X
                                  specifiers convert the item to unsigned form, however, so lheyTe not normally used
                                  to read ne^g' ative numbers.
                                       The [ specifier is a more complicated (and more flexible) version of the s
                                  specifier. A complete conversion specification using [ has the form % [s<?r] or
                                  % [^ v e /], where set can be any set of characters. (If ] is one of the characters in
                                  set. however, it must come first.) % [.ve/] matches any sequence ofcharacters in set
                                  (the scanset). % [^.vez] matches any sequence of characters not in set (in other
                                  words, the scanset consists of all characters not in set). For example. % [ a b c ]
           C h a p te r 2 2   ln p u t/O u tp u t aZYXWVUTSRQPONMLKJIHGFEDCBA
5 6 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                                              matches any string containing only the letters a , b. and c . while % [ ^ a b c ]
                                                              matches any string that doesn’t contain a , b, or c.
                                                                      Many of the ... s c a n f conversion specifiers are closely related to the num eric
                                                              conversion functions in < s t d l i b . h > . These functions convert strings (like
                                                > 2 6 .2onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
n u m e r ic c o n v e r s io n fu n c t io n s BA


                                                               ” - 2 9 7 " ) to their equivalent num eric values (-297). The d specifier, for example,
                                                              looks for an optional + or - sign, followed by a series o f decimal digits; this is
                                                              exactly the same form that the s t r t o l function requires when asked to convert a
                                                              string to a decimal number. Table 22.13 shows the correspondence between con­
                                                              version specifiers and num eric conversion functions.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  T a b le 2 2 .1 3                              C o n v e r s io n
 Correspondence between                                            S p e c ifie r         N u m e r ic C o n v e r s io n F u n c tio n
    . . . s c a n f Conversion                                           d                s t r t o l with 10 as the basc
  Specifiers and Numeric                                                 i                s t r t o l with 0 as lhc base
    Conversion Functions RQPONMLKJIHGFEDCBA                              o                s t r t o u l with 8 as the base
                                                                         u                s t r t o u l with 10 as the base
                                                                       x ,X               s t r t o u l with 16 us the basc
                                                            a . A, e , E, f , F. g . G    s trto d



                                      It pays to be careful when writing calls of s c a n f . An invalid conversion specifica­
                                      tion in a s c a n f form at string is just as bad as one in a p r i n t f format string;
                                      either one causes undefined behavior.




                          ^P>         C 9 9 C h a n g e s to . . . s c a n f C o n v e r s i o n S p e c if ic a ti o n s

                                      The conversion specifications for s c a n f and f s c a n f have undergone some
                                      changes in C99. but the list isn’t as extensive as il was for the . . . p r i n t f functions:cbaZYXWVU

                                        ■ A d d itio n a l le n g th m o d ifiers. C99 adds the h h . 11, j . z. and t length m odifi­
                                          ers. These correspond to the length modifiers in . . . p r i n t f conversion specifi­
                                          cations.
                                        ■ A d d itio n a l co n versio n specifiers. C99 adds the F. a. and A conversion specifi­
                                          ers. T hey’re provided for sym m etry with . . . p r i n t f ; the . . . s c a n f functions
                                          treat them the same as e , E, f . g, and G.
                                        ■ A b ility to rea d in fin ity a n d N a N . Just as the . . . p r i n t f functions can write
                                          infinity and NaN, the .. . s c a n f functions can read these values. To be read
                                          properly, they should have the same appearance as values written by the
                                          . . . p r i n t f functions, with case being ignored. (For example, either IN F or
                                          i n f will be read as infinity.)
                                        ■ S u p p o r tfo r wide characters. The .. . s c a n f functions are able to read multi-
                                          byte characters, which are then converted to wide characters for storage. The
                                          % lc conversion specification is used to read a single m ullibyte character or a
                                                                                                    2 2 ,3                                563onmlkjihgfedcbaZYX
                                                                                                                F o rm a tte d I/O kjihgfedcbaZYXWVUTSRQPONMLKJ


                               sequence of m ultibyte characters; % ls is used to read a string of m ullibyte
                               characters (a null character is added at the end). The %1 [<srer] and %1 [^scv]
                               conversion specifications can also read a string of m ultibyte characters.



                          scanf E x a m p le s
                                       dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                          The next three tables contain sample calls of s c a n f . Each call is applied to the
                          input characters shown to its right. Characters printed in strikeout are consum ed
                          by the call. The values of the variables after the call appear to the right o f the in­
                          put.
                               The exam ples in Table 22.14 show the effect of com bining conversion specifi­
                          cations, w hite-space characters, and non-w hile-space characters. In three cases no
                          value is assigned to j . so it retains its value from before the call o f s c a n f . The PONMLKJIHGFEDCB
                                         ^?         ~J .


                          exam ples in Table 22.15 show the effcct o f assignm ent suppression and specifying
                          a field width. The exam ples in Table 22.16 illustrate the more esoteric conversion
                          specifiers ( i , [, and n).

      T a b le 2 2 .1 4                            s c a n f RQPONMLKJIHGFEDCBA
                                                             C a ll                                 In p u t            V a ria b le s
s c a n f Examples               n = s c a n f ( "% d% d",        & i,      & j ) ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                             ^Q r^, » 3 4 0           n: 1
          (Group I)                                                                                                   i 12
                                                                                                                   __ j_ unchang^?ed
                                 n = s c a n f ( " % d ,% d " ,      & i,      & j);         « • • , »340             n ^1
                                                                                                                      i 12
                                                                                                                   __ j_ unchan ts^ed
                                 n = s c a n f ( "%d ,% d " ,           & i,    & j);        1 2 * ,-* -3 4 C         n 9
                                                                                                                      1 12
                                                                                                                   __ j_ 34
                                 n = s c a n f ( "% d,       % d",    & i,      & j);        « • , >34D               n 1
                                                                                                                      i 12
                                                                                                                   __ j_ unchanged


      T a b le 2 2 .1 5                        s c a n f C a ll                                In p u t                  V a r ia b le s
s c a n f Examples               n -    sc a n f("% * d % d ",       & i);          • l-2-*3 4 -a     n: 1
          (Group 2)                                                              _____________________ i : 34_________
                                 n = sc a n f("% * s% s",            s tr);        M y < ^ a 4 r» L a d y a           n: 1
                                                                                                                      s tr: " F a ir”
                                 n = s c a n f(" % ld % 2 d % 3 d " ,              ■1-2 3 4 -5 0       n: 3
                                                 & i , &j , &k) ;                                      i: 1
                                                                                                       j:2 3
                                                                                 _____________________ k: 45_________
                                 n = sc a n f("% 2 d % 2 s% 2 d ",                  1 2 3 4 -S GQ      n: 3
                                               & i , s t r , & j) ;                                    i : 12
                                                                                                       s t r : "34"
                                                                                 _____________________ j : 5 6 _________
            C h a p te r 2 2   ln p u t/O u tp u t dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 6 4 ZYXWVUTSRQPONMLKJIHGFEDCBA


                 T a b le 2 2 .1 6 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                     s c a n f RQPONMLKJIHGFEDCBA
                                                                               C a ll                                      In p u t              V a ria b le s
          s c a n f Examples            n = s c a n f(" % i% i% i" ,                & i,      & j,    & k );kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                   i2*G4r2^x4r2a                n: 3
                    (Group 3)                                                                                                                   i : 12
                                                                                                                                                j : 10
                                                                                                                                                k: 18
                                        n = sc a n f("% [0 1 2 3 4 5 6 7 8 9 ]",                     s tr);        4 r2 ^ a b c o              n: 1
                                                                                                                                               s t r : "123"
                                        n = sc a n f("% [0 1 2 3 4 5 6 7 8 9 ]",                     s tr);        a b c l2 3 Q                n: 0
                                                                                                                                               s tr:
                                                                                                                                               unchang%
                                                                                                                                                      v>*ed
                                        n = sc a n f("% [^ 0 1 2 3 4 5 6 7 8 9 ]",                    s tr);       abel23O                     n: 1
                                                                                                                                               s tr : "abc"
                                        n = sc a n f("% * d % d % n ",                & i,     & j);               XQ^oa>3 0D                  n: 1
                                                                                                                                               i : 20
                                                                                                                                               j : 5 _________


                                     D e te c tin g E n d -o f-F ile a n d E r r o r C o n d itio n s

                                       void clearerr(FlLE *stream);
                                       int feof(FILE *stream);
                                       int ferror(FILE *stream);

                                     If we ask a ...s c a n f function to read and store n data items, we expect its return
                                     value to be n . Tfthe return value is less than n . something<^ went wrong^. There are
                                     three possibilities:

                                                        The function encountered end-of-file before matching the format
                                        ■ E n d -o f - file .
                                            string completely.
                                        ■ R e a d e r r o r . The function was unable to read characters from the stream.

                                        ■ M a tc h in g            A data item was in the wrong format. For exam ple, the
                                                              fa ilu r e .
                                            function mi vg^*ht have encountered a letter w
                                                                                         ^ hile searching uf~or the first digit of
                                            an integer,aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                      ^   r




                                     But how can we tell which kind of failure occurred? In many cases, it doesn't mat­
                                     ter: something went wrong, and w e’ve got to abandon the program . There may be
                                     times, however, when w e'lI need to pinpoint the reason for the failure.
                                             Every stream has two indicators associated with it: an e r r o r i n d i c a t o r and an
                                     e n d - o f - f i l e i n d i c a t o r . These indicators are cleared when the stream is opened. Not
                                     surprisingly, encountering end-of-file sets the end-of-file indicator, and a read error
                                     sets the error indicator. (The error indicator is also set when a write error occurs on
                                     an output stream.) A m atching failure doesn’t change either indicator.
                     clearerr                Once the error or end-of-file indicator is set. it remains in that state until it’s
                                     explicitly cleared, perhaps by a call of the clearerr function, clearerr clears
                                     both the end-of-file and error indicators:

                                     c le a re rr(fp );                      /*   c le a rs     eo f and e r r o r          in d ic a to rs      fo r    fp       */
                                                                    2 2 .3   F o r m a tte d I/O hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                         5 6 5 aZYXWVUTSRQPON


              c l e a r e r r isn’t needed often, since, soinc o fth e other library functions clear one
 Q&A          or both indicators as a side effect.
  fe o f               We can call the f e o f and f e r r o r functions to test a stream ’s indicators to
fe rro r      determine why a prior operation on the stream failed. The call f e o f ( f p ) returns
              a nonzero value if the end-of-file indicator is set for the stream associated with f p .
 Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
              The call f e r r o r ( f p ) returns a nonzero value if the error indicator is set. Both
              functions return zero otherwise.
                       When s c a n f returns a smaller-than-expected value, we can use f e o f and
              f e r r o r to determine the reason. If f e o f returns a nonzero value, w e’ve reached
              the end of the input file. If f e r r o r returns a nonzero value, a read error occurred
              during input. Ifneither returns a nonzero value, a matching failure must have oc­
              curred. Regardless of what the problem was, the return value of s c a n f tells us
              how many data items were read before the problem occurred.
                       To see how f e o f and f e r r o r might be used, let’s write a function that
              searches a file for a line that begins with an integer. Here's how we intend to call
              the function:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
         n = find_int("foo");

         " f o o " is the name of the file to be searched. The function returns the value of the
         integer that it finds, which is then assigned to n. I f a problem arises— the file can't
         be opened, a read error occurs, or no line begins with an integer— f i n d _ i n t will
         retum an error code (-1. -2 , or -3 . respectively). I'll assume that no line in the file
         besins
            <^
                  with a neaative
                            v^
                                  integer.
                                      C^
                                           GFEDCBA


         int find_int(const char *filename)

             FILE *fp = fopen(filename,                "r");
             int n;

             if (fp == NULL)
               return -1;                              /* c a n ’t open file */

            while (fscanf(fp,            ”%d", &n)       != 1) {
              if (ferror(fp))            {
                fclose(fp);
                return -2;                             /* read error */

                if (feof(fp)) {
                  fclose(fp);
                  return -3;                           /* integer not found */

                fscanf(fp,       "%*[^\n]");           /* skips rest of line */


             fclose(fp);
             return n;


         The w h i l e loop's controlling expression calls f s c a n f in an attempt to read an
         integer from the file. If the attempt fails ( f s c a n f returns a value other than I),
            C h a p te r 2 2   ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                     f i n d _ i n t calks f e r r o r and f e o f to see if the problem was a read error or end-
                                     of-file. If not, f s c a n f must have failed because of a matching error, so kjihgfedcb
                                     find_int skips the rest o fth e characters on the current line and tries again. Note
                                     the use of the conversion %* [ ^ \ n ] to skip all characters up to the next new-line.
                                     (Now that we know about scansets, it's time to show off!) aZYXWVUTSRQPONMLKJIHGFEDCBA




                        2 2 .4       C h a r a c t e r I/O

                                     ln Lhis section, w e'll examine library functions that read and write single charac­
                                     ters. These functions work equally well with text streams and binary stream s.
                                            You’ll notice that the functions in this section treat characters as values o ftype
                                     i n t , not c h a r . One reason is that the input functions indicate an end-of-file (or
                                     error) condition by returning EOF, which is a negative integer constant.dcbaZYXWVUTSRQPONMLKJIHG


                                      O u tp u t F u n c tio n s

                                                      c, FILE *stream);
                                        int fputc(int PONMLKJIHGFEDCBA
                                        int putc(int c, FILE *stream);
                                        int putchar(int c);

                       putchar       p u t c h a r writes one character to the s t d o u t stream:

                                      putchar(ch);                    /* writes ch to stdout */

                           fputc      f p u t c and p u t c are more general versions of p u t c h a r that write a character to
                            pute      an arbitrary stream:

                                      fputc(ch, fp);                  /* writes ch to fp */
                                      putc(ch, fp);                  /* writes ch to fp */

                                            Although p u t c and f p u t c do the same thing, p u t c is usually implemented
                                      as a macro (as well as a function), while f p u t c is implemented only as a function,
                                      p u t c h a r itself is usually a macro dcfmed in the following way:

                                      #define putchar(c) putc((c), stdout)

                                      ft may seem odd that the library provides both p u t c and f p u t c . But, as we saw
                                      in Section 14.3, macros have several potential problems. The C standard allows the
                                      p u t c macro to evaluate the s t r e a m argument more than once, which f p u t c
                                      isn’t permitted to do. Although programmers usually prefer p u t c , which gives a
                           Q&A        faster program, f p u t c is available as an alternative.
                                            If a write error occurs, all three functions set the error indicator for the stream
                                      and return EOF; otherwise, they return the character that was written.
                                                                             22 .4   C h a ra c te rl/O hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                5 6 7 dcbaZYXWVUTSRQPO


           I n p u t F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

             int fgetc(FILE *stream);
             int getc(FILE *stream);
             int getchar(void);
             int ungetc(int c, FILE *stream);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

getchar    g e t c h a r reads a character from the s t d i n stream :

           ch = getchar();                  /* reads a character from stdin */

  fgetc    f g e t c and g e t c read a character from an arbitrary stream:
   getc
           ch = fgetc(fp);                  /* reads a character from fp */
           ch = getc(fp);                   /* reads a character from fp */

           All three functions treat the characteras an u n s i g n e d c h a r value (which is then
           convened to i n t type before it’s returned). As a result, they never return a nega­
           tive value other than EOF.
                The relationship between g e t c and f g e t c is sim ilar to that betw een p u t c
           and f p u t c . g e t c is usually im plemented as a macro (as well as a function),
           while f g e t c is im plem ented only as a function, g e t c h a r is norm ally a m acro as
           well:

           #define getchar() getc(stdin)

           For reading characters from a file, program m ers usually prefer g e t c over f g e t c .
           Since g e t c is norm ally available in macro form, it tends to be faster, f g e t c can
           be used as a backup if g e t c isn’t appropriate. (The standard allows the g e t c
           macro to evaluate its argum ent more than once, which may be a problem .)
                The f g e t c , g e t c . and g e t c h a r functions behave the same if a problem
           occurs. At end-of-file. they set the stream 's end-of-file indicator and return EOF. If
           a read error occurs, they set the stream 's error indicator and return EOF. To differ­
           entiate between the two situations, we can call either f e o f or f e r r o r .
                One of the most common uses of f g e t c , g e t c . and g e t c h a r is to read
           characters from a file, one by one, until end-of-file occurs. It’s custom ary to use the
           following w h i l e loop for that purpose:

 id io m   while ((ch - getc(fp))                     != EOF) {



           After reading a character from the file associated with f p and storing it in the vari­
           able c h (which must be of type i n t ) , the w h i l e test com pares c h with EOF. Lf
           c h isn’t equal to EOF, w e’re not at the end o f the file yet, so the body o f the loop is
           executed. If c h is equal to EOF, the loop term inates.
5 6 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r2 2      ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                            Always store the return value of f g e t c . g e t c , or g e t c h a r in an i n t variable,
                                                            not a c h a r variable. Testing a c h a r variable against EOF may give the wrong
                                                            result.


                                        ungetc                   There's one other character input function, u n g e t c , which “pushes back”
                                                            a character read from a stream and clears the stream ’s end-of-file indicator.
                                                            This capability can be handy if we need a “lookahead” character during input.
                                                            For instance, to read a series of digits, stopping at the first nondigit, we could
                                                            write

                                                            while (isdigit(ch = getc(fp)))
            i s d i g i t i u n c t i o n > 2 & 5 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                    {


                                                            ungetc(ch, fp);               /* pushes back last character read */

                                                                 The number of characters that can be pushed back by consecutive calls of
                                                            u n g e t c — with no intervening read operations— depends on the implementation
                                                            and the type of stream involved; only the first call is guaranteed to succeed. Calling
    f iie - p o s it io n in g f u n c t io n s > 2 2 . 7   a file-positioning function ( f s e e k , f s e t p o s , or r e w i n d ) causes the pushed-
                                                            back characters to be lost.
                                                                 u n g e t c returns the character it was asked to push back. However, it returns
                                                            EOF if an attempt is made to push back EOF or to push back more characters than
                                                            the implementation allows.


                                          C o p y in g a F ile
                        P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                            The following program makes a copy of a file. The names of the original file and
                                                            the new file will be specified on the command line when the program is executed.
                                                            For example, to copy the file f l . c to f 2 . c. w e’d use the command

                                                            fcopy fl.c f2.c

                                                            f c o p y will issue an error message if there aren’t exactly two file names on the
                                                            command line or ifeither file can't be opened.RQPONMLKJIHGFEDCBA

                                      f c o p y .c          /* Copies a file */

                                                            #include <stdio.h>
                                                            #include <stdlib.h>

                                                            int main(int argc, char *argv[])

                                                               FILE *source_fp, *dest_fp;
                                                               int ch;
                                                                           2 2 .5                      5 6 9 kjihgfedcbaZYXWVUTSRQPO
                                                                                    L in e I/O hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

            if (argc != 3) {
              fprintf(stderr, "usage: fcopy source dest\n");
              exit(EXIT_FAILURE) ;


            if ((source_fp = fopen(argv[l], "rb")) == NULL)                             {
              fprintf(stderr, "Can't open %s\n", argv[l]);
              exit(EXIT_FAILURE);


            if ((dest_fp = fopen(argv[2], "wb")) == NULL) {
              fprintf{stderr, "Can't open %s\n", argv[2]);
              fclose(source_fp);
              exit(EXIT_FAILURE);


            while ((ch = getc(source_fp))                        1= EOF)
              putc(ch, dest— fp);

            fclose(source_fp);
            fclose(dest_fp);
            return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


              Using ” r b ” and ”w b ” as the file modes enables f c o p y to copy both text and
         binary files. If wc used ”r " and "w" instead, the program wouldn't necessarily be
         able to copy binary files.aZYXWVUTSRQPONMLKJIHGFEDCBA




2 2 .5   L in e l/O

         We'H now turn to library functions that read and write lines. These functions are
         used mostly with text streams, although it’s legal to use them with binary streams
         as well.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


         O u tp u t F u n c t io n s


          int fputs(const char * PONMLKJIHGFEDCBA
                                  restrict s f
                    FILE * restrict stream);
          int puts(const char *s);

  puts   We encountered the p u t s function in Section 13.3; it writes a string of characters
         to s t d o u t :
         puts("Hi, there!");                  /* writes to stdout */

         After it writes the characters in the string, p u t s always adds a new-line character.
           C h a p te r 2 2 ln p u t/O u tp u t
570 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                       fputs          f p u t s is a more general version o f p u t s . Ils second argument indicates the
                                 stream to which the output should be written:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                 fputs("Hi, there!", fp);                /* writes to fp */

                                 Unlike p u t s , the f p u t s function doesn’t write a new-line character unless one is
                                 present in the string.
                                     Both functions return EOF if a write error occurs: otherwise, they return a
                                 nonnegoative number,dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                 I n p u t F u n c tio n s

                                   c h a r * fg e ts (c h a r * r e s tr ic t:     s t in t n,
                                                       F IL E * r e s t r i c t    s tre a m );
                                   c h a r * g e ts (c h a r * s );

                        gets     The g e t s function, which we first encountered in Section 13.3, reads a line of
                                 input from s t d i n :

                                 gets(str);           /* reads a line from stdin */

                                 g e t s reads characters one by one, storing them in the array pointed to by s t r ,
                                 until it reads a new-line character (which it discards).
                       fgets           f g e t s is a more general version of g e t s that can read from any stream,
                                 f g e t s is also safer than g e t s , since it limits the number ofcharacters that it will
                                 store. Here’s how we might use f g e t s , assuming that s t r is the name o f a char­
                                 acter array:

                                 fgets(str, sizeof(str), fp);                     /* reads a line from fp */

                                 This call will cause f g e t s to read characters until it reaches the first new-line
                                 character or s i z e o f ( s t r ) - 1 characters have been read, whichever happens
                                 first. If it reads the new-line character, f g e t s stores it along with the other charac­
                                 ters. (Thus, g e t s neverstores the new-line character, but f g e t s som etim es does.)
                                       Both g e t s and f g e t s return a null pointer if a read error occurs or they
                                 reach the end of the input stream before storing any characters. (As usual, we can
                                 call f e o f or f e r r o r to determine which situation occurred.) Otherwise, both
                                 return their first argument, which points to the array in which the input was stored.
                                 As you’d expect, both functions store a null character at the end of the string.
                                       Now that you know about f g e t s , f d suggest using it instead of g e t s in
                                 most situations. With g e t s , there’s always the possibility ofstepping outside the
                                 bounds of the receiving array, so it’s safe to use only when the string being read is
                                 guaranteed to fit into the array. When there’s no guarantee (and there usually
                                 isn’t), it’s much safer to use f g e t s . Note that f g e t s will read from the standard
                                 input stream if passed s t d i n as its third argument:

                                 fgets(str, sizeof(str), stdin);
                                                                           2 2 .6                        571aZYXWVUTSRQPONM
                                                                                    B lo c k l/ O kjihgfedcbaZYXWVUTSRQPONMLKJIH




2 2 .6    B lo c k l/O

            s iz e _ t                            r e s tr ic t p tr,
                         f r e a d ( v o i d * cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     s i z e _ t s i z e , s i z e _ t nm em b,
                                     F IL E * r e s t r i c t s t r e a m ) ;
            s iz e _ t   f w r ite ( c o n s t v o id * r e s t r i c t p t r ,
                                       s i z e _ t s i z e , s i z e _ t nm em b,
                                       F IL E * r e s t r i c t s t r e a m ) ;

               The f r e a d and f w r i t e functions allow a program to read and write large
               blocks of data in a single step, f r e a d and f w r i t e are used prim arily with
               binary streams, although— with care— it's possible lo use them with text stream s
               as well.
  Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
 fwrite                 f w r i t e is designed to copy an array from memory to a stream. The first
               argument in a call of f w r i t e is the array's address, the second argum ent is the
               size o fe a c h array element (in bytes), and the third argument is the num ber o f ele­
               ments to write. The fourth argum ent is a file pointer, indicating where the data
               should be written. To write the entire contents of the array a , for instance, we
               could use the following call of f w r i t e :

          fwrite(a, sizeof(a[0]), sizeof(a) / sizeof(a[0]), fp);

          T here’s no rule that we have to write the entire array: we could just as easily
          write any portion of it. f w r i t e returns the num ber of elem ents (not bytes) actu­
          ally written. This number will be less than the third argum ent if a write error oc­
          curs.
 fread          f r e a d will read the elem ents of an array from a stream, f r e a d \ s argum ents
          are sim ilar to f w r i t e \ s : the array's address, the size of each elem ent (in bytes),
          the number ofelem ents to read, and a file pointer. To read the contents o f a file into
          the array a , we might use the following call of f r e a d :

          n = fread(a, sizeof(a[0]), sizeof(a) / sizeof(a[0]),                                 fp);

          It’s important to check f r e a d ’s return value, which indicates the actual num ber of
          elements (not bytes) read. This num ber should equal the third argument unless the
          end of the inputfile was reached or a read error occurred. The f e o f and f e r r o r
          functions can be used to determ ine the reason for any shortage.


          Be careful not to confuse f r e a d ’s second and third arguments. Consider the fol­
          lowing call of f r e a d :
          fread(a, 1, 100, fp)

          W e’re asking f r e a d to read 100 one-byte elements, so it will return a value
5 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 2   ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      between 0 and 100. The following call asks f r e a d to read one block of 100
                                      bytes:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      fread(a, 100, 1, fp)

                                      f r e a d ’s return value in this case will be either 0 or I .


                                            fwrite is convenient for a program that needs to store data in a file before
                                     terminating. Later, the program (or another program, for that matter) can use
                                     f r e a d to read the data back into memory. Despite appearances, the data doesn’t
                                     need to be in array form; f r e a d and f w r i t e work jtisi as well with variables of
                                     all kinds. Structures, in particular, can be read by fread or written by fwrite.
                                     To write a structure variable s to a file, for instance, we could use the folIowin V   a
                                     call of f w r i t e :
                                      fwrite(&s, sizeof(s), 1, fp);


                                      Be careful when using f w r i t e to write out structures that contain pointer values;

                          A           these values aren’t ^auaranteed to be valid when read back in.aZYXWVUTSRQPONMLKJIHGFEDCBA




                        2 2 .7        F ile P o s itio n in g

                                                           restrict stream,
                                       int fgetpos(FILE * PONMLKJIHGFEDCBA
                                                   fpos_t * restrict pos);
                                       int fseek(FILE *stream, long int offset, int whence);
                                       int fsetpos(FILE *stream, const fpos__t *pos);
                                       long int ftell(FILE *stream);
                                       void rewind(FILE *stream);

                                                                          il e p o sitio n . When a file is opened, the file posi­
                                     Every stream has an associated fcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     tion is set at the beginning o fth e file. (Ifth e file is opened in “append” mode, how­
                                     ever, the initial file position may bc at the beginning or end o fth e file, depending
                                     on the im plementation.) Then, when a read or write operation is perform ed, the file
                                     position advances automatically, allowing us to move through the file in a sequen­
                                     tial manner.
                                          Although sequential access is fine for many applications, some program s need
                                     the ability to ju m p around within a file, accessing som e data here and other data
                                     there, ff a file contains a series of records, for example, we might want to jum p
                                     directly to a particular record and read it or update it. < s t d i o . h > supports this
                                     form of access by providing five functions that allow a program to determ ine the
                                     current file position or to change it.
                         fseek            The f s e e k function changes the file position associated with the first argu­
                                     ment (a file pointer). The third argument specifies whether the new position is to
                                                                                          2 2 .7   F ile P o s itio n in g hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                                   5 7 3 onmlkjihgfedcbaZYXWVU


                                   be calculated with respect lo the beginning of the file, the current position, or the
                                   end o f the file, < s t d i o . h > defines three macros for this purpose:

                                        SEEK^^MSET *^ B e s^~-^in n in g o ffile
                                        SEEK_CUR      Current file position
                                        SEEK_END      Encl o ffile

                                   The second argument is a (possibly negative) byte count. To move to the beginning
                                   of a file, for example, the seek direction would be SEEK _SET and the byte count
                                   would be zero:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   fseek(fp, 0L, SEEK_SET);                   /* moves to beginning of file */

                                   To move to the end of a file, the seek direction would be SEEK_END:

                                   fseek(fp, 0L, SEEK_END);                   /* moves to end of file */

                                   To move back 10 bytes, the seek direction would be SEEK_CUR and the byte count
                                   would be -1 0 :

                                   fseek(fp,      -10L, SEEK_CUR);             /* moves back 10 bytes */

                                   Note that the byte count has type l o n g i n t . so I've used 0L and - 1 0 L as argu­
                                   ments. (0 and - 1 0 would also work, o fco tirse. since argum ents are converted to
                                   the proper type automatically.)
                                        Normally, f s e e k returns zero. If an error occurs (the requested position
                                   doesn’t exist, for example), f s e e k returns a nonzero value.
                                        The file-positioning functions are best used with binary stream s, by the way. C
                                   doesn’t prohibit program s from using them with text stream s, but care is required
                                   because of operating system differences, f s e e k in particular is sensitive to
                                   w hether a stream is text or binary. For text stream s, either (1) o f f s e t ( f s e e k 's
                                   second argument) must be zero or (2) w h e n c e (its third argum ent) must be
                                   SEEK_SET and o f f s e t a value obtained by a previous call o f f t e l l . (ln other
                                   words, we can only use f s e e k to move to the beginning or end of a text stream or
                                   to return to a place that was visited previously.) For binary stream s, f s e e k isn't
                                   required to support calls in which w h e n c e is SEEK_END.
                         ftell          The f t e l l function returns the current file position as a long integer. (If an
e r r n o v a r ia b ie > 2 4 .2   error occurs, f t e l l returns - l L and stores an error code in e r r n o . ) The value
                                   returned by f t e l l may be saved and later supplied to a call of f s e e k . making it
                                   possible to return to a previous file position:

                                   long file_pos;
                                   •••
                                   file_pos = ftell(fp);                             /* saves current position */
                                   •••
                                   fseek(fp, file_pos, SEEK_SET);                   /* returns to old position */

                                   If f p is a binary stream, the call f t e l l ( f p ) returns the current file position as a
                                   byte count, where zero represents the beginning of the file. If f p is a text stream ,
                                   however, f t e l l ( f p ) isn't necessarily a byte count. As a result, it’s best not to
                                   perform arithmetic on values returned by f t e l l . For exam ple, it's not a good
           C h a p te r 2 2    ln p u t/O u tp u t dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 7 4 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                  idea to subtract values returned by f t e l l to see how far apart two file positions
                                  are.
                      rewind              The r e w i n d function sets the file position al the beginning. The call
                                  r e w i n d ( f p ) isn e a rly e q u iv a le n lto f s e e k ( f p , 0 L , S E E K _ S E T ).T h e d if-
                                 ference? r e w i n d doesn't return a value but does clear the error indicator for f p .
                     fgetpos               f s e e k and f t e l l have one problem: they're LLmited to files whose posi-
                     fsetpos tions c a n be stored in a long integer. For working with very large files, C pro­
                                  vides two additional functions: f g e t p o s and f s e t p o s . These functions can
                        Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  handle large files because they use values of type f p o s _ t to represent file posi­
                                  tions. An f p o s _ t value isn’t necessarily an integer: it could be a structure, for
                                  instance.
                                          The call f g e t p o s ( f p , & f i l e _ p o s ) stores the file position associated
                                  with f p in the f i l e _ p o s variable. The call f s e t p o s ( f p , & f i l e _ p o s ) sets
                                  the file position for f p to be the value stored in f i l e p o s . (This value must have
                                 been obtained by a previous call of f g e t p o s . ) Ifa call of f g e t p o s or f s e t p o s
                                  fails, it stores an error code in e r r n o . Both functions return zero when they suc­
                                 ceed and a nonzero value when they fail.
                                           Here’s how we might use f g e t p o s and f s e t p o s to save a file position and
                                  return to it later:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   fpos_t file_pos;

                                   fgetpos(fp, &file_pos);                          /* saves current position */

                                   fsetpos(fp,          &file_pos);                 /* returns to old position */



              PROGRAM              M o d ify in g a F ile o f P a r t R e c o r d s

                                   The following program opens a binary file containing p a r t structures, reads the
                                   structures into an array, sets the o n _ h a n d member o feach structure to 0, and then
                                   writes the structures back to the file. Note that the program opens the file in
                                   " r b + " mode, allowing both reading and writing.BA

                  in vclear.c      /* Modifies a file of part records by setting the quantity
                                      on hand to zero for all records */

                                   #include <stdio.h>
                                   #include <stdlib.h>

                                   #define NAME_LEN 25
                                   #define MAX_PARTS 100

                                   struct part {
                                     int number;
                                     char n a m e [NAME_LEN+1] ;
                                     int on_hand;
                                   } inventory[MAX_PARTS] ;
                                                                       2 2 ,8                         5 7 5 kjihgfedcbaZYXWVUTS
                                                                                S tr in g I/O hgfedcbaZYXWVUTSRQPONMLKJIHGFE


         int num__parts,-

         int main(void)

            FILE *fp;
            int i ;

            if ((fp = fopen(’’inventory.dat”, "rb+”)) == NULL) {
              fprintf(stderr, ’’Can’t open inventory file\n'*);
              exit(EXIT_FAILURE);


            num__parts = fread(inventory, sizeof(struct part),
                               MAX_PARTS, fp);

            for (i = 0; i < num__parts; i+ + )
              inventory[i].on_hand = 0;

            rewind(fp);
            fwrite(inventory, sizeof(struct part), num_parts, fp);
            fclose(fp);

            return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


         Calling r e w i n d is critical, by the way. After the f r e a d call, the file position is al
         the end of the file. If we were to call f w r i t e without calling^? r e w i n d first,
         f w r i t e would add new data to the end ol’ the file instead of overwriting the old
         data.aZYXWVUTSRQPONMLKJIHGFEDCBA




2 2 .8   S t r in g I/O

         The functions described in this section are a bit unusual, since they have nothing to
         do with streams or files. Instead, they allow us to read and write data using a string
         as though it were a stream. The s p r i n t f and s n p r i n t f functions write charac­
         ters into a string in the same way they would be written to a stream; the s s c a n f
         function reads characters from a string as though it were reading from a stream.
         These functions, which closely resemble p r i n t f and s c a n f , are quite useful,
         s p r i n t f and s n p r i n t f give us access to p r i n t f \ s formatting capabilities
         without actuahy having to write data to a stream. Similarly, s s c a n f gives us
         access to s c a n f ’s powerful pattern-matching capabilities. The remainder of this
         section covers s p r i n t f , s n p r i n t f , and s s c a n f in detail.
              Three similar functions ( v s p r i n t f , v s n p r i n t f , and v s s c a n f ) also
         belong to < s t d i o . h > . However, these functions rely on the v a _ l i s t type,
         which is declared in < s t d a r g . h > . I’ll postpone discussing them until Section
         26.1, which covers that header.
            C h a p te r2 2
5 7 6 ZYXWVUTSRQPONMLKJIHGFEDCBAln p u t/O u t p u t dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    O u tp u t F u n c t io n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       in t                                 r e s tr ic t s f
                                               s p r i n t f ( c h a r * cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                c o n s t c h a r * r e s t r i c t fo rm a t, . . . ) ;
                                       in t    s n p r in tf(c h a r * r e s tr ic t s, s iz e _ t n,
                                                                  c o n s t c h a r * r e s t r i c t fo r m a t, . . . ) ;

                                      N01e: In this and subsequent chapters, the prototype fora function that is nc\v in
                                      C99 will be in italics. Also, the name ofth e function will be italicized when it
                                      appears in the left margin.

                        sprintf     The s p r i n t f function is sim ilar to p r i n t f and f p r i n t f . except that it writes
                                    output into a character an*ay (pointed to by its first argum ent) instead o f a stream,
                                    s p r i n t f ’s second argument is a format string identical to that used by p r i n t f
                                    and f p r i n t f . F orexam ple, the callkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    sprintf(datc, "%d/%d/%d", 9, 20, 2010);

                                    will write ” 9 / 2 0 / 2 0 1 0 ” into d a t e . When it's finished writing into a siring,
                                    s p r i n t f adds a null character and returns the num ber of characters stored (not
                                    counting the null character). If an encoding error occurs (a wide character could
                                    not be translated into a valid m ultibyte character), s p r i n t f returns a negative
                                    value.
                                          s p r i n t f has a variety of uses. For exam ple, we mighi occasionally want to
                                    format data for output without actually writing it. We can use s p r i n t f to do the
                                    form atting, then save the result in a string until it’s lime to produce output,
                                    s p r i n t f is also convenient for converting num bers to character form.
                      snprin tf          The s n p r i n t f function is the same as s p r i n t f , excepl for the additional
                                    param eter n. No more lhan n - 1 characters will be written to the string, not count­
                                    ing the term inating null character, which is alw ays written unless n is zero. (Equiv­
                                    alently, we could say that s n p r i n t f writes al most n characters lo the string, the
                                    lasl of which is a null character.) For exam ple, the call

                                    snprintf(name, 13, "%s, %s", "Einstein”, ’’Albert”);

                                    will write ’’E i n s t e i n , A l ” in to n a m e .
                                         s n p r i n t f returns the num ber of characters lhat would have been written
                                    (not including the null character) had there been no length restriction. Ifa n encod­
                                    ing error occurs, s n p r i n t f returns a negative number. To see if s n p r i n t f had
                                    room to write all the requested characters, we can test w hether its return value was
                                    nonnegative and less than n.


                                    I n p u t F u n c tio n s

                                       in t    ssc a n f(c o n st        char         * r e s tr ic t       s,
                                                         const           char         * r e s tr ic t       fo rm a t,   ...) ;
                                                                                                        Q ZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                          & A        5 7 7 onmlkjihgfedcbaZYXWV

sscanf   The s s c a n f function is similar to s c a n f and f s c a n f . except that it reads from
         a string (pointed to by its first argument) instead of reading from a stream,
         s s c a n f 's second argument is a format string identical to that used by s c a n f and
         fsc a n f.
               s s c a n f is handy for extracting data from a string that was read by another
         input function. For example, we might use f g e t s to obtain a line of input, then
         pass the line to s s c a n f for further processing:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

         fgets(str, sizeof(str), stdin);                                 /* reads a line of input */
         sscanf(str, "%d%d", &i, &j);                                   /* extracts two integers */

         One advantage of using s s c a n f instead o f s c a n f or f s c a n f is that we can
         examine an input line as many times as needed, notjust once, making it easier to
         recognize alternate input forms and to recover from eiTors. Consider the problem
                                                            m o n th /d a y /y e a r or m o n th -d a y -
         ofreading a date that\s written either in the form cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         year. Assuming that s t r contains a line of input we can extract the month, day.
         and year as follows:

         if (sscanf(str, "%d /%d /%d", &month, &day, &year) == 3)
           printf("Month: %d, day: %d, year: %d\n", month, day, year);
         else if (sscanf(str,    "%d -%d -%d", &month, &day, &year) == 3)
           printf("Month: %d, day: %d, year: %d\n", month, day, year);
         else
           printf("Date not in the proper form\n");

              Like the s c a n f and f s c a n f functions, s s c a n f returns the number o fd ata
         items successfully read and stored, s s c a n f returns EOF if it reaches the end of
         the string (marked by a null character) before finding the first item.aZYXWVUTSRQPONMLKJIHGFEDCBA




         Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

   Q:    I f I u se in p u t o r o u tp u t r e d ir e c tio n , w ill th e r e d ir e c te d file n a m e s s h o w u p a s
         c o m m a n d -lin e a r g u m e n ts ? [p. 5 4 1 ]
   A:    No: the operating system removes them from the command line. Let's say that we
         run a program by entering

         demo foo <in_file bar >out_file baz

         Thc value of a r g c will be 4, a r g v [ 0 ] will point to the program name,
         a r g v [ l ] will point to " f o o " . a r g v [ 2 ] will point to " b a r " , and a r g v [ 3 ]
         will point to " b a z ” .

   Q:    I th o u g h t th a t th e e n d o f a lin e w a s a lw a y s m a r k e d b y a n e w -lin e c h a r a c te r .
         N o w y o u ’re s a y in g th a t th e e n d -o f -lin e m a r k e r v a r ie s, d e p e n d in g o n th e o p e r ­
         a tin g s y s te m . H o w y o u e x p la in th is d is c r e p a n c y ? [p . 5 4 2 ]
   A:    C library functions make it appear as though each line ends with a single new-line
5 7 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r2 2      ln p u t f O u t p u t


                                       character. Regardless of\vhether an input file contains a carriage-return character,
                                       a line-feed character, or both, a library function such as g e t c will return a single
                                       new-line character. The output functions perform the reverse translation. If a pro­
                                       gram calls a library function to write a new-line character to a file, the function
                                       will translate the character into the appropriate end-of-line marker. C ’s approach
                                       makes prograins more portable and easier lo write; we can work with text files
                                       without having to worry about how end-of-line is actually represented. Note that
                                       input/output performed on a file opened in binary mode isnT subject to any char­
                                       acter translation— carriagk**e return and line feed are treated the same as the other
                                       characters.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Q:       I ’m w r itin g a p r o g r a m th a t n e e d s to s a v e d a ta in a file , to b e r e a d la te r b y
                                       a n o th e r p r o g r a m . Is it b e tte r to s to r e th e d a ta in te x t fo r m o r b in a r y fo r m ? [p .
                                       542]
                               A:      Thal depends. If die data is all text to start with, there's not much difference. If the
                                       data contains numbers, however, the decision is tougC?her.
                                             Binary form is usually preferable, since it can be read and written quickly.
                                       Numbers are already in binary form when stored in memory, so copying them to a
                                       file is easy. Writing numbers in text form is much slower, since each number must
                                       be converted (usually by f p r i n t f ) to character form. Reading the file later will
                                       also take more time, since numbers will have to be converted from text form back
                                       to binary. Moreover, storing data in binary form often saves space, as we saw in
                                       Section 22.1.
                                             Binary files have two disadvantages, however. T hey’re hard for humans to
                                       read, which can hamper debugging. Also, binary files generally aren’t portable
                                       from one system to another, since different kinds ofcom puters store data in differ­
                                       ent ways. For instance, some machines store i n t values using two bytes but others
                                       use four bytes. There’s also the issue of byte order (big-endian versus little-
                                       endian).

                              Q:       C p r o g r a m s fo r U N I X n e v e r s e e m to u s e th e le t te r b in th e m o d e s t r in g , e v e n
                                       w h e n th e file b e in g o p e n e d is b in a r y . W h a t g iv e s ? [p . 5 4 4 ]
                               A:      In UNIX, text files and binary files have exactly the same format, so there’s never
                                       any need to use b. UNIX programmers should still include the b, however, so that
                                       then* programs will be more portable to other operating systems.

                              Q:       I ’v e s e e n p r o g r a m s th a t c a ll f o p e n a n d p u t th e le tt e r t in th e m o d e s tr in g .
                                       W h at d oes t m ean ?
                               A:      The C standard allows additional characters to appear in the mode string, provided
                                       that they follow r , w, a. b, or +. Some compilers allow the use of t to indicate that
                                       a file is to be opened in text mode instead of binary mode. O f course, text mode is
                                       the default anyway, so t adds nothing. W henever possible, it’s best to avoid using
                                       t and other nonportable features.

                              Q:       W h y b o th e r to c a ll f c l o s e to c lo s e a file ? I s n ’t it tr u e th a t aII o p e n file s a re
                                       c lo s e d a u to m a ti c a lly w h e n a p r o g r a m te r m in a te s ? [p . 5 4 5 ]
                                                                                                                         Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGFEDC
                                                                                                                                       579

                A:                    T hal’s usually true. but not if the program calls a b o r t to terminate. Even when
                                       a b o r t isn’t used, though, there are still aood reasons to call f c l o s e . First, it
a b o r t fu n c tio n > 2 6 . 2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                             ^ ^                     ^ >                                                  '




                                       reduces the number of open files. Operating systems limit the number of files that
                                       a program may have open al the same lime; large programs may bump into this
                                       limil. (The macro FOPEN_MAX, defined in < s t d i o . h > . specifies the minimum
                                       number of files that the implementation guarantees can be open simultaneously.)
                                       Second, the program becomes easier lo understand and modify; by looking for the
                                      call of f c l o s e . it’s easier for the reader to determ ine (he point al which a file is
                                       no longer in use. Third, there’s the issue of safety. Closing a file ensures that its
                                      contents and directory entry are updated properly; if the program should crash
                                       laier. at least the file will be inlact.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                Q:     I ’m w r it in g a p r o g r a m th a t w ill p r o m p t th e u s c r to e n te r a file n a m e . H o w
                       lo n g s h o u ld I m a k e th e c h a r a c te r a r r a y th a t w ill s t o r e th e file n a m e ? [ p. 5 4 6 ]
                A:     That depends on your operating system. Fortunately, you can use the macro
                       FILENAME_MAX (defined in < s t d i o . h > ) lo specify the size of the array.
                       FILENAME_MAX is lhe length o f a string that will hold the longest file name that
                       the implementation guarantees can be opened.

                Q:     C an f f l u s h       flu s h a s tr e a m th a t w a s o p e n e d fo r b o th r e a d in g a n d w r itin g ?
                       [p . 5 4 9 ]
                A;     According to the C standard, the effect o fcallin g f f l u s h is defined for a stream
                       that (a) was opened for output, or (b) was opened for updating and whose last oper­
                       ation was not a read. In all other cases, the effect o fcallin g f f l u s h is undefined.
                       When f f l u s h is passed a null pointer, il flushes all streams lhat satisfy either (a)
                       or (b).

                Q:     C a n th c fo r m a t s t r in g in a c a ll o f . . . p r i n t f o r . . . s c a n f b e a v a r ia b le ?
                A;     Sure; it can be any expression of type c h a r *. This property makes the . . . p r i n t f
                       and ...s c a n f functions even more versatile than w e’ve had reason to suspect. Con­
                                                                                             The C P ro g ra m -
                       sider the following classic example from Kernighan and R itchie's cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                       nm ig Language, which prints a program ’s com m and-line arguments, separated by
                       spaces;kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                       while (--argc > 0)
                         printf((argc > 1) ? "%s " : "%s", *++argv);

                       The formal string is the expression ( a r g c > 1) ? "%s ” : "% s", which evalu­
                       ates to "%s " for all command-line arguments but the last.

                Q:     W h ic h lib r a r y fu n c tio n s o t h e r th a n c l e a r e r r         c le a r a s t r e a m ’s e r r o r a n d
                       e n d -o f -f ile in d ic a to r s ? [p . 5 6 5 ]
                A:     Calling r e w i n d clears both indicators, as does opening or reopening the stream.
                       Calling u n g e t c , f s e e k , or f s e t p o s clears just die end-of-file indicator.

                Q:     I c a n ’t g e t f e o f to w o r k ; it s e e m s to r e tu r n z e r o e v e n a t e n d -o f- file . W h a t a m
                       I d o in g w r o n g ? [p . 5 6 5 ]
            C h a p te r 2 2   ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
5 8 0 ZYXWVUTSRQPONMLKJIHGFEDCBA


                              A:     f e o f will only return a nonzero value when a previous read operation has failed:
                                                                                     before attempting to read. Instead, you
                                     you can 't use f e o f to check for end-of-file cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     should first attempt to read, then check the return value from the input function. If
                                     the return value indicates that the operation was unsuccessful, you can then use
                                     f e o f to determine whether the failure was due to end-of-file. In other words, it's
                                     best not to think ofcall.ing f e o f as a way to detect end-of-file. Instead, think o fit
                                     as a way to confirm that end-of-file was the reason for the failure o f a read opera­
                                     tion.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      I s till d o n ’t u n d e r s ta n d w h y th e U O lib r a r y p r o v i d e s m a c r o s n a m e d p u t c a n d
                                     g e t c in a d d it io n to fu n c t io n s n a m e d f p u t c a n d f g e t c . A c c o r d in g to S e c ­
                                     tio n 2 1 .1 , th e r e a r e a lr e a d y tw o v e r s i o n s o f p u t c a n d g e t c (a m a c r o a n d a
                                     fu n c t io n ). I f w e n e e d a g e n u in e fu n c t io n in s te a d o f a m a c r o , w e c a n e x p o s e th e
                                     p u tc    or g e t c      fu n c tio n b y u n d e f in in g th e m a c r o . S o w h y d o f p u t c             and
                                      f g e t c e x is t? [p . 5 6 6 ]
                              A:     Historical reasons. Prior to standardization. C had no rule that there be a true func­
                                     tion to back up each parameterized macro in the library, p u t c and g e t c were tra­
                                     ditionally implemented only as macros; f p u t c and f g e t c were implemented
                                     only as functions.

                            *Q :     W h a t ’s w r o n g w ith s t o r in g th e r e tu r n v a lu e o f f g e t c , g e t c , o r g e t c h a r in
                                     a c h a r v a r ia b le ? I d o n ’t s e e h o w te s t in g a c h a r v a r i a b le a g a in s t EO F c o u ld
                                     g iv e th e w r o n g a n sw e r , [p . 5 6 8 ]
                              A:     There are two cases in which this test can csi ve the wrong^ result. To make the fol-
                                     lowing discussion concrete, 1'11 assum e lwo's-com plem ent arithmetic.
                                            First, suppose that c h a r is an unsigned type. (Recall that som e compilers
                                     treat c h a r as a signed type but others treat it as an unsigned type.) Now suppose
                                     that g e t c returns EOF. which we store in a c h a r variable named c h . IfE O F rep­
                                     resents -1 (its typical value), c h will end up with the value 255. Com paring c h (an
                                     unsigned character) with EOF (a signed integer) requires converting c h to a signed
                                     integer (255, in this case). The comparison against EOF fails, since 255 is not equal
                                     to - 1 .
                                            Now assume that c h a r is a signed type instead. Consider what happens if
                                     g e t c reads a byte containing the value 255 from a binary stream. Storing 255 in
                                     the c h variable ^gp.ives it the value -1 . cs^ince c h is a signed ^*character. Testins
                                     whether c h is equal to EOF will (erroneously) give a true result.

                              Q:     T h e c h a r a c te r in p u t fu n c t io n s d e s c r ib e d in S e c tio n 2 2 .4 r e q u ir e th a t th e E n te r
                                      k e y b e p r e s s e d b e fo r e th e y c a n r e a d w h a t th e u s e r h a s ty p e d . H o w c a n I w r ite
                                     a p r o g r a m th a t r e s p o n d s to in d iv id u a l k e y s tr o k e s ?
                              A:     As you've noticed, the g e t c . f g e t c . and g e t c h a r functions are buffered: they
                                     don't start to read input until the user has pressed the Enter key. In order to read
                                     characters as theyTe entered— which is important for some kinds of program s—
                                     you’ll need lo use a nonstandard library that's tailored to your operating system. In
                                     UNIX, for example, the c u r s e s library often provides this capability.
                                                                                                                  581 dcbaZYXWVUTSR
                                                                                                   Q & A hgfedcbaZYXWVUTSRQPONMLKJIH


Q:   W h e n F m r e a d in g u s e r in p u t, h o w c a n I s k ip a ll c h a r a c te r s le ft o n th e c u r r e n t
     in p u t lin e ? onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
A:   One possibility is to write a small function that reads and ignores all characters up
     to (and including) the first new-line character:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

     void skip_line(void)

         while (getchar()                   l- '\n')cbaZYXWVUTSRQPONMLKJIHGFEDCBA
     >       '

          Another possibility is to ask s c a n f to skip ail characters up to the first new-
     line character:

     scanf("%*[^\n]");                       /* skips characters up to new-line */

     s c a n f will read all characters up to the first new-line character, but not store them
     anywhere (the * indicates assignment suppression). The only.problem with using
     s c a n f is that it leaves the new-line character unread, so you may have to discard
     it separately.
           Whatever you do, don’t call the f f l u s h function:

     fflush(stdin);                    /* effect is undefined */

     Although some implementations allow the use o f f f l u s h to “flush” unread input,
     it’s not a good idea to assume that all do. f f l u s h is designed to flush output
     streams; the C standard states that its effect on input streams is undefined.

Q:   W h y is it n o t a g o o d id e a to u se f r e a d a n d f w r i t e w ith te x t s tr e a m s ? [p .
     571]
A:   One difficulty is that, under some operating systems, the new-line character
     becomes a pair of characters when written to a text file (see Section 22.1 for
     details). We must take this expansion into account, or else w e’re likely to lose track
     of our data. For example, if we use f w r i t e to write blocks of 80 characters, some
     of the blocks may end up occupying more than 80 bytes in the file because of new-
     line characters that were expanded.

Q:   W h y a r e th e r e tw o s e ts o f file -p o s itio n in g fu n c tio n s ( f s e e k / f t e l l           and
     f s e t p o s / f g e t p o s ) ? W o u ld n ’t o n e s e t b e e n o u g h ? [p . 5 7 4 ]
A:   f s e e k and f t e l l have been part of the C library for eons. They have one draw­
     back, though: they assume that a file position will fit in a l o n g i n t value. Since
     l o n g i n t is typically a 32-bit type, this means that f s e e k and f t e l l may not
     work with files containing more than 2,147,483,647 bytes. In recognition of this
     problem, f s e t p o s and f g e t p o s were added to < s t d i o . h > when C89 was
     created. These functions aren’t required to treat file positions as numbers, so
     they’re not subject to the l o n g i n t restriction. But don’t assume that you have to
     use f s e t p o s and f g e t p o s ; if your implementation supports a 64-bit l o n g
     i n t type, f s e e k and f t e l l are fine even for very large files.
5 8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 2   ln p u t/O u tp u t dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                            Q:     W h y d o e s n ’t th is c h a p te r d is c u s s s c r e e n c o n tr o l: m o v in g th e c u r s o r , c h a n g in g
                                   th e c o lo r s o f c h a r a c te r s o n th e s c r e e n , a n d s o o n ?
                            A:     C provides no standard functions for screen control. The C standard addresses only
                                   issues that can reasonably be standardized across a wide range of com puters and
                                   operating systems; screen control is outside this realm. The custom ary way to
                                   solve this problem in UNIX is lo use the c u r s e s library, which supports screen
                                   control in a term inal-independent manner.
                                        Similarly, there are no standard functions for building programs with a graphi­
                                   cal user interface. However, you can most likely use C function calls to access the
                                   windowing API (application programming interface) for your operating system .aZYXWVUTS




                                   E x e r c is e s
S e c t i o n 2 2 .1         l.    Indicate whether each of the following files is more likely to contain text data or binary
                                   data:
                                   (a) A file of object code produced by a C com piler
                                   (b) A program listing produced by a C com piler
                                   (c) An email message sent from one computer to another
                                   (d) A file containing a graphics image

S e c t i o n 2 2 .2   ©     2.    Indicate which mode string is m ost likely to be passed to f o p e n in each of the following
                                   situations:
                                   (a) A database management system opens a file containing records to be updated.
                                   (b) A mail program opens a file of saved messages so that it can add additional messages to
                                       the end.
                                   (c) A graphics program opens a file containing a picture to be displayed on the screen.
                                   (d) An operating system command interpreter opens a “shell script” (or “batch file”) con­
                                       taining commands to be executed.

                             3.    Find the error in the following program fragment and show how to fix it.kjihgfedcbaZYXWVUTSRQPONMLKJIHGF
                                   FILE *fp;
                                   if (fp = fopen(filename,                          "r"))       {PONMLKJIHGFEDCBA
                                     read characters until end-of-file

                                   fclose(fp);

S e c t i o n 2 2 .3   ©     4.    Show how each of the following numbers will look if displayed by p r i n t f                                       with
                                   % # 0 1 2 . 5 g as the conversion specification:
                                   (a)   83.736l
                                   (b)   29748.6607
                                   (c)   l054932234.0
                                   (d)   0.00002352l8

                             5.    Is there any difference between the p r i n t f conversion specifications %. 4 d and % 04d? If
                                   so. explain what it is.
                                                                                                                                         5 8 3 aZYXWVUTSRQPO
                                                                                                                E x e r c is e s hgfedcbaZYXWVUTSRQPONMLKJIH


                      © *6.      Write a call of p r i n t f that prints
                                 1 w id g e t
                                 if the w i d g e t variable (of type i n t ) has the value 1, and RQPONMLKJIHGFEDCBA
                                 n   w id g e ts
                                 otherwise, where ti is the value of w i d g e t . You are not allowed to use the i f statement or
                                 any other statement; the answer must be a single call o f p r i n t f .

                          *7.    Suppose that we call s c a n f as follows:
                                 n = sc a n f("% d % f% d ",         & i,   &x,    & j);
                                 ( i , j , and n are i n t variables and x is a f l o a t variable.) Assuming that the input stream
                                 contains the characters shown, give the values of i , j . n. and x after the call. In addition,
                                 indicate which characters were consumed by the call.
                                 (a)    10*20*30a
                                 (b)    1 .0 * 2 .0 * 3 .0 O
                                 (c)    0 .1 * 0 .2 * 0 .3 O
                                 (d)    .1 ^ .2 * .3 Q

                     ©     8.    In previous chapters, w e’ve used the s c a n f format string •' %c” when we wanted to skip
                                 white-space characters and read a nonblank character. Some programmers use " % ls "
                                 instead. Are the two techniques equivalent? If not, what are the differences?

                                     9.   Which one of the following calls is n o t a valid way of reading one character from the stan­
S e c t io n 2 2 .4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 dard input stream?
                                 (a)    g e t c h ()
                                 (b)    g e t c h a r ()
                                 (c)    g e tc (s td in )
                                 (d)    fg e tc (s td in )

                     ©    10.    The f c o p y . c program has one m inor Daw: it doesn’t check for errors as it's writing to the
                                 destination file. Errors during writing are rare, but do occasionally occur (the disk might
                                 become full, for example). Show how to add the missing error check to the program, assum­
                                 ing that we want it to display a message and terminate immediately if an error occurs.

                          11.    The following loop appears in the f c o p y . c program:
                                 w h ile ((c h = g e tc ( s o u r c e _ f p ) )        ’ = EOF)
                                    p u tc (c h , d e s t_ f p );
                                 Suppose that we neglected to put parentheses around c h = g e t c ( s o u r c e _ _ f p ) :
                                 w h ile (c h = g e t c ( s o u r c e _ f p )      ! = EOF)
                                   p u tc (c h , d e s t_ fp );
                                 Would the program compile without an error? If so, what would the program do when it’s
                                 run?

                          12.    Find the error in the following function and show how to fix it.
                                 in t    c o u n t_ p e r io d s ( c o n s t c h a r * file n a m e )

                                       F IL E * f p ;
                                       i n t n = 0;
5 8 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 2    ln p u t/O u tp u t hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           if      ( (f p = fo p e n (file n a m e , " r " ) )       != NULL)      {
                                                w h i l e ( f g e t c ( f p ) != EOF)
                                                     i f ( f g e t c ( f p ) == ' . ' )
                                                        n+ + cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                             i
                                                f c l o s e (f p ) ;
                                           }
                                           re tu rn     n;


                             13.    W rite the followingo function:
                                     in t       lin e _ le n g th (c o n s t c h a r     * file n a m e ,   in t n );
                                    The function should return the length of line n in the text file whose name is f i l e n a m e
                                    (assuming that the first line in the file is line 1). If the line doesn’t exist, the function should
                                    return 0.

S e c tio n 2 2 .5      ©    14,     (a) W rite your own version of the f g e t s function. Make it behave as much like the real
                                     f g e t s function as possible; in particular, make sure that it has the proper retum value. To
                                     avoid conflicts with the standard library, don’t name your function f g e t s .
                                     (b) W rite your own version o f f p u t s , following the sam e rules as in part (a).

S e c tio n 2 2 .7      ©    15.     Write calls of f s e e k that perform the following file-positioning operations on a binary file
                                     whose data is arranged in 64-byte “records.” Use f p as the file pointer in each case.
                                     (a)    Move to the beginning o freco rd n. (Assume that the first record in the file is record 0.)
                                     (b)    Move to the beginning o f the last record in the file.
                                     (c)    Move forward one record.
                                     (d)    Move backward two records.

S e c tio n 2 2 .8           16.     Assume that s t r is a string that contains a “sales rank” immediately preceded by the #
                                     symbol (other characters may precede the # and/or follow the sales rank). A sales rank is a
                                     series of decimal digits possibly containing commas, such as the following examples:
                                     989
                                     2 4 ,6 7 5
                                     1 ,1 6 2 ,6 2 0
                                     W rite a call o f s s c a n f that extracts the sales rank (but not the # symbol) and stores it in a
                                     string^^ variable named s a l e s «M*r a n k .aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     P r o g r a m m in g P r o je c t s

                               1.    Extend the c a n o p e n . c program of Section 22.2 so that the user may put any num ber of
                                     file names on the command line:
                                     can o p en fo o b a r b az
                                    The program should print a separate c a n b e o p e n e d or c a n ’ t b e o p e n e d message for
                                    each file. Have the program term inate with status EX IT_FA ILU R E if one or more of the
                                    files can’t be opened.

                        ©     2.     W rite a program that converts all letters in a file to upper case. (Characters other than letters
                                     shouldn't be changed.) The program should obtain the file nam e from the command line and
                                     write its output to s t d o u t .
                                                                                                         585onmlkjihgfedcbaZYXWVUTSRQ
                                                                  P ro g ra m m in g P ro je c ts kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCB

    3.   Write a program named f c a t that “concatenates’' any number of files by writing them to
         standard output, one after the other, with no break between files. For example, the following
         command will display the files f l . c , f 2 . c , and f 3 . c on the screen:
         fcat fl.c f2.c f3.c
                                                                             H int: Since it has no more
         f c a t should issue an error message if any file can’t be opened. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         than one file open at a time, f c a t needs only a single file pointer variable. Once it’s fin­
         ished with a file, f c a t can use the same variable when it opens the next file.

©   4.   (a) W rite a program that counts the number of characters in a text file.
         (b) W rite a program that counts the number of words in a text file. (A “word” is any
         sequence of non-white-space characters.)
         (c) W rite a program that counts the number of lines in a text file.
         Have each program obtain the file name from the command line.

    5.   The x o r . c program of Section 20.1 refuses to encrypt bytes that— in original or encrypted
         form — are control characters. We can now remove this restriction. M odify the program so
         that the names of the input and output files are com m and-line arguments. Open both files in
         binary mode, and remove the test that checks w hether the original and encrypted characters
         are printing characters.

©   6.   W rite a program that displays the contents of a file as bytes and as characters. Have the user
         specify the file name on the command line. H ere’s what the output will look like when the
         program is used to display the p u n . c file of Section 2.1:
         Offset                         Bytes                          Characters

               0     23 69 6E 63 6C 75 64 65 20 3C                    #include <
              10     73 74 64 69 6F 2E 68 3E 0D 0A                    stdio.h > ..
              20     0D 0A 69 6E 74 20 6D 61 69 6E                    ..int main
              30     28 76 6F 69 64 29 0D 0A 7B 0D                    (void)..{.
              40     0A 20 20 70 72 69 6E 74 66 28                       printf(
              50     22 54 6F 20 43 2C 20 6F 72 20                    "To C, or
              60     6E 6F 74 20 74 6F 20 43 3A 20                    not to C:
              70     74 68 61 74 20 69 73 20 74 68                    that is th
              80     65 20 71 75 65 73 74 69 6F 6E                    e question
              90     2E 5C 6E 22 29 3B 0D 0A 20 20                    .\n");..
             100     72 65 74 75 72 6E 20 30 3B 0D                    return 0;.
             110     0A 7D
         Each line shows 10 bytes from the file, as hexadecimal numbers and as characters. The
         number in the O f f s e t column indicates the position within the file of the first byte on the
         line. Only printing characters (as determ ined by the i s p r i n t function) are displayed;
         other characters are shown as periods. Note that the appearance of a text file may vary,
         depending on the character set and the operating system. The exam ple above assumes that
         p u n . c is a Windows file, so 0D and 0A bytes (the ASCH carriage-return and line-feed
         characters) appear at the end ofeach line. H int: Be sure to open the file in " r b " mode.

    7.   O f the many techniques for compressing the contents of a file, one of the sim plest and fast­
         est is known as ru n -le n g th encoding. This technique compresses a file by replacing
         sequences of identical bytes by a pair of bytes: a repetition count followed by a byte to be
         repeated. For example, suppose that the file to be compressed begins with the following
         sequence ofbytes (shown in hexadecimal):
         46 6F 6F 20 62 61 72 21 21 21 20 20 20 20 20
         The compressed file will contain the following bytes:
            C h a p te r 2 2
5 8 6 ZYXWVUTSRQPONMLKJIHGFEDCBAln p u t/O u tp u t kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      01 46 02 6F 01 20 01 62 01 61 01 72 03 21 05 20onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFED
                                     Run-length encoding works well if the original file contains many long sequences o fidenti-
                                     cal bytes. In the worst case (a file with no repeated bytes), run-length encoding can actually
                                     double the length of the file.
                                      (a) W rite a program named c o m p r e s s _ f i l e that uses run-length encoding to compress
                                      a file. To run c o m p r e s s _ f i l e , w e'd use a command of the form
                                                                  origin al-file
                                      c o m p r e s s _ f i l e cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      c o m p r e s s _ f i l e will write the compressed version of origin al-file to o r ig in a lfile . r l e .
                                      For example, the command
                                      c o m p re s s _ file      f o o .tx t
                                      will cause c o m p r e s s _ f i l e to write a compressed version o f f o o . t x t to a file named
                                      f o o . t x t . r l e . H int: The program described in Programming Project 6 could be useful
                                      for debugging.
                                     (b) W rite a program named u n c o m p r e s s _ f i l e that reverses the compression performed
                                     by the c o m p r e s s _ f i l e program. The u n c o m p r e s s _ f i l e command will have the
                                     form
                                     u n c o m p r e s s _ f i l e c o m p re sse d file
                                      c o m p re sse d file should have Lhe extension . r l e . For exam ple, the command
                                     u n c o m p re s s _ file       f o o .tx t.r le
                                      will cause u n c o m p r e s s _ f i l e to open the file f o o . t x t . r l e and write an uncom­
                                      pressed version o f its contents to f o o . t x t . u n c o m p r e s s _ f i l e should display an error
                                      message ifits comm and-line argum ent doesn’t end with the . r l e extension.

                               8.     M odify the i n v e n t o r y . c program of Section 16.3 by adding two new operations:
                                            ■   Save the database in a specified file.
                                        ■       Load the database from a specified file.
                                     Use the codes d (dump) and r (restore), respectively, to represent these operations. The
                                     interaction with the user should have the following appearance:
                                      E n te r o p e ra tio n c o d e : d
                                      E n t e r n am e o f o u t p u t f i l e :            in v e n to ry .d a t

                                      E n te r o p e r a tio n c o d e : r
                                      E n t e r n am e o f i n p u t f i l e :          in v e n to ry .d a t
                                      H int: Use f w r i t e to write the array containing the parts to a binary file. Use f r e a d to
                                      restore the array by reading it from a file.

                         ©     9.     Write a program that merges two files containing part records stored by the i n v e n t o r y . c
                                      program (see Programming Project 8). Assume that the records in each file are sorted by
                                      part number, and that we want the resulting file to be sorted as well. Ifb o th files have a part
                                      with the sam e number, com bine the quantities stored in the records. (As a consistency
                                      check, have the program com pare the part names and print an error message if they don't
                                      match.) Have the program obtain the names of the input files and the merged file from the
                                      command line.

                             *10.     Modify the i n v e n t o r y 2 . c program of Section 17.5 by adding the d (dump) and r
                                      (restore) operations described in Program ming Project 8. Since the part structures aren't
                                      stored in an array, the d operation can't save them all by a single call of f w r i t e . Instead, it
                                      will need to visit each node in the linked list, writing the part number, part name, and quan-
                                                                                                          5 8 7 onmlkjihgfedcbaZYXW
                                                                 P ro g ra m m in g P ro je c ts hgfedcbaZYXWVUTSRQPONMLKJIHG

      lily on hand to a file. (D on't save the n e x t pointer; it w on't be valid once the program ter­
      minates.) As it reads parts from a file, the r operation will rebuild the list one node at a time.

11.   Write a program that reads a date from the command line and displays it in the following
      form:
      S e p te m b e r 1 3 ,       2010
      Allow the user to enter the date as either 9 - 1 3 - 2 0 1 0 or 9 / 1 3 / 2 0 1 0 ; you may assume
      that there are no spaces in the date. Print an error m essage if the date doesn’t have one of the
                        H int: Use s s c a n f to extract the month, day, and year from the com m and­
      specified forms. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
      line argument.

12.   M odify Programming Project 2 from Chapter 3 so that the program reads a series o f items
      from a file and displays the data in columns. Each line of the file will have the following
      form:
      ite m , p r ic e , m m /d d /y y y y
      For example, suppose that the file contains the following lines:
      5 8 3 ,1 3 .5 ,1 0 /2 4 /2 0 0 5
      3 9 1 2 ,5 9 9 .9 9 ,7 /2 7 /2 0 0 8
      The output o fth e program should have the following appearance:
      Ite m                            U n it             P u rc h a se
                                       P ric e            D a te
      583                              $    1 3 .5 0      1 0 /2 4 /2 0 0 5
      3912                             $ 5 9 9 .9 9       7 /2 7 /2 0 0 8
      Have the program obtain the file name from the command line.

13.   Modify Program m ing Project 8 from Chapter 5 so that the program obtains departure and
      arrival times from a file named f l i g h t s . d a t . Each line o fth e file will contain a depar­
      ture time followed by an arrival time, with one or more spaces separating the two. Times
      will be expressed using the 24-hour clock. For example, here's what f l i g h t s . d a t might
      look like if it contained the flight information listed in the original project:
      8 :0 0 1 0 :1 6
      9 :4 3 1 1 :5 2
      1 1 :1 9 1 3 :3 1
      1 2 :4 7 1 5 :0 0
      1 4 :0 0 1 6 :0 8
      1 5 :4 5 1 7 :5 5
      1 9 :0 0 2 1 :2 0
      2 1 :4 5 2 3 :5 8

14.   Modify Programming Project 15 from Chapter 8 so that the program prompts the user to
      enter the namc of a file containing the message to be encrypted:
      E n t e r n am e o f f i l e t o b e e n c r y p t e d :   m essag e. tx t
      E n te r s h i f t am ount (1 -2 5 ): 2
      The program then writes the encrypted message to a file with the same name but an added
      extension of . e n c . In this example, the original file name is m e s s a g e . t x t , so the
      encrypted message will be stored in a file named m e s s a g e . t x t . e n c . T here’s no limit on
      the size of the file to be encrypted or on the length of each line in the file.

15.   Modify the j u s t i f y program of Section 15.3 so that it reads from one text file and writes
      to another. Have the program obtain the names of both files from the command line.
588 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r2 2    ln p u t/O u tp u t onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                             16.    Modify the f c o p y . c program of Section 22.4 so that it uses f r e a d and f w r i t e to copy
                                    the file in blocks of 512 bytes. (The last block may contain fewer than 512 bytes, of course.)

                             17.     W rite a program that reads a series of phone numbers from a file and displays them in a
                                     standard format. Each line o f the file will contain a single phone number, but the numbers
                                     may be in a variety of formals. You may assume that each line contains 10 digits, possibly
                                     mixed with other characters (which should be ignored). For example, suppose that the file
                                     contains the following<^ lines:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     404.817.6900
                                     (215) 686-1776
                                     312-746-6000
                                     877 275 5273
                                     6173434200
                                    The output of the program should have the following appearance:
                                     (404)      817-6900
                                     (215)      686-1776
                                     (312)      746-6000
                                     (877)      275-5273
                                     (617)      343-4200
                                     Have the program obtain the file name from the command line.

                             18.    W rite a program that reads integers from a text file whose name is given as a command-line
                                    argument. Each line of the file may contain any num ber of integers (including none) sepa­
                                    rated by one or more spaces. Have the program display the largest num ber in the file, the
                                    smallest number, and the median (the number closest to the middle if the integers were
                                    sorted). If the file contains an even number o f integers, there will be two numbers in the
                                    middle; the program should display their average (rounded down). You may assum e that the
                                                                                H int: Store the integers in an array and then sort
                                    file contains no more than 10.000 integers. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    the array.

                             19.    (a) W rite a program that converts a Windows text file to a UNIX text file. (See Section 22.1
                                    for a discussion of the differences between Windows and UNIX text files.)
                                     (b) Write a program that converts a UNIX text file to a Windows text file.
                                    In each case, have the program obtain the names o fb o th files from the command line. Hint:
                                    Open the input file in " r b " mode and the output file in "w b" mode.
            2 3                         L ib r a r y S u p p o r t f o r N u m b e r s
                                        a n d C h a r a c t e r D a ta                                         ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                               P ro lo n g e d c o n ta c t w ith th e c o m p u te r tu r n s
                                                                                               m a th e m a tic ia n s in to c le r k s a n d v ic e v e rs a . onmlkjihgfedcbaZYXW




                                        This chapter describes the five most important library headers that provide support
                                        for workingo wit7h numbers, ■ characters, and char&acter strings. Sections 23.1 and
                                        23.2 cover the < f l o a t . h > and < l i m i t s . h > headers, which contain macros
                                        describing the characteristics o f numeric and character types. Sections 23.3 and
                                        23.4 describe the < m a t h . h> header, which provides mathematical functions. Sec­
                                        tion 23.3 discusses the C89 version of < m a th .h > ; Section 23.4 covers the C99
                                        additions, which are so extensive that Tve chosen to cover them separately. Sec­
                                        tions 23.5 and 23.6 are devoted to the < c t y p e . h > and < s t r i n g . h > headers,
                                        which provide character functions and string functions, respectively.
                                             C99 adds several headers that also deal with numbers, characters, and strings.
                                        The < w c h a r . h> and < w c t y p e . h> headers are discussed in Chapter 25. Chap­
                                        ter 27 covers < c o m p l e x .h > , < f e n v . h > , < i n t t y p e s . h > . < s t d i n t . h > ,
                                        and < t g m a t h .h > .




                      2 3 .1            T h e < f l o a t . h > H e a d e r : C h a r a c t e r is tic s o f
                                        F lo a t in g T y p e s

                                        The < f l o a t .h > header provides macros that defme the range and accuracy of
                                        the f l o a t , d o u b l e , and l o n g d o u b l e types. There are no types or functions
                                        in < f l o a t . h>.
                                             Two macros apply to all floating types. The FLT_ROUNDS macro represents hgfedcbaZYXWVUTS
ro u n d in g d ire c tio n > 2 3 . 4   the current rounding direction for floating-point addition. Table 23.1 shows the
                                        possible values of FLT_ROUNDS. (Values not shown in the table indicate imple­
                                        mentation-defined rounding behavior.)
                                                                        <_rf>         <




                                                                                                                                                        589
5 9 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 3    L ib ra ry S u p p o r t fo r N u m b e r s a n d C h a r a c te r D a ta dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                          T a b le 2 3 .1 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA V a l u e            M e a n in g
        R ounding Direcl.ions RQPONMLKJIHGFEDCBA                                       -1       Indeterm inable
                                                                                        0       Toward zero
                                                                                        1       To nearest
                                                                                        2       Toward positive infinity
                                                                                        3       Toward negative infinity

                                                Unlike the other macros in < f l o a t . h > , which represent constant expressions,
                                                the value of FLT_ROUNDS may change during execution. (The f e s e t r o u n d
    f e s e t r o u n d fu n ctio n > 2 7 . 6   function allows a program to change the current rounding direction.) The other
                                                macro, FLT_RADIX, specifies the radix ofexponent representation; it has a mini­
                                                mum value of 2 (indicating binary representation).
                                                     The remaining macros, which Tll present in a series of tables, describe the
                                                characteristics of specific types. Each macro begins with either FLT, DBL, or
                                                LDBL, depending on whether it refers to the f l o a t , d o u b l e , or l o n g d o u b l e
                                                type. The C standard provides extremely detailed definitions of these macros; my
                                                descriptions will be less precise but easier to understand. The tables indicate maxi­
                                                mum or minimum values forsom e macros, as specified in the standard.
                                                     Table 23.2 lists macros that define the number ofsig^n ificant diC  g1its cg*uaranteed
                                                by each floating type.

                         T a b le 2 3 .2                      N am e                V a lu e                                  D e s c r ip tio n
 Significant-D igit M acros                          FLT_MANT_DIG                               N u m b ero fsig n ifican t digits (base FLT_RA D IX )
          in < f l o a t . h>                        DBL_MANT_DIG
                                                     LDBL_MANT_DIG
                                                     F L T _D IG                     >6         N um ber o fsig n ifican t digits (base 10)
                                                     DBL_DIG                         >10
                                                     LDBL_DIG                        >10

                                                    Table 23.3 lists macros having to do with exponents.

                         T a b le 2 3 .3                    N am e                   V a lu e                                  D e s c r ip tio n
             Exponent M acros                     FLT_M IN _EX P                                Sm allest (m ost negative) pow er to which
              in < f l o a t . h >                DBL_M IN_EXP                                  FLT_RADIX can be raised
                                                  LDBL_M IN_EXP
                                                  F L T _M IN _10_E X P              <_ 37      Sm allest (m ost negative) pow er to which 10 can be
                                                  D B L_M IN _10_E X P                          raised
                                                  L D B L _M IN _10_E X P
                                                  FLT_MAX_EXP                                   Largest pow er to which FLT_R A D IX can be raised
                                                  DBL_MAX_EXP
                                                  LDBL_MAX_EXP
                                                  FLT_M AX_10_EXP                    >+37       Largest pow er to which 10 can be raised
                                                  DBL_MAX_10_EXP                     >+37
                                                  LDBL_MAX_10_EX P                   >+37

                                                    Table 23.4 lists macros that describe how large numbers can be, how close to
                                                                                                                        ^ »                         ♦




                                                zero they can get, and how close two consecutive numbers can be.
                                                    2 3 .2                                                                                       591 RQPONMLKJIHGFED
                                                                 T h e < l i m i t s . h > H e a d e r: S iz e s o f In te g e r T ype s hgfedcbaZYXWVUTSRQPONMLKJIHG


               T a b le 2 3 .4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 N am e              V a lu e                                D e s c r ip tio n
 Max, Min. and Epsilon             FLT_M AX                         > 1 0 +37    Largest finite value
M acros in < f l o a t . h> ZYXWVUTSRQPONMLKJIHGFEDCBA
                                   DBL_MAX                          > 1 0 +37
                                      LDBL_MAX                      > 1 0 + 37
                                      F L T _ M IN                  < IO - 3 7   Smallest positive value
                                      D B L _M IN                   <10^ 37
                                      L D B L _ M IN                <10^ 37
                                      F L T _ E P S IL O N           <10^ 5      Smallest representable difference between two num bers
                                      D B L _ E P S IL O N           <10^ 9
                                      LD B L *“•E P S IL O N         <1()- 9


                       C99              C99 provides two other macros, DECIM AL_DIG and FLT_EVAL_METHOD.
                                   DECIMAL_DIG represents the num ber o f significant digits (base 10) in the w id­
                                   est supported floating type; it has a minim um value of 10. The value of
                                   FLT_EVAL_METHOD indicates w hether an im plem entation will perform float­
                                   ing-point arithm etic using greater range and precision than is strictly necessary. If
                                   this macro has the value 0, for example, then adding two f l o a t values would be
                                   done in the normal way. If it has the value 1, however, then the f l o a t values
                                   would be converted to d o u b l e before the addition is perform ed. Table 23.5 lists
                                   the possible values of FLT_EVAL_METHOD. (N egative values not shown in the
                                   table indicate im plem entation-defined behavior.)

               T a b le 2 3 .5       V a lu e                                                 M e a n in g
    Evaluation M ethods                -1         Indeterm inable
                                         0        Evaluate all operations and constantsjust to the range and precision o f the type
                                         1        Evaluate operations and constants o f type f l o a t and d o u b l e to the range
                                                  and precision of the d o u b l e type
                                         2       Evaluate all operations and constants to the range and precision o f the l o n g
                                                 d o u b l e type

                                        M ost of the macros in < f l o a t . h > are o f interest only to experts in num eri­
                                   cal analysis, making it probably one of the least-used headers in the standard
                                   library.aZYXWVUTSRQPONMLKJIHGFEDCBA




                   2 3 .2         T h e < l i m i t s . h > H e a d e r : S i z e s o f In t e g e r T y p e s

                                   The < l i m i t s .h > header provides macros that define the range o f each integer
                                   type (including the character types), < l i m i t s . h > declares no types or functions.
                                         One set of macros in < l i m i t s . h > deals with the character types: c h a r ,
                                   s i g n e d c h a r , and u n s i g n e d c h a r . Table 23.6 lists these m acros and shows
                                   the maxim um or minim um value of each.
                                         The other macros in < l i m i t s . h > deal with the rem aining integer types:
                                   s h o r t i n t , u n s i g n e d s h o r t i n t , i n t , u n s i g n e d i n t , l o n g i n t , and
5 9 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 3     L ib r a r y S u p p o r t fo r N u m b e rs a n d C h a ra c te r D a ta dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                        T a b le 2 3 .6 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                             N am e           V a lu e                                D e s c r ip tio n
          C h a r a c te r M a c ro s         C H A R _ B IT                         >8^^     Number of bits per byte
           in < l i m i t s . h > RQPONMLKJIHGFEDCBA
                                              S C H A R _ M IN                   <-127        Minimum s i g n e d c h a r value
                                                           SCH A R_M A X         >^-1^7       Maximum s i g n e d c h a r value
                                                           UCHAR_M AX             >255        Maximum u n s i g n e d c h a r value
                                                           C H A R _ M IN              t      Minimum c h a r value
                                                           CHAR_M AX                  tt      Maximum c h a r value
                                                           M B _LEN _M A X           >1       Maximum number ofbytes per multibyte character
                                                       -
                                                                                              in any supported locale (see Section 25.2)
                                                           ^CHAR_MIN is equal to SCHAR_MIN if c h a r is treated as a signed type: otherw ise.
                                                           CHAR_MIN is 0.
                                                           '^CHAR_MAX has the same value as either SCHAR_MAX or UCHAR_MAX. depending on
                                                           w hether c h a r is treated as a signed type o r an unsigned type.


                                               u n s i g n e d l o n g i n t . Table 23.7 lists these macros and shows the maximum or
                                               minimum value of each; the formula used to compute each value is also given.
                                 <^fc>         Note that C99 provides three macros that describe the characteristics of the l o n g
                                               l o n g i n t types.

                        T a b le 2 3 .7                    N am e                        V a lu e              F o r m u la                D e s c r ip tio n
           I n te g e r M a c r o s in                                                              <-32767    - ( 2 ,5 - l )
                                                S H R T _ M IN                                                                  Minimum s h o r t i n t value
                < lim its .h >                  SH R T_M A X                                        >+32767         2 I5-1      Maximum s h o r t i n t value
                                                U SH R T_M A X                                       >65535         2 ,6 - l    Maximum u n s i g n e d
                                                                                                                                s h o r t i n t value
                                                IN T _ M IN                                         <-32767    - ( 2 ,3 - l )   Minimum i n t value
                                                IN T _ M A X                                        >4-32767        2 I5 -1     Maximum i n t value
                                                U IN T _ M A X                                       >65535         2 I6 -1     Maximum u n s i g n e d i n t
                                                                                                                                value
                                                L O N G _ M IN                             <-2147483647        - (2 31-1 )      Minimum l o n g i n t value
                                                LONG_M AX                                  >4-2147483647           23 ,- l      M aximum l o n g i n t value
                                                ULONG_M AX                                  >4294967295            232 - l      Maximum u n s i g n e d l o n g
                                                                                                                                i n t value
                                                L L O N G _ M IN 1          <-9223372036854775807              - ( 2 63 - ! )   Minimum l o n g l o n g i n t
                                                                                                                                value
                                                LLONG_M AX*                >+9223372036854775807                    26 3 - l    Maximum l o n g l o n g i n t
                                                                                                                                value
                                                ULLONG_M AX*                >18446744073709551615                   2 64 - !    Maximum u n s i g n e d l o n g
                                                                                                                                l o n g i n t value
                                                f
                                                    C 9 9 o n ly


                                                    The macros in < l i m i t s . h> are handy for checking whether a com piler sup­
                                               ports integers of a particular size. For example, to determ ine whether the i n t type
                                               can store numbers as large as 100,000, we might use the following preprocessing
                                               directives:
                                               # i f IN T _M A X < 1 0 0 0 0 0
                                               # e r r o r i n t ty p e i s to o               s m a ll
                                               # e n d if

         # e r r o r d ir e c tiv e > 7 4 .5   If the i n t type isn’t adequate, the # e r r o r directive will cause the preprocessor
                                               lo display an error message.
                                                            2 3 .3                                                                         5 9 3 onmlkjihgfedcbaZYXWVU
                                                                     T h e <ma t h . h > H e a d e r ( C 8 9 ): M a th e m a tic s hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                                                Going a step further, we might use the macros in < l i m i t s . h > to help a
                                         program cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                     choose how to represent a type. Let’s say that variables of type Q u a n ­
                                         t i t y must be able to hold integers as large as 100,000. If INT_MAX is at least
                                         100,000, we can define Q u a n t i t y to be i n t ; otherwise, w e’ll need to make it
                                         l o n g i n t :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                         #if INT_MAX >= 100000
                                         typedef int Quantity;
                                         #else
                                         typedef long int Quantity;
                                         #endif




                      2 3 .3             T h e < m a t h . h > H e a d e r (C 8 9 ): M a th e m a tic s

                                         The functions in the C89 version of < m a t h . h> fall into five groups:

                                               Tri ogonometric functions
                                               Hyperbolic functions
                                               Exponential and logarithm ic functions
                                               Power functions
                                               Nearest integoe r,7 absolute value, and rem ainder functions

                                         C99 adds a number of functions td these groups as well as introducing other cate­
                                         g ories of math functions. The C99 chan <
                                         o
                                                                                    gr-es to < m a t h .h > are so extensive that
                                         I’ve chosen to cover them in a separate section that follows this one. That way,
                                         readers who are prim arily interested in the C89 version of the header— or who are
                                         using a com piler that doesn’t support C99— w on’t be overwhelmed by all the C99
                                         additions.
                                               Before we delve into the functions provided by < m a t h . h>, let’s take a brief
                                         look at how these functions deal with errors.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         E rrors

                                         The < m a th . h > functions handle errors in a way th a fs different from other library
                                         functions. W hen an error occurs, most < m a t h . h> functions store an error code in
< e rrn o .h > h e a d e r> z * 2        a special variable named e r r n o (declared in the < e r r n o . h > header). In addi­
                                         tion,' when the return value ko**f a function w^o*uld be larger than the largest d o u b l e
                                         value, the functions in < m a t h . h> return a special value, represented by the macro
                                         HUGE_VAL (defined in < m a th .h > ) . HUGE_VAL is of type d o u b l e , but it isn’t
                                         necessarily an ordinary number. (The IEEE standard for floating-point arithmetic
                 in n n it y > 2 3 . 4   defines a value named “infinity”— a logical choice for HUGE_VAL.)
                                               The functions in < m a t h . h> detect two kinds oferrors:

                                             ■ D om ain error: An argument is outside a function’s domain. If a dom ain error
                                               occurs, the function’s return value is implementation-defined and EDOM
5 9 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 3   L ib r a r y S u p p o r t f o r N u m b e r s a n d C h a r a c te r D a ta


                                          (“dom ain error”) is stored in e r r n o . ln som e im plem entations of
                      NaN >23.4           < m a t h . h> , functions return a special value known as NaN (“ not a num ber”)
                          RQPONMLKJIHGFEDCBA

                                          when a domain error occurs.
                                       ■                  The return value of a function is outside the range of d o u b l e
                                           R a n g e error:
                                           values. If the return value's m agnitude is too large (overflow), the function
                                           retum s positive or negative HUGE_VAL, depending on the sign of the correct
                                           result. In addition, ERANGE (“range error”) is stored in e r r n o . If the return
                 underfiow>2s.4            value's m agnitude is too small to represent (underflow), the function retum s
                                           zero; some im plem entations may also store ERANGE in e r r n o .

                                          W e’ll ignore the possibility of error for the rem ainder o f this section. How­
                                     ever, the function descriptions in Appendix D explain the circum stances that lead
                                     to each type of error.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T r ig o n o m e tr ic F u n c t i o n s


                                       d o u b le    a c o s (d o u b le x );
                                       d o u b le    a s in (d o u b le x );
                                       d o u b le    a ta n (d o u b le x );
                                       d o u b le    a t a n 2 (d o u b le y ,        d o u b le x ) ;
                                       d o u b le    c o s (d o u b le x );
                                       d o u b le    s in (d o u b le x );
                                       d o u b le    ta n (d o u b le x );

                            cos      The c o s , s i n , and t a n functions com pute the cosine, sine, and tangent, respec-
                             s ‘n    tively. lf P I is defined to be 3 .1 4 1 5 9 2 6 5 , passing P I / 4 to c o s , s i n , and t a n
                            fo n
                                     produces the following results:

                                     c o s (P I/4 )        > 0.707107
                                     s in (P I/4 )         > 0.707107
                                     ta n (P l/4 )         > 1.0

                                     Note that arguments to c o s , s i n , and t a n are expressed in radians, not degrees,
                          aco s          a c o s , a s i n , and a t a n com pute the arc cosine, arc sine, and arc tangent:
                           asin
                          atan       a c o s ( 1 .0 )    => 0.0
                                     a s in ( 1 .0 )     => 1.5708
                                     a ta n ( 1 .0 )     => 0.785398

                                     Applying a c o s to a value returned by c o s w on’t necessarily yield the original
                                     argument to c o s , since a c o s always returns a value between 0 and 7i. a s i n and
                                     a t a n return a value between -7i/2 and 7i/2.
                         atan2             a t a n 2 com putes the arc tangent of y / x , where y is the function’s first argu­
                                     m ent and x is its second. T he return value of a t a n 2 is between -7i and K. The call
                                     a t a n ( x ) is e q u iv a le n tto a ta n 2 (x , 1 . 0 ) .
                              2 3 .3                                                                        595dcbaZYXWVUTS
                                        T h e <ma t h . h > H e a d e r (C 8 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONMLK


         H y p e r b o lic F u n c tio n s

          double cosh(double x);
          double sinh(double x);
          double tanh(double x);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

cosh     The c o s h , s i n h , and t a n h functions compute the hyperbolic cosine, sine, and
 sinh    tangent:
tanh
         cosh(0.5)         => 1.12763
         sinh(0.5)         => 0.521095
         tanh(0.5)         => 0.462117

         Arguments to c o s h , s i n h , and t a n h must be expressed in radians, not degrees.


         E x p o n e n tia l a n d L o g a r ith m ic F u n c tio n s

          double       exp(double x);
          double       frexp(double value, int *exp);
          double       ldexp(double x, int exp);
          double       log(double x);
          double       l o g l O (double x ) ;
          double       modf(double value, double *iptr),-

  exp                               e raised to a power:
         The e x p function returns cbaZYXWVUTSRQPONMLKJIHGFEDCBA

         exp(3.0)        => 20.0855

   log         l o g is the inverse of e x p — it computes the logarithm of a number to the base
log10    e. l o g l O computes the “com mon” (base 10) logarithm:

         log(20.0855)           => 3.0
         loglO (1000)           => 3.0

         Computing the logarithm to a base other than e or 10 isn’t difficult. The following
         function, for example, computes the logarithm of x to the base b, for arbitrary x
         and b:

         double log_base(double x, double b)

            return log(x) / log(b);


modf          The m o d f and f r e x p functions decompose a d o u b l e value into two parts,
         m o d f splits its first argument into integer and fractional parts. It retum s the frac­
         tional part and stores the integer part in the object pointed to by the second argu­
         ment:
596ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 2 3     L ib r a ry S u p p o r t fo r N u m b e rs a n d C h a r a c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     m o d f ( 3 .1 4 1 5 9 ,     & in t_ p a rt)       => 0 .1 4 1 5 9 ( in t_ p a r tis a s s ig n e d 3 .0 )

                                     Although i n t _ p a r t must have type d o u b l e , we can always cast it to i n t or
                                     l o n g i n t later.
                          frexp            The f r e x p function splits a floating-point number into a fractional p a rt/a n d
                                                     n in such a way that the original number equals f x 2", where either
                                     an exponent cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     0.5 < f < 1 o r / = 0. f r e x p re tu m s/a n d stores n m the (integer) object pointed to
                                     by the second argument:

                                     f r e x p ( 1 2 .0 , & exp)         => .75 (e x p is assigned 4)
                                     f r e x p ( 0 . 2 5 , & exp)        => 0 .5 ( e x p is a s s ig n e d - l)

                         ldexp            l d e x p undoes the work of f r e x p by combining a fraction and an exponent
                                     into a single number:

                                     l d e x p ( . 7 5 , 4)       => 12.0
                                     ld e x p ( 0 .5 , -1 )       => 0.25

                                    In general, the call l d e x p ( x , e x p ) returns x x 2 e x p .
                                         The m o d f, f r e x p , and l d e x p functions are primarily used by other func­
                                    tions in < m a t h . h>. They are rarely called directly by programs.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     P o w e r F u n c t io n s

                                       d o u b le p o w (d o u b le x , d o u b le y ) ;
                                       d o u b le s q r t ( d o u b l e x ) ;

                           pow      The pow function raises its first argument to the power specified by its second
                                    arogument:

                                    p o w ( 3 .0 , 2 .0 )         => 9.0
                                    p o w ( 3 .0 , 0 .5 )         => 1.73205
                                    p o w ( 3 .0 , - 3 .0 )       => 0.037037

                           sqrt            s q r t computes the square root:

                                     s q r t( 3 .0 )     => 1.73205

                                    Using s q r t to find square roots is preferable to calling pow, since s q r t is usu­
                                    ally a much faster function.


                                    N e a r e s t I n te g e r , A b s o lu te V a lu e , a n d R e m a in d e r F u n c tio n s

                                       d o u b le    c e il(d o u b le x );
                                       d o u b le    fa b s (d o u b le x ) ;
                                       d o u b le    f l o o r (d o u b le x ) ;
                                       d o u b le    fm o d (d o u b le x , d o u b le y ) ;
                                     2 3 .4      T h e <ma t h . h > H e a d e r (C 9 9 ): M a th e m a tic s hgfedcbaZYXWVUTSRQPONMLKJIHGFED
                                                                                                                      5 9 7 onmlkjihgfedcbaZYXWVUT


    ceil   T he c e i l ("ceiling”) function returns— as a d o u b l e value— the sm allest integer
  floor    that’s greater than or equal to its argument, f l o o r returns the largest integer that’s
           less than or equal to its argument:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           c e i l (7.1)                    8.0
           c e i l (7.9)                    8.0
           c e i l (-7.1)                  -7.0
           c e i l (-7.9)                  -7.0

           f l o o r (7.1)               7.0
           f l o o r (7.9)               7.0
           floor(-7.1)               => -8.0
           floor(-7.9)               => -8.0

           In other words, c e i l “rounds up” to the nearest integer, while f l o o r “rounds
           down.” C89 lacks a standard function that rounds lo the nearest integer, but we can
           easily use c e i l and f l o o r to write our own:

           double round_nearest(double x)

                return x < 0.0 ? ceil(x - 0.5)                                : floor(x + 0.5);


 <@ >      C99 provides several functions that round to the nearest integer, as w e’ll see in the
           next section.
  fa b s        f a b s com putes the absolute value o f a number:

           f a b s (7.1)                 7.1
           f a b s (-7.1)                7.1

 fm o d        fm o d returns the rem ainder when its first argum ent is divided by its second
           argum ent:

           f m o d (5.5, 2.2)

           C doesn’t allow the % operator to have floating-point operands, but fm o d is a
           m ore-than-adequate substitute.aZYXWVUTSRQPONMLKJIHGFEDCBA




2 3 .4     T h e < m a t h . h > H e a d e r (C 9 9 ): M a th e m a tic s

           The C99 version of the < m a t h . h> header includes the entire C89 version, plus a
           host of additional types, macros, and functions. The changes to this header are so
           numerous that I’ve chosen to cover them separately. There are several reasons why
           the standards com m ittee added so many capabilities to < m a t h . h>:RQPONMLKJIHGFEDCBA

            ■                                                                      C99 doesn’t
                 P r o v id e b e tte r s u p p o r t f o r th e I E E E f lo a ti n g - p o i n t s ta n d a r d .
                 mandate the use of the LEEE standard; other ways of representing floating-point
5 9 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 3     L ib r a r y S u p p o r t fo r N u m b e r s a n d C h a r a c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             numbers are permitted. However, it’s safe to say that the vast majority o f C pro­
                                             grams are executed on systems that support this standard.RQPONMLKJIHGFEDCBA
                                         ■ P ro v id e                                                Better control over
                                                         m o r e c o n tr o l o v e r f lo a t in g - p o in t a r ith m e tic .
                                             floating-point arithmetic may allow programs to achieve greater accuracy and
                                             speed.
                                         ■ M ake C m         o r e a t t r a c t i v e t o F o r t r a n p r o g r a m m e r s . T he addition of many math
                                             functions, along with enhancements elsewhere in C99 (such as support for
                                             complex numbers), was intended to increase C ’s appeal to program mers who
                                             might have used other programming languages (primarily Fortran) in the past.
                                           Another reason that Fve decided to cover C99's < m a t h . h > header in a sepa­
                                      rate section is that it’s not likely to be ofm uch interest to the average C programmer.
                                      Those using C for its traditional applications, which include systems programming
                                      and embedded systems, probably w on’t need the additional functions that C99 pro­
                                      vides. However, programmers developing engineering, mathem atics, or science
                                      applications may find these functions to bc quite useful.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      I E E E F lo a tin g -P o in t S ta n d a r d

                                      One motivation for the changes to the < m a th .h > header is better support for
                                      IEEE Standard 754, the most widely used representation for floating-point num­
                                      bers. The full title of the standard is “ IEEE Standard for Binary Floating-Point
                                      Arithmetic” (ANSI/IEEE Standard 754-1985). It’s also known as E C 60559,
                                      which is how the C99 standard refers to it.
                                           Section 7.2 described some of the basic properties of the IEEE standard. We
                                      saw that the standard provides two primary formats for floating-point numbers:
                                      single precision (32 bits) and double precision (64 bits). Numbers are stored in a
                                      form of scientific notation, with each number having three parts: a sign, an expo­
                                      nent, and a fraction. That limited knowledge o flh e IEEE standard is enough lo use
                                      the C89 version of < m a th .h > effectively. Understanding the C99 version, how­
                                      ever, requires knowing more about the standard. H ere’s some additional inform a­
                                      tion that w e’ll need:

                                                                      One of the bits in the lEEE representation of a float­
                                         ■ P o s i tiv e /n e g a tiv e z e ro .
                                             ing-point number represents the num ber’s sign. As a result, the num ber zero
                                             can be either positive or negative, depending on the value of this bit. The fact
                                             that zero has two representations may sometimes require us to treat it differ­
                                             ently from other floating-point numbers.
                                         ■ S u bn orm      a l n u m b e r s . When a floating-point operation is performed, the result
                                             may be too small to represent, a condition known as u n d e r f l o w . Think of what
                                             happens ify o u repeatedly divide a number using a hand calculator: eventually
                                             the result is zero, because it becomes too small to represent using the calcula­
                                             tor’s number representation. The E E E standard has a way to reduce the
                                             impact of this phenomenon. Ordinary floating-point numbers are stored in a
                                             “normalized” format, in which the number is scaled so that there’s exactly one
                                          2 3 .4                                                                         599onmlkjihgfedcbaZYXW
                                                   T h e <m a t h . h > H e a d e r ( C 9 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONMLKJIH


                           digit to the left o f the binary point. W hen a num ber gets small enough, how­
                           ever, it’s stored in a different format in which it’s not norm alized. T h e se ra /;- cbaZYXWVUTSRQPONM
                           n o rm a l n u m b e rs (also known as d e n o rm a lize d n u m b e rs or d e n o rm a ls) can
                           be much sm aller than norm alized numbers; the trade-off is that they get pro­
                           gressively less accurate as they get smaller.
                        ■ S p ecia l values. Each floating-point format allows the representation o fth re e
                          special values: p o sitive in fin ity , negative in fin ity, and N a N (“not a num ber”).
                          Dividing a positive num ber by zero produces positive infinity. Dividing a neg­
                          ative number by zero yields negative infinity. The result of a m athem atically
                          undefined operation, such as dividing zero by zero, is NaN. ^ t ’s m ore accurate
                          to say “the result is a NaN” rather than “the result is N a N ” because the TEEE
                          standard has m ultiple representations for NaN. The exponent part of a NaN
                          value is all 1 bits, but the fraction can be any nonzero sequence o fb its.) Spe­
                          cial values can be operands in subsequent operations. Infinity behaves ju st as
                          it does in ordinary mathem atics. For example, dividing a positive num ber by
                          positive infinity yields zero. (Note that an arithmetic expression could produce
                          infinity as an interm ediate result but have a noninfinite value overall.) Per­
                          forming any operation on NaN gives NaN as the result.
                        ■ R o u n d in g direction. When a number can’t be stored exactly using a floating­
                          point representation, the current ro u n d in g d irection (or ro u n d in g m ode)
                          determ ines which floating-point value will be selected to represent the num ­
                          ber. There are four rounding directions: (1) R o u n d tow ard nearest. Rounds to
                          the nearest representable value. If a num ber falls halfway between two values,
                          it is rounded to the “even” value (the one whose least significant bit is zero).
                          (2) R ou n d tow ard zero. (3) R ou n d tow ard p o sitive infinity. (4) R ou n d to w ard
                          negative infinity. The default rounding direction is round toward nearest.
                        ■ E xcep tio n s. There are five types offloating-point exceptions: overflow, u n d er­
                          flow , division by zero, invalid operation (the result of an arithmetic operation
                           was NaN), and inexact (the result of an arithmetic operation had to be
                           rounded). When one of these conditions is detected, we say that the exception
                           is raised. dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                       T ypes

                       C99 adds two types, f l o a t _ t and d o u b l e _ t , to < m a t h .h > . The f l o a t _ t
                       type is at least as “wide” as the f l o a t type (m eaning that it could be the f l o a t
                       type or any wider type, such as d o u b l e ) . Similarly, d o u b l e _ t is required to be
                       at least as wide as the d o u b l e type. (It must also be at least as wide as
                       f l o a t _ t . ) These types are provided for the program m er w ho’s trying to m axi­
                       mize the perform ance of floating-point arithmetic, f l o a t _ t should be the most
                       efficient floating-point type th at’s at least as wide as f l o a t ; d o u b l e _ t should
                       be the most efficient floating-point type that’s at least as wide as d o u b l e .
FLT_EVAL_METH0D>23.;         The f l o a t _ t and d o u b l e _ t types are related to the FLT_EVAL_METHOD
                       macro, as shown in Table 23.8.
600 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 2 3    L ib r a r y S u p p o r t fo r N u m b e rs a n d C h a r a c te r D a ta dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                  T a b le 2 3 .8                Value ofGFEDCBA                 Meaning of                       Meaning of
     R elationship betw een                 FLT_EVAL_METHOD                       float_t                         double_t
    FLT_EVAL_METHOD                                     0                 flo a t                          d o u b le
    and the f l o a t _ t and
                                                        1                 d o u b le                       d o u b le
        d o u b l e _ t Types
                                                        2                 lo n g d o u b le                lo n g d o u b le
                                                     O ther               Im plem entation-defined         Im plem entation-defined


                                    M acros
                                    C99 adds a number of macros to < m a t h . h>. I’ll mention just two of them at this
                                    point. IN F IN IT Y represents the f l o a t version ofpositive or unsigned infinity.
                                    (If the implementation doesn’t support infinity, then IN F IN IT Y represents a
                                    f l o a t value that overflows at compile lime.) The NAN macro represents the
                                    f l o a t version o f “not a number.” More specifically, it represents a “quiet” NaN
                                    (one that doesn’t raise an exception if used in an arithmetic expression). If quiet
                                    NaNs aren’t supported, the NAN macro w on’t be defined.
                                          T’ll cover the funclion-like macros in < m a t h .h > later in the section, along
                                    with ordinary functions. Macros that are relevant only to a specific function will be
                                    described with the function itself.

                                    E rrors
                                    For the most part, the C99 version of < m a t h . h> deals with errors in the same
                                    way as the C89 version. However, there are a few twists that w e’ll need to discuss.
                                           First, C99 provides several macros that give im plem entations a choice of how
                                    errors are signaled: via a value stored in e r r n o , via a floating-point exception, or
                                    both. The macros MATH_ERRNO and MATH_ERREXCEPT represent the integer
                                    constants 1 and 2, respectively. A third macro, m a t h _ _ e r r h a n d l i n g , represents
                                    an i n t expression whose value is either MATH_ERRNO, MATH_ERREXCEPT, or
                                    the bitwise OR of the two values. (It’s also possible that m a t h _ e r r h a n d l i n g
                                    isn’t really a macro; it might be an identifier with external linkage.) The value of
                                    m a t h _ e r r h a n d l i n g can’t be changed within a program.
                                           Now, let’s see what happens when a domain error occurs during a call of one
                                    of the functions in < m a th .h > . The C89 standard says that EDOM is stored in
                                    e r r n o . The C99 standard, on the other hand, states that if the expression
                                    m a t h _ e r r h a n d l i n g & MATH_ERRNO is nonzero (i.e., the MATH_ERRNO bit is
                                    set), then EDOM is stored in e r r n o . If the expression m a t h _ e r r h a n d l i n g &
                                                                                  invalid floating-point exception is raised.
                                    MATH_ERREXCEPT is nonzero, the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    Thus, either or both actions are possible, depending on the value of
                                    m a th _ e rrh a n d lin g .
                                           Finally, let’s turn to the actions that take place when a range error is detected
                                    during a function call. There are two cases, based on the magnitude of the func­
                                    tion’s return value.
                                         Overflow, If the magnitude is too large, the C89 standard requires the function
                                    to return positive or negative HUGE_VAL, depending on the sign of the correct
                              2 3 .4                                                                         601onmlkjihgfedcbaZYXWV
                                       T h e < m a t h . h > H e a d e r (C 9 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


result. In addition, ERANGE is stored in e r r n o . The C99 standard describes a
more com plicated set o fac tio n s when overflow occurs:
      ■ Ifd ef au lt rounding is in effect or ifth e return value is an “exact infinity” (such
          as l o g ( 0 . 0 ) ) , then the function returns either HUGE_VAL, HUGE_VALF, or
          HUGE_VALL, depending on the function’s return type. (HUGE_VALF and
          HUGE_VALL— the f l o a t and l o n g d o u b l e versions of HUGE_VAL— are
          new in C99. Like HUGE_VAL, they may represent posiLive infinity.) T he value
          returned has the sign o f the correct result.
  ■             If the value o f m a t h _ e r r h a n d l i n g & MATH_ERRNO is nonzero, ERANGE
                is stored in e r r n o .
          ■     If the value o f m a t h _ e r r h a n d l i n g & MATH_ERREXCEPT is nonzero, the cbaZYXWVUTSRQPONM
                divide-by~zero floating-point exception is raised if the m athem atical result is
                an exact infinity. Otherwise, the overflo w exception is raised.

     U nderflo w . If the m agnitude is too small to represent, the C89 standard
requires the function to return zero; som e im plem entations may also store
ERANGE in e r r n o . The C99 standard prescribes a som ewhat different set of
actions:
          ■ The f unction returns a value whose m agnitude is less than or equal to the
             sm allest norm alized positive num ber belonging to the function’s return type.
             (This value m ight be zero or a subnorm al number.)
              ■ If the v alue o f m a t h _ e r r h a n d l i n g & MATH_ERRNO is nonzero, an im ple­
                  m entation may store ERANGE in e r r n o .
      ■         If the value o f m a t h _ e r r h a n d l i n g & MATH_ERREXCEPT is nonzero, an
                im plem entation may raise the unde>flow floating-point exception.
Notice the word “m ay” in the latter two cases. For reasons ofefficiency, an im ple­
mentation is not required to modify e r r n o or raise the und erflo w exception.dcbaZYXWVUTSRQPONMLKJIHG


F u n c tio n s
W e're now ready to tackle the functions that C99 adds to < m a t h . h > . Fll present the
functions in groups, using the same categories as the C99 standard. These categories
differ som ewhat from the ones in Section 23.3, which cam e from the C89 standard.
      One o fth e biKg^<g^-est chang*^es in the C99 version o f < m a t h .h > is the addition
of two m ore versions of most functions. In C89, there's only a single version of
each math function; typically, it takes at least one argum ent of type d o u b l e and/
or returns a d o u b l e value. In C99, however, there are two additional versions:
one for f l o a t and one for l o n g d o u b l e . The names o f these functions are
identical to the nam e of the original function except for the addition o f an f or 1
suffix. For exam ple, the original s q r t function, which takes the square root o f a
d o u b l e value, is n o w jo in e d by s q r t f (the f l o a t version) and s q r t l (the
l o n g d o u b l e version). Fll list the prototypes for the new versions (in italics, as
is my custom for functions that are new in C99). 1 w on’t describe the functions
further, though, since they’re virtually identical to their C89 counterparts.
            C h a p te r 2 3
6 0 2 ZYXWVUTSRQPONMLKJIHGFEDCBAL ib r a r y S u p p o r t fo r N u m b e r s a n d C h a r a c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            The C99 version o f < m a t h .h > also includes a num ber of com pletely new
                                      functions (and function-like macros). I’ll give a brief description o fea ch one. As in
                                      Section 23.3, I w on’t discuss error conditions for these functions, but Appendix
                                      D— which lists all standard library functions in alphabetical order— provides this
                                      information. 1 w on’t list the names of all the new functions in the left margu^in:
                                      instead, I’ll show ju st the name of the primary function. For exam ple, there are
                                      three new functions that com pute the arc hyperbolic cosine: a c o s h , a c o s h f , and
                                      a c o s h l . I ’ll describe a c o s h and display only its name in the left margin.
                                            Keep in mind that many of the new functions are highly specialized. As a
                                      result, the descriptions o f these functions may seem sketchy. A discussion of what
                                      these functions are used for is outside the scope of this book.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      C la s s if ic a t io n M a c r o s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        in t    fp c la s s ify (r e a l-flo a tin g x ) ;
                                        in t    is fin ite (r e a l-J lo a lin g x ) ;
                                        in t    is in f(r e a l-flo a tin g x ) ;
                                        in t    is n a n ( r e a l - f l o a ti n g x ) ;
                                        in t    i s n o r m a l (real-floating x ) ;
                                        in t    s i g n b i t (real-floating x ) ;

                                      Our first category consists of function-like macros that are used to determine
                                      whether a floating-point value is a ‘*normal” num ber or a special value such as
                                      infinity or NaN. The macros in this group are designed to accept argum ents of any
                                      real floating type ( f l o a t , d o u b l e , or l o n g d o u b l e ) .
                    fp cla ssify            The f p c l a s s i f y m acro classifies its argument, returning the value o fo n e
                                      o fth e number-classification macros shown in Table 23.9. An im plem entation may
                                      support other classifications by defining additional macros whose names begin
                                      with F P _ a n d an upper-case letter.

                   T a b le 2 3 .9                     N am e                                            M e a n i n g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
     Number-Classification            FP_INFINITE                           Infinity (positive or negative)
                  Macros RQPONMLKJIHGFEDCBA
                                      FP_NAN                                Not a number
                                               FP_NORMAL                    Normal (not zero, subnorm al, infinite, or NaN)
                                               FP_SUBNORMAL                 Subnormal
                                               FP_ZERO                      Zero (positive or negative)

                       isfinite           The i s f i n i t e macro returns a nonzero value if its argument has a finite
                          isinf      value (zero, subnormal, or normal, but not infinite or NaN). i s i n f returns a non­
                        isnan
                                     zero value if its argum ent has the value infinity (positive or negative), i s n a n
                     isnorm al
                                     returns a nonzero value if its argum ent is a NaN value, i s n o r m a l retum s a non­
                                     zero value if its argum ent has a normal value (not zero, subnorm al, infinite, or
                                     NaN).
                        signbit           The last classification macro is a bit different from the others, s i g n b i t
                                     returns a nonzero value if the sign of its argument is negative. The argument need
                                     not be a finite number; s i g n b i t also works for infinity and NaN.
                      2 3 .4     T h e <ma t h . h > H e a d e r (C 9 9 ): M a th e m a tic s hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                      6 0 3 dcbaZYXWVUTSRQPO


T r ig o n o m e tr ic F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

  flo a t a c o s f(flo a t x );                                                             see onmlkjihgfedcbaZYXWVUTSRQPONMLK
                                                                                                  acos
  lo n g d o u b le a c o s l ( l o n g        d o u b le x ) ;                              see a c o s

  flo a t a s in f(flo a t x );                                                              see a s i n
  lo n g d o u b le a s i n l ( l o n g        d o u b le x ) ;                              see a s i n

  flo a t a ta n f(flo a t x );                                                              see a t a n
  lo n g d o u b le a t a n l ( l o n g        d o u b le x ) ;                              see a t a n

  flo a t a ta n 2 f(flo a t y , flo a t x );                                              see a t a n 2
  lo n g d o u b le a ta n 2 1 ( lo n g d o u b le y ,
                                 lo n g d o u b le x ) ;                                   see a t a n 2

  flo a t c o s f (flo a t x) ;                                                               see c o s
  lo n g d o u b le c o s l ( l o n g        d o u b le    x );                               seecos

  flo a t s in f(flo a t x );                                                                 s e e s in
  lo n g d o u b le s i n l ( l o n g        d o u b le    x );                               s e e s in

  flo a t ta n f(flo a t x );                                                                 s e e ta n
  lo n g d o u b le t a n l ( l o n g        d o u b le    x );                               s e e ta n

The only new trigonometric functions in C99 are analogs of C89 functions. For
descriptions, see the corresponding functions in Section 23.3.


H y p e r b o lic F u n c t io n s

  d o u b le a c o s h (d o u b le x ) ;
  flo a t a c o s h f(flo a t x );
  lo n g d o u b le a c o s h l( lo n g          d o u b le x ) ;

  d o u b le a s in h ( d o u b le x ) ;
  flo a t a s in h f(flo a t x );
  lo n g d o u b le a s i n h l ( l o n g        d o u b le x ) ;

  d o u b le a ta n h ( d o u b le x ) ;
  flo a t a ta n h f(flo a t x );
  lo n g d o u b le a ta n h l ( l o n g         d o u b le x ) ;

  flo a t c o s h f(flo a t x );                                                             see c o s h
  lo n g d o u b le c o s h l( l o n g         d o u b le x ) ;                              see c o s h

  flo a t s in h f(flo a t x );                                                              see s i n h
  lo n g d o u b le s i n h l ( l o n g        d o u b le x ) ;                              see s i n h

  flo a t ta n h f(flo a t x ) ;                                                             see t a n h
  lo n g d o u b le t a n h l (lo n g d o u b le x ) ;                                       see t a n h
604 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 3    L ib r a r y S u p p o r t f o r N u m b e r s a n d C h a r a c te r D a ta


                        acosh       Six functions in this group correspond to the C89 functions c o s h , s i n h , and
                         a s in h   t a n h . The new functions are a c o s h , which computes the arc hyperbolic cosine;
                        a ta n h
                                    a s i n h , which computes the arc hyperbolic sine; and a t a n h , which computes the
                                    arc hyperbolic tangent.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    E x p o n e n tia l a n d L o g a r ith m ic F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       flo a t e x p f(flo a t x );                                                                   exp
                                                                                                                                  seekjihgfedcbaZYXWVUTS
                                       lo n g d o u b le e x p l( l o n g          d o u b le x ) ;                               see exp
                                       d o u b le e x p 2 (d o u b le x ) ;
                                       flo a t e x p 2 f(flo a t x ) ;
                                       l o n g d o u b l e e x p 2 1 ( l o n g d o u b l e x ) ; PONMLKJIHGFEDCBA

                                       d o u b le e x p m l (d o u b le x ) ;
                                       flo a t e x p m lf(flo a t x );
                                       lo n g d o u b le e x p m ll( lo n g d o u b le x ) ;

                                       f l o a t f r e x p f ( f l o a t v a lu e , i n t * e x p );                           see frexp
                                       lo n g d o u b le f r e x p l (lo n g d o u b le v a lu e ,
                                                                         in t * e x p );                                       see frexp
                                       in t    ilo g b (d o u b le x ) ;
                                       in t    ilo g b f(flo a t x );
                                       in t    i l o g b l ( l o n g d o u b le x ) ;

                                       flo a t ld e x p f( flo a t x , in t e x p );                                           see ldexp
                                       lo n g d o u b le l d e x p l ( l o n g d o u b le x ,                in t   e x p );   s e e l& e x p

                                       f l o a t 1 o g f (f l o a t x ) ;                                                         see log
                                       lo n g d o u b le l o g l ( l o n g         d o u b le x ) ;                               see log
                                       flo a t lo g lO f(flo a t x );                                                          see loglO
                                       lo n g d o u b le lo g l0 1 ( lo n g            d o u b le x ) ;                        see loglO
                                       d o u b le lo g lp ( d o u b le x ) ;
                                       flo a t lo g lp f(flo a t x ) ;
                                       lo n g d o u b le l o g l p l (lo n g d o u b le x ) ;

                                      d o u b le lo g 2 (d o u b le x ) ;
                                      flo a t lo g 2 f(flo a t x );
                                      lo n g d o u b le l o g 2 1 (lo n g d o u b le x ) ;

                                       d o u b le lo g b ( d o u b le x ) ;
                                       flo a t lo g b f(flo a t x );
                                       lo n g d o u b le l o g b l ( l o n g         d o u b le x ) ;

                                       f l o a t m o d ff( flo a t v a lu e , f l o a t * ip tr ) ;                             see modf
                                       lo n g d o u b le m o d fl( lo n g d o u b le v a lu e ,
                                                                   lo n g d o u b le * i p t r ) ;                              see modf
                                 2 3 .4                                                                        605
                                           T h e <ma t h . h > H e a d e r (C 9 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONM



              d o u b le s c a lb n ( d o u b le x , i n t n ) ;
              flo a t s c a lb n f( flo a t x , in t n );
              lo n g d o u b le s c a lb n l (lo n g d o u b le x , i n t n) ;
              d o u b le s c a lb ln ( d o u b le x , lo n g i n t n ) ;
              f l o a t s c a l b l n f ( f l o a t x t lo n g i n t n ) ;
              lo n g d o u b le s c a l b l n l ( l o n g d o u b le x f lo n g i n t                n ) ; onmlkjihgfedcbaZYXWVUTSRQPON

   exp2       In additional to new versions o f e x p , f r e x p , l d e x p , l o g , l o g l 0 , and m o d f,
e x p m 1 aZYXWVUTSRQPONMLKJIHGFEDCBA
              there are several entirely new functions in this category. Two of these, e x p 2 and
                 e x p m l, are variations on the e x p function. When applied to the argument x, the
    Q&A          e x p 2 function returns 2 X, and e x p m l returns e* - l .
     lo g b             The l o g b function returns the exponent o fits argument. More precisely, the
    ilo g b      call l o g b ( x ) returns log/lxl), where r is the radix of floating-point arithmetic
   lo g 1 p
                 (defined by the macro FLT_RADIX, which typically has the value 2). The i l o g b
     lo g 2
                 function returns the value of l o g b after il has been cast to i n t type. The l o g l p
                 function returns ln(l + x ) when given x as its argument. The l o g 2 function com ­
                 putes the base-2 logarithm of its argument.
 s c a lb n             The s c a l b n function returns x x FLT_RADIX n , which it com putes in an
s c a lb ln cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                 efficient way (not by explicitly raising FLT__RADIX to the nth power), s c a l b l n
                 is the same as s c a l b n , except that its second parameter has type l o n g i n t
                 instead of i n t .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


            P o w e r a n d A b s o l u t e V a lu e F u n c ti o n s

              d o u b le c b r t( d o u b le x ) ;
              flo a t c b r tf(flo a t x );
              lo n g d o u b le c b r t l ( l o n g d o u b le x ) ;

              flo a t fa b s f(flo a t x );                                                             s e e fa b s
              lo n g d o u b le f a b s l ( l o n g      d o u b le x ) ;                               .v e e f a b s

              d o u b le h y p o t (d o u b le x , d o u b le y ) ;
              flo a t h y p o tf(flo a t x, flo a t y );
              lo n g d o u b le h y p o t l ( l o n g d o u b le x t lo n g             d o u b le     y );

              flo a t p o w f(flo a t x , flo a t y );                                                    see pow
              lo n g d o u b le p o w l( lo n g d o u b le x ,
                                         lo n g d o u b le y ) ;                                          see pow

              flo a t s q r tf(flo a t x );                                                             see s q r t
              lo n g d o u b le s q r t l (lo n g d o u b le x ) ;                                      see s q r t

            Several functions in this group are new versions of old ones ( f a b s , pow, and
            s q r t ) . Only the functions c b r t and h y p o t (and their variants) are entirely new.
   c b rt         The c b r t function computes the cube root of its argument. The pow function
            can also be used for this purpose, but pow is unable to handle negative arguments
6 0 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 3    L ib ra ry S u p p o r t fo r N u m b e rs a n d C h a ra c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    (a domain error occurs), c b r t , on the other hand, is defined for both positive and
                                    negative arguments. When its argument is negative, c b r t returns a negative result.cbaZYXWVU
                         hypot           When applied to arguments x and y, the h y p o t function returns 7 x 2 + y 2 . In
                                    other words, this function computes the hypotenuse of a right triangle with legs x
                                    and y.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    E r r o r a n d G a m m a F u n c t io n s

                                      d o u b le e r f ( d o u b l e x ) ;
                                      f l o a t e r f f (f l o a t x ) ;
                                      lo n g d o u b le e r f l (lo n g d o u b le               x );

                                      d o u b le e r fc ( d o u b le x ) ;
                                      flo a t e r fc f( flo a t x );
                                      lo n g d o u b le e r f c l (lo n g d o u b le x ) ;

                                      d o u b le lg a m m a (d o u b le x ) ;
                                      f l o a t lg a m m a f( f l o a t x ) ;
                                      lo n g d o u b le lg a m m a l(lo n g d o u b le x ) ;

                                      d o u b le tg a m m a (d o u b le x ) ;
                                      f l o a t tg a m m a f(flo a t x ) ;
                                      lo n g d o u b le tg a m m a l(lo n g d o u b le x ) ;

                            erf     The e r f function computes the error fu n c tio n erf (also known as the G aussian
                           erfc     error fu n c tio n ), which is used in probability, statistics and partial differential
                                    equations. The mathematical definition o fe rfis

                                                                             crf(.v) = ^ p f e 1 di
                                                                                       vrc J o
                                    e r f c computes the co m p lem en ta ry error fu n c tio n , erfc(.r) = 1 - erf(.t).
                     lgam m a             The g a m m a fu n c tio n V is an extension of the factorial function that can be
                     tgam m a       applied to real numbers as weII as to integers. When applied to an integer n, T(n) =
                         Q&A        (z?-l)!: the definition of T for nonintegers is more complicated. The tg am m a func­
                                    tion computes T. The lg am m a function computes ln(IF(x)l), the natural logarithm
                                    of the absolute value o fth e gamma function, lg am m a can sometimes be more use­
                                    ful than the gamma function itself, because T grows so quickly that using it in cal­
                                    culations may cause overflow.aZYXWVUTSRQPONMLKJIHGFEDCBA

                                    N e a r e s t I n te g e r F u n c t io n s

                                      flo a t c e ilf( flo a t x );                                                                       ceil
                                                                                                                                     see kjihgfedcbaZYXWVUTSR
                                      lo n g d o u b le c e i l l (lo n g d o u b le x ) ;                                           see ceil

                                      flo a t flo o r f( flo a t x );                                                              see floor
                                      lo n g d o u b le f l o o r l ( l o n g          d o u b le x ) ;                            see floor
                                 2 3 .4                                                                       607PONMLKJIHGFEDCB
                                          T h e <ma t h . h > H e a d e r (C 9 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONMLKJI



               double nearbyint (double x) ;
               float nearbyintf(float x);
               long double nearbyintl(long double x);
               double rint (double x ) ;
               float rintf(float x);
               long double rintl(long double x ) ;
               long     int lrint(double x);
               long     int lrintf(float x);
               long     int lrintl(long double x);
               long     long int llrint(double x);
               long     long int llrintf(float x);
               long     long int llrintl(long double x ) ;
               double round(double x);
               float roundf(float x);
               long double roundl(long double x ) ;
               long int lround(double x);
               long int lroundf(float x);
               long int lroundl(long double x);
               long long int llround(double x);
               long long int llroundf(float x);
               long long int llroundl (long double x ) ;
               double trunc(double x);
               float truncf(float x);
               long double truncl(long double x);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

              Besides additional versions of c e i l and f l o o r . C99 has a number of new func­
              tions that convert a floating-point value to the nearest integer. Be careful when
              using these functions: although all of them return an integer, some functions
              return it in floating-point format (as a f l o a t , d o u b l e , or l o n g d o u b l e
              value) and some retum it in integer format (as a l o n g i n t or l o n g l o n g i n t
              value).cbaZYXWVUTSRQPONMLKJIHGFEDCBA
nearbyint          The n e a r b y i n t function rounds its argument to an integer, returning it as a
     rirrt    floating-point number, n e a r b y i n t uses the current rounding direction and does
              not raise the inexact floating-point exception, r i n t is the same as n e a r b y i n t ,
              except that it may raise the inexact floating-point exception if the result has a dif­
              ferent value than the argument.
      Irint        The l r i n t function rounds its ar^g?ument to the nearest inte^ger,7 accordingc^ to
     llrint   [he current rounding direction, l r i n t returns a l o n g i n t value, l l r i n t is the
              same as l r i n t , except that it returns a l o n g l o n g i n t value.
   round           The r o u n d function rounds its argument to the nearest integer value, return­
              ing it as a floating-point number, r o u n d always rounds away from zero (so 3.5 is
              rounded to 4.0, for example).
            C h a p te r 2 3
6 0 8 ZYXWVUTSRQPONMLKJIHGFEDCBAL ib r a r y S u p p o r t fo r N u m b e rs a n d C h a r a c te r D a ta cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                         lround onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                              The l r o u n d function rounds its ar^g*ument to the nearest intefgcr*er value, return-
                        llround jn g it a s a l o n g i n t value. Like r o u n d , it rounds away from zero, l l r o u n d is
                                     the same as l r o u n d , except that it returns a l o n g l o n g i n t value.
                           trunc              The t r u n c function rounds its ar^g*ument to the nearest intecg^er not larC    g^er in
                                     maO    gnitud'e. (In other words, it truncates thec?argument toward ze/ro.) t r u n c retums
                                     the result as a floating-point number.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     R e m a in d e r F u n c tio n s

                                       flo a t fm o d f(flo a t x f flo a t y );                                                      s e e fm o d
                                       lo n g d o u b le fm o d l(lo n g d o u b le x ,
                                                                   lo n g d o u b le y ) ;                                             s e e tv a o d

                                       d o u b le r e m a in d e r (d o u b le x , d o u b le y ) ;
                                       flo a t r e m a in d e r f(flo a t x , flo a t y );
                                       lo n g d o u b le r e m a in d e r l( lo n g d o u b le x ,
                                                                              lo n g d o u b le y ) ;

                                       d o u b le r e m q u o (d o u b le x , d o u b le y , i n t * q u o );
                                       f l o a t r e m q u o f( flo a t x , f l o a t y , i n t * q u o );
                                       lo n g d o u b le r e m q u o l(lo n g d o u b le x , lo n g d o u b le y ,
                                                                         i n t * q u o );

                                     Besides additional versions of fm od, this category includes new remainder func­
                                     tions named r e m a i n d e r and re m q u o .
                   remainder              The r e m a i n d e r function returns x REM y, where REM is a function defined
                                     in the IEEE standard. For y ^ 0, the value o f x REM y is r = x - ny, where n is the
                                     integer nearest the exact value o f x / y . (If x / y is halfway between two integers, n
                                     is even.) If r = 0, it has the same sign as x.
                      rem quo             The re m q u o function returns the same value as r e m a i n d e r when given the
                                     same first two arguments. In addition, re m q u o modifies the object pointed to by
                                     the q u o parameter so that it contains n low-order bits of the integer quotient lx/yl,
                                     where n depends on the implementation but must be at least three. The value stored
                                     in this object will be negative if x / y < 0.

                                     M a n ip u la t io n F u n c tio n s

                                       d o u b le c o p y s ig n ( d o u b le x , d o u b le y ) ;
                                       flo a t c o p y s ig n f(flo a t x , flo a t y );
                                       lo n g d o u b le c o p y s ig n l (lo n g d o u b le x ,                    lo n g d o u b le y ) ;

                                       d o u b le n a n ( c o n s t c h a r * ta g p );
                                       f l o a t n a n f( c o n s t c h a r * ta g p );
                                       lo n g d o u b le n a n l (c o n s t c h a r * ta g p ) ;

                                       d o u b le n e x t a f t e r ( d o u b l e x , d o u b le y ) ;
                                       flo a t n e x ta fte r f(flo a t x, flo a t y );
                                                      2 3 .4                                                                        609
                                                                T h e <ma t h . h > H e a d e r (C 9 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDC



                              lo n g     d o u b le     n e x t a f t e r l (lo n g       d o u b le     x,     lo n g     d o u b le y ) ;

                              d o u b le n e x tto w a r d ( d o u b le x , lo n g d o u b le y ) ;
                              f l o a t n e x t t o w a r d f ( f l o a t x , lo n g d o u b le y ) ;
                              lo n g d o u b le n e x tto w a r d l( lo n g d o u b le x ,
                                                                          l o n g d o u b l e y ) ; onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     The mysteriously named “manipulation functions” are all new in C99. They pro­
                                     vide access to the low-level details of floating-point numbers.
               c o p y s ig n               The c o p y s i g n function copies the sign of one number to another number.
                                     The call c o p y s i g n ( x , y ) returns a value with the magnitude o f x and the sign
                                     o fy .
                                            The n a n function converts a string to a NaN value. The call n a n ( "n-char-
                          n a n dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     se q u e n c e ") is equivalent to s t r t o d ( " N P ^ ( n - c h a r - s e q u e n c e ) " , ( c h a r * * )
                                     NU LL). (Scc the discussion of s t r t o d for a description of the format of n-char-
a L x L u d fu n c tio n RQPONMLKJIHGFEDCBA
                         > ~ 2 d .2


                                     sequence.) The call n a n (" ") is equivalent to s t r t o d ( "NAN() " , ( c h a r * * )
                                     NULL). If the argument in a call of n a n doesn’t have the value "n-char~
                                     sequence" or " " , thecall is equivalent to s t r t o d ( "NAN" , ( c h a r * * ) N U L L ).
                                     If quiet NaNs aren’t supported, n a n returns zero. Calls of n a n f and n a n l are
                                     equivalent to calls of s t r t o f and s t r t o l d . respectively. This function is used
                                     to construct a NaN value containing a specific binary pattern. (Recall from earlier
                                     in this section that the fraction part of a NaN value is arbitrary.)
                                            The n e x t a f t e r function determ ines the next representable value o f a num­
               n e x ta ft e r aZYXWVUTSRQPONMLKJIHGFEDCBA
                                     ber x (if all values o f x ’s type were listed in order, the number that would come
                                     just before o rju st after x). The value o f y determ ines the direction: if y < x , then
                                     the function retums the valuejust before x; i f x < y it returns the val.uejust after x.
                        Q&A          If x and y are equal, n e x t a f t e r retum s y.
                                            The n e x t t o w a r d function is the same as n e x t a f t e r . except that the y
           n e x tto w a rd cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     parameter has type l o n g d o u b l e instead of d o u b l e . Lf x and y are equal,
                                     n e x t t o w a r d returns y converted to the function’s return type. The advantage of
                                     n e x t t o w a r d is that a value of any (real) floating type can be passed as the second
                                     argument without the danger of it being incorrectly converted to a narrower type.

                            M a x im u m , M in im u m , a n d P o s itiv e D iffe r e n c e F u n c tio n s

                              d o u b le fd im ( d o u b le x , d o u b le y ) ;
                              flo a t fd im f(flo a t x f flo a t y );
                              lo n g d o u b le f d i m l (lo n g d o u b le x ,                     lo n g     d o u b le y ) ;

                              d o u b le fm a x (d o u b le x f d o u b le y ) ;
                              flo a t fm a x f(flo a t x, flo a t y );
                              lo n g d o u b le f m a x l (lo n g d o u b le x ,                     lo n g     d o u b le y ) ;

                              d o u b le fm in ( d o u b le x , d o u b le y ) ;
                              flo a t fm in f(flo a t x, flo a t y );
                              lo n g d o u b le f m i n l (lo n g d o u b le x r                     lo n g     d o u b le     y );
6 1 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 3   L ib r a r y S u p p o r t fo r N u m b e rs a n d C h a r a c te r D a ta cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                           fdim     The f d im function computes the positive difference o f x and y:

                                             x - y      ifx > y
                                             +0         ifx < y

                          fm ax          The fm a x function returns the larger of its two arguments, f m i n returns the
                           fmin      value of the sm aller ar^gJument.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                     F lo a t in g M u ltip I y -A d d


                                       d o u b le fm a (d o u b le x , d o u b le y , d o u b le z ) ;
                                       flo a t fm a f(flo a t x , flo a t y , flo a t z );
                                       lo n g d o u b le fm a l ( lo n g d o u b le x t lo n g d o u b le y ,
                                                                  lo n g d o u b le z ) ;

                           fma      The fm a function multiplies its first two arguments, then adds the third argument.
                                    In other words, we could replace the statementkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     a = b * c + d;

                                     with

                                     a = fma(b, c , d);

                                    This function was added to C99 because some newer CPUs have a “fused multi-
                                    ply-add” instruction that both multiplies and adds. Calling fm a tells the compiler
                                    to use this instruction (ifavailable), which can be faster than perform ing separate
                                    multiply and add instructions. Moreover, the fused multiply-add instruction per­
                                    forms only one rounding operation, not two, so it may produce a more accurate
                                    result. It's particularly useful for algorithms that perform a series of multiplications
                                    and additions, such as the algorithms for finding the dot product o ftw o vectors or
                                    multiplying two matrices.
                                         To determine whether calling the fm a function is a good idea, a C99 program
                                    can test whether the FP_FAST_FMA macro is defined. If it is, then calling fm a
                                    should be faster than— or at least as fast as— performing separate multiply and add
                                    operations. The FP_FAST_FMAF and FP_FAST_FMAL macros play the same
                                    ro lefo r the f m a f and f m a l functions, respectively.
                                         Performing a combined multiply and add is an example o fw h a t the C99 stan­
                                    dard calls “contraction,’’ where two or more mathematical operations are combined
                                    and performed as a single operation. As we saw with the fm a function, contraction
                                    often leads to better speed and greater accuracy. However, programmers may wish
                                    to control whether contraction is done automatically (as opposed to calls of fm a,
                                    which are explicit requests for contraction), since contraction can lead to slightly
                                    different results. In extreme cases, contraction can avoid a float-point exception
                                    that would otherwise be raised.
                                                                  2 3 .4                                                                              611hgfedcbaZYXWVUT
                                                                                  T he < m at h . h > H e a d e r (C 9 9 ): M a th e m a tic s kjihgfedcbaZYXWVUTSRQPONMLKJ


                                        C99 provides a pragma named FP_CONTRACT that gives the program m er
# p r a g m a d ir e c tiv e > 1 4 .5 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    control over contraction. H ere’s how the pragm a is used:

                                    #pragma STDC FP_CONTRACT PONMLKJIHGFEDCBA
                                                             on-off-switch

                                                   on-off-sw itch is either ON, OFF, or DEFAULT. If ON is selected, the
                                    The value of cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    compiler is allowed to contract expressions; ifO F F is selected, the com piler is pro­
                                    hibited from contracting expressions. DEFAULT is useful for restoring the default
                                    setting (which may be either ON or OFF). Tf the pragm a is used at the outer level of
                                    a program (outside any function definitions), it rem ains in effect until a subsequent
                                    FP_CONTRACT pragma appears in the same file, or until the file ends. If the
                                    pragma is used inside a compound statement (including the body of a function), it
                                    must appear first, before any declarations or statements; it remains in effect until
                                    the end of the statement, unless overridden by another pragma. A program may
                                    still call fm a to perform an explicit contraction even when FP_CONTRACT has
                                    been used to prohibit automatic contraction of expressions.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    C o m p a r is o n M a c r o s

                                      in t       i s g r e a t e r ( r e a l ~ J l o a t i n g x , real-floating y ) ;
                                      in t       i s g r e a t e r e q u a l (real-floating x , real-floating y ) ;
                                      in t       i s l e s s ( r e a l - J l o a t i n g x z real-floating y ) ;
                                      in t       i s l e s s e q u a l (real-floating x , real-floating y ) ;
                                      in t       i s l e s s g r e a t e r ( r e a l - f l o a t i n g x , real-floating y ) ;
                                      in t       i s u n o r d e r e d ( r e a l - f l o a t i n g x , real-floating y ) ;

                                    Our final category consists of function-likc macros that compare two numbers.
                                    These macros are designed to accept arguments of any real floating type.
                                           The comparison macros exist because o f a problem that can arise when float­
                                    ing-point numbers are compared using the ordinary relational operators such as <
                                    and >. If either operand (or both) is a NaN, such a comparison may cause the
                                    invalid floating-point exception to be raised, because NaN values— unlike other
                                    floating-point values— are considered to be unordered. The com parison macros
                                    can be used to avoid this exception. These macros are said to be “quiet" versions of
                                    the relational operators because they do th eirjo b without raising an exception.
            isgreater                      The i s g r e a t e r , i s g r e a t e r e q u a l , i s l e s s , and i s l e s s e q u a l mac­
      isgreaterequal                ros perform the same operation as the >, >=, <, and <= operators, respectively,
               isless               except that they don’t cause the invalid floating-point exception to be raised when
         islesseq u a l
                                    the aroguments are unordered,
         islessgreater                     T h e c a ll i s l e s s g r e a t e r ( x , y ) ise q u iv a le n tto (x) < (y ) | | (x ) >
                                     ( y ) , except that it guarantees not to evaluate x and y twice, and— like the previ­
                                    ous macros— doesn’t cause the invalid floating-point exception to be raised when
                                    x and y are unordered.
          isunordered                      The i s u n o r d e r e d macro returns I if its arguments are unordered (at least
                                    one of them is a NaN) and 0 otherwise.
6 1 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 3   L ib r a r y S u p p o r t f o r N u m b e r s a n d C h a r a c te r D a ta aZYXWVUTSRQPONMLKJIHGFEDCBA




                         2 3 .5            T h e < c t y p e . h > H e a d e r : C h a r a c t e r H a n d lin g onmlkjihgfedcbaZYXWVUTS

                                           The < c t y p e .h > header provides two kinds of functions: character-classification
                                           functions (like i s d i g i t , which tests whether a character is a digit) and character
                                           case-mapping functions (like t o u p p e r , which converts a lower-case letter to
                                           tipper case).
                                                 Although C doesnU require that we use the functions in < c t y p e . h> to test
                                           characters and perform case conversions, it’s a good idea to do so. First, these
                                           functions have been optimized for speed (in fact, many are implemented as mac­
                                           ros). Second, we’ll end up with a more portable program, since these functions
                                           work with any character set. Third, the < c t y p e .h > functions adjust their behav-
                   io c a ie s > 2 5 . /   ioi* when the locale is changed, which helps us write programs that run properly in
                                           different parts of the world.
                                                 The functions in < c t y p e . h > all take i n t arguments and return i n t val­
                                           ues. hi many cases, the argument is already stored in an i n t variable (often as a
                                           result of having been read by a call of f g e t c , g e t c , or g e t c h a r ) . If the argu­
                                           ment has c h a r type, however, we need to be careful. C can automatically con­
                                           vert a c h a r argument to i n t type; if c h a r is an unsigned type or if we're
                                           using a seven-bit character set such as ASCII, the conversion will go smoothly.
                                           But if c h a r is a signed type and if some characters require eight bits, then con­
                                           vertingo such a character from c h a r to i n t owill giveo a negative result. The be-
                                           havior of the < c t y p e . h > functions is undefined for negative arguments (other
                                           than EOF), potentially causing serious problems. In such a situation, the argu­
                                           ment should be cast to u n s i g n e d c h a r for safety. (For maximum portability,
                                           some programmers always cast a c h a r value to u n s i g n e d c h a r when pass­
                                           ing it to a < c t y p e . h> function.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           C h a r a c te r -C la s s ific a tio n F u n c tio n s

                                            in t    is a ln u m (in t c );
                                            in t    i s a l p h a ( i n t c ) ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            in t    is b la n k ( in t c );
                                            in t    is c n tr l( in t c );
                                            in t    is d i g it( in t c );
                                            in t    is g ra p h (in t c );
                                            in t    is lo w e r(in t c );
                                            in t    is p r in t( in t c );
                                            in t    is p u n c t(in t c );
                                            in t    is s p a c e (in t c );
                                            in t    is u p p e r(in t c );
                                            in t    is x d ig it( in t c );
                                                             2 3 .5                                                                                    613
                                                                           T h e < c t y p e . h > H e a d e r: C h a r a c te r H a n d lin g onmlkjihgfedcbaZYXWVUTSRQPONMLK


                                Each character-classification function returns a nonzero value if its arcgzum ent has a
                                particular property. Table 23.10 lists the property that each function tests.dcbaZYXWVUTSRQPONMLKJIHGFEDC

            T a b le 2 3 .1 0                              F u n c tio n                                    T e s t kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
Character-Classification                       isalnum(c)                         Is c alphanumeric?
              Functions                        isalpha(c)                         Is c alphabetic?
                                               isblank(c)                         Is c a blank?*
                                               iscntrl(c)                         Is c a control character?^1
                                               isdigit(c)                         Is c a decimal digit?
                                               isgraph(c)                         Is c a printing character (other than a space)?
                                               islower(c)                         Is c a lower-case letter?
                                               isprint(c)                         Is c a printing character (including a space)?
                                               ispunct(c)                         Is c punclualion? t f t
                                               isspace(c)                         ls c a white-space character? w +
                                               isupper(c)                         Is c an upper-case letter?
                                               isxdigit(c)                        Is c a hexadecimal di<v«-iit?
                                               'T hc standard blank characters are space and horizontal lab ( \ t ) . This
                                              function is new in C99.RQPONMLKJIHGFEDCBA
                                              t + ln ASCIL ihc control characters are \ x 0 0 lhroueh \ x l f plus \ x 7 f . hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                              iJ L J .                                                           *"


                                              '' 'A11 printing characters except those for which i s s p a c e or i s a l n u m
                                              are true are considered punctuation.
                                               4 ,|,L J.


                                                   The white-space characters are space, fomi feed ( \ f ) . new-line ( \n ) .
                                              carriage return ( \ r ) . horizontal tab ( \ t ) . and vertical tab ( \v ) .


                                      The C99 definition of i s p u n c t is slightly different than the one in C89. In
                                C89, i s p u n c t (c ) tests whether c is a printing character but not a space or a
                                character for which i s a l n u m ( c ) is true. In C99, i s p u n c t (c ) tests whether
                                c is a printing character for which neither i s s p a c e ( c ) nor i s a l n u m ( c ) is
                                true.


         PROGRAM                T e s tin g th e C h a r a c t e r -C la s s if ic a tio n F u n c t io n s

                                The following program demonstrates the character-classification functions (with
                                the exception of i s b l a n k , which is new in C99) by applying them to the charac­
                                ters in the string "azA Z 0 ! \ t " .

            tc la s s ify .c    /★    Tests the character-classification functions */

                                #include <ctype.h>
                                #include <stdio.h>

                                #define TEST(f) printf("                                  %c     ", f(*p) ? ‘x 1 : ' ')

                                int main(void)

                                     char *p;

                                     printf("                      alnum      cntrl      graph      print"
                                             "                     space    xdigit\n"
                                             "                          alpha      digit      lower      punct"
                                             "                    upper\n");
           C h a p te r 2 3    L ib r a r y S u p p o r t f o r N u m b e rs a n d C h a r a c te r D a ta kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
6 1 4 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                         for (p = "azAZO !\t"; *p •= '\O*; p++)                                   (
                                           if (iscntrl(*p))
                                             printf("\\x%02x:", *p);
                                           else
                                             printf(”    %c:", *p);
                                           TEST(isalnum);
                                           TEST(isalpha);
                                           TEST(iscntrl);
                                           TEST(isdigit);
                                           TEST(isgraph);
                                           TEST(islower);
                                           TEST(isprint);
                                           TEST(ispunct);
                                           TEST(isspace);
                                           TEST(isupper);
                                           TEST(isxdigit);
                                           printf("\n");


                                         return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           The program produces the following output:

                                              alnum              cntrl              graph         print         space         xdigit
                                                        alpha          digit                 lower      punct           upper
                                           a:     x       x                        x           x    x                               x
                                           z:     x       x                        x           x    x
                                           A:     x       xaZYXWVUTSRQPONMLKJIHGFEDCBA  y£          x                      x        x
                                           Z:     x       x                        x                x                      x
                                           0:     x                       X        X                X                               X
                                                                                                    X              X
                                         1:                                             x           2C    XdcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     \xO9:                           X                                             X


                                     C h a r a c te r C a s e -M a p p in g F u n c tio n s


                                       int tolower(int c);
                                       int toupper(int c);

                       tolower       The t o l o w e r function returns the lower-case version of a letter passed to it as an
                      toupper        argument, while t o u p p e r returns the upper-case version. If the argument lo
                                     either function is not a letter, it returns the character unchanged.


               PROGRAM               T e stin g th e C a s e -M a p p in g F u n c tio n s

                                     The following program applies the case-m apping functions to the characters in the
                                     string "aA 0 1 ” .
                                    2 3 .6       T h e < s t r i n g . h > H e a d e r: S tr in g H a n d lin g hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                                        6 1 5 cbaZYXWVUTSRQPONMLK


tc a s e m a p .c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                      /* Tests the case-mapping functions */

             #include <ctype.h>
             #include <stdio.h>

             int main(void)

                char * p ;

                for (p = "aAOl” ; *p != *\0'; p++) {
                  printf("tolower(*%c*) is ’% c ’; ” , *p,                                tolower(*p));
                  printf(*'toupper(*%c*) is *%c*\n", *p,                                  toupper(*p));onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH

                return 0;


                  The program produces the following outpul:

             t o l o w e r ( 1 a ’) is       ’a ’; t o u p p e r (’a ’) is       ’A ’
             t o l o w e r (’A ’) is         ’a ’; t o u p p e r (’A ’) is       ’A ’
             t o l o w e r (’0 ’) is         ’0 ’; t o u p p e r (’0 ’) is       ’0 1
             t o l o w e r (’!’) is          ’ !’; t o u p p e r (’! ’) is       ' ! ’aZYXWVUTSRQPONMLKJIHGFEDCBA




    2 3 .6   T h e < s t r i n g . h > H e a d e r : S t r in g H a n d lin g

             We first encountered the < s t r i n g . h> header in Section 13.5, which covered the
             most basic string operations: copying strings, concatenating strings, comparing
             strings, and finding the length of a string. As w e'll see now, there are quite a few
             string-handling functions in < s t r i n g . h > , as well as functions that operate on
             character arrays that aren’t necessarily null-terminated. Functions in the latter cate­
             gory have names that begin with mem, to suggest that these functions deal with
             blocks of memory rather than strings. These memory blocks may contain data of
             any type, hence the arguments to the mem functions have type v o i d * rather than
             c h a r *.
                   < s t r i n g . h> provides five kinds of functions:

               ■ C opying fu n c tio n s . Functions that copy characters from one place in memory
                 to another place.
               ■ C oncatenation fu n c tio n s . Functions that add characters to the end of a string.
               ■ C o m p a riso n fu n c tio n s. Functions that compare character arrays.
               ■ Sea rch fu n c tio n s . Functions that search an array for a particular character, a
                 set of characters, or a string.
                                         ^             *^


               ■ M iscella n eo u s fu n c tio n s . Functions that initialize a memory block or com ­
                 pute the length of a string.
             WeTl now discuss these functions, one group at a time.
            C h a p te r 2 3
6 1 6 ZYXWVUTSRQPONMLKJIHGFEDCBAL ib r a r y S u p p o r t fo r N u m b e rs a n d C h a ra c te r D a ta dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    C o p y in g F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      void *memcpy(void * restrict sl,
                                                   const void * PONMLKJIHGFEDCBA
                                                                 restrict s2, size_t n);
                                      void *memmove(void *sl, const void *s2, size_t n);
                                      char *strcpy(char * restrict sl,
                                                   const char * restrict s2);
                                      char *strncpy(char * restrict sl,
                                                    const char * restrict s2, size_t n);

                                   The functions in this category copy characters (bytes) from one place in memory
                         Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    (the “source”) to another (the “destination”). Each function requires that the first
                                    argum ent point to the destination and the second point to the source. All copying
                                    functions return the first argument (a pointer to the destination).
                   memcpy                  m em cpy copies n characters from the source to the destination, where n is the
                  memmove           function’s third argument. If the source and destination overlap, the behavior of
                                    m em cpy is undefined, mem move is the same as m em cpy, except that it works cor­
                                    rectly when the source and destination overlap.
                        strcpy             s t r c p y copies a null-term inated string from the source to the destination,
                      strncpy       s t r n c p y is sim ilar to s t r c p y but it w on’t copy more than n characters, where
                                    n is the function’s third argument. (If n is too sm all, s t r n c p y w o n 't be able to
                                    copy a term inating null character.) If it encounters a null character in the source,
                                    s t r n c p y adds null characters to the destination until it has written a total o f n
                                    characters, s t r c p y and s t r n c p y like m e m c p y aren’t guaranteed to work ifthe
                                    source and destination overlap.
                                           The following exam ples illustrate the copying functions: the com m ents show
                                    which characters are copied.

                                    char source[] = { ’h ’ , ’o ’                    't*,     *\0*,      •t ’, ‘e ’, ’a •} ;
                                    char d e s t [7];

                                    memcpy(dest, source,                  3);          /* h,        o, t                                   */
                                    m e m c p y ( d e s t , source,       4);          /* h,        o, t, \0                               */
                                    memcpy(dest, source,                  7);          /* h,        o, t, \0,       t,    e, a             */

                                    m e m m o v e (dest, source, 3);                   /* h,        o, t                                   */
                                    m e m m o v e (d e s t , s o u r c e , 4);         /* h,        o, t, \0                               */
                                    m e m m o v e (dest, source, 7);                   /* h,        o, t, \0,       t,    e, a             */

                                    strcpy(dest,           source);                    /* h,        o, t, \0                               */

                                    strncpy(dest,            source,        3);        /* h,        o, t                                   */
                                    strncpy(dest,            source,        4);        /* h,        o, t, \0                               */
                                    strncpy(dest,            source,        7);        /* h,        o, t, \0,\0,         \0,   \0 */

                                    Note that m e m c p y memmove, and s t r n c p y don’t require a null-terminated
                                    string; they w orkjust as well with any block ofm em ory. The s t r c p y function, on
                                    the other hand, doesn’t stop copying until it reaches a null character, so it works
                                    only with null-term inated strings.
                                    2 3 .6    T h e < s t r i n g . h> H e a d e r: S trin g H a n d lin g onmlkjihgfedcbaZYXWVUTSRQPO
                                                                                                                     617

                  Section 13.5 gives examples of how s t r c p y and s t r n c p y are typically
              used. Although neither function is completely safe, s t r n c p y at least provides a
              way to limit the number of characters it will copy.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

              C o n c a t e n a tio n F u n c tio n s

               ch ar * s trc a t(c h a r * r e s tr ic t s l,
                                  co n st char * r e s t r i c t s2 );
               ch ar * s trn c a t(c h a r * r e s t r i c t s l,
                                    c o n st c h a r * r e s t r i c t s2,                    s i z e _ t n ) ;hgfedcbaZYXWVUTSRQPON

  s trc a t   s t r c a t appends its second argument to the end of the first argument. Both argu­
              ments must be null-terminated strings; s t r c a t puls a null character at the end of
              the concatenated siring. Consider lhe following example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
              char str[7] = "tea";

              strcat(str,         "bag");          /* adds b, a, g, \0 to end of str */

              The letter b overwrites the null character after the a in " t e a " , so that s t r now
              contains the string " t e a b a g " , s t r c a t returns its first argument (a pointer).
s trn c a t       s t r n c a t is the same as s t r c a t , except that its third argument limits the
              number of characters it will copy:
              char str[7] = "tea";

              strncat(str, "bag", 2);                     /* adds b, a, \0 to str    */
              strncat(str, "bag", 3);                     /* adds b, a, g, \0 to str */
              strncat(str, "bag", 4);                     /* adds b, a, g, \0 to str */

              As these examples show, s t r n c a t always leaves the resulting string properly
              null-terminated.
                   In Section 13.5, we saw that a call of s t r n c a t often has (he following ap­
              pearance:
              strncat(strl, str2, sizeof(strl) - strlen(strl)                                      - 1);

              The third argument calculates the amount of space remaining in s t r l (given by
              the expression s i z e o f ( s t r l ) - s t r l e n ( s t r l ) ) and then subtracts 1 to
              ensure that there will be room for the null character.

              C o m p a r is o n F u n c tio n s

                i n t m e m c m p (c o n st v o i d * s l , c o n s t v o i d * s 2 , s i z e _ t n ) ;
                i n t s trc m p (c o n s t c h a r * s l, c o n s t c h a r * s 2 );
                in t s tr c o ll( c o n s t ch ar * s l, c o n st c h a r * s2 );
                i n t s trn c m p (c o n s t c h a r * s l, c o n s t c h a r * s2 ,
                                   s iz e _ t n ) ;
                s iz e _ t s trx frm (c h a r * r e s t r i c t s l ,
                                          c o n st c h a r * r e s t r i c t s2, s iz e t n );
6 1 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 3   L ib r a r y S u p p o r t f o r N u m b e rs a n d C h a r a c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         The comparison functions fall into two groups. Functions in the first group (mem-
                                         cm p, s t r c m p , and s t r n c m p ) compare the contents of two character arrays.
                                         Functions in the second group ( s t r c o l l and s t r x f r m ) are used if the locale aZYXWVU
                    io c a ie s > 2 5 .1 needs to be taken into account.
                     memcmp                  The memcmp, s t r c m p , and s t r n c m p functions have much in common. All
                          strcmp three expect to be passed pointers to character arrays. The characters in the first
                       strncmp a r r a y a r e then compared one by one with the characters in lhc second array. All
                                     three functions return as soon as a mismatch is found. Also, all three return a ne<       g_«a-
                                     tive, zero, or positive integer, depending on whether the stopping character in the
                                     first array was less than, equal to, or greater than the stopping character in the sec­
                                     ond.
                                             The differences among the three functions have to do with when to stop com­
                                     paring characters if no mismatch is found. The memcmp function is passed a third
                                     argument, n . that limits the number of comparisons performed; it pays no particu­
                                     lar attention to null characters, s t r c m p doesn't have a preset limit, stopping
                                     instead when it reaches a null character in either array. (As a result, s t r c m p
                                     works only with null-terminated strings.) s t r n c m p is a blend of memcmp and
                                     s t r c m p ; it stops when n comparisons have been performed or a null character is
                                     reached in either array.
                                             The following examples illustrate memcmp, s t r c m p , and s t r n c m p :kjihgfedcbaZYXWVUTSR

                                     char sl[] = {'b',                  *i',     *g',      '\0',      *c',      'a',     'r'};
                                     char s2[] = {'b*,                  *i*,     'g*,      *\0*,      'c',      ’a',     't*j;

                                     if (memcmp(slz s2, 3) == 0) ...                                / * true *
                                     if (memcmp(s1, s2, 4) == 0) ...                                / * true *
                                     if (memcmp(slz s2, 7) == 0) ...                                / * false *

                                     if (strcmp(sl, s2)                  ==    0) ...               /* true          *

                                     if       (strncmp(sl, s2 z 3) == 0) ...                        /* true */
                                     if       (strncmp(sl, s2, 4) == 0) ...                         /* true */
                                     if       (strncmp(sl, s2 z 7) == 0) ...                        /* true */

                         strcoll            The s t r c o l l function is sim ilar to s t r c m p , but the outcom e o fth e compar­
                                     ison depends on the current locale.
                       strxfrm               Most of the time, s t r c o l l is fine for perform ing a locale-dependent string
                                     com parison. Occasionally, however, we might need to perform the comparison
                                     more than once (a potential problem, since s t r c o l l isn’t especially fast) or
                                     change the locale without affecting the outcome of the comparison. In these situa­
                                     tions, the s t r x f r m (“string transform ’') function is available as an alternative to
                                     s trc o ll.
                                             s t r x f r m transforms its second argument (a string), placing the result in the
                                     array pointed to by the first argument. The third argument limits the number of
                                     characters written lo the array, including the terminating null character. Calling
                                     s t r c m p with two transformed strings should produce the same outcom e (nega­
                                     tive, zero, or positive) as calling s t r c o l l with the original strings.
                                  2 3 .6      The < s t r i n g . h> H eader: String H andling hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                       6 1 9 onmlkjihgfedcbaZYXWV


                s t r x f r m returns the length of the transform ed string. As a result, it’s typi­
           cally caUed twice: once to determ ine the length o fth e transform ed string and once
           to perform the transformation. H ere’s an example:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           size_t len,-
           char *transformed;

           len = strxfrm(NULL, original, 0);
           transformed = malloc(len + 1);
           strxfrm(transformed, original, len);dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


           S e a r c h F u n c t io n s


            v o id * m e m c h r(c o n st v o id * s, i n t c , s i z e _ t n ) ;
            c h a r * s tr c h r ( c o n s t c h a r *s, in t c );
            s iz e _ t s trc s p n (c o n s t ch ar * s l, c o n st ch ar * s2 );
            c h a r * s trp b rk (c o n s t c h a r * s l, c o n st c h a r * s2 );
            c h a r * s tr r c h r ( c o n s t c h a r *s, in t c );
            s iz e _ t s trs p n (c o n s t c h a r * s l, c o n st c h a r * s2 );
            c h a r * s tr s tr ( c o n s t c h a r * s l, c o n st c h a r * s2 );
            ch ar * s trto k (c h a r * r e s tr ic t s l,
                                    c o n s t c h a r * r e s t r i c t s2 ) ;

  strchr   The s t r c h r function searches a string for a particular character. The following
           example shows how we might use s t r c h r to search a string for the letter f .

           char *p, str[] = "Form follows function.";

           p = strchr(str,                ’f ’);     /* finds first ’f ’ */

           s t r c h r returns a pointer to the first occurrence of f in s t r (the one in the word
           f o l l o w s ) . Locating multiple occurrences o f a character is easy; for example, the
           call

           p = strchr(p + 1, ’f ’);                     /* finds next *f' */

           finds the second f in s t r (the one in f u n c t i o n ) . If it can’t locate the desired
           character, s t r c h r returns a null pointer.
mem chr         m e m c h r is sim ilar to s t r c h r , but it stops searching after a set num ber of
           characters instead ofstopping at the first null character, m e m c h r’s third argument
           limits the number of characters it can exam ine— a useful capability if we d on’t
           want to search an entire string or if w e’re searching a block of memory that’s not
           terminated by a null character. The following exam ple uses m em ch r to search an
           array ofcharacters that lacks a null character at the end:

           char *p, str[22] = "Form follows function.";

           p = memchr(str,                ’f ’, sizeof(str));
6 2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 3   L ib r a r y S u p p o r t f o r N u m b e r s a n d C h a r a c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      Like the s t r c h r function, m e m c h r returns a pointer lo the first occurrence of the
                                      character. If it can’t find the desired character, m e m c h r returns a null pointer,
                        strrchr                                                                                       reverse order:kjihgfedcbaZ
                                           s t r r c h r is sim ilar to s t r c h r , but it searches the stringo in cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      char *p z str[] = "Form follows function.";

                                     p = strrchr(str,                 ’f ’);         /* finds last ’f ’ */

                                      In this example, s t r r c h r will first search for the null character al the end of the
                                      string, then go backwards to locate the letter f (the one in f u n c t i o n ) . Like
                                      s t r c h r and m em ch r, s t r r c h r returns a null pointer if it fails to find the
                                      desired character.
                       strpbrk               s t r p b r k is more general than s t r c h r : it returns a pointer to the leftmost
                                      character in the first ar^g^ument that matches an •v character in the second arK   s^um ent:

                                      chax- *p, str[] = "Form follows function.";

                                      p = strpbrk(str,                "mn");           /* finds first 'm' or 'n' */dcbaZYXWVUTSRQPONML

                                     In this example, p will point to the letter m in F orm , s t r p b r k returns a null
                                     pointer if no match is found.
                        strspn              The s t r s p n and s t r c s p n functions, unlike the other search functions,
                       strcspn       return an integer (of type s i z e _ t ) , representing a position within a string. When
                          Q&A        given a string to search and a set of characters to look for, s t r s p n retum s the
                                     index of the first character that’s not in the set. When passed sim ilar arguments,
                                     s t r c s p n returns the index of lhe first character that’s in the set. Here are exam­
                                     ples of both functions:

                                      size_t n;
                                      char str[] = "Form follows function.";

                                     n = strspn(str, "morF");                                /* n = 4 */
                                     n = strspn(str, " \t\n");                               /* n = 0 */
                                     n = strcspn(str, "morF");                               /* n = 0 */
                                     n = strcspn(str, " \t\n");                              /* n = 4 */

                          strstr           s t r s t r searches its first argument (a string) for a match with its second
                                     argument (also a string). In the following example, s t r s t r searches for the word
                                     fu n :

                                      char *p z str[] = "Form follows function.";

                                     p = strstr(str z "fun”);                          /* locates "fun" in str */

                                     s t r s t r returns a pointer to the first occurrence of the search string; it returns a
                                     null pointer if it can’t locate the siring. After the call above, p will point to the let­
                                     ter f in f u n c t i o n .
                         strtok            s t r t o k is the m ost complicated of the search functions. It’s designed to
                                     search a string for a “token”— a sequence o f characters that doesn’t include certain
                                     delimiting characters. The call s t r t o k ( s l , s 2 ) scans the s l siring for a non­
                                     em pty sequence of characters that are not in the s 2 string, s t r t o k marks the end
                        2 3 .6      The < s t r i n g . h > H e a d e r: S trin g H a n d lin g hgfedcbaZYXWVUTSRQPONMLKJIHGFE
                                                                                                        621 onmlkjihgfedcbaZYXWVU


of the token by storing a nuU character in s l ju st after the last character in the
token; it then returns a pointer to the first character in the token.
     W hat makes s t r t o k especially useful is that later calls can find additional
tokens in the sam e string. The call s t r t o k ( N U L L , s 2 ) continues the search
begun by the previous s t r t o k call. As before, s t r t o k marks the end o f the
token with a null character, then returns a pointer to the beginning of the token.
The process can be repeated until s t r t o k returns a null pointer, indicating that no
token was found.
     To see how s t r t o k works, w e’ll use it to extract a m onth, day, and year from
a date written in the form cbaZYXWVUTSRQPONMLKJIHGFEDCBA

m onth d a y , y e a r

where spaces and/or tabs separate the month from the day and the day from the
year. In addition, spaces and tabs may precede the com m a. L et’s say that the string
s t r has the following appearance to start with:


   s                    D      r     n      1
                 A kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA     7_«
                                                             «     8           1     9     9     8     \0
                        ^                                                t




After the call

p = s trto k (s tr,          " \ t ”);

s t r will have the following appearance:




p points to the first character in the m onth string, which is now term inated by a
null character. Calling s t r t o k with a null pointer as its first argument causes it to
resume the search from where it left off:

p = s trto k (N U L L ,          " \t," ) ;

After this caLL p points to the first character in the day:




   s tr



A final call of s t r t o k locates the year:

p = s trto k (N U L L ,          ” \ t ”);
            C h a p te r 2 3
6 2 2 ZYXWVUTSRQPONMLKJIHGFEDCBA L ib r a r y S u p p o r t fo r N u m b e rs a n d C h a r a c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              After this call, s t r will have the following appearance:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                  str


                                              When s t r t o k is called repeatedly to break a string into tokens, the second argu­
                                              ment isn’t required to be the same in each call. Tn our example, the second call of
                                              s t r t o k has theargum ent " \ t , " instead of " \ t " .
                                                     s t r t o k has several well-known problems that limit its usefulness; I’ll men­
                                              tion just a couple. First, it works with only one string at a time; it can’t conduct
                                              simultaneous searches througC3h two different stringws. Also,? s t r t o k treats a
                                              sequence of delimiters in the same way as a single delimiter, making it unsuitable
                                              for applications in which a string contains a series of fields separated by a delimiter
                                              (such as a comma) and some of the fields are empty.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              M isc e lla n e o u s F u n c tio n s

                                                v o id * m e m s e t(v o id * s , i n t c , s i z e _ t n ) ;
                                                s iz e _ t s trle n (c o n s t ch ar * s);

                            m em set          m e m s e t stores multiple copies of a character in a specified area of memory. If p
                                              points to a block ofN bytes, for example, the call
                                              m e m s e t(p ,    '    1,   N) ;

                                              will store a space in every byte of the block. One o f m e m s e t’s uses is initializing
                                              an array to zero bits:
                                              m e m s e t( a ,   0,    s iz e o f(a ));

                                              m e m s e t returns its lirst argument (a pointer).
                                strlen             s t r l e n returns the length of a string, not counting the null character. See
                                              Section 13.5 for examples of s t r l e n calls.
       s tr e r r o r tu n c tio n > 2 4 .2        There’s one other miscellaneous string function, s t r e r r o r , which is cov­
                                              ered along with the < e r r n o . h> header.aZYXWVUTSRQPONMLKJIHGFEDCBA



                                              Q & A
                                      Q:      W h y d o e s th e e x p m l fu n c tio n e x is t, s in c e a ll it d o e s is s u b t r a c t 1 fr o m th e
                                              v a lu e r e tu r n e d b y th e e x p fu n c tio n ? [p . 6 0 5 ]
                                      A:      When applied to numbers that are close to zero, the e x p function returns a value
                                              that’s very close to 1. The result of subtracting 1 from the value returned by e x p
                                              may not be accurate because of round-off error, e x p m l is designed to give a more
                                              accurate result in this situation.
                                                                                                                                                 6 2 3 onmlkjihgfedcbaZ
                                                                                                                         E x e rc is e s hgfedcbaZYXWVUTSRQPONMLK


                                    The l o g l p function exists for a sim ilar reason. For values o f x that are close
                               to zero, l o g l p (x ) should be more accurate than l o g (1 + x ) .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                         Q:    W h y is th e fu n c ti o n th a t c o m p u t e s th e g a m m a f u n c t io n             nam ed        tg a m m a
                               in s t e a d o f j u s t g a m m a ? [p . 6 0 6 ]
                         A:    At the time the C99 standard was being written, som e com pilers provided a func­
                               tion named gam m a, but it computed the log of the gam m a function. This function
                               was later renamed lg am m a . Choosing the name gam m a for the gam m a function
                               would have conflicted with existing practice, so the C99 com m ittee decided on the
                               name tg a m m a (“true gam m a”) instead.

                         Q:    W h y d o e s th e d e s c r ip ti o n o f th e n e x t a f t e r f u n c t io n s a y th a t i f x a n d y a r e
                               e q u a l, n e x t a f t e r     r e tu r n s y ? I f x a n d y a r e e q u a l, w h a t ’s th e d if f e r e n c e
                               b e t w e e n r e t u r n in g x o r y ? [p. 6 0 9 ]
                         A:    Consider the call n e x t a f t e r ( - 0 . 0 , + 0 . 0 ) . in which the argum ents are
                               m athem atically equal. By returning y instead o f x , the function has a return value
                               of +0.0 (rather than -0 .0 , which would be counterintuitive). Similarly, the call
                               n e x t a f t e r ( + 0 . 0 , - 0 . 0 ) re tu m s-0 .0 .

                         Q:    W h y d o e s < s t r i n g . h > p r o v id e s o m a n y w a y s to d o th e s a m e th in g ? D o w e
                               r e a lly   need     fo u r    c o p y in g   f u n c t io n s   (m e m c p y ,   m em m ove,    str c p y ,       and
                               s t r n c p y ) ? [p . 6 1 6 ]
                         A:    L et’s start with m em cp y and s t r c p y . These functions are used for different pur­
                               poses. s t r c p y will only copy a character array that’s term inated with a null char­
                               acter (a string, in other words); m em cpy can copy a mem ory block that lacks such
                               a term inator (an array of integers, for example).
                                      The other functions allow us to choose betw een safety and perform ance,
                               s t r n c p y is safer than s t r c p y , since it limits the num ber ofcharacters that can be
                               copied. We pay a price for safety, however, since s t r n c p y is likely to be slower
                               than s t r c p y . Using memmove involves a sim ilar trade-off. m em m ove will copy
                               bytes from one region of memory into a possibly overlapping region, m em cp y isn’t
                               guaranteed to work properly in this situation; however, ifw e can guarantee no over­
                               lap, m em cpy is likely to be faster than memmove.

                         Q:    W h y d o e s th e s t r s p n fu n c t io n h a v e s u c h a n o d d n a m e ? [p . 6 2 0 ]
                         A:    Instead of thinking of s t r s p n ’s return value as the index o f the first character
                                       not in a specified set, we could think of it as the length of the longest “span”
                                that’s cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                of characters that are in the set.




                               E x e rc is e s         aZYXWVUTSRQPONMLKJIHGFEDCBA



S e c tio n 2 3 .3   ©    I.   Extend the r o u n d _ n e a r e s t function so that i( rounds a floating-point number .v to n dig­
                               its after the decimal point. For example, the call r o u n d _ n e a r e s t ( 3 .1 4 1 5 9 , 3) would
            C h a p te r 2 3
6 2 4 ZYXWVUTSRQPONMLKJIHGFEDCBAL ib ra ry S u p p o r t fo r N u m b e rs a n d C h a r a c te r D a ta


                                    retum 3.142. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  H int: M ultiply .r by 10". round to the nearest integer, then divide by 10". Be
                                    sure that your function works correctly for both positive and negative values of.v.

S e c tio n 23.4             2.     (C99) W rite the following function:
                                    d o u b le     e v a lu a te _ p o ly n o m ia l(d o u b le              a [],       in t n,     d o u b le x ) ;
                                   Thc function should return the value of the polynomial a ir xJ ' + «„_|.vn " 1 + ... + r/0 , where the
                                   ctj's are stored in corresponding elem ents of the array a , which has length n 4- 1. Have the
                                   function use H om er’s Rule to com pute the value o fth e polynomial:
                                    ((.. ,((a ir x + a , ^ ) x + fl„_2 ),v + ... )x 4- a t ).v 4- r/0
                                    Use the fm a function to perform the m ultiplications and additions.

                             3.     (C99) Check tlie docum entation for your com piler to see if it perform s contraction on arith­
                                    metic expressions and, ifso , under what circum stances.

S e c tio n 23.5             4.    Using i s a l p h a and i s a l n u m , write a function that checks whether a string has the syn­
                                   tax of a C identifier (it consists o f letters, digits, and underscores, with a letter or underscore
                                   at the beginning).
                                            <~      o^
                                                       aZYXWVUTSRQPONMLKJIHGFEDCBA



                             5.     Using i s x d i g i t , write a function that checks w hether a string represents a valid hexadec­
                                    imal num ber (it consists solely ofhexadecim al digits). Ifso . the function returns the value of
                                    the num ber as a l o n g i n t . Otherw ise, the function returns -1 .

S e c tio n 23.6 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                          ©       6.    In each o f the following cases, indicate which function would be the best to use: m em cpy.
                                        m em m ove, s t r c p y . or s t r n c p y . Assume that the indicated action is to be perform ed by a
                                        single function call.
                                   (a) M oving all elem ents of an array “down” one position in order to leave room for a new
                                       elem ent in position 0.
                                   (b) Deleting the first character in a null-term inated string by m oving all other characters
                                       back one position.
                                   (c) Copying a string into a character array that may not be large enough lo hold il. lf the
                                       array is too small, assum e that lhc siring is to be truncated; no null character is neces­
                                       sary at the end.
                                   (d) Copying the contents of one array variable into another.

                             7.    Section 23.6 explains how lo call s t r c h r repeatedly to locate all occurrences of a charac­
                                   ter within a siring. Is it possible to locate all occurrences in reverse order by calling
                                   s t r r c h r repeatedly?

                       ©     8.     Use s t r c h r lo write the following function:
                                   in t     n u m c h a r(c o n st c h a r            *s,      ch ar c h );
                                   n u m c h a r returns the num ber o ftim e s the character c h occurs in the string s .

                             9.    Replace lhc lest condition in the following i f statement by a single call o f s t r c h r :
                                   if      ( c h ==       ‘a ’     ||    ch    ==      'b '    ||       c h ==   'c ')     ...

                       ©    10.    Replace the test condition in the following i f statem ent by a single call of s t r s t r :
                                   if      (s trc m p (s tr,            "fo o ")      == 0 | | s t r c m p ( s t r ,             "b a r")   == 0    ||
                                            s trc m p (s tr,            "baz")        == 0) ...
                                   H int: Com bine lhe siring literals into a single siring, separating them wilh a special charac­
                                   ter. Does your solution assum e anything about lhe contents o f s t r ?
                                                                                                                   6 2 5 onmlkjihgfedcbaZYXW
                                                                          P ro g r a m m in g P ro je c ts hgfedcbaZYXWVUTSRQPONMLKJIHG


©   11.   Write a call of m e m se t that replaces the last n characters in a null-terminated string s with
          ! characters.

    12.   Many versions of < s t r i n g . h > provide additional (nonstandard) functions, such as those
          listed below. Write each function using only the features of the C standard.
          (a) s t r d u p ( s ) — Returns a pointer to a copy of s stored in memory obtained by calling
              m a l l o c . Returns a null pointer ifenough memory couldn’t be allocated.
          (b) s t r i c m p ( s l , s 2 ) — Similar to s t r c m p , but ignores the case of letters.
          (c) s t r l w r ( s ) — Converts upper-case letters in s to lower case, leaving other characters
              unchang^*ed; retums s.
          (d) s t r r e v ( s ) — Reverses the characters in s (except the null character); returns s.
          (e) s t r s e t ( s , c h ) — Fills s with copies of the character c h ; returns s.
          If you test any of these functions, you may need to alter its name. Functions whose names
          begin with s t r are reserved by the C standard.

    13.   Use s t r t o k to write the followingo function:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
          int count_words(char *sentence);
          c o u n t —w o r d s returns the number of words in tohe siring s e n t e n c e , where a “word” is
          any sequence of non-white-space characters, c o u n t _ w o r d s is allowed to modify the
          string.aZYXWVUTSRQPONMLKJIHGFEDCBA




          P r o g r a m m in g P ro je c t s

     1.                                                         ax2 + bx + c = 0 using the formula
          Write a program that finds the roots o fth e equation cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                          -b ± Jb ^ - 4ac
                                                                      .v = ------ ------------
                                                                2a

          Have the program prompt for the values of «, b, and c. then print both values o fx . (If b 2 -
          ^a c is negative, the program should instead print a message to the effect that the roots are
          complex.)

©    2.   Write a program that copies a text file from standard input to standard output, removing all
          white-space characters from the beginning of each line. A line consisting entirely of white­
          space characters will not be copied.

     3.   Write a program that copies a text file from standard input to standard output, capitalizing
          the first letter in each word.

     4.   Write a program that prompts the user to enter a series of words separated by single spaces,
          then prints the words in reverse order. Read the input as a string, and then use s t r t o k to
          break it into words.

     5.   Suppose that money is deposited into a savings account and left for r years. Assume that the
          annual interest rate is r and that interest is compounded continuously. The formula A(t) =
          Pe rt can be used to calculate the final value of the account, where P is the orig
                                                                                           oinal amount
          deposited. For example, $1000 left on deposit for 10 years at 6% interest would be worth
          $1000 x 6-0 6x l() = $1000 x e b = $1000 x 1.8221188 = $1,822.12. Write a program that dis-
          plays the result of this calculation after prompting the user to enter the original amount
          deposited, the interest rale, and ihe number of years.
            C h a p te r 2 3
6 2 6 ZYXWVUTSRQPONMLKJIHGFEDCBAL ib r a r y S u p p o r t fo r N u m b e rs a n d C h a ra c te r D a ta onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                               6.    W rite a program that copies a text file from standard input to standard output, replacing each
                                     control character (other than \ n ) by a question mark.

                               7.    W rite a program that counts the num ber o fsen ten ces in a text file (obtained from standard
                                     input). Assum e that each sentence ends with a .. ?, or 1 followed by a w hite-space charac­
                                     ter (including \ n ) .
2 4   E r r o r H a n d lin g                     ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                            T h e re a re tw o w a y s to w rite e rr o r- fr e e
                                                              p r o g r a m s ; o n ly th e th ir d o n e w o rk s . onmlkjihgfedcbaZYXWVU




      Although student programs often fail when subjected to unexpected input, com ­
      mercial programs need to be “bulletproof'— able to recover gracefully from errors
      instead of crashing. Making programs bulletproof requires that we anticipate
      errors that might arise during the execution of the program, include a check for
      each one, and provide a suitable action for the program to perform if the error
      should occur.
            This chapter describes two ways for programs to check for errors: by using
      the a s s e r t macro and by testing the e r r n o variable. Section 24.1 covers the
      < a s s e r t . h > header, where a s s e r t is defined. Section 24.2 discusses the
      < e r r n o . h > header, to which the e r r n o variable belongs. This section also
      includes coverage of the p e r r o r and s t r e r r o r functions. These functions,
      which come from < s t d i o . h > and < s t r i n g . h > , respectively, are closely re­
      lated to the e r r n o variable.
            Section 24.3 explains how programs can detect and handle conditions known
      as signals, some of which represent errors. The functions that deal with signals are
      declared in the < s i g n a l .h > header.
            Finally, Section 24.4 explores the s e t j m p / l o n g j m p mechanism , which is
      often used for responding to errors. Both s e t j m p and l o n g j m p belong to the
      < s e t j m p . h > header.
            Error detection and handling aren’t among C ’s strengths. C indicates run-tim e
      errors in a variety of ways rather than in a single, uniform way. Furthermore, it’s
      the program m er’s responsibility to include code to test for errors. It’s easy to over­
      look potential errors; if one of these should actually occur, the program often con­
      tinues running, albeit not very well. Newer languages such as C++, Java, and C#
      have an “exception handling’’ feature that makes it easier to detect and respond to
      errors.kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                             627
6 2 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 4    E r r o r H a n d lin g aZYXWVUTSRQPONMLKJIHGFEDCBA




                             2 4 .1          T h e < a s s e r t . h > H e a d e r : D ia g n o s tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFED

                                              v o id               (sca la r e x p r e s s i o n ) ;
                                                       a s s e r t cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              assert         a s s e r t , which is defined in the < a s s e r t . h> header, allows a program to mon­
                                             itor its own behavior and detect possible problems at an early stage.
                                                   Although a s s e r t is actually a macro, it’s designed to be used like a func­
                                             tion. It has one argument, which must be an ‘"assertion”— an expression that we
                                             expect to be true under normal circumstances. Each time a s s e r t is executed, it
                                             tests the value of its argument. If the argument has a nonzero value, a s s e r t does
          s t d e r r stre a m > 2 2 .7      nothing. If the argument’s value is zero, a s s e r t writes a message to s t d e r r
           a b o r t fu n ctio n > 2 6 . 2   (the standard error stream) and calls the a b o r t function to terminate program
                                             execution.
                                                   For example, let’s say that the file d e m o . c declares an array a of length I0.
                                             We’re concerned that the statementkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                             a[i] = 0;

                                             in d e m o , c might cause the program to fail because i isn't between 0 and 9. We
                                             can use a s s e r t to check this condition before we perform the assignment to
                                             a [i]:

                                             assert(0 <= i && i < 10);                     /* checks subscript first */
                                             a[i] = 0;                                     /* now does the assignment */

                                             lf i ’s value is less than 0 or greater than or equal to 10, the program will terminate
                                             after displaying a message like the following one:

                                             Assertion failed: 0 <= i && i < 10, file demo.c, line 109

                                                   C99 changes a s s e r t in a couple of minor ways. The C89 standard states that
                                             the argument to a s s e r t must have i n t type. The C99 standard relaxes this
                                             requirement, allowing the argument to have any scalar type (hence the word scalar
                                             in the prototype for a s s e r t ) . This change allows the argument to be a floating­
                                             point number or a pointer, for example. Also, C99 requires that a failed a s s e r t
                                             display the name of the function in which it appears. (C89 requires only that
                                             a s s e r t display the argument— in text form— along with the name of the source
                                             file and the source line number). The suggested form of the message is

                                                                expression, function ubc, file .vyz, line nnn.
                                             Assertion failed: PONMLKJIHGFEDCBA

                                                  The exact form of the message produced by a s s e r t may vary from one com­
                                             piler to another, although it should always contain the information required by the
                                             standard. For example, the GCC compiler produces the following message in the
                                             situation described earlier:

                                             a.out: demo.c:109: main: Assertion "0 <- i && i < 10’ failed.
                                                                    2 4 .2                                                629onmlkjihgfedcbaZYXWV
                                                                             T he < e r r n o . h> H eader: Errors kjihgfedcbaZYXWVUTSRQPONMLKJIH

                                       a s s e r t has one disadvantage: it slightly increases the running time of a pro­
                                  gram because of the extra check it performs. Using a s s e r t once in a while prob­
                                  ably won’t have any great effect on a program's speed, but even this small time
                                  penalty may be unacceptable in critical applications. As a result, many program­
                                  mers use a s s e r t during testing, then disable it when the program is finished.
                                  Disabling a s s e r t is easy: we need only define the macro NDEBUG prior to
                                  including^»“ the < a s s e r t . h> header:

                                  #define NDEBUG
                                  #include <assert.h>

                                  The value of NDEBUG doesn't matter, just the fact that it’s defined. If the program
                                  should fail later, we can reactivate a s s e r t by removing NDEBUG’s definition.hgfedcbaZYXWVUTSRQPON


                                  Avoid putting an expression that has a side effect— including a function call—
                   A              inside an a s s e r t ; if a s s e r t is disabled at a later date, the expression won't be
                                  evaluated. Consider the following example:
                                  assert((p = malloc(n))             1= NULL);

                                  IfNDEBUG is defined, a s s e r t will be ignored and m a l l o c won’t be caUed.aZYXWVUTSRQPONMLKJIHG




                2 4 .2            T h e < e r r n o . h > H e a d e r : E r r o rs

                                  Some functions in the standard library indicate failure by storing an error code (a
                                  positive integer) in e r r n o , an i n t variable declared in < e r r n o . h > . ( e r r n o
            iv a iu e s > 4 . 2   may actually be a macro, lfs o , the C standard requires that it represent an lvalue,
                                  allowing us to use it like a variable.) Most of the functions that rely on e r r n o
                                  belong to < m a th . h>, but there are a few in other parts of the library.
                                         Let’s say that we need to use a library function that signals an en o r by storing
                                  a value in e r r n o . After calling<~~ the function, we can check whether the value of
                                  e r r n o is nonzero; ifso , an error occurred during the function call. For example,
s q r tt u n c tio n > 2 3 .3     suppose that we want to check whether a call of the s q r t (square root) function
                                  has failed. Here's what the code would look like:

                                  errno = 0;
                                  y = sqrt(x);
                                  if (errno != 0) {
                                    fprintf(stderr, "sqrt error; program terminated.\n");
                                    exit(EXIT_FAILURE);


                                  When e r r n o is used to detect an error in a call o fa library function, it’s important
                    Q&A           to store zero in e r r n o before callingv- the function. Althoug<*-h e r r n o is zero at the
                                  beginning of program execution, it could have been altered by a later function call.
                                  Library functions never clear e r r n o ; that’s the program's responsibility.dcbaZYXWVUTSRQPONMLKJIHGFEDC
6 3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 4    E rr o r H a n d lin g aZYXWVUTSRQPONMLKJIHGFEDCBA


                                                  T he value stored in e r r n o when an error occurs is often either EDOM or
                                  Q&A        ERANGE. (Both are macros defined in < e r r n o . h > . ) T hese m acros represent the
                                             tw o kinds o f errors that can occur when a math function is called:RQPONMLKJIHGFEDCBA

                                               ■ D o m a in       (EDOM): An argument passed to a function is outside the func­
                                                              errors
                                                  tion's dom ain. For exam ple, passing a negative num ber to s q r t causes a
                                                  dom ain error.
                                               ■ R a n g e errors  (ERANGE): A function's return value is too large to be repre­
              e x p lu n c tlo n > 2 3 . 3        sented in the function's return type. For exam ple, passing 1000 to the e x p
                                                  function usually causes a range error, because <?,0 0 ° is too large to represent as
                                                  a d o u b l e on most com puters.

                                                       Som e functions can experience both kinds of errors; by com paring e r r n o to
                                                       EDOM or ERANGE, we can determ ine which error occurred.
                                      C99                      C99 adds the E IL S E Q macro to < e r r n o . h > . Library functions in certain
      < w c h a r . h > header > 2 5 .5                headers— especially the < w c h a r . h > header— store the value o f E IL S E Q in
                                                       e r r n o when an encoding error occurs.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
              e n c o d in g e r r o r > 2 2 ~ 3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                             T h e p e r r o r a n d s t r e r r o r F u n c tio n s


                                              v o id p e r r o r ( c o n s t c h a r * s );                                   fro m < s t d i o . h >
                                              c h a r * s t r e r r o r ( i n t e r r n u i n ) ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                            from < s t r i n g . h >

                                             W e'll now look at two functions that are related to the e r r n o variable, althougoh
                                             neither function belongs to < e r r n o . h> .
                              perror              W hen a library function stores a nonzero value in e r r n o , we may want to
                                             display a m essage that indicates the nature o fth e error. O ne way to do this is to call
                                             the p e r r o r function (declared in < s t d i o . h > ) , w hich prints the follow ing
                                             items, in the order shown: (1) its argum ent. (2) a colon. (3) a space, (4) an error
                                             m essage determ ined by the value o f e r r n o , and (5) a new -line character, p e r r o r
          s td e r r s ir e a m   > 2 2 .1   writes to the s t d e r r stream , not to standard output.
                                                  H ere’s how we m ight use p e r r o r :kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                             errno = 0 ;
                                             y = sqrt(x);
                                             if (errno != 0) {
                                               perror("sqrt error11);
                                               exit(EXIT_FAILURE) ;


                                             Ifth e call o f s q r t fails because o f a dom ain error, p e r r o r will generate the fol­
                                             lowing output:

                                             sqrt error: Numerical argument out of domain

                                             The error m essage that p e r r o r displays after s q r t e r r o r is im plem entation-
                                             defined. In this exam ple, N u m e r i c a l a r g u m e n t o u t o f d o m a i n is the mes-
                                2 4 .3                                                                            631 onmlkjihgfedcbaZYXWV
                                         T h e < s i g n a l . h > H e a d e r: S ig n a l H a n d lin g hgfedcbaZYXWVUTSRQPONMLKJIHGF


           sage that corresponds to the EDOM error. An ERANGE error usually produces a dif-
           f e r e n tm e s s a g e ,s u c h a s N u m e r ic a l r e s u l t o u t o f r a n g e .
strerror           The s t r e r r o r function belongs to < s t r i n g . h > . W hen passed an error
           code, s t r e r r o r returns a pointer to a string describing the error. For exam ple,
           the callkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           puts(strerror(EDOM));

           might print

           Numerical argument out of domain

           The argum ent to s t r e r r o r is usually one of the values of e r r n o , but
           s t r e r r o r will return a string for any integer passed to it.
                  s t r e r r o r is closely related to the p e r r o r function. The error message that
           p e r r o r displays is the same m essage that s t r e r r o r would return if passed
           e r r n o as its argument.aZYXWVUTSRQPONMLKJIHGFEDCBA




2 4 .3     T h e < s i g n a l . h > H e a d e r : S ig n a l H a n d lin g

           The < s i g n a l .h > header provides facilities for handling exceptional conditions,
                  a ssig n a ls. Signals fall into two categories: run-tim e errors (such as division
           known cbaZYXWVUTSRQPONMLKJIHGFEDCBA
           by zero) and events caused outside the program. Many operating system s, for
           example, allow users to interrupt or kill running programs; these events are treated
           as signals in C. W hen an error or external event occurs, we say that a signal has
           been raised. M any signals are asynchronous: they can happen at any time during
           program execution, not ju st at certain points that are known to the programmer.
           Since signals may occur at unexpected times, they have to be dealt with in a unique
           way.
                This section covers signals as they’re described in the C standard. Sign<ds play
           a more prominent role in UNIX than you might expect from their lim ited coverage
           here. For inform ation about UNIX signals, consult one o f the UNIX program m ing
           books listed in the bibliography.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


           S ig n a l M a c r o s

  Q&A      < s i g n a l . h> defines a num ber of macros that represent signals; Table 24.1 lists
           these macros and their meanings. The value of each macro is a positive integer
           constant. C im plem entations are allowed to provide other signal macros, as long as
           their names begin with S IG followed by an upper-case letter. (UNIX im plem enta­
           tions, in particular, provide a large num ber of additional signal macros.)
                 The C standard doesn’t require that the signals in Table 24.1 be raised auto­
           matically, since not all o f them may be meaningful for a particular com puter and
           operating system. Most im plem entations support at least some o f these signals.
           C h a p te r 2 4    E r r o r H a n d lin g dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
6 3 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                           T a b le 2 4 .1 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                               N am e                                    M e a n i n g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   Signals
                                     c     RQPONMLKJIHGFEDCBA
                                                        SIGABRT             Abnormal termination (possibly caused by a call o f a b o r t )
                                                               SIGFPE       Error during an arithmetic operation (possibly division by zero
                                                                            or overflow)
                                                            SIGILL          Invalid instniciion
                                                            SIGINT          Interrupt
                                                            SIGSEGV         Invalid storage access
                                                            SIGTERM         Termination request


                                                     T h e s i g n a l F u n c tio n

                                                      v o id     (* s ig n a l(in t    s ig ,   v o id    (* fu n c )( in t) ) ) ( in t) ;

                                     s ig n a l      < s i g n a l . h > provides two functions: r a i s e and s i g n a l . W e’ll start with
                                                     s i g n a l , which installs a signal-handling function for use later if a given signal
                                                     should occur, s i g n a l is much easier to use than you might expect from its rather
                                                     intimidating prototype. Its first argument is the code for a particular signal; the sec­
                                                     ond argument is a pointer to a function that will handle the signal i f i t ’s raised later
                                                     in the program. For example, the following call of s i g n a l installs a handler for
                                                     th e S IG IN T sigG?nal:

                                                     signal(SIGINT, handler);aZYXWVUTSRQPONMLKJIHGFEDCBA

                                                     h a n d l e r is the name o f a signal-handling function. Ifth e S IG IN T signal occurs
                                                     later during program execution, h a n d l e r will be called automatically.
                                                          Every signal-handling function must have an i n t param eter and a return type
                                                     of v o i d . When a particular signal is raised and its handler is called, the handler
                                                     wiil be passed the code for the signal. Knowing which signal caused it to be called
                                                     can be useful for a signal handler; in particular, it allows us to use the sam e handler
                                                     for several different si^enals.
                                                          A signal-handling function can do a variety of things. Possibilities include
                                                     ignoring the signal, perform ing some sort o fe rro r recovery, or term inating the pro­
              a b o r t                   > 2 6 .2
                           lu n c t i o n BA         gram. Unless it’s invoked by a b o r t or r a i s e , however, a signal handler
     s ta tic s to r a g e d u r a tio n >   1B.2    shouldn't call a library function or attempt to use a variable with static storage
                                       Q&A           duration. (There are a few exceptions to these rules, however.)
                                                          If a signal-handling function returns, the program resumes executing from the
                                                     point at which the signal occurred, except in two cases: (1) lf the signal was
                                                     SIGABRT, the program will term inate (abnorm ally) when the handler returns. (2)
                                                     The effect of returning from a function that has handled S IG F P E is undefined, (hi
                                                     other words, don't do it.)
                                                          Although s i g n a l has a return value, it’s often discarded. The retum value, a
                                                     pointer to the previous handler for the specified signal, can be saved in a variable if
                                                     desired. In particular, if we plan to restore the original signal handler later, we need
                                                     to save s i g n a l ’s return value:

                                                     void (*orig_handler)(int);                    /* function pointer variable */
                        2 4 .3                                                                             6 3 3 kjihgfedcbaZYXW
                                  T h e < s i g n a l . h > H e a d e r : S ig n a l H a n d lin g hgfedcbaZYXWVUTSRQPONMLKJIH


orig_handler = signal(SIGINT, handler);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

This statement installs h a n d l e r as the handler for S IG IN T and then saves a
pointer to the original handler in the o r i g _ h a n d l e r variable. To restore the
oritg^-inal handler later, we’d write

signal(SIGINT, orig_handler); /* restores original handler */dcbaZYXWVUTSR


P r e d e fin e d S ig n a l H a n d le r s
Instead of writing our own signal handlers, we have the option of using one of the
predefined handlers that < s i g n a l . h> provides. There are two ofthese, each rep­
resented by a macro:
    ■ S IG _D FL . SIG_DFL han dles signals in a “default" way. To install
        SIG_DFL, we’d use a call such as

       signal(SIGINT, SIG_DFL);                        /* use default handler */

       The effect ofcalling SIG_DFL is implementation-defined, but in most cases it
       causes program termination.
    ■ S IG _ IG N .T h e c a ll

       signal(SIGINT, SIG_IGN);                        /* ignore SIGINT signal */

       specifies that S IG IN T is to be ignored if it should be raised later.
In addition to SIG_DFL and SIG _IG N , the < s i g n a l .h > header may provide
other signal handlers; their names must begin with S IG _ followed by an upper­
case letter. Al the beginning of program execution, the handler for each signal is
initialized to either SIG _D FL or SIG _IG N , depending on the implementation.
     < s i g n a l . h> defines another macro, SIG_ERR, that looks like it should be
a signal handler. SIG_ERR is actually used to test for an error when installing a
signal handler. If a call of s i g n a l is unsuccessful— it can’t install a handler for
the specified signal— it returns SIG_ERR and stores a positive value in e r r n o .
Thus, to test whether s i g n a l has failed, we could write

if (signal(SIGINT, handler) == SIG_ERR) {
  perror("signal(SIGINT, handler) failed");

}
     There’s one tricky aspect to the entire signal-handling mechanism: what hap­
pens ifa signal is raised by the function that handles that signal? To prevent infinite
recursion, the C89 standard prescribes a two-step process when a signal is raised
for which a signal-handling function has been installed by the programmer. First,
either the handler for that signal is reset to SIG _D FL (the default handler) or else
the signal is blocked from occurring while the handler is executing. (S IG IL L is a
special case; neither action is required when S IG IL L is raised.) Only then is the
handler provided by the programmer called.
           C h a p te r 2 4    E rr o r H a n d lin g kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
6 3 4 ZYXWVUTSRQPONMLKJIHGFEDCBA




                                       After a signal has been handled, whether or not the handler needs to be reinstalled
                          A            is implementation-defined. UNIX implementations typically leave the signal han­
                                onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       dler installed after it's been used, but other implementations may reset the handler
                                       to SIG__DFL. In the lattercase. the handler can reinstall itselfby calling s i g n a l
                                       before it returns.


                                           C99 changes the signal-handling process in a few minor ways. When a signal
                                     is raised, an implementation may choose to disable notjust that signal but others as
                                     well. If a signal-handling function returns from handling a S IG IL L or SIGSEGV
                                     signal (as well as a SIG FPE signal), the effect is undefined. C99 also adds the
                                     restriction that if a sisv?,nal occursC>as a result of calling the a b o r t function or the
                                     r a i s e function, the signal handler itselfm usl not call r a i s e .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T h e r a i s e F u n c tio n

                                        in t r a is e (in t          s ig );

                          raise      Although signals usually arise from run-time errors or external events, it’s occa­
                                     sionally handy for a program to cause a signal to occur. The r a i s e function does
                                     just that. The argument to r a i s e specifies thc code for the desired signal:

                                     raise(SIGABRT);                   /* x^aises the SIGABRT signal */

                                     The return value of r a i s e can be used to test whether the call was successful:
                                     zero indicates success, while a nonzero value indicates failure.


               PROGRAM               T e stin g S ig n a ls

                                     The following program illustrates the use ofsignals. First, it installs a custom han­
                                     dler for the S IG IN T signal (carefully saving the original handler), then calls
                                     r a i s e _ s i g to raise that signal. Next, it installs S IG _IG N as the handler for the
                                     S IG IN T signal and calls r a i s e _ _ s i g again. Finally, it reinstalls the original han­
                                     dler for SIGINT, then calls r a i s e _ s i g one last time.BA
                    tsignal.c        /* Tests signals */

                                     #include <signal.h>
                                     #include <stdio.h>

                                     void handler(int sig);
                                     void raise sig(void);

                                     int main(void)

                                         void (*orig_handler)(int);
                              2 4 .4   T h e < s e hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                   t j m p . h > H e a d e r: N o n lo c a l J u m p s   6 3 5 kjihgfedcbaZ


           printf("Installing handler for signal %d\n", SIGINT);
           orig_handler = signal(SIGINT, handler);
           raise_sig();

           printf("Changing handler to SIG_IGN\n");
           signal(SIGINT, SIG_IGN);
           raise_sig();

           printf("Restoring original handler\n");
           signal(SIGINT, orig_handler);
           raise_sig();

           printf("Program terminates normally\n");
           return 0;


         void handler(int sig)

           printf("Handler called for signal %d\n*', sig);


         void raise_sig(void)

            raise(SIGINT);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


              Incidentally. the call of r a i s e doesn’t need to be in a separate function. 1
         defined r a i s e _ s i g simply to make a point: regardless of where a signal is
         raised— whether it's in m a in or in some other function— it will be caught by the
         most recently installed handler for that signal.
              The output ofthis program can vary somewhat. Here’s one possibility:

         Installing handler for signal 2
         Handler called for signal 2
         Changing handler to SIG_IGN
         Restoring original handler

         From this output, we see that our implementation defines S IG IN T to be 2 and that
         the original handler for S IG IN T must have been SIG_DFL. (Tf it had been
         SIG _IG N , we'd also see the message P r o g r a m t e r m i n a t e s n o r m a l l y .)
         Finally, we observe that SIG_DFL caused the program to terminate without dis­
         playing an error message.aZYXWVUTSRQPONMLKJIHGFEDCBA




2 4 .4   T h e < s e t j m p . h > H e a d e r : N o n lo c a l J u m p s

          i n t s e tjm p (jm p _ b u f e n v ) ;
          v o id lo n g jm p (jm p b u f en v ,           in t v a l);
636 ZYXWVUTSRQPONMLKJIHGFEDCBA
        C h a p te r 2 4    E r r o r H a n d lin g aZYXWVUTSRQPONMLKJIHGFEDCBA


                                                 Normally, a function returns to the point at which it was called. We can’t use a
                                                 g o t o statement to make it go elsewhere, because a g o t o can jum p only to a label
                                     > 6 .4hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
           g o t o s t a t e m e n t BA


                                                 within the same function. The < s e t j m p . h > header, however, makes it possible
                                                 for one function to jump directly to another function without returning.
                                                        The most important items in < s e t j m p . h > are the s e t j m p macro and the
                                                 lo n g jm p function, s e t j m p “marks" a place in a program; lo n g j m p can then
                                                 be used to return to that place later. Although this powerful mechanism has a vari­
                                                 ety ofpotential applications, it’s used primarily for error handling.
                              s e tjm p                 To mark the target o fa future jump, we call s e t j m p , passing it a variable of
                                                 type jm p _ b u f (declared in < s e t j m p . h>). s e t j m p stores the current “environ­
                                 Q&A             ment” (including a pointer to the location o fth e s e t j m p itself) in the variable for
                                                 later use in a call of lo n g jm p ; it then returns zero.
                           lo n g jm p                  Returning to the point ofthe s e t j m p is done by calling lo n g jm p , passing it
                                                 the same jm p _ b u f variable that we passed to s e t j m p . After restoring the envi­
                                                 ronment represented by the jm p _ b u f variable, lo n g jm p will—here's where it
                                                                  retiirn fro m the s e t j m p ccill. s e t j m p 's return value this time is
                                                 gets tricky— cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                 v a l , the second argument to lo n g jm p . ( l f v a l is 0, s e t j m p returns 1.)


                                   Be sure that the argument to lo n g jm p was previously initialized by a call of
                        A          s e t j m p . It’s also important that the function containing the original call of s e t ­
                                   jm p must not have returned prior to the call of lo n g jm p . If either restriction is
                                   violated, calling lo n g jm p results in undefined behavior. (The program will prob­
                                   ably crash.)


                                        To summarize, s e t j m p returns zero the first time it’s called: later, lo n g jm p
                                   transfers control back to the original call of s e t j m p , which this time retums a
                                   nonzero value. Got it? Perhaps we need an exam ple...


              PROGRAM              T e stin g s e t j m p / l o n g j m p

                                   The following program uses s e t j m p to mark a place in m a in ; the function f2
                                   later returns to that place by calling lo n g jm p .

                  tsetjmp.ckjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                /* Tests setjmp/longjmp */

                                   #include <setjmp.h>
                                   #include <stdio.h>

                                   jmp_buf env;

                                   void fl(void);
                                   void f 2 (void);

                                   int main(void)

                                      if (setjmp(env) == 0)
                                        printf("setjmp returned 0\n");
                                                                                                                6 3 7 kjihgfedcbaZYXWVU
                                                                                                 Q & A hgfedcbaZYXWVUTSRQPONMLKJIHGF


         else {
           printf("Program terminates: longjmp called\n");
           return 0;


         fK) ;
         printf("Program terminates normally\n");
         return 0;


     void fl(void)

         printf("fl begins\n");
         f2() ;
         printf("fl returns\n");


     void f2 (void)

         printf("f2 begins\n");
         longj m p (env, 1) ;
         printf("f2 returns\n");onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


           The oulput of this program will be
     setjmp returned 0
     fl begins
     f2 begins
     Program terminates: longjmp called

     The original call of s e t j m p returns 0, so m a in calls f l . Next, f l calls f 2 ,
     which uses l o n g j m p to transfer control back to m a in instead o fretu m in g to f l .
     When l o n g j m p is executed, control goes back to the s e t j m p call. This time,
     s e t j m p returns 1 (the value specified in the l o n g j m p call).aZYXWVUTSRQPONMLKJIHGFEDCBA




     Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Q:   Y ou s a id th a t i t ’s im p o r t a n t to s t o r e z e r o in e r r n o b e fo r e c a llin g a lib r a r y
     f u n c t io n t h a t m a y c h a n g e it, b u t I ’v e s e e n U N I X p r o g r a m s th a t te s t e r r n o
     w it h o u t e v e r s e tt in g it to z e r o . W h a t ’s th e s t o r y ? [p . 6 2 9 ]
A:   UNIX programs often contain calls of functions that belong to the operating sys­
     tem. These RQPONMLKJIHGFEDCBA
                  s y s t e m c a l l s rely on e r r n o , but they use it in a slightly different way
     than described in this chapter. When such a call fails, it returns a special value
     (such as - I or a null pointer) in addition to storing a value in e r r n o . Programs
     don’t need to store zero in e r r n o before such a call, because the function’s return
     value alone indicates that an error occurred. Some functions in the C standard
     library work this way as well, using e r r n o not so much to signal an error as to
     specify which error it was.
6 3 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 4    E r ro r H a n d lin g dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        Q:      M y v e r s io n o f < e r r n o . h > d e fi n e s o th e r m a c r o s b e s id e s EDOM a n d ERANGE.
                                                Is th is p r a c t ic e le g a l? [p . 6 3 0 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         A:     Yes. The C standard allows macros that represent other error conditions, provided
                                                that their names begin with the letter E followed by a digit or an upper-case letter.
                                                UNIX im plem entations typically define a huge num ber o f such macros.

                                        Q:      S o m e o f th e m a c r o s th a t r e p r e s e n t s ig n a ls h a v e c r y p t i c n a m e s , lik e S I G F P E
                                                a n d S IG S E G V . W h e r e d o th e s e n a m e s c o m e fr o m ? [p . 6 3 1 ]
                                         A:     The names of these signals date back to the early C com pilers, which ran on a DEC
                                                P D P -11. The P D P -11 hardware could detect errors with names like '"Floatin og Point
                                                Exception” and “Segmentation Violation.”

                                        Q:      O K , I ’m c u r io u s . U n le s s i t ’s in v o k e d b y a b o r t o r r a i s e , a s ig n a l h a n d le r
                                                s h o u l d n ’t c a ll a s t a n d a r d lib r a r y f u n c t io n , b u t y o u s a id th e r e w e r e e x c e p t io n s
                                                to th is r u le . W h a t a r e th e y ? [p . 6 3 2 ]
                                         A:     A signal handler is allowed to call the s i g n a l function, provided that the first
                                                argum ent is the signal that it’s handhng at the mom ent. This proviso is important,
                                   frffi>       because it allows a signal handler to reinstall itself. In C99, a signal handler may
                                     >26.2 also call the a b o r t function or the E x i t function.
                E x i t fu n c tio n cbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                      *Q :      F o llo w in g u p o n th e p r e v io u s q u e s t io n , a s i g n a l h a n d le r n o r m a lly i s n ’t s u p ­
                                                p o s e d to a c c e s s v a r ia b le s w ith s ta ti c s t o r a g e d u r a ti o n . W h a t ’s th e e x c e p t io n to
                                                th is r u le ?
                                         A:     That one’s a bit harder. The answer involves a type named s i g _ a t o m i c _ t that’s
                                                declared in the < s i g n a l . h> header, s i g _ a t o m i c _ t is an integer type that can
                                                be accessed “as an atom ic en tity ” according to the C standaid. In other words, the
                                                CPU can fetch a s i g _ a t o m i c _ t value from memory or store one in memory
                                                with a sing^ le m achine instruction, rather than using^ two or more m achine instruc-
                                                tions. s i g _ a t o m i c _ t is often defined to be i n t , since most CPUs can load or
                                                store an i n t value in one instruction.
                                                     That brings us to the exception to Lhe rule that a signal-handling function isn't
                                                supposed to access static variables. The C standard allows a signal handler to store
                                                a value in a s i g _ a t o m i c _ t variable— even one with static storage duration—
  v o ia tiie t y p e q u a iifie r > 2 o . 3   provided that it’s declared v o l a t i l e . To see the reason for this arcane rule, con­
                                                sider what might happen if a signal handler were to modify a static variable that’s
                                                of a type that’s wider than s i g _ a t o m i c _ t . If the program had fetched part of
                                                the variable from m em oryjust before the signal occurred, then com pleted the fetch
                                                after the signal is handled, it could end up with a garbage value, s i g _ a t o m i c _ t
                                                variables can be fetched in a single step, so this problem doesn’t occur. Declaring
                                                the variable to be v o l a t i l e warns the com piler that the variable’s value may
                                                change at any time. (A signal could suddenly be raised, invoking a signal handler
                                                that modifies the variable.)

                                        Q:      The t s i g n a l . c        p r o g r a m c a ll s p r i n t f fr o m in s id e a s ig n a l h a n d le r , k n ’t
                                                th a t ille g a l?
                                                                                                                                        639onmlkjihgfedcbaZYXW
                                                                                                                 E x e rc is e s kjihgfedcbaZYXWVUTSRQPONMLKJI


                      A:    A signal-handling function invoked as a result of r a i s e or a b o r t may call
                            library functions, t s i g n a l . c uses r a i s e to invoke the signal handler.dcbaZYXWVUTSRQPONMLKJIHGFE

                      Q:    H o w c a n s e t j m p m o d ify th e a r g u m e n t t h a t ’s p a ss e d to it? I th o u g h t th a t C
                            a lw a y s p a ss e d a r g u m e n ts b y v a lu e , fp . 6 3 6 ]
                      A:    The C standard says that jm p _ b u f must be an array type, so s e t j m p is actually
                            being passed a pointer.

                      Q:    I ’m h a v in g tr o u b le w ith s e t j m p . A r e th e r e a n y r e s tr ic t io n s o n h o w it c a n b e
                            u se d ?
                      A:    According to the C standard, there are only two legal ways to use s e t j m p :
                              ■   As the expression in an expression statement (possibly cast to v o i d ) .
                              ■ A s part of the controlling expression in an i f . s w i t c h , w h i l e , d o , or f o r
                                 statement. The entire controlling expression must have one of the following
                                               constexpr is an integer constant expression and op is a relational
                                 forms, where cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 or equality operator:

                                  s e t j m p (...)
                                   ! s e t j m p (...)
                                  c o n ste xp r op s e t j mp (...)
                                  s e t j mp (...) op c o n stexp r

                            Using s e t j m p in any other way causes undefined behavior.

                      Q:    A fte r a p r o g r a m h a s e x e c u te d a c a ll o f l o n g j m p , w h a t a r e th e v a lu e s o f th e
                            v a r ia b le s in th e p r o g r a m ?
                      A:    Most variables retain the values they had at the time o fth e lo n g jm p . However, an
                            automatic variable inside the function that contains the s e t j m p has an indetermi­
                            nate value unless it was declared v o l a t i l e or it hasn’t been modified since the
                            s e t j m p was performed.

                      Q:    Is it le g a l to c a ll l o n g j m p in s id e a s ig n a l h a n d le r ?
                       A:   Yes, provided that the signal handler w asn’t invoked because o fa sig n a l raised dur-
                    <i^E>   ing the execution o f a signal handler. (C99 removes this restriction.) hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                            E x e rc is e s

S e c ti o n 24.1      l.   (a) Assertions can be used to test for two kinds of problems: ( I) problems that should never
                            occur if the program is correct, and (2) problems that are beyond the conlrol of the program.
                            Explain why a s s e r t is best suited for problems in the first category.
                            (b) Give three examples of problems that are beyond the control o fth e program.

                       2.   Write a call o f a s s e r t that causes a program to terminate if a variable named t o p has the
                            value NULL.
6 4 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 4    E rr o r H a n d lin g


                             3.    Modify lhe s ta c k A D T 2 ,c file of Section 19.4 so that it uses a s s e r t lo lest for errors
                                   instead ofusing i f statements. (Note that the t e r m i n a t e function is no longer necessary
                                   and can be removed.)

S e c tio n 24.2       ©     4.    (a) Writc a “wrapper” function named t r y _ m a t h _ f c n that calls a math function
                                   (assumed to have a d o u b l e argument and return a d o u b l e value) and then checks
                                   wheiher the call succeeded. Here’s how we might use t r y _ m a t h _ f c n :
                                   y = try _ m a th _ fc n (s q rt,        x,   "E rro r in       c a ll of     s q rt" );
                                   If the call s q r t (x) is successful, t r y _ m a t h _ f c n relums the value computed by s q r t .
                                   Tf the call fails, t r y _ m a t h _ f c n calls p e r r o r lo print the message E r r o r i n c a l l o f
                                   s q r t , lhen calls e x i t lo terminate the program.
                                   (b) Write a macro thal has the same effect as t r y _ m a t h _ f c n but builds the error mes­
                                           from the funclioifs name:
                                   sag&ecbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   y = TR Y _M A TH _FC N (sqrt, x ) ;
                                   If the call of s q r t fails, the message will bc E r r o r i n c a l l o f s q r t . Hint: Havc
                                   TRY_MATH_FCN call t r y _ m a t h _ f c n .

S e c tio n 24.4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                          ©       5.   In the i n v e n t o r y . c program (see Section 16.3), the m a i n function has a f o r loop ihai
                                   prompts the user to enter an operation code, reads the code, and then calls either i n s e r t ,
                                   s e a r c h , u p d a t e , or p r i n t . Add a call of s e t j m p to m a in in such a way that a subse­
                                   quent call of l o n g jm p will relum to the f o r loop. (After the l o n g jm p , the user will bc
                                   prompted for an operation code, and lhc program will continue normally.) s e t j m p will
                                   need a jm p _ b u f variable; where should it bc declared?
2 5   In t e r n a tio n a l F e a tu r e s                                      ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                   I f y o u r c o m p u te r s p e a k s E n g lis h
                                                                    it w a s p ro b a b ly m a d e in J a p a n . onmlkjihgfedcbaZYXWVU




      For many years, C wasn’t especially suitable for use in non-English-speaking
      countries. C originally assumed that characters were always single bytes and that
      all computers recognized the characters #, [, \ , ] , ^, {, |, }, and ~, which are
      needed to write programs. Unfortunately, these assumptions aren’t valid in all parts
      of the world. As a result, the experts who created C89 added language features and
      libraries in an effort to make C a more international language.
           In 1994, Amendment 1 to the ISO C standard was approved, creating an
      enhanced version ofC 89 that’s sometimes known as C94 or C95. This amendment
      provides additional library support for international programming via the digraph
      language feature and the < i s o 6 4 6 .h > , < w c h a r .h > , and < w c t y p e .h > head­
      ers. C99 adds even more support for internationalization in the form of universal
      character names. This chapter covers all of C's international features, whether they
      come from C89, Amendment 1, orC 99. 1'11 flag the Amendment I changes as C99
      changes, although they actually predate C99.
           The < l o c a l e .h > header (Section 25.1) provides functions that allow a pro­
      gram to tailor its behavior to a particular “locale"— often a country or other geo­
      graphical area in which a particular language is spoken. Multibyte characters and
      wide characters (Section 25.2) enable programs to work with large character sets
      such as those found in Asian countries. Digraphs, trigraphs, and the < i s o 6 4 6 . h>
      header (Section 25.3) make it possible to write programs on computers that lack
      some of the characters normally used in C programming. Universal character
      names (Section 25.4) allow programmers lo embed characters from the Universal
      Character Set into the source code o fa program. The < w c h a r . h> header (Section
      25.5) supplies functions forwide-character input/output and wide-string manipula­
      tion. Finally, the < w c ty p e .h > header (Section 25.6) provides wide-character
      classification and case-mapping functions.




                                                                                                             641
6 4 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 5   In te rn a tio n a l F e a tu re s aZYXWVUTSRQPONMLKJIHGFEDCBA




                                       25.1              T h e < l o c a l e . h > H e a d e r : L o c a liz a t io n onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHG

                                                         The < l o c a l e .h > header provides functions to control portions of the C library
                                                         whose behavior varies from one locale to another. (A RQPONMLKJIHGFEDCBA
                                                                                                                 l o c a l e is typically a country
                                                         or a region in which a particular language is spoken.)
                                                              Locale-dependent aspects of the library include:

                                                           ■                                                                  In some locales, for example, the deci­
                                                                                       F o r m a t tin g o f n u m e r ic a l q u a n titie s .
                                                                                       mal point is a period (297.48), while in others it's a comma (297,48).
                                                           ■ F o r m a ttin g o f m o n e ta r y q u a n titie s .                                For example, the currency symbol varies
                                                                                       from country to country.
                                                           ■                           C h a r a c t e r s e t . The character set often depends on the language in a particular
                                                                                       locale. Asian countries usually require a much larger character set than West­
                                                                                       ern countries.
                                                                       ■               A p p e a r a n c e o f d a t e a n d t i m e . In some locales, it's customary lo pul the month
                                                                                       first when writing a date (8/24/2012); in others, the day goes first (24/8/2012).dcbaZYX


                                                         C a te g o r ie s

                                                         By changing locale, a program can adapt its behavior to a different area of the
                                                         world. But a locale change can affect many parts of the library, some of which we
                                                         might prefer not to alter. Fortunately, we’re not required to change all aspects ofa
                                                         locale at the same time. Instead, we can use one of the following macros to specify
                                                         a c a te g o r y :

                                                                   ■                   LC_COLLATE. Affects the behavior of two string-comparison functions.
        < s tr in g .h >         header > 2 3 .6                                       s t r c o l l and s t r x f r m . (Both functions aredeclared in < s t r i n g . h > ) .
          < c t y p e . h > header > 2 3 .5                    ■                       LC_CTYPE. Affects the behavior of the functions in < c t y p e . h > (except
                                                                                       i s d i g i t and i s x d i g i t ) . Also affects the multibyte and wide-character
                                                                                       functions discussed in this chapter.
                                                                                   ■   LC_MONETARY. Affects the monetary formatting information returned by the
                                                                                       l o c a l e c o n v function.
                                                                           ■           LC_NUMERIC. Affects the decimal-point character used by formatted I/O
n u m e ric c o n v e rs io n fu n c tio n s > 2 6 . 2                                 functions (like p r i n t f and s c a n f ) and the numeric conversion functions
                                                                                       (such as s t r t o d ) in < s t d l i b . h > . Also affects the nonmonetary format­
                                                                                       ting information returned by l o c a l e c o n v .
           s tr ftim e          lu n ctio n > 2 6 . 3                          ■       LC_TIME. Affects the behavior of the s t r f t i m e function (declared in
                                                                                       < t i m e .h > ) , which converts a time into a character string. In C99, also
           w c s f t i m e fu n c tio n > 2 5 . 5                                      affects the behavior of the w c s f t i m e function.
                                                         Implementations are free to provide additional categories and define LC_ macros
                                                         not listed above. For example, most UNIX systems provide an LC__MESSAGES
                                                         category, which affects the format ofaffirm ative and negative system responses.
                                                                         25.1                                                                              643dcbaZYXWVUTSRQP
                                                                                     T h e < l o c a l e . h > H e a d e r : Lo c a li z a t i o n kjihgfedcbaZYXWVUTSRQPONMLKJIHG


                                       T h e setlocale F u n c t i o n GFEDCBA


                                         ch ar       * s e t lo c a le ( in t          categ ory ,             con st          ch ar     * lo c a le ) ;


                 se t lo ca le         Th e s e t l o c a l e f u n ct io n ch an g es t he cu r r en t lo cale , eit h er f o r a sin g le ca t eg o r y
                                       o r f o r all cat eg or ies. I f t he fir st ar g u m en t is on e o f t he m acr os L C _ C O L L A T E ,
                                       L C _ C T Y PE ,     LC_ M O N ET A RY            LC_ N U M ERI C,          or L C _ T I M E,        a ca ll     of    set-
                                       l o c a l e aff ect s o n ly a sin g le cat eg or y . I f t he f ir st ar g u m en t is LC_ _ A LL, t he ca ll
                                       af fect s all cat eg or ies. Th e C st an d ar d d ef in es o n ly t w o v alu es f o r t he seco n d ar g u ­
                                       m ent : " C " and “ " , Ot h e r lo ca les, i f any, d ep en d on t he im p le m en t at io n .
                                             A t t he b e g in n in g o f p r o g r am ex ecu t io n , t he ca ll

                                       setlocale(LC_ALL,                     "C");

                                       o ccu r s b eh in d t he scenes. I n t he ” C ” lo cale, lib r a r y f u n ct io n s b eh av e in t he “ n o r ­
                                       m a l” w ay , and t he d ecim a l p o in t is a p er iod .
                                             Ch a n g in g lo ca le aft er t he p r o g r am has b egu n ex ecu t io n r eq u ir es an e x p lic i t
                                       ca ll o f s e t l o c a l e .       Ca llin g     s e t lo c a le        w it h   ” ”    as t he seco n d ar g u m en t
                                       sw it ch es t o t he n at iv e locale, a llo w in g t he p r o g r a m t o adapt it s b e h a v io r t o t he
                                       lo ca l en v ir o n m en t . Th e C st an d ar d d o e sn T d e f in e t he ex act ef f ect o f s w i t c h in usT t o
                                       t he n at iv e lo cale. So m e im p le m e n t a t io n s o f s e t l o c a l e                 ch e ck t he ex ecu t io n
g e t e n v f u n c t io n > 2 6 . 2   en v ir o n m en t ( in t he sam e w a y as g e t e n v ) f o r an en v ir o n m en t v a r ia b le w it h a p ar ­
                                       t icu la r n am e ( per h ap s t he sam e as t he cat eg or y m acr o) . Ot h e r im p le m e n t a t io n s
                                       d o n ’ t d o an y t h in g at all. ( Th e st an d ar d d o e sn ’ t r eq u ir e s e t l o c a l e            t o h av e any
                                       eff ect . O f cou r se, a lib r a r y w h o se v er sio n o f s e t l o c a l e d oes n o t h in g is n ’ t lik e ly
                                       t o sell t oo w e ll in som e p ar t s o f t he w o r ld . ) RQPONMLKJIHGFEDCBA




                                                                                               L o c a le s

                                       Lo ca le s ot h er t han " C" an d " " v ar y fr om o n e co m p ile r t o an ot h er . Th e G N U C
                                       library, k n ow n a s g l i b c , p r ov id es a " PO S l X " locale, w h ich is t he sa m e a s t he " C"
                                       locale, g l i b c , w h ich is u se d by Lin u x , a llo w s ad d it io n al lo ca le s t o b e in st a lled if
                                       d esir ed . T h e s e lo ca le s h av e t he for m

                                       lan gu ag e [ _t err it or y] [ . cod eset ] [ &m odifier]

                                       w h er e e a ch b r ack et ed it em is op t io n al. Po ssib le v a lu es for lan g u ag e ar e list ed in a
                                       st a n d ar d k n ow n a s I SO 639, t er r it or y com es fr om an o t h er st an d a r d ( I SO 3166 ) , an d
                                       co cf e se t sp e cif ie s a ch a r a ct er set o r an e n co d in g of a ch a r a ct e r set . Her e ar e a f ew
                                       ex am p les:

                                       "swedish"
                                       " e n _ G B " ( En g l i s h - U n i t e d Kin g d om )
                                       " e n _ l E " ( En g lish - I reland)
                                       "fr_CH" ( Fr en ch - Sw it zer lan d )

                                       T h e r e a r e s e v e r a l v a r i a t io n s o n t h e " e n _ i E " locale, in clu d in g " e n _ i E @ e u r o " ( u sin g
                                       t h e e u r o cu r r e n cy ) , " e n _ i E . i s o 8 8 5 9 i " ( u sin g t h e I SO/ I EC8 8 5 9 - 1 ch a r a ct e r se t ) ,
644 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 5    ln te r n a t io n a lF e a t u r e s

                                     " e n _ l E . iso 8 8 5 9 1 5 @ e u ro " (using the ISO/IEC 8859-15 character set and the euro
                    uTF-8>25.2       currency), and " e n _ i E . u t f 8 " (using the UTF-8 encoding o fth e Unicode character
                                     set).
                                           Linux and other versions of UNIX support the l o c a l e com m and, which can be
                                     used to get locale information. One use of the l o c a l e com m and is to get a list of
                                     all available locales, which can be done by entering
                                     lo c a le     -a

                                     at the command line.
                                          B ecause locale information is becoming increasingly important, the Unicode
                                     Consortium created the Common Locale Data Repository (CLDR) project to estab­
                                     lish a standard set of locales. More information about the CLDR project can be
                                               www.unicode.org/cldr/. aZYXWVUTSRQPONMLKJIHGFEDCBA
                                     found at cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           When a call of s e t l o c a l e succeeds, it returns a pointer to a string associ­
                                     ated with the category in the new locale. (The string might be the locale name
                                     itself, for example.) On failure, s e t l o c a l e returns a null pointer.
                                           s e t l o c a l e can also be used as a query function. If its second argument is a
                                     null pointer, s e t l o c a l e returns a pointer to a string associated with the category
                                     in lhe current locale. This feature is especially useful if the first argument is
                                     LC_ALL, since it allows us to fetch the current settings for all categories. A string
                                     returned by s e t l o c a l e can be saved (by copying it into a variable) and then
                          Q&A        used in a latercall o f s e t l o c a l e .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T h e l o c a l e c o n v F u n c tio n

                                       s tru c t        lc o n v   * lo c a le c o n v (v o id );

                  localeconv         Although we can ask s e t l o c a l e about the current locale, the information that it
                                     returns isn't necessarily in the most useful form. To find out highly specific infor­
                                     mation about the current locale (W hafs the decim al-point character? W hat's the
                                     currency symbol?), we need l o c a l e c o n v . the only other function declared in
                                     < l o c a l e . h>.
                                           l o c a l e c o n v returns a pointer to a structure of type s t r u c t l c o n v . The
                                     members of this structure contain detailed information about the current locale.
                                     The structure has static storage duration and may be modified by a later call of
                                     l o c a l e c o n v or s e t l o c a l e . Be sure to extract the desired information from
                                     the l c o n v structure before it's wiped out by one of these functions.
                                           Some members of the l c o n v structure have c h a r * type; other members
                                     have c h a r type. Table 25.l lists the c h a r * members. The first three members
                                     describe the formatting of nonmonetary quantities, while the others deal with mon­
                                     etary quantities. The table also shows the value o fea ch member in the ” C ” locale
                                     (the default); a value of ” " means iknot available."
                                           The g r o u p i n g and m o n _ g r o u p i n g mem bers deserve special mention.
                                                                 2 5 .1                                                                      6 4 5 dcbaZYXWVUTSR
                                                                           T he < l o c a l e . h > H e a d e r: L o c a liz a tio n hgfedcbaZYXWVUTSRQPONMLKJI


          T a b le 2 5 .1 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA           Value in kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
c h a r * M embers of                             N am e                     "C" L ocale                        D escrip tio n
     l c o n v Structure cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 ^^ decimal_pointGFEDCBA                            ii      ii
                                                                                                      Decim al-point character
                                £ thousands_sep                                      H ii
                                                                                                      C haracter used lo separate groups of
                                C 4U
                                ^*S
                                e>                                                                    digits before decimal pointaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    ‘w
                                    ^
                                     grouping
                                    ^ .
                                    «^
                                                                                     ii H
                                                                                                      Sizes o fd ig it groups
                                    c
                                ^




                                            mon_decimal_point                        ii ii
                                                                                                      D eci ma l-poi nt character
                                                                                     H H
                                            mon_thou sands_s ep                                       Character used to separate groups of
                                    c^                                                                digits before decimal point
                                ^ J         mon_grouping                             ii H
                                                                                                      Sizes o f digit groups
                                 *•                                                  H H
                                ^5          positive_sign                                             String indicating nonnegative quantity
                                O ^
                                            negative_sign                            ii ti
                                                                                                      String indicating negative quantity
                                            currency_symbol                          ii H
                                                                                                      Local currency symbol
                                            int_curr_symbol                          H H              International currency sym bol 1
                                        'A thrce-lciicr abbreviation followed by a separator (often a spacc or a period). F orcxaniplc, thc
                                        international currency symbols for Switzerland, the United Kingdom, and the United States are
                                        "CHF " ." G B P " ,a n d " U S D ".respectively.

                             Each character in these strings specifies the size o fo n e group o fd ig its. (G rouping
                             takes place from right to left, starting at the decim al point.) A value ofCHAR_MAX
                             indicates that no further grouping is to be perform ed; 0 indicates that the previous
                             elem ent should be used for the rem aining digits. For exam ple, the string " \ 3 ” ( \ 3
                             followed by \ 0 ) indicates that the first group should have 3 digits, then all other
                             digits should be grouped in 3\s as well.
                                  The c h a r members of the l c o n v structure are divided into two groups. The
                             m em bers of the first group (Table 25.2) affect the local form atting o f m onetary
                             quantities. The m em bers of the second group (Table 25.3) affect the in tern a tio n a l
                  C 99       form atting of monetary quantities. All but one of the m em bers in Table 25.3 were
                             added in C99. As Tables 25.2 and 25.3 show, the value o f each c h a r m em ber in
                             the "C" locale is CHAR_MAX, which means “not available.”

          T a b le 2 5 .2                                              Value in
 c h a r M embers o f                           N am e                ”C " Locale                               D escrip tio n
   l c o n v Structure                  frac_digits                   CHAR_MAX               Num ber o f digits after decim al point
 (Local Form atting)                    p_cs_precedes                 CHAR_MAX               1 if c u r r e n c y _ s y m b o l precedes
                                                                                             nonncgative quantity; 0 if it succeeds quantity
                                        n_cs_precedes                 CHAR_MAX               1 if c u r r e n c y _ s y m b o l precedes negative
                                                                                             quantity; 0 if it succeeds quantity
                                        p_sep_by_space                CHAR_MAX               Separation of c u r r e n c y _ s y m b o l and sign
                                                                                             siring from nonnegative quantity (see Table
                                                                                             25.4)
                                        n_sep_by_space                CHAR_MAX               Separation o f c u r r e n c y _ s y m b o l and sign
                                                                                             siring from negative quantity (see Table 25.4)
                                     p_sign_posn                      CHAR_MAX               Position o f p o s i t i v e _ s i g n for
                                                                                             nonnegalive quantity (see Table 25.5)
                                        n_sign_posn                   CHAR_MAX               Position of n e g a t i v e _ s i g n for negative
                                                                                             quantity (scc Table 25.5)
6 4 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 5    In te rn a tio n a l F e a tu r e s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                   T a b le 2 5 .3 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                V a lu e in
        c h a r Members of                                N am e                          ” C ” L o c a le                     D e s c r ip tio n
          l c o n v Structure              int_frac_digits                            C H A R _M A X            Number ofdigits after decimal point
(International Formatting)                 int_p_cs_precedes*                         C H A R _M A X            1 i f i n t _ c u r r _ s y m b o l precedes
                                                                                                                nonnegative quantity: 0 if it succeeds
                                                             t                                                  quantity
                                           int_n_cs_precedes'                         C H A R _M A X            1 if i n t _ c u r r _ s y m b o l precedes
                                                                                                                negative quantity; 0 if i( succeeds
                                                              I                                                 quantity
                                           int_p_sep_by_space"                        C H A R _M A X            Separation o f i n t _ c u r r _ s y m b o l
                                                                                                                and sign string from nonncgative
                                                                                                                quantity (see Table 25.4)
                                           int_n_sep_by_space*                        C H A R _M A X            Separation o f i n t _ c u r r _ s y m b o l
                                                                                                                and sign string from negative quantity
                                                                                                                (see Table 25.4)
                                           int_p_sign_posn*                           C H A R _M A X            Position of p o s i t i v e _ s i g n lbr
                                                           ♦                                                    nonnegative quantity (see Table 25.5)
                                           int_n_sign_posn'                           C H A R _M A X            Position of n e g a t i v e _ s i g n for
                                                                                                                negative quantity (see Table 25.5)
                                           f C99   o n ly cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                            Table 25.4 explains the meaning of the values of the p _ s e p _ b y _ s p a c e .
                                      n _ s e p _ b y _ s p a c e , i n t _ p _ s e p _ b y _ s p a c e . and i n t _ n _ s e p _ b y _ s p a c e
                         <*ffi>       members. The meaning of p _ s e p _ b y _ s p a c e and n _ s e p _ b y _ s p a c e has
                                      changed in C99. In C89, there are only two possible values for these members: I
                                      (if there’s a space between c u r r e n c y _ s y m b o l and a monetary quantity) or 0 (if
                                      there's not).

                   T a b le 2 5 .4             V a lu e                                                   M e a n in g
                Values of kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                         0        No space separates currency symbol and quantity.
        ...sep_by_space                  1        lf currency symbol and sign are adjacent, a space separates them from
                Members                           quantity; otherwise, a space separates currency symbol from quantity.
                                         2        Ifcurrency symbol and sign are adjacent, a space separates them;
                                                  otherwise, a space separates sign from quantity.

                                            Table 25.5 explains the meaning of the values of the p _ s i g n _ p o s n ,
                                      n _ s i g n _ p o s n . i n t _ p _ s i g n _ p o s n and i n t _ n _ s i g n _ p o s n members.

                   T a b le 2 5 .5                          V a lu e                                      M e a n in g
                   Values of                                   0        Parentheses surround quantity and currency symbol
              ...sign_posn                                     1        Sign precedes quantity and currency symbol
                  Members                                      2        Sign succeeds quantity and cunency symbol
                                                               3        Sign immediately precedes currency symbol
                                                               4        Sign immediately succeeds currency symbol

                                            To see how the members of the l c o n v structure might vaiy from one locale lo
                                      another, let’s look at two examples. Table 25.6 shows typical values o fth e monetary
                                      l c o n v members for the U.S.A, and Finland (which uses the euro as its currency).
                                                           2 5 .2                                                                         647dcbaZYXWVU
                                                                     M u ltib y te C h a ra c te rs a n d W id e C h a ra c te rs kjihgfedcbaZYXWVUTSRQPONM


         T a b le 2 5 .6 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   M em ber                       U .S .A .   F in la n d
 Typical Values of                                       m o n _ d e c im a l_ p o in t            n n             n/ n
 Monetary l c o n v                                      m o n _ th o u s a n d s _ s e p          n/ n            n n
      M em bers for                                      m o n _ g ro u p in g                     " \3 "          n\ 3 n
U.S.A, and Finland RQPONMLKJIHGFEDCBA                                                                              nn
                                                         p o s i t i v e _ s i g n hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                               II   II



                                                         n e g a tiv e _ s ig n                II _      II        ii _ n
                                                         c u rre n c y _ sy m b o l                "$"             " EUR"
                                                         fra c _ d ig its                          2               2
                                                         P _ c s _ P r e c e < ^e s                1               0
                                                         n _ c s_ p re c e d e s                   1               0
                                                         p_sep_by_space                            0               2
                                                         n_sep_by_space                            0               2
                                                         p _ s ig n _ p o s n                      1               1
                                                         n _ s ig n _ p o s n                      1               1
                                                         in t_ _ c u rr_ s y m b o l               "USD "          "EUR "
                                                         in t_ fra c _ d ig its                    2               2
                                                         in t_ p _ c s _ p re c e d e s            1               0
                                                         in t_ n _ c s _ p re c e d e s            1               0
                                                         i n t_ p _ s ep _ b y _ s p a c e         1               2
                                                         in t_ n _ s e p _ b y _ s p a c e         1               2
                                                         in t_ p _ s ig n _ p o s n                1               1
                                                         in t_ n _ s ig n _ p o s n                1               1

                                  H ere’s how the monetary quantity 7593.86 would be formatted in the two
                             locales, depending on the sign of the quantity and w hether the form atting is local
                             or international:

                                                                                        U.S.A.                Finland
                             Local form at (positive)                               $7,593.86            7 593,86                   EUR
                             Local form at (negative)                              -$7,593.86       - 7 593,86                      EUR
                             International form at (positive)                    USD 7,593.86            7 593,86                   EUR
                             International form at (negative)                   -USD 7,593.86PONMLKJIHGFEDCBA
                                                                                                    - 7 593,86                      EUR

                             Keep in mind that none o f C ’s library functions are able to form at m onetary quan­
                             tities automatically. It’s up to the program m er to use the inform ation in the l c o n v
                             structure to accomplish the form atting.aZYXWVUTSRQPONMLKJIHGFEDCBA




             2 5 .2          M u lt ib y t e C h a r a c t e r s a n d W id e C h a r a c t e r s

                             O ne of the biggest problems in adapting program s to different locales is the char-
          Latin-i >7.3       acter-set issue. ASCII and its extensions, which include L atin -l, are the m ost pop­
                             ular character sets in North America. Elsewhere, the situation is more com plicated.
                             In many countries, com puters employ character sets that are sim ilar to ASCII, but
                             lack certain characters; w e’ll discuss this issue further in Section 25.3. O ther coun­
                             tries, especially those in Asia, face a different problem: written languages that
                             require a very large character set, usually num bering in the thousands.
6 4 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 5    In te rn a tio n a l F e a tu re s aZYXWVUTSRQPONMLKJIHGFEDCBA


                                              Changing the m eaning o f type c h a r to handle larger character sets isn’t pos­
                                      sible. since c h a r values are— by definition— lim ited to single bytes. Instead, C
                                                                         e x te n d e d c h a ra c te r set. This character set may be
                                      allows com pilers to provide an cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      used for writing C program s (in com m ents and strings, for exam ple), in the envi­
                                      ronm ent in which the program is run. or in both places. C provides two techniques
                                      for encoding an extended character set: m ultibyte characters and wide characters.
                         Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      It also supplies functions that convert from one kind o fen co d in g to the other.dcbaZYXWVUTSRQPO


                                    M u ltib y te C h a r a c te r s
                                    In a m u ltib y te c h a ra c te r encoding, each extended character is represented by a
                                    sequence o f one or more bytes. The num ber of bytes may vary, depending on the
                                    character. C requires that any extended character set include certain essential char­
                                    acters (letters, digits, operators, punctuation, and w hite-space characters); these
                                    characters must be single bytes. O ther bytes can be interpreted as the beginning of
                                    a m ultibyte character.RQPONMLKJIHGFEDCBA



                                                                       J a p a n e s e C h a r a c te r S e ts

                                    The Ja p a n e se employ several different writing system s. The m ost complex, kanji,
                                    consists of th ousands of sym bols—far too many to represent in a one-byte encod­
                                    ing. (Kany/symbols actually com e from C hinese, which has a similar problem with
                                    large character sets.) T here’s no single way to encode kanji\ common encodings
                                    include JIS (Jap an ese Industrial Standard), Shift-JIS (the most popular encoding),
                                    and EUC (Extended UNIX Code).


                                         Som e m ultibyte character sets rely on a sta te -d e p e n d e n t en c o d in g , In this
                                    kind o fen co d in g , each sequence o f m ultibyte characters begins in an in itia ls h ift
                                    state. Certain bytes encountered later (known as a s h i f t se q u en c e} may change the
                                    shift state, affecting the meaning of subsequent bytes. Japan’s JIS encoding, for
                                    exam ple, mixes one-bytc codes with two-byte codes; “escape sequences” em bed­
                                    ded in strings indicate when to switch betw een one-byte and tw o-byte modes, (ln
                                    contrast, the Shift-JIS encoding is not state-dependent. Each character requires
                                    either one or two bytes, but the first byte o f a tw o-byte character can always be dis­
                                    tinguished from a one-byte character.)
                                         In any encoding, the C standard requires that a zero byte always represent a
                                    null character, regardless of shift stale. Also, a zero byte can ’t be the second (or
                                    later) byte o f a multibyte character.
                                         The C library provides two m acros, MB_LEN_MAX and MB_CUR_MAX. that
                                    are related to m ultibyte characters. Both macros specify the m axim um num ber of
                                    bytes in a m ultibyte character. MB__LEN_MAX (defined in < l i m i t s . h > ) gives the
                                    m axim um for any supported locale; MB_CUR_MAX (defined in < s t d l i b . h > )
                                    gives the m aximum for the current locale. (Changing locales may affect the inter­
                                    pretation of muItibyte characters.) Obviously, MB_CUR_MAX can ’t be larger than
                                    MB_LEN_MAX.
                            2 5 .2                                                                           649 aZYXWVUTSRQPO
                                      M u ltib y te C h a ra c te rs a n d W id e C h a ra c te rs onmlkjihgfedcbaZYXWVUTSRQPONML


              Any string may contain multibyte characters, although the length o f such a
      string (as determ ined by the s t r l e n function) is the number o fb y tes in the string,
      not the number o f characters. In particular, the form at strings in calls of the
      . . . p r i n t f and ...s c a n f functions may contain mullibyte characters. As a result,
C99                                              m u ltib y te strin g to be a synonym for string. dcbaZYXWVUTSRQPONMLK
      the C99 standard defines the term cbaZYXWVUTSRQPONMLKJIHGFEDCBA

      W id e C h a r a c te r s
      The other way lo encode an extended character set is to use wide characters. A
      wide ch a ra cter is an integer whose value represents a character. Unlike multibyte
      characters, which may vary in length, ail wide characters supported by a particular
      implementation require the same number of bytes. A wide sirin g is a string con­
      sisting of wide characters, with a null wide character at the end. (A n u ll wide c h a r­
      acter is a wide character whose numerical value is zero.)
            Wide characters have the type w c h a r _ t (declared in < s t d d e f . h > and cer­
      tain other headers), which must be an integer type able to represent the largest
      extended character set for any supported locale. For example, if two bytes are
      enough to represent any extended character set, then w c h a r _ t could be defined
      as u n s i g n e d s h o r t i n t .
            C supports both wide character constants and wide string literals. W ide char­
      acter constants resemble ordinary character constants but are prefixed by the letter
      L:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

      L'a 1

      Wide string literals are also prefixed by L:
      L"abc"
      This string represents an array containing the wide characters L ' a 1 . L 1 b ' . and
      L ' c 1 , followed by a null wide character.

      U n ic o d e a n d th e U n iv e r s a l C h a r a c te r S e t
      The differences between mullibyte characters and wide characters become appar­
      ent when discussing U nicode. Unicode is an enormous character set developed by
      the Unicode Consortium, an organization established by a group ofco m p u ter man­
      ufacturers to create an international character set for com puter use. The first 256
      characters of Unicode are identical to Latin-1 (and therefore the first 128 charac­
      ters of Unicode match the ASCII character set). However, Unicode goes far
      beyond Latin-1, providing the characters needed for nearly all modern and ancient
      languages. Unicode also includes a number of specialized symbols, such as those
      used in mathematics and music. The U nicodestandard was first published in 1991.
           Unicode is closely related to international standard ISO/IEC 10646, which
      defines a character encoding known as the U niversal C h a ra cter S e t (U C S). UCS
      was developed by the kiternational Organization for Standardization (lSO). start­
      ing al aboul the same time that Unicode was initially defined. Although UCS orig­
      inally differed from Unicode, the two character sets were later unified. ISO now
6 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 5   In te r n a tio n a l F e a tu re s aZYXWVUTSRQPONMLKJIHGFEDCBA


                                       works closely with the Unicode Consortium to ensure that ISO/IEC 10646 reinains
                                       consistent with Unicode. Because Unicode and UCS are so similar. I ’ll use the two
                          Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       terms interchangeably.
                                                Unicode was originally limited to 65.536 characters (the num ber ofcharacters
                                       that can be represented using 16 bits). That limit was later found to be insufficient;
                                       Unicode currently has over 100.000 characters. (For the most recent version, visitcbaZYXWVU
                                       w w w .unicode.org.) The first 65,536 characters of Unicode— which include the
                                       most frequently used characters— are known as the B asic M u ltilin g u a l Plane
                                       (B M P ). dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      E n c o d in g s o f U n ic o d e

                                      Unicode assigns a unique number (known as a code p o in t) to each character. There
                                      are a number of ways to represent these code points using bytes: I’ll mention two
                                      of the sim pler techniques. One of these encodings uses wide characters; the other
                                      uses multibyte characters.
                                           U C S-2 is a wide-character encoding in which each Unicode code point is
                                      stored as two bytes. UCS-2 can represent all the characters in the Basic Multilin­
                                      gual Plane (those with code points between 0000 and FFFF in hexadecim al), but it
                                      is unable to represent Unicode characters that d o n 't belong to the BMP.
                                           A popular alternative is the 8-bit U C S T ra n sfo rm a tio n F o rm a t (U TF -8).
                                      which uses multibyte characters. UTF-8 was devised by Ken Thompson and his
                                      Bell Labs colleague Rob Pike in 1992. (Yes, that's the same Ken Thom pson who
                                      designed the B language, the p red ecesso ro fC .) UTF-8 has the useful property that
                                      ASCII characters look identical in UTF-8: each character is one byte and has the
                                      same binary encoding. Thus, software designed to read UTF-8 data can also handle
                                      ASCII data with no change. For these reasons, UTF-8 is widely used on the Inter­
                                      net for text-based applications such as web pages and email.
                                           In UTF-8. each code point requires between one and four bytes. UTF-8 is
                                      organized so that the most commonly used characters require fewer bytes, as
                                      shown in Table 25.7.

                   T a b le 2 5 .7               C o d e P o in t R a n g e                 U T F -8 B y te S e q u e n c e
           U T F -8 E n co d in g RQPONMLKJIHGFEDCBA
                                                  (H e x a d e c im a l)                             ( B i n a r y ) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 000000-00007F                0xxxxxxx
                                                 000080-0007FF                110xxxxx 10xxxxxx
                                                 000800-00FFFF                1110xxxx 10xxxxxx 10xxxxxx
                                                 010000-10FFFF                11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

                                           UTF-8 takes the bits in the code point value, divides them into groups (repre­
                                      sented by the x 's in Table 25.7), and assigns each group to a different byte. The
                                      simplest case is a code point in the range 0 -7 F (an ASCII character), which is rep­
                                      resented by a 0 followed by the seven bits in the original number.
                                           A code point in the range 80-7FF (which includes all the Latin-1 characters)
                                      would have its bits split into groups of five bits and six bits. The five-bit group is
                                2 5 .2                                                                            651 onmlkjihgfedcbaZY
                                         M u ltib y te C h a r a c te rs a n d W id e C h a r a c te r s hgfedcbaZYXWVUTSRQPONMLKJ


prefixed by I lO and the six-bit group is prefixed by l0. For example, the code
point for the character RQPONMLKJIHGFEDCBA
                        a is E4 (hexadecimal) or l 1100100 (binary). In UTF-8, il
would be represented by the two-byte sequence 11000011 10100100. Note how
the underlined portions, w henjoined together, spell out 00011100100.
     Characters whose code points fall in the range 800-FFFF, which includes the
remaining characters in the Basic Multilingual Plane, require three bytes. All other
Unicode characters (most of them rarely used) are assigned four bytes.
     UTF-8 has a num berofuseful properties:

         ■       Each of the 128 ASCII characters is represented by one byte. A string consist­
                 ing solely ofA S C lI characters looks exactly the same in UTF-8.
     ■           Any byte in a UTF-8 string whose leftmost bit is 0 must be an ASCfl charac­
                 ter, because all other bytes begin with a 1 bit.
 ■               The first byte o fa multibyte character indicates how long the character will be.
                 If the number of I bits at the beginning o f the byte is two, the character is two
                 bytes long. If the number of I bits is three or four, the character is three or four
                 bytes long, respectively.
             ■   Every other byte in a multibyte sequence has 10 as its leftmost bits.
The last three properties are especially important, because they guarantee that no
sequence ofbytes within a niultibyte character can possibly represent another valid
multibyte character. This makes it possible to search a multibyte string for a partic­
ular character or sequence ofcharaclers by simply doing byte comparisons.
     So how does UTF-8 stack up against UCS-2? UCS-2 has the advantage that
characters are stored in their most natural form. On the other hand, UTF-8 can han­
dle all Unicode characters (not just those in the BMP), often requires less space
than UCS-2, and retains compatibility with ASCII. UCS-2 isn’t nearly as popular
as UTF-8, although it was used in the Windows NT operating system. A newer
version that uses four bytes f U C S - 4 ) is gradually taking its place. Some system s
extend UCS-2 into a multibyte encoding by allowing a variable num ber of byte
pairs to represent a character (unlike UCS-2. which uses a single byte pair per
character). This encoding, known as U T F - 1 6 . has the advantage that it’s com pati­
ble with UCS-2.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


M u ltib y te A V id e -C h a r a c te r C o n v e r sio n F u n c tio n s

 i n t m b le n (c o n s t c h a r * s, s i z e _ t n ) ;                                /h w t< s td lib .h >
                                     r e s t r i c t pw c,
 i n t m b t o w c ( w c h a r t * cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                   const char * r e s tr ic t s,
                   s iz e _ t n ) ;                                                      fro m < s t d l i b . h >
 i n t w c to m b (c h a r * s , w c h a r t w c );                                      fr o m <s t d l i b . h>

Although the C89 standard introduced the concepts o f multibyte characters and
wide characters, it provides only five functions for working with these kinds of
652ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 2 5     In te rn a tio n a l F e a tu re s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     characters. We’ll now describe these functions, which belonog to die < s t d l i b . h>
                                     header. C99’s < w c h a r .h > and < w c ty p e .h > headers, which are discussed in
                                     Sections 25.5 and 25.6, supply a number ofadditional multibyte and wide-character
                                     functions.
                                           C89's mullibyte/wide-character functions are divided into two groups. The
                                     first group converts single characters from multibyte form to wide form and vice
                                     versa. The behavior ofthese functions depends on the LC_CTYPE category of the
                                     current locale. If the multibyte encoding is state-dependent, the behavior also
                                                               conversion state. The conversion state consists of the cur­
                                     depends on the current cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     rent shift state as weII as the current position within a multibyte character. Calling
                                     any of these functions with a null pointer as the value of its c h a r * parameter
                                     sets the function's internal conversion state to the initial conversion state, signify­
                                     ing thai no multibyte character is yel in progress and that the initial shift state is
                                     in effect. Later calls of the function cause its internal conversion state to be
                                     updated.
                         mblen             The m b le n function checks whether its first argument points to a series of
                                     bytes lhat form a valid multibyte character. Ifso , the function returns the number
                                     of bytes in the character; if not, it returns-1. As a special case, m b le n returns 0 if
                                     the first argument points to a null character. The second argument limits the num­
                                     ber of bytes that m b le n will examine; typically, w e’lI pass MB_CUR_MAX.
                                           The following function, which comes from P. J. Plauger’s The Standard C
                                     Lihrary\ uses m b le n to determine whether a string consists of valid multibyte
                                     characters. The function returns zero if s points to a valid string.

                                     int mbcheck(const char *s)

                                          int n;

                                          for (mblen(NULL, 0); ; s += n)
                                            if ((n = mblen(s, MB_CUR_MAX))                              <= 0)
                                              return n;
                                      }

                                     Two aspects of the m b c h e c k function deserve special mention. First, there’s the
                                     mysterious call m b le n (NULL, 0 ) , which sets m b l e n ’s internal conversion state
                                     to the initial conversion state (in case the multibyte encoding is stale-dependent).
                                     Second, there’s the matter of termination. Keep in mind that s points to an ordi­
                                     nary character string, which is assumed to end with a null character, m b le n will
                                     return zero when it reaches this null character, causingC7 m b c h e c k to return.
                                     m b c h e c k will return sooner i f m b le n relum s-1 because o fa n invalid multibyte
                                     character.
                      mbtowc              The m b to w c function converts a multibyte character (pointed to by the sec­
                                     ond argument) into a wide character. The first argument points to a w c h a r _ t vari­
                                     able into which the function will store the result. The third arogument limits the
                                     number of bytes dial m b to w c will examine, m b to w c returns the same value as
                                     m b le n : the number of bytes in the multibyte character if it’s valid, -1 if it’s not,
                                     and zero if the second argument points lo a null character.
                                  2 5 .2                                                                        6 5 3 onmlkjihgfedcbaZYX
                                           M u ltib y te C h a ra c te rs a n d W id e C h a ra c te rs hgfedcbaZYXWVUTSRQPONMLKJIH


 wctomb         The w cto m b function converts a wide character (the second argument) into a
           multibyte character, which it stores into the array pointed to by the first argument,
           w cto m b may store as many as MB_LEN_MAX characters in the array, but doesn’t
           append a null character, w c to m b returns the number of bytes in the multibyte
           character or -1 if the wide character doesn’t correspond to any valid multibyte
           character. (Note that w cto m b returns 1 ifasked to convert a null wide character.)
                                                                            The Standard C Library) uses
                The following function (also from Plauger’s cbaZYXWVUTSRQPONMLKJIHGFEDCBA
           w cto m b to determine whether a string of wide characters can be converted to
           valid mullibyte characters:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           int wccheck(wchar_t *wcs)

              char buf[MB_LEN_MAX];
              int n ;

              for (wctomb(NULL, 0); ; ++wcs)
                if ((n = wctomb(buf, *wcs)) <= 0)
                  return -1;              /* invalid character */
                else if (buf[n-l] == ’\0’)
                  return 0;               /* all characters are valid */


               Incidentally, all three functions— m b le n , m b to w c, and w c to m b — can be
           used to test whether a multibyte encoding is state-dependent. When passed a null
           pointeras its c h a r * argument, each function returns a nonzero value ifm ultibyte
           characters have state-dependent encodings or zero if they don't.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


           M u ltib y te A V id e -S t r in g C o n v e r s io n F u n c t io n s

             s i z e _ t m b s to w c s (w c h a r_ t * r e s t r i c t p w cs,
                                         c o n s t chax~ * r e s t r i c t s ,
                                         s iz e _ t n );                        /r o /n < s td lib .h >
             s i z e _ t w c s to m b s (c h a r * r e s t r i c t s ,
                                         c o n s t w c h a r_ t * r e s t r i c t p w cs,
                                         s iz e _ t n );                        /r c w ? < s td lib .h >

           The remaining C89 multibyte/wide-character functions convert a string containing
           multibyte characters to a wide-character string and vice versa. How the conversion
           is performed depends on the LC_CTYPE category o fth e current locale.
mbstowcs        The m b s to w c s function converts a sequence of multibyte characters into
           wide characters. The second argument points to an array containing the multibyte
           characters to be converted. The first argument points to a wide-character array: the
           third argument limits the number of wide characters that can be stored in the array,
           m b s to w c s stops when it reaches the limit or encounters a null character (which it
           stores in the wide-character array). It returns the number of array elements modi­
           fied, not including the terminating null wide character, if any. m b s to w c s returns
           -1 (cast to type s i z e _ t ) if it encounters an invalid multibyte character.
            C h a p te r2 5
6 5 4 ZYXWVUTSRQPONMLKJIHGFEDCBAln t e r n a t io n a lF e a t u r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                    wcstom bs                The w c s to m b s function is the opposite of m b s to w c s : it converts a
                                       sequence o fw id e characters into muItibyte characters. The second argument points
                                       to the wide-character string. The first argument points to the array in which the
                                       muItibyte characters are to be stored. The third argum ent limits the num ber of
                                       bytes that can be stored in the array, w c s to m b s stops when it reaches the limit or
                                       encounters a null character (which il stores). It returns the num ber o fb y tes stored,
                                       not including the term inating null character, ifany. w c s t o m b s returns - I (cast to
                                       type s i z e _ t ) if it encounters a wide character that doesn’t correspond to any
                                       muItibyte character.
                                             The m b s to w c s function assumes that the string^^ to be converted be tg^ins in the
                                       initial shift state. The string created by w c s to m b s always begins in the initial
                                       shift state.aZYXWVUTSRQPONMLKJIHGFEDCBA




                         2 5 .3         D ig r a p h s a n d T r ig r a p h s

                                       Programm ers in certain countries have traditionally had trouble entering C pro­
                                       gram s because their keyboards lacked som e of the characters that are required by C.
                                       This has been especially true in Europe, where older keyboards provided the accent­
                                       ed characters used in European languages in place o f the characters that C needs,
                                       such as #, [, \ , ] . ^. {, |, }. and ~, C89 introduced trigraphs— three-character
                                       codes that represent problem atic characters— as a solution to this problem. Tri­
                                       graphs proved to be unpopular, however, so Amendment I to the standard added
                                       two improvements: digraphs, which are more readable than trigraphs, and the
                                       < i s o 6 4 6 . h> header, which defines macros that represent certain C operators.dcbaZYXWVUTSR


                                       T r ig r a p h s

                                          t r i g r a p h s e q u e n c e (or simply, a t r i g r a p h ) is a three-character code that can be
                                       A RQPONMLKJIHGFEDCBA
                                       used as an alternative to an ASCH character. Table 25.8 gives a com plete list of tri­
                                       graphs. All trigraphs begin with ? ? . which makes them, if not exactly attractive, at
                                       least easy to spot.

                    T a b le 2 5 .8                                                 Trigraph            A S C II
        Trigraph Sequences cbaZYXWVUTSRQPONMLKJIHGFEDCBA                            Sequence          Equivalent
                                                                                        9 9
                                                                                        • •   =             #
                                                                                                                    [
                                                                                        9 9       (
                                                                                                            \
                                                                                        9 9   /

                                                                                                            ]
                                                                                        9 ? )
                                                                                                            ^           \
                                                                                        9 9       •
                                                                                                                        »


                                                                                        ? ? <
                                                                                                                        .


                                                                                        9 9       I
                                                                                                                ’

                                                                                        ? ? >

                                                                                        ? ? “               ^ r
                                                             2 5 .3                                               6 5 5 onmlkjihgfedcbaZ
                                                                      D ig ra p h s a n d T rig ra p h s hgfedcbaZYXWVUTSRQPONMLK


                       Trigraphs can be freely substituted for their ASCII equivalents. For example,
                  the program kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  #include <stdio.h>

                  int main(void)

                     printf("hello, world\n");
                     return 0;


                  could be written

                  ??=include <stdio.h>

                  int main(void)
                  ??<
                    printf("hello, world??/n");
                    return 0;
                  ??>

                      Compilers that conform to the C89 or C99 standards are required to accept tri­
                  graphs, even though they’re rarely used. Occasionally, this feature can cause prob­
                  lems.


                  Be careful about putting ?? in a string literal— it’s possible that the compiler will
                  treat it as the beginning o fatrigraph. Ifthis should happen, turn the second ? char­
                  acter into an escape sequence by preceding it with a \ character. The resulting ? \ ?
                  combination can't be mistaken for the beginning o fa trigraph.aZYXWVUTSRQPONMLKJIHGFEDCBA



                  D ig r a p h s

                          Acknowledging that trigraphs are difficult to read. Amendment 1 to the C89 stan­
                                                                          digraphs. As the name implies, a
                         dard added an alternative notation known as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                         digraph requiresjust two characters instead of three. Digraphs are available as sub­
                         stitutes for the six tokens shown in Table 25.9.
              > 2 .8dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
  t o k e n s BA




T a b le 2 5 .9
  Digraphs




                      Digraphs— unlike trigraphs— are token substitutes, not character substitutes.
                  Thus, digraphs won’t be recognized inside a string literal or character constant. For
                  example, the string "< : : >" has length four; il contains the characters: <, •., :,
656 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 2 5    In te r n a tio n a l F e a tu re s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      and >, not the characters [ and ] . In contrast, the string " ? ? ( ? ? ) " has length
                                      two, because the com piler replaces the trigraph ? ? ( by ihe character [ and the tri­
                                      graph ? ? ) by the character ] .
                                            Digraphs are more limited than trigraphs. First; as w e’ve seen, digraphs are of
                                      no use inside a string literal or character constant; trigraphs are still needed in these
                                      situations. Second, digraphs don’t solve the problem ofproviding alternate repre­
                                      sentations for the characters \ , ^. | , and ~. The < i s o 6 4 6 .h > header, described
                                      ne,xt, helps with this problem.


                          <%E>        T h e < i s o 6 4 6 . h > H e a d e r : A lte r n a tiv e S p e llin g s

                                      The < i s o 6 4 6 .h > header is quite simple. Tt contains nothing but the definitions
                                      of the eleven macros shown in Table 25.10. Each macro represents a C operator
                                      that contains one of the characters &. | , ~. !. or ^, making it possible to use the
                                      operators listed in the table even when these characters are absent from the key­
                                      board.

                  T a b le 2 5 .1 0                                                 M acro         V a lu e
          Macros Defined in kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                    and
              <iso646.h>RQPONMLKJIHGFEDCBA                                         and_eq
                                                                                   bitand
                                                                                    bitor
                                                                                    compl
                                                                                     not
                                                                                   not_eq
                                                                                      or
                                                                                    or_eq
                                                                                     xor
                                                                                   xor eq

                                           The name of the header comes from ISO/IEC 646, an older standard for an
                                      ASCTT-like character set. This standard allows for “national variants,” in which
                                      countries substitute local characters for certain ASC11 characters, thereby causing
                                      the problem that digraphs and the < i s o 6 4 6 . h> header are trying to solve.aZYXWVUTSRQPON




                        2 5 .4        U n iv e r s a l C h a r a c t e r N a m e s ( C 9 9 )

                                      Section 25.2 discussed the Universal Character Set (UCS), which is closely related
                                      to Unicode. C99 provides a special feature, u n i v e r s a l c h a r a c t e r n a m e s , that allows
                                      us to use UCS characters in the source code o f a program.
                                            A universal character name resembles an escape sequence. However, unlike
                                      ordinary escape sequences, which can appear only in character constants and string
                                      literals, universal character names may also be used in identifiers. This feature
                                      allows programmers to use their native languages when defining names for vari­
                                      ables. functions, and the like.
                                                            2 5 .5                                                         657onmlkjihgfedcbaZYXWV
                                                                     T h e < w c h a r , h > H e a d e r ( C 9 9 ) kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


                                                                                                        ( \u d d d d and
                                 There arc two ways to write a universal character name cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                           \U dddddddd), where each d is a hexadecimal digit. In the form \X klddddddd, the
                           rf’s form an eight-digit hexadecimal number that identifies the UCS code point of
                           the desired character. The form \vtd d d d can be used for characters whose code
                           points have hexadecimal values of FFFF or less, which includes all characters in
                           the Basic Multiling<^ual Plane.
                                 For example, the UCS code point for the Greek letter £ is 000003B2, so the
                           universal character name for this character is \U 0 0 0 0 0 3 B 2 (or \U 0 0 0 0 0 3 b 2 ,
                           since the case ofhexadecim al digits doesn't matter). Because the first four hexa­
                           decimal digits of the UCS code point are 0, we can also use the \ u notation, writ­
                           ing the character as \uO 3B 2 or \u O 3 b 2 . The code point values for UCS (which
                           match those for Unicode) can be found at www.unicode.org/charts/.
                                 Not all universal character names may be used in identifiers; the C99 standard
                           contains a list of which ones are allowed. Also, an identifier may not begin with a
                           universal character name that represents a digit.aZYXWVUTSRQPONMLKJIHGFEDCBA




           2 5 .5          T h e < w c h a r .h > H e a d e r (C 9 9 )
                           E x t e n d e d M u ltib y t e a n d W id e - C h a r a c t e r U t ilit ie s

                           The < w c h a r .h > header provides functions for wide-character input/output and
                           wide-string manipulation. The vast majority of functions in < w c h a r .h > are
                           wide-character versions of functions from other headers (primarily < s t d i o . h >
                           and < s t r i n g . h>).
                               The < w c h a r . h> header declares several types and macros, including the fol­
                           lowing:
                            ■ m b s t a t e _ t — A value of this type can bc used to s tore the conversion state
                               when a sequence of multibyte characters is converted to a sequence of wide
                               characters or vicc versa.
                            ■ w   i n t _ t — An integer type whose values represent extended characters.
                            ■ WEOF — A macro representing a w i n t _ t value that’s different from any
E O F m a c r o > 2 2 .2       extended character. WEOF is used in much the same way as EOF, typically to
                               indicate an error or end-of-file condition.
                                 Note that < w c h a r . h> provides functions for wide characters but not multi­
                           byte characters. That’s because C’s ordinary library functions are capable of deal­
                           ing with multibyte characters, so no special functions are needed. For example, the
                           f p r i n t f function allows its format string to contain multibyte characters.
                                 Most wide-character functions behave the same as a function that belongs to
                           another part o fth e standard library. Usually, the only changes involve arguments
                           and return values of type w c h a r _ t instead of c h a r (or w c h a r _ t * instead of
                           c h a r *). In addition, arguments and return values that represent character
                           counts are measured in wide characters rather than bytes. In the remainder of this
                           section. I’ll indicate which other library function (if any) corresponds to each
            C h a p te r2 5
6 5 8 ZYXWVUTSRQPONMLKJIHGFEDCBAln t e r n a t io n a lF e a t u r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                w ide-character function. I w on't discuss the wide-character function further un­
                                                less there’s a significant difference between it and its “non-w ide” counterpart.dcbaZYXWVUTSRQP


                                                S tr e a m O r ie n ta tio n

                                                Before we look at lhe input/output functions provided by < w c h a r . h> , it's impor­
                                                                       stream o rien ta tio n , a concept that doesn’t exist in C89.
                                                tant to understand cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                       Every stream is either b yte-o rien ted (the traditional orientation) or wide-
                                                o rie n te d (data is written to the stream as wide characters). W hen a stream is first
           s ta n d a rd s tre a m s > 2 2 .7   opened, it has no orientation. (In particular, the standard streams s t d i n , s t d o u t ,
                                                and s t d e r r have no orientation at the beginning ofprogram execution.) Perform ­
                                                ing an operation on the stream using a byte input/output function causes the stream
                                                to becom e byte-oriented: perform ing an operation using a w ide-character input/
                                                output function causes the stream to becom e wide-oriented. The orientation of a
                                                stream can also bc selected by calling the f w i d e function (described later in this
                                                section). A stream retains its orientation as long as il remains open. Calling the
         fr e o p e n tu n c tio n > 2 2 .2     f r e o p e n function lo reopen the stream will remove its orientation.
                                                       When wide characters are written to a wide-oriented stream, they are con­
                                                verted to multibyte characters before being stored in the file that is associated with
                                                the stream. Conversely, when input is read from a wide-oriented stream, the m ulti­
                                                byte characters found in the stream are converted lo wide characters. The multibyte
                                                encoding<- used in a file is sim ilar to that used for characters aC     n3d strings within a
                                                program, except that encodings used in files may contain em bedded null bytes.
                                                       Each wide-oriented stream has an associated m b s t a t e _ t object, which keeps
                                                track of the stream ’s conversion state. An encoding error occurs when a wide char­
                                                acter written to a stream doesn’t correspond to any multibyte character, or when a
                                                sequence ofcharacters read from a stream doesn’t form a valid multibyte character.
                                                In either case, the value o flh e E IL SE Q macro (defined in the < e r r n o . h> header)
             e r r n o v a r ia b ie   >24.2    is stored in the e r m o variable to indicate the nature of the error.
                                                       Once a stream is byte-oriented, it’s illegal to apply a wide-character input/out-
                                                put function to that stream. Similarly, it’s illegal lo apply a byte input/output func­
                                                tion to a wide-oriented stream . Other stream functions may be applied to streams
                                                of either orientation, although there are a few special considerations for wide-ori­
                                                ented streams:

                                                      ■ Binary wide-oriente d streams are subject to the file-positioning restrictions of
                                                         both text and binary streams.
                                                  ■     After a file-positioning operation on a wide-oriented stream, a wide-character
                                                        output function may end up overwriting part of a m ultibyte character. Doing
                                                        so leaves the rest of the file in an indeterm inate state.
         f g e t p o s fu n c tio n > 2 2 . 7     ■ Calling f g e t p o s for        a wide-oriented stream retrieves the stream ’s
                                                     m b s t a t e _ t object as pan of the f p o s _ t object associated with the stream.
         f s e t p o s fu n c tio n > 2 2 . 7        A later call of f s e t p o s using this f p o s _ t object will restore the
                                                     m b s t a t e _ t object to its previous value.
                                      25.5                                     659dcbaZYXWVUTSRQP
                                                The<wchar.h>Header(C99)kjihgfedcbaZYXWVUTSRQPONMLKJIH

F o r m a t te d W id e - C h a r a c te r I n p u tA 3 u tp u t F u n c t io n s


  int fwprintf(FILE * restrict stream,
               const wchar_t * restrict format, ...);
  int fwscanf(FILE * restrict stream,
              const wchar_t * restrict format, ...);
  int swprintf(wchar_t * restrict s, size_t n,
               const wchar_t * restrict format, ...);
  int swscanf(const wchar_t * restrict s,
              const wchar_t * restrict format, ...);
  int vfwprintf(FILE * restrict stream,
                const wchar_t * restrict format,
                va_list arg);
  int vfwscanf(FILE * restrict stream,
               const wchar_t * restrict format,
               va_list arg);
  int vswprintf(wchar_t * restrict s, size_t n,
                const wchar_t * restrict format,
                va_list arg);
  int vswscanf(const wchar_t * restrict s,
               const wchar_t * restrict format,
               va_list arg);
  int vwprintf(const wchar_t * restrict format,
               va_list arg);
  int wscanf(const wchar_t * restrict format,
              va_list arg);
  int wprintf(const wchar_t * restrict format, ...);
  int wscanf(const wchar_t * restrict format, ...);onmlkjihgfedcbaZYXWVUTSRQPONM

The functions in this group are wide-character versions of the formatted input/out-
put functions found in < s t d i o . h > and described in Section 22.3. The
< w c h a r .h > functions have arguments of type w c h a r _ t * instead of c h a r *,
but their behavior is mostly the same as the < s t d i o . h > functions. Table 25.11
shows the correspondence between the < s t d i o . h > functions and their wide-
character counterparts. Unless mentioned otherwise, each function in the left col­
umn behaves the same as the function(s) to its right.
     All functions in this group share several characteristics:

  ■ All have a format string <^,' which consists of wide    characters.
                                                    cbaZYXWVUTSRQPONMLKJIHGFEDCBA


  ■ ...printf   functions, which return the number of characters written, now
     retum the count in wide characters.
  ■ The %n conversion specifier refers to the number of wide characters written so
     far (in the case of a . . . p r i n t f function) or read so far (in the case o f a
     ...s c a n f function).
6 6 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r2 5    ln t e r n a t io n a lF e a t u r e s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                 T a b l e 2 5 .i l onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                  < w c h a r . h > F u n c tio n    < B t d i o . h > E q u i v a l e n t kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE
Formatted W ide-Character                                               fwprintf                          fprintf
   InputfOutput Functions                                                fwscanf                           fscanf
  and Their < s t d i o . h>                                            swprintf                     snprintf. sprintf
              Equivalents RQPONMLKJIHGFEDCBA                             swscanf                           sscanf
                                                                       vfwprintf                         vfprintf
                                                                        vfwscanf                          vfscanf
                                                                       vswprintf                    vsnprintf. vsprintf
                                                                       vswscanf                           vsscanf
                                                                       vwprintf                           vprintf
                                                                        vwscanf                            vscanf
                                                                         wprintf                           printf
                                                                          wscanf                            scanfcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      fwprintf            Additional differences between f w p r i n t f and f p r i n t f include the fol­
                                      lowing:

                                         ■ The %c conversion specifier is used when the corresponding argument has
                                            type i n t . lfth e 1 length modifier is present (making the conversion % lc). the
                                            argument is assumed to have type w i n t _ t . ln either case, the corresponding
                                            argument is written as a wide character.
                                         ■ T he %s conversion specifier is used with a pointer to a character array, which
                                            may contain multibyte characters, ( f p r i n t f has no special provision for
                                            multibyte characters.) If the 1 length modifier is present, as in % ls, the corre­
                                            sponding argument should be an array containing wide characters. In either
                                            case, the characters in the ai*ray are written as wide characters. (With
                                            f p r i n t f . the % ls specification also indicates an array o fw id e characters,
                                            but they're converted to multibyte characters before being written.)
                      fw sca n f           Unlike f s c a n f . the f w s c a n f function reads wide characters. The %c. %s.
                                      and % [ conversions require special mention. Each o fth e se causes wide characters
                                      to be read and then converted lo multibyte characters before being stored in a char­
                                      acter array, f w s c a n f uses an m b s t a t e _ t object to keep track of the state of the
                                      conversion during this process; the object is set to zero at the beginning of each
                                      conversion. If the 1 length modifier is present (making the conversion % lc. % ls,
                                      or %1 [), then the input characters are not converted but instead are stored directly
                                      in an array o f w c h a r _ t elements. Thus, it’s necessary to use % ls when reading a
                                      string of wide characters if the intent is to store them as wide characters. If %s is
                                      used instead, wide characters will be read from the input stream but converted to
                                      multibyte characters before being stored.
                     swprintf              s w p r i n t f writes wide characters into an array o f w c h a r _ t elements. It’s
                                      similar to s p r i n t f and s n p r i n t f but not identical to either one. Like
                                      s n p r i n t f . it uses the param etern to limit the n u m berof(w ide) characters that it
                                      will write. However, s w p r i n t f returns the num ber of wide characters actually
                                      written, not including the null character. In this respect, it resembles s p r i n t f
                                      rather than s n p r i n t f , which returns the number o fch aracters that would have
                                      been written (not including the null character) had there been no length restriction.
                                                                         2 5 ,5        T h e < w c h a r . h > H e a d e r ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                                             661 onmlkjihgfedcbaZYX


                               s w p r i n t f returns a negative value if the number of wide characters to be written
                               is n or more, which differs lfom the behavior of both s p r i n t f and s n p r i n t f .cbaZYXWVUTSRQPON
              vswprintf             v s w p r i n t f is equivalent to s w p r i n t f , with a r g replacing the variable
                               argument list of s w p r i n t f . Like s w p r i n t f , which is similar— but not identi­
                               cal— to s p r i n t f and s n p r i n t f , the v s w p r i n t f function is a combination of
                               v s p r i n t f and v s n p r i n t f . Ifan attempt is made to write n or more wide char­
                               acters, v s w p r i n t f returns a negative integer, in a manner similar to s w p r i n t f .dcbaZYXWVUTSR


                               W id e -C h a r a c t e r I n p u t/ O u tp u t F u n c tio n s PONMLKJIHGFEDCBA

                                wint_t fgetwc(FILE *stream);
                                wchar_t *fgetws(wchar_t * restrict s, int n,
                                                FILE * restrict stream);
                                wint_t fputwc(wchar_t c, FlLE *stream);
                                int fputws(const wchar_t * restrict s f
                                           FILE * restrict stream);
                                int fwide(FILE *stream, int mode);
                                wint_t getwc(FILE *stream);
                                wint_t getwchar(void);
                                wint_t putwc(wchar_t c, FILE *stream);
                                wint_t putwchar(wchar_t c);
                                wint_t ungetwc(wint_t c, FILE *stream);

                               The functions in this group are wide-character versions of the character input/oul-
                               put functions found in < s t d i o . h > and described in Section 22.4. Table 25.l2
                               shows the correspondence between the < s t d i o . h > functions and their wide-
                               character counterparts. As the table shows, f w i d e is the only truly new function.

           T a b le 2 5 .1 2                         < w c h a r . h > F u n c tio n       < s t d i o . h > E q u i v a l e n t kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
W ide-C haracter Input/                                       fgetwc                                   fgetc
Output Functions and                                          fgetws                                   fgets
   Their < s t d i o . h>                                     fputwc                                   fputc
           Equivalents RQPONMLKJIHGFEDCBA                     fputws                                   fputs
                                                               fwide                                     —
                                                              getwc                                    getc
                                                            getwchar                                 getchar
                                                              putwc                                    putc
                                                            putwchar                                 putchar
                                                             ungetwc                                  ungetc

                                    Unless otherwise indicated, you can assume that each < w c h a r .h > function
                               listed in Table 25.12 behaves like the corresponding < s t d i o . h > function. How­
                               ever. one minor difference is common to most of these functions. To indicate an
                               error or end-of-file condition, some < s t d i o . h > character VO functions return
                               EOF. The equivalent < w c h a r . h> functions return WEOF instead.
            C h a p te r2 5    ln t e r n a t io n a lF e a t u r e s
6 6 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                         fg e tw c               T here's another twist that affects the w ide-character input functions. A call of
                          g e tw c      a function that reads a single character ( f g e t w c . g e t w c . and g e t w c h a r ) may
                     g e tw c h a r
                                        fail because the bytes found in the input stream d o n ’t form a valid wide character
                         fg e tw s
                                        or there aren’t enough bytes available. The result is an encoding error, which
                                        causes the function to store E IL S E Q in e r r n o and return WEOF. T he f g e t w s
                                        function, which reads a string o f wide characters, m ay also fail because o f an
                                        encoding error, in which case it returns a null pointer.
                         fp u tw c               W ide-character output functions may also encounter encoding errors. Functions
                          p u tw c      that w rite a single character ( f p u t w c . p u t w c . and p u t w c h a r ) store E IL S E Q in
                     p u tw c h a r
                                        e r r n o and return WEOF if an encoding error occurs. However, the f p u t w s func­
                         fp u tw s
                                        tion, which writes a w ide-character string, is different: it returns EOF (not WEOF) if
                                        an encoding^ error occurs.
                                                 The f w i d e function doesn’t correspond to any C 89 function, f w i d e is used
                           fw id e onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        to determ ine the current orientation o f a stream and. if desired, attem pt to set its
                                        orientation. T he m o d e param eter determ ines the behavior o f the function:
                                             ■ m o d e > 0. A ttem pts to make the stream w ide-oriented if it has no orientation.
                                         ■     m o d e < 0. A ttem pts to make the stream byte-oriented if it has no orientation.
                                             ■ m o d e = 0. The orientation is not chanc^ ed.
                                      f w i d e d o esn 't change the orientation if the stream already has one.
                                                                                                                              after
                                            The value returned by f w i d e depends on the orientation o f the stream cbaZYXWVUTSRQPO
                                      the call. The return value is positive if th e stream has w ide orientation, negative if
                                      it has byte orientation, and zero if it has no orientation.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      G e n e r a l W id e - S t r in g U tilitie s
                                      The < w c h a r . h > header provides a num ber o ffu n c tio n s that perform operations
                                      on w ide strings. These are w ide-character versions o f functions that belong to the
                                      < s t d l i b . h > and < s t r i n g . h > headers.RQPONMLKJIHGFEDCBA


                                       W i d e - S t r i n g N u m e r i c C o n v e r s i o n F u n c t i o n s PONMLKJIHGFEDCBA


                                         double wcstod(const wchar_t * restrict nptr,
                                                       wchar_t ** restrict endptr);
                                         float wcstof(const wchar_t * restrict nptr,
                                                      wchar_t ** restrict endptr);
                                         long double wcstold(const wchar_tkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                             * restrict nptr,
                                                             wchar_t ** restrict endptr);
                                         long int wcstol(const wchar_t * restrict nptr,
                                                         wchar_t ** restrict endptr,
                                                         int base);
                                         long long int wcstoll (const wchar_t * restrict nptr,
                                                                wchar_t ** restrict endptr,
                                                                int base);
                                                                            2 5 .5                                                            663PONMLKJIHGFEDCB
                                                                                         T h e < w c h a r . h > H e a d e r ( C 9 9 ) kjihgfedcbaZYXWVUTSRQPONMLKJ



                                   unsigned long int wcstoul(
                                                         const wchar_t * restrict nptr,
                                                         wchar_t ** restrict endptr,
                                                         int base);
                                   unsigned long long int wcstoull(
                                                         const wchar_t * restrict nptr,
                                                         wchar_t ** restrict endptr,
                                                         int base);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                  The functions in this group are wide-character versions of the numeric conversion
                                  functions found in < s t d l i b . h> and described in Section 26.2. The < w c h a r . h>
                                  functions have arguments oftype w c h a r _ t * and w c h a r _ t ** instead o f c h a r
                                  * and c h a r **, but their behavior is mostly the same as the < s t d l i b . h> func­
                                  tions. Table 25.13 shows the correspondence between the < s t d l i b . h> functions
                                  and their wide-character counterparts.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

              T a b le 2 5 .1 3                        < w c h a r . h > F u n c tio n      < s t d l i b . h > E q u iv a le n t
   W ide-String Numeric                                        w c s to d                               s trto d
Conversion Functions and                                       w c s to f                               s trto f
    Their < s t d l i b . h>                                  w c s to ld                              s trto ld
             Equivalents RQPONMLKJIHGFEDCBA                    w c s to l                               s trto l
                                                              w c s to ll                              s trto ll
                                                              w c s to u l                             s trto u l
                                                              w c s to u ll                           s trto u ll



                                  W id e -S trin g C o p y in g F u n c tio n s


                                    wchar_t *wcscpy(wchar_t * restrict sl,
                                                    const wchar_t * restrict s2);
                                    wchar_t *wcsncpy(wchar_t * restrict sl,
                                                     const wchar_t * restrict s2,
                                                     size_t n);
                                    wchar_t *wmemcpy(wchar_t * restrict sl,
                                                     const wchar_t * restrict s2,
                                                     size_t n ) ;
                                    wchar_t *wmemmove(wchar_t *sl, const wchar_t *s2,
                                                      size_t n) ;

                                  The functions in this group are wide-character versions of the string copying func­
                                  tions found in < s t r i n g . h > and described in Section 23.6. The < w c h a r .h >
                                  functions have arguments of type w c h a r _ t * instead of c h a r *, but theirbehavior
                                  is mostly the same as the < s t r i n g .h > functions. Table 25.14 shows the corre­
                                  spondence between the < s t r i n g . h> functions and their wide-character counter­
                                  parts.
6 6 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 5    In te rn a tio n a l F e a tu re s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                 < w c h a r .h > Function
                 T a b le 2 5 .1 4 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                       < s t r i n g . h> Equivalent
      W ide-Siring C opying                                            w c sc p y                              s trc p y
       Functions and T heir                                           w c sn c p y                            s trn c p y
              < s t r i n g . h>                                      wmemcpy                                  menicpy
                 Equivalents cbaZYXWVUTSRQPONMLKJIHGFEDCBA            wmemmove                                memniove RQPONMLKJIHGFEDCBA


                                     W i d e - S t r i n g C o n c a t e n a t i o n F u n c t i o n s PONMLKJIHGFEDCBA


                                       wchar_t *wcscat(wchar_t * kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                 restrict sl,
                                                       const wchar_t * restrict s2);
                                       wchar_t *wcsncat(wchar_t * restrict sl,
                                                        const wchar_t * restrict s2,
                                                        size_t n);

                                     The functions in this group are widc-charactcr versions o fth e string concatenation
                                     functions found in < s t r i n g . h> and described in Section 23.6. The < w c h a r . h>
                                     functionshavea rg u m e n ts o fty p c w c h a r_ t * in s te a d o f c h a r *.buttheirbehavior
                                     is mostly the same as the < s t r i n g . h > functions. Table 2 5 .l5 shows the corre­
                                     spondence between lhe < s t r i n g . h > functions and their wide-character counter­
                                     parts.

                 T a b le 2 5 .1 5                            < w c h a r. h> F unction            < s t r i n g . h> Equivalent
Widc-S1rin2«_>Concatenation                                            w cscat                                  s trc a t
           Functions and Their                                         w csncat                                s trn c a t
< s t r i n g . h > Equivalents

                                     W id e - S tr in g C o m p a r is o n F u n c tio n s


                                       int wcscmp(const wchar_t *sl, const wchar_t *s2);
                                       int wcscoll(const wchar_t *sl, const wchar_t *s2);
                                       int wcsncmp(const wchar_t *sl, const wchar_t *s2,
                                                   size_t n);
                                       size_t wcsxfrm(wchar_t * restrict sl,
                                                      const wchar_t * restrict s2 f
                                                      size_t n);
                                       int wmemcmp(const wchar_t * sl, const wchar_t * s2,
                                                   size_t n ) ;

                                     The functions in this group are wide-character versions of the string comparison
                                     functions found in < s t r i n g . h > and described in Section 23.6. The
                                     < w c h a r .h > functions have arguments of type w c h a r _ t * instead of c h a r *,
                                     but theirbehavior is mostly the same as the < s t r i n g . h > functions. Table 25.l6
                                     shows the correspondence between the < s t r i n g . h > functions and their wide-
                                     character counterparts.
                                                                                  2 5 .5                                                            6 6 5 dcbaZYXWVUTSRQ
                                                                                               T h e < w c h a r . h > H e a d e r (C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIH


                                                              < w c h a r .h > F u n c tio n
              T a b le 2 5 .1 6 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                        < s t r i n g . h> E q u iva len t
Wide-String Comparison                                               w cscm o                               s trc m p
    Functions and Thcir                                              w c s c o ll                          s trc o ll
         < s t r i n g . h>                                          w c sn c m p                          s trn c m p
            Equivalents cbaZYXWVUTSRQPONMLKJIHGFEDCBA                w c sx frm                            s trx frm
                                                                     wmemcmp                                memcmp RQPONMLKJIHGFEDCBA


                                   W id e -S tr in g S e a rc h F u n c tio n s


                                     w c h a r_ t * w c s c h r (c o n s t w c h a r_ t *s, w c h a r_ t c ) ;
                                     s iz e _ t w c sc sp n (c o n st w char_t * s l, c o n s t w ch a r_ t * s2 );
                                     w char_t * w c sp b rk (c o n st w ch a r_ t * s l,
                                                                   c o n s t w char_t * s 2 );
                                     w char_t * w c src h r(c o n st w ch a r_ t * s, w ch a r_ t c );
                                     s iz e _ t w c ssp n (c o n st w char_t * s l, c o n s t w ch a r_ t * s2 );
                                     w char_t * w c s s tr (c o n s t w ch a r_ t * s l,
                                                                 c o n s t w char_t * s 2 );
                                     w c h a r_ t * w c s to k (w c h a r _ t * r e s t r i c t s l ,
                                                                 c o n s t w char_t * r e s t r i c t s2 ,
                                                                 w c h a r _ t ** r e s t r i c t p t r ) ;
                                     w c h a r_ t * w m e m c h r(c o n st w c h a r_ t * s, w c h a r _ t c ,
                                                                   s i z e _ t n) ;

                                  The functions in this group are wide-character versions of the string search func­
                                  tions found in < s t r i n g . h > and described in Section 23.6. The < w c h a r .h >
                                  functions have arguments o fty p e w c h a r _ t * and w c h a r _ t ** instead o f c h a r
                                  * and c h a r **, but their behavior is mostly the same as the < s t r i n g . h> func­
                                  tions. Table 25.17 shows the correspondence between the < s t r i n g . h> functions
                                  and their wide-character counterparts.


              T a b le 2 5 .1 7                             < w c h a r .h > F u n c tio n       < s t r i n g . h > E quivalent
     Wide-Strin^e Search                                             w cschr                                s trc h r
     Functions and Their                                             w cscspn                              s trc s p n
         < s t r i n g . h>                                          w c sp b rk                           s trp b rk
             Equivalents                                             w c src h r                           s trrc h r
                                                                     w csspn                                s trs p n
                                                                      w c s s tr                            s trs tr
                                                                     w c s to k                             s trto k
                                                                     w m em chr                             m em ch r


                    w cstok             The w c s t o k function serves the same purpose as s t r t o k , but is used som e­
                                   what differently, thanks to its third parameter, ( s t r t o k has only two parameters.)
                                   To understand how w c s t o k works. weTl first need to review the behavior of
                                   s trto k .
6 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 5     In te r n a tio n a l F e a tu r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                               We saw in Section 23.6 that s t r t o k searches a string for a “token"— a
                                       sequence of characters that doesn’t include certain deHmiting characters. The call
                                       s t r t o k ( s l , s 2 ) scans the s l string for a nonempty sequence of characters
                                                     not in the s 2 string, s t r t o k marks the end of the token by storing a null
                                       that are cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       character in s l just after the last character in the token; it then returns a pointer to
                                       the first character in the token.
                                               Later calls of s t r t o k can find additional tokens in the same stringo. The call
                                       s t r t o k ( N U L L , s 2 ) continues the search begun by the previous s t r t o k call.
                                       As before, s t r t o k marks the end of the token with a null character, and then
                                       returns a pointer to the beginning of the token. The process can be repeated until
                                       s t r t o k returns a null pointer, indicating that no token was found.
                                               One problem with s t r t o k is that il uses a static variable to keep track of a
                                       search, which makes it impossible to use s t r t o k to conduct simultaneous
                                       searches on two or more strings. Thanks to its extra parameter, w c s t o k doesn’t
                                       have this problem.
                                               The first two parameters to w c s t o k are the same as for s t r t o k (except that
                                       they point to wide strings, of course). The third parameter, p t r , will point to a
                                       variable of type w c h a r _ t *. The function will save information in this variable
                                       that enables later calls of w c s t o k to continue scanning the same string (when the
                                       first argument is a null pointer). When the search is resumed by a subsequent call
                                       of w c s t o k , a pointer to the same variable should be supplied as the third argu­
                                       ment; the value o fth is variable must not be changed between calls o f w c s t o k .
                                               To see how w c s t o k works, let's redo the example ofS eclion 23.6. Assume
                                       that s t r , p , and q are declared as follows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       wchar_t str[] = L" April                             28,1998";
                                       wchar_t *p, *q,-
                                       Our initial call o f w c s t o k will pass s t r as the first argument:
                                       p = wcstok(str, L" \t", &q);

                                       p now points to the first character in A p r i l , which is followed by a null wide
                                       character. Calling w c s t o k with a null pointer as its first argument and &q as the
                                       third argument causes it to resume the search from where it left off:
                                       p = wcstok(NULL, L" \t,", &q);
                                       After this call, p points to the first character in 2 8, which is now terminated by a
                                       null wide character. A final call of w c s t o k locates the year:
                                       p = wcstok(NULL, L" \t", &q);
                                       p now points to the first character in 1 9 9 8 .RQPONMLKJIHGFEDCBA

                                       M i s c e l l a n e o u s F u n c t i o n s PONMLKJIHGFEDCBA


                                          size_t v/cslen(const wchar_t *s);
                                          wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n);
                                                                                  2 5 .5       T h e < w c h a r .h > H e a d e r ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIHGFED
                                                                                                                                                    6 6 7 onmlkjihgfedcbaZYXWVU

                                    The functions in this group are wide-characler versions of the miscellaneous
                                    string functions found in < s t r i n g . h > and described in Section 23.6. The
                                    < w c h a r .h > functions have arguments of type w c h a r _ t * instead of c h a r *,
                                    but their behavior is mostly the same as the < s t r i n g . h > functions. Table 25.18
                                    shows the correspondence between the < s t r i n g . h > functions and their wide-
                                    character counterparts.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                T a b le 2 5 .1 8                            < w c h a r . h > F u n c tio n     < s t r i n g . h > E q u i v a l e n t kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
M iscellaneous W ide-Siringc*                                         wcslen                                 strlen
          Functions and T heir                                       wmemset                                 memsetZYXWVUTSRQPONMLKJIHGFEDCBA
< s t r i n g . h > Equivalents RQPONMLKJIHGFEDCBA


                                    W id e - C h a r a c t e r T im e -C o n v e r s io n F u n c ti o n s

                                           s iz e _ t   w c s ftim e (w c h a r _ t * r e s t r i c t s , s i z e _ t m a x s iz e ,
                                                                       c o n s t w ch a r_ t * r e s t r i c t fo r m a t,
                                                                       c o n s t s t r u c t tm * r e s t r i c t t i m e p t r ) ;

                   w c s ftim e     The w c s f t i m e function is the wide-character version of s t r f t i m e . which
                                    belongs to the < t i m e . h> header and is described in Section 26.3.


                                    E x te n d e d M u ltib y t e A V id e -C h a r a c t e r C o n v e r s io n U ti liti e s

                                    W e'll now examine < w c h a r .h > functions that perform conversions between
                                    multibyte characters and wide characters. Five of these functions ( m b r le n ,
                                    m b rto w c . w c rto m b , m b s r to w c s , and w c s r to m b s ) correspond to the multi-
                                    byte/wide-character and multibyte/wide-string conversion functions declared in
                                    < s t d l i b . h > . The < w c h a r .h > functions have an additional parameter, a
                                    pointer to a variable of type m b s t a t e _ t . This variable keeps track of thc state of
                                    the conversion of a multibyte character sequence to a wide-characier sequence (or
                                    vice versa), based on the current locale. As a result, the < w c h a r . h> functions are
                                    “rcstartable’t by passing a pointer to an m b s t a t e _ t variable modified by a previ­
                                    ous function call, we can “restart’1 the function using the conversion state from that
                                    call. Onc advanta^e^'e o fth is arrang4^ement is that it allows two functions to share the
                                    same conversion state. For example, calls of m b rto w c and m b s r t o w c s that are
                                    used to process a single multibyte character string could share an m b s t a t e _ t
                                    variable.
                                          The conversion state stored in an m b s t a t e _ t variable consists of the current
                                    shift state plus the current position within a multibyte character. Setting the bytes
                                    o f an m b s t a t e _ t variable to zero puts it in the initial conversion state, signifying
                                    that no multibyte character is yet in progress and that the initial shift state is in
                                    effect:

                                    mbstate_t state;
                                    • ••

                                    memset(&state,                *\0’, sizeof(state));
6 6 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r2 5      ln te m a tio n a lF e a tu r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      Passing & s t a t e to one of the restartable functions causes the conversion to begin
                                      in the initial conversion state. Once an m b s t a t e _ t variable has been altered by
                                      one of these functions, it should not be used to convert a different multibyte char­
                                      acter sequence, nor should it be used to perforin a conversion in the opposite direc­
                                      tion. Attempting to perform either action causes undefined behavior. Using the
                                      variable after a change in the LC_CTYPE category of a locale also causes unde­
                                      fined behavior.RQPONMLKJIHGFEDCBA

                                      S i n g l e - B y t e / W i d e - C h a r a c t e r C o n v e r s i o n F u n c t i o n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                         w in t_ t b to w c (in t              c );
                                         i n t w c to b (w in t_ t             c );

                                      The functions in this group convert single-byte characters to wide characters and
                                      vice versa.
                          btowc             The b to w c function returns WEOF if c is equal to EOF or if c (when cast to
                                      u n s i g n e d c h a r ) isn’t a valid single-byte character in the initial shift state. Oth­
                                      erwise, b to w c returns the wide-character representation of c.
                          wctob             The w c to b function is the opposite of b to w c . It returns EOF if c doesn’t
                                      correspond to one multibyte character in the initial shift state. Otherwise, it returns
                                      the single-byte representation of c.

                                      C o n v e r s io n - S ta te F u n c tio n s


                                         in t    m b s in it(c o n s t            m b s ta te _ t        * p s);

                        m bsinit      This group consists of a single function, m b s i n i t , which returns a nonzero value
                                      i f p s is a null pointer or it points to an m b s t a t e _ t variable that describes an ini­
                                      tial conversion state.


                                      R e s ta r ta b le M u ltib y te /W id e - C h a r a c te r C o n v e r s io n F u n c tio n s


                                         s iz e _ t     m b r le n (c o n s t c h a r * r e s t r i c t s , s i z e _ t n,
                                                                    m b s ta te _ t * r e s t r i c t p s ) ;
                                         s iz e _ t     m b r to w c (w c h a r _ t * r e s t r i c t pw c,
                                                                       co n st char * r e s tr ic t s, s iz e _ t n,
                                                                       m b s ta te _ t * r e s t r i c t p s ) ;
                                         s iz e _ t     w c r to m b ( c h a r * r e s t r i c t s , w c h a r _ t w c,
                                                                      m b s ta te _ t ★ r e s t r i c t p s ) ;

                                      The functions in this group are restartable versions of the m b le n . m b to w c , and
                                      w c to m b functions,' which belon<s«7 to < s t d l i b . h > and are discussed in Section
                                      25.2. The newer m b r l e n . m b rto w c , and w c r to m b functions differ from their
                                      < s t d l i b . h> counterparts in several ways:
                                                 2 5 .5    T h e < w c h a r .h > H e a d e r ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                 6 6 9 onmlkjihgfedcbaZYXW


             ■ m b r l e n , m b rto w c , and w c rto m b have an additional parameter named p s .
                When one of these functions is called, the corresponding argument should
                point to a variable of type m b s t a t e _ t ; the function will store the state o fth e
                conversion in this variable. If the argument corresponding to p s is a null
                pointer, the function will use an internal variable to store the conversion state.
                (Al the beginning of program execution, this variable is set to the initial con­
                version state.)
             ■ When the s paramete r is a null pointer, the older m b le n . m b to w c , and
                w cto m b functions return a nonzero value if multibyte character encodings
                have state-dependent encodings (and zero otherwise). The newer functions
                don't have this behavior.
             ■ m b r l e n , m b rto w c . and w c rto m b return a value oftype s i z e _ t instead of
                i n t , the return type o fth e older functions.
 mbrlen        A call of m b r l e n is equivalent to the callkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

           mbrtowc(NULL,         s, n, ps)

           except that i f p s is a null pointer, then the address o fa n internal variable is used
           instead.
m brtowc        If s is a null pointer, a call of m b rto w c is equivalent to the call

           mbrtowc(NULL,         ••••, 1, ps)

           Otherwise, a call o f m b rto w c examines up to n bytes pointed to by s to see if they
           complete a valid multibyte character. (Note that a multibyte character may already
           be in progress prior to the call, as tracked by the m b s t a t e _ t variable to which
           p s points.) lfso . these bytes are converted into a wide character. The wide charac­
           ter is stored in the location pointed to by pw c as long as pw c isnT null. Ifthis char­
           acter is the null wide character, the m b s t a t e _ t variable used during the call is
           left in the initial conversion state.
                 m b rto w c has a variety ofpossible return values. It returns 0 ifth e conversion
           produces a null wide character, lt returns a number between 1 and n if the conver­
           sion produces a wide character other than null, where the value returned is the
           number of bytes used to complete the multibyte character. It returns - 2 if the n
           bytes pointed to by s aren't enough to complete a multibyte character (although
           thc bytes themselves were valid). Finally, il returns -1 if an encoding error occurs
           (the function encounters bytes that doift form a valid multibyte character). In the
           last case, m b rto w c also stores EILSEQ in e r r n o .
wcrtomb          If s is a null pointer, a call of w c r to m b is equivalent to

           wcrtomb(buf,        L*\0*,      ps)

           where b u f is an internal buffer. Otherwise, w c r to m b converts wc from a wide
           character into a multibyte character, which it stores in the array pointed to by s.
           If wc is a null wide character, w c rto m b stores a null byte, preceded by a shift
           sequence if one is necessary to restore the initial shift state. In this case, the
          C h a p te r 2 5     In te rn a tio n a l F e a tu r e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
670 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      m b s t a t e _ t variable used during the call is left in the initial conversion state,
                                      w c r to m b returns the number of bytes that it stores, including shift sequences. If
                                      wc isn’t a valid wide character, the function returns -1 and stores EILSEQ in
                                      e r r n o .RQPONMLKJIHGFEDCBA


                                      R e s t a r t a b l e M u l t i b y t e f W i d e - S t r i n g C o n v e r s i o n F u n c t i o n s PONMLKJIHGFEDCBA


                                        size_t mbsrtowcs(wchar_t * restrict dst,
                                                         const char ** restrict src,
                                                         size_t len,
                                                         mbstate_t * restrict p s);
                                        size_t wcsrtombs(char * restrict dst,
                                                         const wchar_t ** restrict src
                                                         size_t len,
                                                         mbstate_t * restrict ps);

                  m bsrtow cs         The m b s r t o w c s and w c s r t o m b s functions are restartable versions of
                  w csrtom bs         m b s to w c s and w c s to m b s , which belong to < s t d l i b . h> and are discussed in
                                      Section 25.2. m b s r t o w c s and w c s r t o m b s are the same as their < s t d l i b . h >
                                      counterparts, except for the following differences:

                                        ■ m b s r t o w c s and w c s r t o m b s have an additional parameter named p s.
                                           When one of these functions is called, the corresponding argum ent should
                                           point to a variable oftype m b s t a t e _ t ; the function will store the state of tlie
                                           conversion in this variable. If the argument corresponding to p s is a null
                                           pointer, the function will use an internal variable to store the conversion state.
                                           (At the beginning of program execution, this variable is set to the initial con­
                                           version state.) Both functions update the state as the conversion proceeds. If
                                           the conversion stops because a null character is reached, the m b s t a t e _ t
                                           variable will be left in the initial conversion state.
                                        ■ The s r c par ameter, which represents the array containing characters to be
                                           converted (the source array), is a pointer to a pointer for m b s r t o w c s and
                                           w c s r t o m b s . (In the o ld e r m b s to w c s and w c s to m b s functions, the corre­
                                           sponding parameter was simply a pointer.) This change allows m b s r t o w c s
                                           and w c s r t o m b s to keep track of where the conversion stopped. The pointer
                                           to which s r c points is set to null if the conversion slopped because a null
                                           character was reached. Otherwise, this pointer is set to pointjust past the last
                                           source character converted.
                                        ■ The d s t parameter may be a null p ointer, in which case the convened charac­
                                           ters aren’t stored and the pointer to which s r c points isn’t modified.
                                        ■ When either function encounte rs an invalid character in the source arrav*,- it
                                           stores EILSEQ in e r r n o (in addition lo returning -1 , as the older functions
                                           do).
                                                                             2 5 .6                                                           671 aZYXWVUTSRQPO
                                                                                       T h e < w c t y p e . h > H e a d e r ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJ




                       2 5 .6         T h e < w c t y p e .h > H e a d e r (C 9 9 )
                                      W id e - C h a r a c t e r C l a s s i f ic a t i o n a n d M a p p i n g U t i lit i e s onmlkjihgfedcbaZYX

                                      The < w c ty p e .h > header is the wide-character version of the < c t y p e . h >
< c ty p e .h > h e a d e r> 2 3 .5   header, < c t y p e . h > provides two kinds of functions: character-classification
                                      functions (like i s d i g i t , which tests whether a character is a digit) and character
                                      case-mapping functions (like t o u p p e r , which converts a lower-case letter to
                                      upper case), < w c ty p e .h > provides similar functions for wide characters,
                                      although it differs from < c t y p e . h> in one important way: some of the functions
                                      in < w c ty p e .h > are “extensible?’ meaning that they can perform custom charac­
                                      ter classification or case mapping.
                                           < w c ty p e .h > declares three types and a macro. The w i n t _ t type and the
                                      WEOF macro were discussed in Section 25.5. The remaining types are w c t y p e _ t ,
                                      whose values represent locale-specific character classifications, and w c t r a n s _ t ,
                                      whose values represent locale-specific character mappings.
                                           Most of the functions in < w c ty p e .h > require a w i n t _ t argument. The
                                      value of this argument must be a wide character (a w c h a r _ t value) or WEOF.
                                      Passing any other argument causes undefined behavior.
                                           The behavior of the functions in < w c ty p e . h> is affected by the LC_CTYPE
                                      category of the currenl locale.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      W id e - C h a r a c te r C la s s ific a tio n F u n c tio n s PONMLKJIHGFEDCBA

                                        int    iswalnum(wint_t wc);
                                        int    iswalpha(wint_t wc);
                                        int    iswblank(wint_t wc);
                                        int    iswcntrl (wint_t wc) ;
                                        int    iswdigit(wint_t wc);
                                        int    iswgraph (wint_t wc) ;
                                        int    iswlower(wint_t wc);
                                        int    iswprint(wint_t wc);
                                        int    iswpunct (wint_t wc) ;
                                        int    iswspace (wint_t wc) ;
                                        int    iswupper(wint_t wc);
                                        int    iswxdigit(wint_t wc);

                                      Each wide-character classification function returns a nonzero value if its arogument
                                      has a particular property. Table 25.19 lists the property that each function tests.
                                           The descriptions in Table 25.19 ignore some of the subtleties o fw id e charac­
                                      ters. For example, the definition of i s w g r a p h in the C99 standard states that it
                                      “tests for any w idecharacterforw hich i s w p r i n t is true and i s w s p a c e is false,”
6 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 5   ln te rn a tio n a lF e a tu re s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                T a b le 2 5 .1 9 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                            F u n c tio n                                 T e s t kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
           W ide-Character                 iswalnum(wc)                       Is wc alphanum eric?
  Classification Functions RQPONMLKJIHGFEDCBA
                                           iswalpha(wc)                       Is wc alphabetic?
                                                   iswblank(wc)               Is wc a blank?*
                                                   iswcntrl(wc)               Is wc a control character?
                                                   iswdigit(wc)               Is wc a decimal digit?
                                                   iswgraph(wc)               Is wc a printing character (other than a space)?
                                                   iswlower(wc)               Is wc a lower-case letter?
                                                   iswprint(wc)               Is wc a printing character (including a space)?
                                                   iswpunct(wc)               Is wc punctuation?
                                                   iswspace(wc)               Is wc a white-space character?
                                                   iswupper(wc)               Is wc an upper-case letter?
                                                   iswxdigit(wc)              Is wc a hexadecimal digit?
                                                   4.
                                                     The standard blank wide characters are space ( L '      ') and horizontal tab
                                                   ( L '\ c ') .

                                    leaving open the possibility that more than one wide character is considered to be a
                                    ‘‘space?" See Appendix D for more detailed descriptions of these functions.
                                         In most cases, the w ide-character classification functions are consistent with
                                    the corresponding functions in < c t y p e .h > : if a < c t y p e .h > function returns a
                                    nonzero value (indicating “true”) for a particular character, then the corresponding
                                    < w c ty p e . h > function will return true for the wide version of the samc character.
                                    The only exception involves white-space wide characters (other than space) that
                                    are also printing characters, which may be classified differently by i s w g r a p h
                                    and i s w p u n c t than by i s g r a p h and i s p u n c t . For exam ple, a character for
                                    which i s g r a p h returns true may cause i s w g r a p h to return false.


                                    E x te n s ib le W id e -C h a r a c te r C la s sific a tio n F u n c tio n s

                                               i s w c t y p e ( w i n t _ t w c, w c t y p e _ t d e s c ) ;
                                       i n t cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       w c ty p e _ t w c ty p e (c o n s t c h a r * p r o p e r ty );

                                    Each of the w ide-character classification functionsjust discussed is able to test a
                                    single fixed condition. The w c t y p e and i s w c t y p e functions— which are de­
                                    signed to be used together— make it possible to test for other conditions as well.
                      w ctype             The w c t y p e function is passed a string describing a class of wide characters:
                                    it returns a w c t y p e _ t value that represents this class. For exam ple, the call

                                    wctype(“upper")

                                    returns a w c t y p e _ t value representing the class o fu p p er-case letters. The C99
                                    standard requires that the following strings be allowed as argum ents to w c ty p e :

                                     "alnum"          "alpha"           "blank"      "cntrl"         "digit"             "graph"
                                     "lower"          "print"           "punct"      "space"         "upper"             "xdigit"

                                    Additional strings may be provided by an implementation. W hich strings are legal
                                    arguments to w c t y p e at a given time depends on the LC_CTYPE category ofthe
                                                2 5 .6                                                              6 73 onmlkjihgfedcbaZYX
                                                           T h e < w c t y p e . h > H e a d e r ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIH


            current iocale; tlie 1.2 strings iisted above are legal in all locales, If w c ty p e is
            passed a string that’s not supported in the current locale, it retums zero.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
iswctype         A call of the i s w c t y p e function requires two parameters: wc (a wide char­
            acter) and d e s c (a value returned by w c ty p e ) . i s w c t y p e returns a nonzero
            value ifw c belongs to the class ofcharacters corresponding to d e s c . For example,
            the callkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
            iswctype(wc, wctype("alnum"))

            is equivalent to
            iswalnum(wc)

            w c ty p e and i s w c t y p e are most useful when the argument to w c t y p e is a
            stringo other than the standard ones listed above,dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


            W id e - C h a r a c te r C a s e -M a p p i n g F u n c tio n s

             w in t_ t    to w lo w e r (w in t_ t       w c );
             w in t_ t    to w u p p e r (w in t_ t      w c );

 towlower   The t o w l o w e r and t o w u p p e r functions are the wide-character counterparts of
towupper    t o l o w e r and t o u p p e r . For example, t o w l o w e r returns the lower-case ver­
            sion of its argument, if the argument is an upper-case letter; otherwise, it returns
            the argument unchanged. As usual, there may be quirks when dealing with wide
            characters. For example, more than one lower-case version o fa letter may exist in
            the current locale, in which case t o w l o w e r is allowed to return any one of them.


            E x te n s ib le W id e - C h a r a c t e r C a s e -M a p p in g F u n c t io n s

             w in t_ t to w c tr a n s (w in t_ t         w c, w c t r a n s _ t d e s c ) ;
             w c tr a n s _ t w c tr a n s ( c o n s t    c h a r * p r o p e r ty );

            The w c t r a n s and t o w c t r a n s functions are used together to support general­
            ized wide-character mapping.
 wctrans        The w c t r a n s function is passed a string describing a character mapping: it
            retums a w c t r a n s _ t value that represents the mapping. For example, the call
            wctrans(”tolower”)

            returns a w c t r a n s _ t value representing the mapping ofupper-case letters to low­
            er case. The C99 standard requires that the strings " t o l o w e r ” and " t o u p p e r "
            be allowed as arguments to w c t r a n s . Additional strings may be provided by an
            implementation. Which strings are legal arguments to w c t r a n s at a given time
            depends on the LC_CTYPE category of the current locale; " t o l o w e r " and
            " t o u p p e r " are legal in all locales. L f w c t r a n s is passed astring that's not sup­
            ported in the current locale, it returns zero.
674 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r2 5     ln te r n a tio n a lF e a tu r e s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                    towctrans             A call of the t o w c t r a n s function requires two parameters: wc (a wide char­
                                     acter) and d e s c (a value returned by w c t r a n s ) . t o w c t r a n s maps wc to
                                     another wide character based on the mapping specified by d e s c . For example, the
                                     call

                                     to w c tr a n s ( w c , w c t r a n s ( " t o l o w e r " ) )

                                     is equivalent to kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     towlower(wc)

                                     t o w c t r a n s is most useful in conjunction with implementation-defined map­
                                     pings.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                     Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                             Q:      H o w lo n g is th e lo c a le in fo r m a tio n s tr in g r e tu r n e d by s e t l o c a l e ? [p . 6 44]
                              A:     There's no maximum length, which raises a question: how can we set aside space
                                     for the siring if we don’t know how long it will be? The answer, of course, is
                                     dynamic storage allocation. The following program fragment (based on a similar
                                     example in Harbison and Steele’s C: A Reference M anual) shows how to deter­
                                     mine the amount of memory needed, allocate the memory dynamically, and then
                                     copy the locale information into that memory:

                                     char *temp, *old locale;

                                     temp - setlocale(LC_ALL, NULL);
                                     if (temp == NULL) {
                                       /* locale information not available */

                                     old_locale = malloc(strlen(temp) + 1);
                                     if (old_locale == NULL) {
                                       /* memory allocation failed */

                                     strcpy(old_locale, temp);

                                     We can now switch to a different locale and then later restore the old locale:

                                     setlocale(LC_ALL,                     ””                     /* switches to native locale */

                                     setlocale(LC_ALL, old_locale); /* restores old locale */

                             Q:      W hy      d oes   C    p r o v id e    b o th   m u Itib y te   c h a r a c te r s   and   w id e   c h a r a c te r s?
                                     W o u ld n ’t e ith e r o n e b e e n o u g h b y its e lf? [p. 6 4 8 ]
                              A:     The two encodings serve different purposes. Multibyte characters are handy for
                                     input/output purposes, since I/O devices are often byte-oriented. Wide characters,
                                     on the other hand, are more convenient to work with inside a program, since
                                     every wide character occupies the same amount of space. Thus, a program might
                                                                                                                                     6 7 5 onmlkjihgfedcbaZYX
                                                                                                             E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIH


                            read multibyte characters, convert them to wide characters for manipulation
                            within the program, and then convert the wide characters back to mullibyte form
                            for output.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      Q:    U n ic o d e a n d U C S s e e m to b e p r e tty m u c h th e s a m e . W h a t ’s th e d iff e r e n c e
                            b e tw e e n th e tw o ? Lp. 6 5 0 ]
                      A:    Both contain the same characters, and characters are represented by the same code
                            points in both. Unicode is more than ju st a character set, though. For example, Uni­
                            code supports ‘"bidirectional display order? Some languages, including Arabic and
                            Hebrew, allow text to be written from right to left instead of left to right. Unicode
                            is capable of specifying the display order of characters, allowing text to contain
                            some characters that are to be displayed from left to right along with others that go
                            from right to left.aZYXWVUTSRQPONMLKJIHGFEDCBA




                             E x e r c is e s

S e c ti o n 25.1      l.    Determine which locales are .supported by your compiler.

S e c ti o n 2 5 .2   2.    The Shift-JIS encoding for cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                         kanji requires either one or two bytes per character. If the first
                            byte of a character is between 0 x 8 1 and 0 x 9 f or between 0 x e 0 and 0 x e f , a second byte
                            is required. (Any other byte is treated as a whole character.) The second byte must be
                            between 0 x 4 0 and 0 x 7 e orbetw een 0 x 8 0 and 0 x f c . (All ranges are inclusive.) Foreach
                            of the following strings, give the value that the m b c h e c k function of Section 25.2 will
                            return when passed that string as its argument, assuming that mullibyte characters are
                            encoded using Shift-JIS in the current locale.
                            (a)   " \x 0 5 \x 8 7 \x 8 0 \x 3 6 \x e d \x a a "
                            (b)   " \x 2 0 \x e 4 \x 5 0 \x 8 8 \x 3 f"
                            (c)   " \x d e \x a d \x t> e \x e f"
                            (d)   " \x 8 a \x 6 0 \x 9 2 \x 7 4 \x 4 1 "

                      3.    One of the useful properties of UTF-8 is that no sequence of bytes within a multibyte char-
                            actercan possibly represent another valid mullibyte character. Does the Shift-JIS encoding
                            for kanji (discussed in Exercise 2) have ihis property?

                      4.    Give a C siring literal thal represents each of the following phrases. Assume that the charac­
                            ters h, e, 6, e, i, 6, u, and ii are represented by single-byte Lalin-1 characters. (You’ll necd to
                            look up the Latin-1 code points for these characters.) For example, the phrase dejd vu could
                            be represented by the string " d \ x e 9 j \ x e 0 v u " .
                            (a)   Cote d'A zur
                            (b)   crem e brulee
                            (c)   crcn iefra ich e
                            (d)   Fahrvergniigen
                            (e)   tete-a-tete

                      5.    Repeat Exercise 4, this time using the UTF-8 multibyte encoding. For example, the phrase
                            dejd vu could be represented by the string " d \ x c 3 \ x a 9 j \ x c 3 \ x a 0 v u " .
6 7 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r2 5    ln t e r n a t io n a lF e a t u r e s aZYXWVUTSRQPONMLKJIHGFEDCBA


S e c t io n 2 5 .3     ©               Modify the following program fragment by replacing as many characters as possible by tri­
                               6. onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     graphs.
                                     w h i l e ( ( o r i g _ c h a r = g e t c h a r ( ) ) != EOF) {
                                        n e w _ c h a r = o r i g _ c h a r ^ KEY;
                                        i f ( i s p r i n t ( o r i g _ c h a r ) && i s p r i n t ( n e w _ c h a r ) )
                                             p u tc h a r(n e w _ c h a r);
                                        e ls e
                                             p u tc h a r(o rig c h a r);


                               7.    (C99) Modify the program fragment in Exercise 6 by replacing as many tokens as possible
                                     by digraphs and macros defined in < i s o 6 4 6 .h > .




                                      P r o g r a m m in g P r o je c t s

                        ©      1.    W rite a program that tests whether yonr com pilers "" (native) locale is the same as its "C"
                                     locale.

                               2.    W rite a program that obtains the name of a locale from the command line and then displays
                                     the values stored in the corresponding l c o n v structure. For example, if the locale is
                                     " f i _ F I " (Finland), the output of the program might look like this:
                                     d e c i m a l _ p o i n t = ••, "
                                     t h o u s a n d s _ se p = " "
                                     g ro u p in g = 3
                                     m o n _ d e c i m a l _ p o i n t = " , •’
                                     m o n _ th o u s a n d s _ s e p = " "
                                     m o n _ g ro u p in g = 3
                                     p o s itiv e _ s ig n = " "
                                     n e g a tiv e _ s ig n = "-"
                                     c u r r e n c y _ s y m b o l = "EUR"
                                     fra c _ d ig its = 2
                                     p _ c s_ p re c e d e s = 0
                                     n _ c s_ p re c e d e s = 0
                                     p _ sep _ b y _ sp ace = 2
                                     n _ sep _ b y _ sp ace = 2
                                     p _ s ig n _ p o s n = 1
                                     n _ s ig n _ p o s n = 1
                                     i n t _ c u r r _ s y m b o l = "EUR "
                                     in t_ fra c _ d ig its = 2
                                     in t_ p _ c s _ p re c e d e s = 0
                                     in t_ n _ c s _ p re c e d e s = 0
                                     in t_ p _ s e p _ b y _ _ s p a c e = 2
                                     in t_ n _ s e p _ b y _ s p a c e = 2
                                     in t_ p _ s ig n _ p o s n = 1
                                     in t_ n _ s ig n _ p o s n = 1
                                     For readability, the characters in g r o u p i n g and m o n _ g r o u p i n g should be displayed as
                                     decimal numbers.
2 6       M is c e lla n e o u s L ib r a r y
          F u n c t io n s                ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                       It is th e u s e r w h o s h o u ld p a r a m e tr iz e
                                                                                 p ro c e d u r e s , n o t t h e ir c re a to rs . onmlkjihgfedcbaZYXW




          < s t d a r g . h > , < s t d l i b . h > , and < t i m e . h > — the only C89 headers that
          weren't covered in previous chapters— are unlike any others in the standard library.
          The < s t d a r g . h> header (Section 2 6 .1) makes it possible to write functions with
          a variable number of arguments, < s t d l i b . h > (Section 26.2) is an assortm ent of
          functions that donT fit into one of the other headers. The < t i m e . h> header (Sec­
          tion 26.3) allows programs to work with dates and times.




 2 6 .1   T h e < s t d a r g . h > H e a d e r : V a r ia b le A r g u m e n t s cbaZYXWVUTSRQPONMLKJIHGFE

           type v a _ a r g ( v a _ l i s t a p , type) ;
           v o id v a _ c o p y (v a _ lis t d e s t, v a _ l i s t          src );
           v o id v a _ e n d ( v a _ lis t a p );
           v o i d v a _ s t a r t ( v a _ l i s t a p , p c in iiN );

          Functions such as p r i n t f and s c a n f have an unusual property: they allow any
          number of arguments. The ability to handle a variable number of argum ents isn’t
          limited to library functions, as it turns out. The < s t d a r g . h> header provides the
          tools weTl need to write our own functions with variable-lengo th arogum ent lists,
          < s t d a r g . h > declares one type ( v a _ l i s t ) and defines several macros. In C89,
          there are three macros, named v a _ s t a r t , v a _ a r g , and v a _ e n d . which can bc
  <@ >    thought of as functions with the prototypes shown above. C99 adds a function-like
          macro named v a _ c o p y .kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                                                                                                                          677
6 7 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           To see how these macros work, w e’ll use them to write a function named
                                                                                 a n y num ber o f integer argum ents. H ere’s
                                      m a x _ i n t that finds the maximum of cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      how we might call the function:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      max_int(3, 10, 30, 20)

                                      The first argum ent specifies how many additional argum ents will follow. This call
                                      o f m a x _ i n t will return 30 (the largest of the numbers 10, 30, and 20).
                                           H ere’s the definition of the m a x _ i n t function:

                                       int max_int(int n,                   ...)         /* n must be at least 1 */

                                          va_list ap;
                                          int i, current, largest;

                                          va_start(ap, n);
                                          largest = va_arg(ap, int);

                                          for (i = 1; i < n; i++) {
                                            current = va_arg(ap, int);
                                            if (current > largest)
                                              largest = current;


                                          va_end(ap);
                                          return largest;


                                      The . . . symbol in the param eter list (known as an ellip sis) indicates that thc
                                      param eter n is followed by a variable num ber of additional parameters.
                                           The body of m a x _ i n t begins with the declaration of a variable of type
                                      v a _ lis t:

                                      va_list ap;

                                      Declaring such a variable is mandatory for m a x _ i n t to be able to access the argu­
                                      ments that follow n.
                       va_start           The statement

                                      va_start(ap, n);

                                       indicates where the variable-length part of the argum ent list begins (in this case,
                                       after n). A function with a variable num ber of argum ents must have at least one
                                       “norm al” parameter; the ellipsis always goes at the end of the param eter list, after
                                       the last normal parameter.
                        va_arg              The statem ent

                                       largest = va_arg(ap, int);

                                       fetches m a x _ i n t 's second argum ent (the one after n), assigns it to l a r g e s t ,
                                       and autom atically advances to the next argument. The word i n t indicates that we
                                       expect m a x _ i n f s second argument to have i n t type. The statem ent
                                                                         2 6 .1                                                                                    679
                                                                                  T h e < s t d a r g . h > H e a d e r : V a r i a b l e A r g u m e n t s kjihgfedcbaZYXWVUTSRQPONMLK

                                                         current - va_arg(ap, int);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                         fetches m a x _ i n t 's remaining arguments, one by one, as il is executed inside a
                                                         loop.


                                                         Don’t forget that v a _ a r g always advances to the next argument after fetching the
                                         A               current one. Because ofthis property, we couldn’t have written m a x _ i n t \ s loop in
                                                         the following way:
                                                         for (i = 1; i < n; i++)
                                                           if (va_arg(ap, int) > largest)                             /*** WRONG ***/
                                                             largest = va_arg(ap, int);


                                     va_end                   The statement

                                                         va_end(ap);

                                                         is required to “clean up” before the function returns. (Or, instead of returning, the
                                                         function mioght call v a _ s t a r t and tra© v erse the arguom en/t list again.)
                                   va_copy                    The v a _ c o p y macro copies s r c (a v a _ l i s t value) into d e s t (also a
                                                         v a _ l i s t ) . The usefulness of v a _ c o p y lies in the fact that multiple calls of
                                                         v a _ a r g may have been made using s r c before it’s copied into d e s t , thus pro­
                                                         cessing some of the arguments. Calling v a _ c o p y allows a function to remember
                                                         where it is in the argument list so that it can later return to the same point to reex­
                                                         amine an argument (and possibly the arguments that follow it).
                                                              Each call of v a _ s t a r t or v a _ c o p y must be paired with a call of v a _ e n d ,
                                                         and the calls must appear in the same function. All calls of v a _ a r g must appear
                                                         between the call o f v a _ s t a r t (or v a _ c o p y ) and the matching call o f v a _ e n d .aZYXWVUTSRQPO


                                                         When a function with a variable argument list is called, the compiler performs the
                                                         default argument promotions on all arguments that match the ellipsis. In particular,
                                                > 9 .3
d e f a u lt a r g u m e n t p r o m o t io n s BA       c h a r and s h o r t arguments are promoted to i n t , and f l o a t values are pro­
                                                         moted to d o u b l e . Consequently, it doesn’t make sense to pass types such as
                                                         c h a r , s h o r t , or f l o a t to v a _ a r g , since arguments— after promotion— will
                                                         never have one of those types.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                         C a llin g a F u n c tio n w ith a V a r ia b le A r g u m e n t L is t

                                                         CaUing a function with a variable argument list is an inherently risky proposition.
                                                         As far back as Chapter 3, we saw how dangerous it can be to pass the wrong argu­
                                                         ments to p r i n t f and s c a n f . Other functions with variable argument lists are
                                                         equally sensitive. The primary difficulty is that a function with a variable argument
                                                         list has no way to determine the number of arguments or their types. This informa­
                                                         tion must be passed into the function and/or assumed by the function, m a x _ i n t
                                                         relies on the first argument to specify how many additional arguments follow; it
           C h a p te r 2 6    M is c e lla n e o u s L ib ra ry F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
6 8 0 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                     assumes that the arguments are of type i n t . Functions such as p r i n t f and
                                     s c a n f rely on the formal string, which describes the number of addilional argu­
                                     ments and the type of each.
                                           Another problem has to do with passing NULL as an argument. NULL is usu­
                                     ally defined to represent 0. When 0 is passed to a function with a variable argu­
                                     ment list, the compiler assumes that it represents an integer— there’s no way it can
                                     tell that we want it to represent the null pointer. The solution is to add a cast, writ­
                                     ing ( v o i d *) NULL or ( v o i d *) 0 instead ofNULL. (See the Q&A section al
                                     the end of Chapter 17 for more discussion of this point.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     T h e v . . . p r i n t f F u n c tio n s

                                       i n t v f p r in tf ( F I L E * r e s t r i c t s tre a m ,
                                                               c o n s t c h a r * r e s t r i c t fo rm a t,
                                                               v a _ l i s t a r g ) ; //w ? ? < s td io .h >
                                       i n t v p r i n t f ( c o n s t c h a r * r e s t r i c t fo rm a t,
                                                                                            fro m < s t d i o . h >
                                                             v a _ l i s t a r g ) ; cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       in t v s n p r in tf(c h a r ★ r e s tr ic t s f s iz e _ t n,
                                                                c o n s t c h a r * r e s t r i c t fo r m a t,
                                                                v a _ l i s t a r g ) ; fro m < s t d i o . h>
                                       in t v s p rin tf(c h a r * r e s tr ic t s,
                                                               c o n s t c h a r * r e s t r i c t fo rm a t,
                                                               v a _ l i s t a r g ) ; /z w ? < s td io .h >

                       vfprintf      The v f p r i n t f , v p r i n t f , and v s p r i n t f functions (the “v . . . p r i n t f func-
                        vprintf      tions”) belong to < s t d i o . h > . We’re discussing them in this section because
                       vsprintf      (hey’re invariably used in conjunction with the macros in < s t d a r g . h>. C99 adds
                         <ffi>       the v s n p r i n t f function.
                                             The v . . . p r i n t f functions are closely related to f p r i n t f , p r i n t f , and
                                     s p r i n t f . Unlike these functions, however, the v . . . p r i n t f functions have a
                                     fixed number of ar<                                            argument is a v a l i s t value.
                                                                 g^7uments. EachG* function’s last^^—
                                     which implies that it will be called by a function with a variable argument list. In
                                     practice, the v . . . p r i n t f functions are used primarily for writing ‘‘wrapper” func­
                                     tions that accept a variable number of arguments, which are then passed to a
                                     v . . . p r i n t f function.
                                             As an example, let’s say thal w e’re working on a program that needs to display
                                     error messages from time to time. We’d like each message to begin with a prefix of
                                     the form kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     ** Error ii:
                                     where n is 1 for lhe first error message and increases by one for each subsequent
                                     error. To make it easier to produce error messages, w e’ll write a function named
                                     e r r o r f that’s similar to p r i n t f , but adds ** E r r o r n : to the beginning of
                                2 6 .1    T h e < s t d a r g . h> H e a d e r : V ariable A r g u m e n ts onmlkjihgfedcbaZYXWVUTSRQPONML
                                                                                                                      681

               its output and always writes to s t d e r r instead of s t d o u t . W e'll have e r r o r f
               call v f p r i n t f to do most o flh e actual output. H ere’s what e r r o r f might look
               like:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

               int errorf(const char *format,                        ...)
               {
                 static int num_errors = 0;
                 int n ;
                 va_list ap;

                   num_errors++;
                   fprintf(stderr, "** Error %d: ”, num_errors);
                   va_start(ap, format);
                   n = vfprintf(stderr, format, ap);
                   va_end(ap);
                   fprintf(stderr, ”\n“);
                   return n;
               }

                    The wrapper function— e r r o r f , in our exam ple— is responsible for calling
               v a _ s t a r t prior to calling the v . . . p r i n t f function and for calling v a _ e n d after
               the v . . . p r i n t f function returns. The w rapper function is allowed to call v a _ a r g
               one or more times before calling the v . . . p r i n t f function.
vsnprintf           The v s n p r i n t f function was added to the C99 version of < s t d i o . h > . It
               corresponds to s n p r i n t f (discussed in Section 22.8). which is also a C99 func­
               tion.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


   <%%fr       T h e v . . . s c a n f F u n c tio n s

                   in t   v fs c a n f( F I L E * r e s t r i c t s tr e a m ,
                                         c o n s t c h a r * r e s t r i c t fo r m a t,
                                         v a _ lis t a rg );       /k w 2 < s td i0 .h >
                   in t   v s c a n f( c o n s t c h a r * r e s t r i c t fo r m a t,
                                       v a _ lis t a rg );          /r c w /< s td io .h >
                   in t   v s s c a n f(c o n s t ch a r * r e s t r i c t s,
                                         c o n s t c h a r * r e s t r i c t fo r m a t,
                                         v a _ lis t a rg );      /r r w ? < s td io .h >

 vfsca n f     C99 adds a set of “v ...s c a n f functions” to the < s t d i o . h > header, v f s c a n f .
  v sc a n f   v s c a n f . and v s s c a n f are equivalent to f s c a n f . s c a n f . and s s c a n f .
v ssc a n f    r e spectively, except that they have a v a _ l i s t param eter through which a variable
               argument list can be passed. Like the v . . . p r i n t f functions., each v . . . s c a n f func­
               tion is designed to be called by a wrapper function that accepts a variable num ber
               of arguments, which it then passes to the v . . . s c a n f function. The w rapper func­
               tion is responsible for calling v a _ s t a r t prior to calling the v . . . s c a n f function
               and for calling v a e n d after the v ...s c a n f function returns.
6 8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 6    M is c e lla n e o u s L ib ra ry F u n c tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA




                      2 6 .2        T h e < s t d l i b . h > H e a d e r : G e n e r a l U t ilit ie s onmlkjihgfedcbaZYXWVUTSRQPONM

                                    < s t d l i b . h > serves as a catch-all for functions that don’t fit into any of the other
                                    headers. The functions in < s t d l i b .h > fall into eight groups:

                                          Numeric conversion functions
                                          Pseudo-random sequence generation functions
                                          M em ory-m anagem ent functions
                                          Com munication with the environment
                                          Searching and sorting utilities
                                               g2er arithmetic functions
                                          Inte <
                                          M ultibyte/w ide-character conversion functions
                                          M ultibyte/w ide-string conversion functions

                                    W e’ll look at each group in turn, with three exceptions: the mem ory management
                                    functions, the m ultibyte/wide-character conversion functions, and the multibyte/
                                    wide-string conversion functions.
                                          The m em ory-m anagem ent functions ( m a l l o c , c a l l o c , r e a l l o c , and
                                    f r e e ) perm it a program to allocate a block of m emory and then later release it or
                                    change its size. Chapter 17 describes all four functions in som e detail.
                                          The m ultibyte/wide-character conversion functions are used to convert a
                                    multibyte character to a wide character or vice-versa. The multibyte/wide-string
                                    conversion functions perform sim ilar conversions between m ultibyte strings and
                                    wide strings. Both groups of functions are discussed in Section 25.2.dcbaZYXWVUTSRQPONMLKJIHGFE


                                    N u m e r ic C o n v e r s io n F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      double atof(const char *nptr);
                                      int atoi(const char *nptr);
                                      long int atol(const char *nptr);PONMLKJIHGFEDCBA
                                      long long int atoll (const char *nptr);
                                      double strtod(const char * restrict nptr,
                                                    char ** restrict endptr);
                                      float strtof(const char * restrict nptr,
                                                   char ** restrict endptr);
                                      long double strtold(const char * restrict nptr,
                                                          char ** restrict endptr);
                                      long int strtol(const char * restrict nptr,
                                                      char ** restrict endptr, int base);
                                                  2 6 .2    T h e < s t d l i b . h > H e a d e r: G e n e ra l U tilitie s hgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                                    683



                             long long int strtoll (const char * restrict nptr,
                                                    char ** restrict endptr,
                                                    int base);kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                             unsigned long int strtoul(
                               const char * restrict nptr,
                               char ** restrict endptr, int base);
                             unsigned long long int strtoull(
                               const char * restrict nptr,
                               char ** restrict endptr, int base);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                       The numeric conversion functions (or “string conversion functions,” as they’re
                                       known in C89) convert strings containing numbers in character form to their
                                       equivalent numeric values. Three of these functions are fairly old, another three
                                       were added when the C89 standard was created, and five more were added in
                                       C99.
                                              All the numeric conversion functions— whether new or old— work in much
                                       the same way. Each function attem pts to convert a string (pointed to by the n p t r
                                       parameter) to a number. Each function skips w hite-space characters at the begin­
                                       ning of the string, treats subsequent characters as part of a num ber (possibly begin­
                                       ning with a plus or minus sign), and stops at the first character that can 't be part of
                                       the number. In addition, each function returns zero if no conversion can be per­
                                       formed (the string is empty or the characters following any initial white space
                                       don’t have the form the function is looking for).
                           a to f             The old functions ( a t o f , a t o i , and a t o l ) convert a string to a d o u b l e ,
                           a to i      i n t , or l o n g i n t value, respectively. Unfortunately, these functions lack any
                           a to l
                                       way to indicate how much of the string was consumed during a conversion. M ore­
                                       over, the functions have no way to indicate that a conversion was unsuccessful.
    e r m o v a ria b le > 2 4 . 2     (Some im plementations of these functions may modify the e r r n o variable when a
                                       conversion fails, but that’s not guaranteed.)
                       s tr to d              The C89 functions (strtod, strtol, and strtoul) are more sophisti­
                        s trto l       cated. For one thing, they indicate where the conversion stopped by m odifying the
                     s trto u l aZYXWVUTSRQPONMLKJIHGFEDCBA
                                       variable that e n d p t r points to. (The second argument can be a null pointer if
                                       w e’re not interested in where the conversion ended.) To check w hether a function
                                       was able lo consume the entire string, we can ju st test whether this variable points
                                       to a null character. If no conversion could be perform ed, the variable that e n d p t r
                                       points to is given the value o f n p t r (as long as e n d p t r isn’t a null pointer).
                                       W hat’s more, strtol and strtoul have a base argum ent that specifies the
                                       base of the number being converted. All bases between 2 and 36 (inclusive) are
                                       supported.
                                              Besides being more versatile than the old functions, strtod, strtol, and
                                       strtoul are better at detecting errors. Each function stores ERANGE in errno
                                       if a conversion produces a value that’s outside the range of the function’s return
                                       type. In addition, the s t r t o d function returns plus or minus HUGE VAL; the
H U G E V A L m a c r o > 2 3 . 3 PONMLKJIHGFEDCBA
6 8 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c tio n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                s t r t o l and s t r t o u l functions return the smallest or largest values of their
                                                respective return types, ( s t r t o l returns either LONG_MIN or LONG_MAX, and
    < l i m i t s . h > m a c r o s >23.2       s t r t o u l returns ULONG_MAX.)
                                    a to ll             C99 adds the a t o l l , s t r t o f , s t r t o l d , s t r t o l l , and s t r t o u l l
                                   s trto f     functions, a t o l l is the same as the a t o l function, except that il converts a
                                s tr to ld
                                               string to a l o n g l o n g i n t value, s t r t o f and s t r t o l d are the same as
                                  s tr to ll
                                                s t r t o d , except that they convert a string to a f l o a t or l o n g d o u b l e value,
                              s tr to u ll aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                respectively, s t r t o l l is the same as s t r t o l . except that it converts a string to
                                               a l o n g l o n g i n t value, s t r t o u l l is the same as s t r t o u l , except that il
                                               converts a string to an u n s i g n e d l o n g l o n g i n t value. C99 also makes a
                                               small change to the floating-point numeric conversion functions: the string passed
                                                to s t r t o d (as well as its newer cousins, s t r t o f and s t r t o l d ) may contain a
                                                hexadecimal floating-point number, infinity, or NaN.
                                   Q & A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




               PROGRAM              T e s tin g th e N u m e r ic C o n v e r s io n F u n c t io n s

                                    The following program converts a siring to numeric form by applying each of the
                                    six numeric conversion functions that exist in C89. After callinL      sz the s t r t o d .
                                    s t r t o l , and s t r t o u l functions, the program also shows whether each conver­
                                    sion produced a valid result and whether it was able to consume the entire string.
                                    The program obtains the input string from the command line.BA

                tnumconv.C kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                               / ★ Tests C89 numeric conversion functions */

                                    #include <errno.h>
                                    #include <stdio.h>
                                    #include <stdlib.h>

                                    #define CHK_VALID                  printf("    %s           %s\n",         \
                                                                              errno != ERANGE ? "Yes" : "No ", \
                                                                              *ptr == '\0' ? "Yes" : "No")

                                    int main(int argc, char *argv[])

                                        char *ptr;

                                        if (argc != 2) {
                                          printf("usage: tnumconv string\n");
                                          exit(EXIT_FAILURE);


                                        printf("Function                 Return Value\n");
                                        printf ("-------                  ----------- \n") ;
                                        printf("atof                     %g\n", atof(argv[l]));
                                        printf("atoi                     %d\n", atoi(argv[l]));
                                        printf("atol                     %ld\n\n", atol(argv[l]));

                                        printf("Function   Return Value                              Valid?          ”
                                               "String Consumed?\n"
                       2 6 .2                                                                                        685
                                    T h e < s t d l i b . h > H e a d e r : G e n e r a l U t i l i t i e s hgfedcbaZYXWVUTSRQPONMLKJIHG

                                                                                       II


               I I kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  \ n ") ;

  errno = 0;
  p r i n t f ("strtod                  %-12g",            strtod(argv[l],             &ptr));
  CHK_VALID;

  errno = 0;
  p r i n t f ("strtol                  %-121d",            strtol(argv[l],                 &ptr,    10));
  CHK_VALID;

  errno - 0;
  p r i n t f ("strtoul                 %-121u",            strtoul(argv[l],                 &ptr,     10));
  CHK_VALID;

   return 0;onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


    If 3 0 0 0 0 0 0 0 0 0 is the com m and-line argument, the output of the program
might have the following appearance:
Function          Return Value

atof              3e+09
atoi              2147483647
atol              2147483647

Function          Return Value                    Valid?           String Consumed?

strtod            3e+09                             Yes                        Yes
strtol            2147483647                        No                         Yes
strtoul           3000000000                        Yes                        Yes

On many machines, the number 3000000000 is too large to represent as a long
integOer,7 althC*o ugh it’s valid as an uOn signed Olong w
                                                         integer. T h e a t o i and a t o l func-
tions had no way to indicate that the num ber represented by their argument was out
of range. In the output shown, they returned 2147483647 (the largest long integer),
but the C standard doesn’t guarantee this behavior. The s t r t o u l function per­
formed the conversion correctly: s t r t o l relumed 2147483647 (the standard
requires it to return the largest long integer) and stored ERANGE in e r r n o .
      If 1 2 3 . 4 5 6 is the com m and-line argument, the output will be
Function          Return Value

atof             123.456
atoi             123
atol             123

Function           Return Value                   Valid?           String Consumed?

strtod             123.456                          Yes                        Yes
strtol             123                              Yes                        No
strtoul            123                              Yes                        No
6 8 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        All six functions treated this strin<oz as a valid number,^ althougoh the inteoger func-
                                        tions stopped at the decimal point. The s t r t o l and s t r t o u l functions were
                                        able to indicate that they didn’t completely consum e the string.
                                             If f o o is the com m and-line argument, the output will be kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        Function           Return Value

                                        atof               0
                                        atoi               0
                                        atol               0

                                        Function           Return Value                Valid?            String Consumed?

                                        strtod             0                             Yes                        No
                                        strtol             0                             Yes                        No
                                        strtoul            0                             Yes                        No

                                        All the functions looked at the letter f and immediately returned zero. The s t r . . .
                                        functions didn't changC*e e r r n o , but we c^^a n tell that s4o^ mething went wrong from
                                        th efact that the functions didn’t consume the string.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                        P s e u d o -R a n d o m S e q u e n c e G e n e r a tio n F u n c tio n s

                                         int rand(void);
                                         void srand(unsigned int seed);

                                        The r a n d and s r a n d functions support the generation of pseudo-random num­
                                        bers. These functions are useful in simulation programs and gam e-playing pro­
                                        grams (to simulate a dice roll or the deal in a card game, for example).
                              ra n d           Each time it’s called, r a n d returns a number between 0 and RAND_MAX (a
                                        macro defined in < s t d l i b . h > ) . The numbers returned by r a n d aren’t actually
                                        random; they’re generated from a “seed” value. To the casual observer, however,
                                        r a n d appears to produce an unrelated sequence of numbers.
                            s ra n d           Calling s r a n d supplies the seed value for r a n d . If r a n d is called prior to
                                        s r a n d , the seed value is assumed to be 1. Each seed value determ ines a particular
                                        sequence of pseudo-random numbers; s r a n d allows us to select which sequence
                                        we want.
                                               A program that always uses the same seed value will always get the same
                                        sequence of numbers from r a n d . This property can sometimes be useful: the pro­
                                        gram behaves the same way each time it’s run, making testing easier. However, we
                                                                                different sequence each time the program is run.
                                        usually want r a n d to produce a cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        (A poker-playing program that always deals the same cards isn’t likely to be popu­
             t i m e function >26 . 3   lar.) The easiest way to “random ize” the seed values is to call the t i m e function,
                                        which returns a number that encodes the current date and time. Passing t i m e ’s
                                        return value to s r a n d makes the behavior of r a n d vary from one run to the next.
                                        See the g u e s s . c and g u e s s 2 . c programs (Section 10.2) for examples of this
                                        technique.
                                      2 6 ,2                                                                          687onmlkjihgfedcbaZYXWVU
                                               T h e < s t d l i b . h > H e a d e r : G e n e ra l U tilitie s kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


            T e s tin g th e P s e u d o - R a n d o m S e q u e n c e G e n e r a t io n F u n c ti o n s
PROGRAM dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                   The following program displays the first five values returned by the r a n d func­
                   tion. then allows the user to choose a new seed value. The process repeats until the
                   userenters zero as the seed.
      tra n d .C   /★    Tests the pseudo-random sequence generation functions */

                   #include <stdio.h>
                   #include <stdlib.h>

                   int main(void)

                        int i z seed;

                        printf("This program displays the first five values of "
                               "rand.\n");

                        for (; ;) {
                          for (i = 0; i < 5; i ++ )
                            printf("%d ", rand());
                          printf("\n\n");
                          printf("Enter new seed value (0 to terminate):                                   ");
                          scanf("%d", &seed);
                          if (seed == 0)
                            break;
                          srand(seed);


                        return 0;


                   Here’s how a session with the program might look:
                   This program displays the first five values of rand.
                   1804289383 846930886 1681692777 1714636915 1957747793

                   Enter new seed value (0 to terminate): 100
                   677741240 611911301 516687479 1039653884 807009856

                   Enter new seed value (0 to terminate): 1
                   1804289383 846930886 1681692777 1714636915 1957747793

                   Enter new seed value (0 to terminate) : £

                   There are many ways to write the r a n d function, so there’s no guarantee that
                   every version of r a n d will generate the numbers shown here. Note that choosing 1
                   as the seed gives the same sequence of numbers as not specifying the seed at all.


                   C o m m u n ic a tio n w ith th e E n v ir o n m e n t

                        void abort(void);
                        int atexit(void (*func)(void));
            C h a p te r 2 6
6 8 8 ZYXWVUTSRQPONMLKJIHGFEDCBAM is c e lla n e o u s L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



                                                  v o i d e x i t ( i n t s t a t u s ) ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                  v o id _ E x it ( in t s ta tu s ) ;
                                                  c h a r * g e te n v ( c o n s t c h a r * n a m e );
                                                  i n t s y s t e m ( c o n s t c h a r * s t r i n g ) ;dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 The functions in lhis group provide a sim ple interface to the operating system,
                                                 allowing programs to (I) terminate, either norm ally or abnorm ally, and reium a
                                                 status code to the operating system . (2) fetch inform ation from the user’s environ-
                                  <*ffi>         ment, and (3) execute operating system com m ands. One of the functions, _ E x i t ,
                                                 is a C99 addition.
                                       exit             Perform ing the call e x i t (//) anywhere in a program is norm ally equivalent
                                                 to executing the statement r e t u r n /z; in m a in : the program term inates, and n is
                                   Q&A           returned to the operating system as a status code, < s t d l i b . h> defines the mac­
                                                 ros E X IT M_FAILURE and E X IT —SUCCESS, which can be used as ar^gum ents to
                                                 e x i t . The only other portable argument to e x i t is 0, which has the sam e mean­
                                                 ing^» as E X I^M. SUCCESS. Returni<^n*g status codes other than these is K
                                                                TM                                                            l^egal but not
                                                 necessarily portable to all operating systems.
                                  atexit               W hen a program term inates, it usually perform s a few final actions behind the
                                                 scenes, including flushing output buffers that contain unwritten data, closing open
                                                 streams, and deleting temporary files. We may have other ‘"clean-up” actions that
                                                 w e’d like a program to perform at term ination. The a t e x i t function allows us to
                                                 ‘"register” a function to be called upon program term ination. To register a function
                                                 named c l e a n u p , forexaniple. we could call a t e x i t as follows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFE

                                                 atexit(cleanup);

                                                 When we pass a function pointer to a t e x i t . it stores the pointer away for future
                                                 reference. If the program later term inates norm ally (via a call of e x i t or a
                                                 r e t u r n statem ent in the m a in function), any function registered with a t e x i t
                                                 will be called automatically. (Iftw o or m ore functions have been registered, they’re
                                                 called in the reverse o fth e order in which they were registered.)
                                   _ E xit             The _ _ E x it function is sim ilar to e x i t . However, _ E x i t d o esn't call func­
                                                 tions that have been registered with a t e x i t , nor does it call any signal handlers
          s i g n a i f u n c t io n > 2 4 . 3   previously passed to the s i g n a l function. Also. _ E x i t d o esn 't necessarily flush
                                                 output buffers, close open streams, or delete temporary files— w hether these
                                                 actions are perform ed is im plem entation-defined.
                                   abort                a b o r t is also sim ilar to e x i t , but calling it causes abnorm al program termi­
                                                 nation. Functions registered with a t e x i t aren't called. D epending on the imple­
                                                 mentation, it may be the case that output buffers containing unwritten data aren’t
                                                 flushed, streams aren't closed, and temporary files aren’t deleted, a b o r t returns
                                   Q&A           an im plem entation-defined status code indicating unsuccessful term ination.
                               getenv                   Many operating systems provide an “environm ent” : a set o f strings that
                                                 describe the user’s characteristics. These strings typically include the path to be
                                                 searched when the user runs a program, the type o fth e user's terminal (in the case
                                                 of a m ulti-user system ), and so on. For example, a UNIX search path might look
                               2 6 .2                                                                          689onmlkjihgfedcbaZYXW
                                        T h e < s t d l i b . h > H e a d e r: G e n e ra l U tilitie s kjihgfedcbaZYXWVUTSRQPONMLKJIH


          somethingo like this:

          PATH=/usr/local/bin:/bin:/usr/bin:.

          g e t e n v provides access to any string in the user’s environment. To find lhe cur­
          rent value of the PATH string, for example, we could write

          char *p - getenv("PATH");

          p now points to thestring ” / u s r / l o c a l / b i n : / b i n : / u s r / b i n : . ". B ecare-
          ful with g e t e n v : it returns a pointer to a staticaUy allocated string that may be
          changed by a later call o fth e function.
system         The s y s t e m function allows a C program to run another program (possibly
          an operating system command). The argum ent to s y s t e m is a string containing a
          command, sim ilar to one that w e’d enter at the operating system prompt. For
          example, suppose that w e’re writing a program that needs a listing of Lhe files in
          Lhe current directory. A UNfX program would call s y s t e m in the following way:

          system("ls >myfiles");

          This call invokes the UNLX com m and l s and asks it to write a listing of the cur­
          rent directory into the file named m y f i l e s .
                The retum value of s y s t e m is implementation-defined, s y s t e m typically
          returns the term ination status code from lhe program that we asked it to run: test­
          ing this value allows us to check w hether the program worked properly. Calling
          s y s t e m with a null pointer has a special meaning: the function returns a nonzero
          value if a command processor is available.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


          S e a r c h in g a n d S o r tin g U tilitie s


           v o id   * b s e a rc h (c o n s t v o id *key, c o n s t v o id * b a se ,
                                      s i z e _ t nm em b, s i z e _ t s i z e ,
                                       i n t ( * c o m p a r ) ( c o n s t v o id *,
                                                                c o n s t v o id * ) ) ;
           v o id   q s o r t ( v o i d * b a s e , s i z e _ t nm em b, s i z e _ t s i z e ,
                                 i n t ( * c o m p a r ) ( c o n s t v o i d * , c o n s t v o i d *) ) ;

bsearch   The b s e a r c h function searches a sorted array for a particular value (the “key”).
          When b s e a r c h is called, the k e y param eter points to the key, b a s e points to the
          array, nm em b is the number ofelem enls in the array, s i z e is the size o fe a c h ele­
          ment (in bytes), and c o m p a r is a pointer to a comparison function. The com pari­
          son function is sim ilar to the one required by q s o r t : when passed pointers to the
          key and an array element (in that order), the function must retum a negative, zero,
          or positive integer depending on whether the key is less than, equal to, or greater
          than the array element, b s e a r c h returns a pointer to an elem ent that m atches the
          key: if it doesn’t find a match, b s e a r c h returns a null pointer.
            C h a p te r 2 6   M is c e lla n e o u s L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
6 9 0 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                            Although the C standard doesn’t require it to, b s e a r c h norm ally uses the
                                      binary search algorithm to search the array, b s e a r c h first com pares the key with
                                      the elem ent in the middle o f the array; if there’s a match, the function returns. If
                                      the key is sm aller than the middle element, b s e a r c h limits its search to the first
                                      half of the array; if the key is larger, b s e a r c h searches only the last half of the
                                      array, b s e a r c h repeats this strategy until it finds the key or runs out ofelem ents
                                      to search. Thanks to this technique, b s e a r c h is quite fast— searching an array of
                                      1000 elements requires only 10 com parisons at most; searching an array of
                                      1,000,000 elements requires no more than 20 comparisons.
                          qsort             Section 17.7 discusses the q s o r t function, which can sort any array,
                                      b s e a r c h works only for sorted arrays, but we can always use q s o r t to sort an
                                      array prior to asking b s e a r c h to search it.


                                 D e te r m in in g A ir M ile a g e
               P R O G R A M dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      Our next program com putes the air m ileage from New York City to various inter­
                                      national cities. The program first asks the user to enter a city name, then displays
                                      the mileage to that city:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      Enter city name: Shanghai
                                      Shanghai is 7371 miles from New York City.

                                      The program will store city/m ileage pairs in an array. By using b s e a r c h to
                                      search the array for a city name, the program can easily find the corresponding
                                                                   Infoplease.com .) BA
                                      mileage. 0VIileages are from cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                   airmiles.c         /* Determines air mileage from New York to other cities */

                                      #include <stdio.h>
                                      #include <stdlib.h>
                                      #include <string.h>

                                      struct city_info {
                                        char *city;
                                        int miles;


                                      int compare_cities(const void *key_ptr,
                                                         const void *element_ptr);

                                      int main(void)

                                          char city_name[81];
                                          struct city_info *ptr;
                                          const struct city_info mileage[] =
                                              "Berlin",          3965 r   "Buenos Aires",                                      5297     7


                                              "Cairo",           5602’ ।  "Calcutta",                                          7918’    /


                                              "Cape Town",       7764 t   "Caracas",                                           2132’    /


                                              "Chicago",          713 !   "Hong Kong",                                         8054’    /


                                              "Honolulu",        4964'   ’"Istanbul",       H
                                                                                                                               4975 ’
                                                                                                                                    4   /
                               2 6 .2                                                                             691 kjihgfedcbaZYXWVUT
                                         T h e < s t d l i b . h > H e a d e r : G e n e ra l U tilitie s hgfedcbaZYXWVUTSRQPONMLKJIHGF


                  "Lisbon",                       3364},   "London",               3458'
                  "Los Angeles",                  2451},   "Manila",               8498'
                  "Mexico City",                  2094},   "Montreal",              320}              4



                 {"Moscow",                       4665}, ’"Paris",PONMLKJIHGFEDCBA 3624'
                 {"Rio de Janeiro",               4817}, • "Rome",                 4281'
                  "San Francisco",                2571},   "Shanghai",             7371
                 ^"Stockholm",                    3924},   "Sydney",               9933
                  "Tokyo",                        6740},   "Warsaw",               4344
                  "Washington",                    205}};

           printf("Enter city name: ”);
           scanf("%80[^\n]", city_name);
           ptr = bsearch(city_name, mileage,
                         sizeof(mileage) / sizeof(mileage[0]),
                         s i z e o f (mileage[0]), compare_cities);
           if (ptr != NULL)
             printf("%s is %d miles from New York City.\n",
                    city_name, ptr->miles);
           else
             printf("%s wasn't found.\n", city name);

           return 0;


        int compare_cities(const void *key_ptr,
                           const void *element_ptr)

           return strcmp((char *) key_ptr,
                         ( (struct city_info *) element_ptr)->city);dcbaZYXWVUTSRQPONMLKJ



        h i t e g e r A r i th m e ti c F u n c ti o n s

          int abs(int j);
          long int labs(long int j);
          long long int llabs(long long int j);
          div_t div(int numer, int denom);
          ldiv_t ldiv(long int numer, long int denom);
          lIdiv_t lldiv(long long int numer,
                        long long int denom);onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

 abs    The a b s function returns the absolute value o fa n i n t value; the l a b s function
labs    returns the absolute value o fa l o n g i n t value.
  div        The d i v function divides its first argument by its second, returning a d i v _ t
        value, d i v _ t is a structure that contains both a quotient member (named q u o t )
        and a remainder member (rem ). For example, if a n s is a d i v _ t variable, we
        could write
        ans = d i v (5, 2);
        printf("Quotient:               %d Remainder:            %d\n",       ans.quot,         ans.rem);
6 9 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                              ldivT he l d i v function is similar but works with Ionoa inte^g ers: it returns an l d i v —t
                                  structure, which also has q u o t and re m mem bers. (The d i v _ t and l d i v _ t types
                                  are declared in < s t d l i b . h > . ) cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                          Q&A aZYXWVUTSRQPONMLKJIHGFEDCBA
                           l/abs        C99 provides two additional functions. The l l a b s function returns the abso-
                            lldiv lute value o fa l o n g l o n g i n t value, l l d i v is sim ilar to d i v and l d i v , except
                                  that it divides two l o n g l o n g i n t values and returns an l l d i v _ t structure.
                          < ffi>  (The l l d i v _ t type was also added in C99.) dcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                        2 6 .3        T h e < t i m e . h > H e a d e r : D a te a n d T im e

                                      The < t i m e . h> header provides functions for determ ining the tim e (including the
                                      date), perform ing arithmetic on time values, and form atting times for display.
                                      Before we explore these functions, however, we need to discuss how times are
                                      stored, < t i m e .h > provides three types, each o fw h ich represents a different way
                                      to store a time:
                                             ■ c l o c k _ t : A time value measured in “clock ticks.”
                                             ■ tim e _ t: A       compact, encoded time and date (a c a le n d a r tim e).
                                         ■     s t r u c t tm : A time that has been divided into seconds, minutes, hours, and
                                               so on. A value o f type s t r u c t tm is often called a b ro k en -d o w n tim e. Table
                                               26.1 shows the members o fth e tm stru ctu re. All members are o fty p e i n t .

                    T a b le 2 6 .1                                                                                              M in im u m            M a x im u m
              M embers of the                     N am e                                   D e s c r ip tio n                        V a lu e                V a l u e kjihgfedcbaZYXWVUTSRQPON
                 tm Structure RQPONMLKJIHGFEDCBAtm_sec                         Seconds after the minute                                  6                     6?
                                                     tm_min                    Minutes after the hour                                    o                     59
                                                     tm_hour                   Hours since midnight                                      0                     23
                                                     tm_mday                   Day of the month                                          1                     31
                                                     tm_mon                    Months since January                                      0                     11
                                                     tm_year                   Years since 1900                                          0                     —
                                                     tm_wday                   Days since Sunday                                         0                      6
                                                     tm_yday                   Days since January 1                                      0                    365
                                                                                                                                         tt                    tt
                                                     tm_isdst                  Daylight Saving Time flag
                                                     t
                                                      A llo w s lo r (w o extra “ leap seconds.” In C 9 9 . thc m a x im u m va lue is 60.
                                                     +*f      •       •           •                         •
                                                         P o s itiv e if D a y l i g l i l S a vin g T im e is in e ffe c t, ze ro i f i t ’s n o t in e ffe c t, and
                                                     n e g a tive i f th is in fo rm a tio n is u n k n o w n .


                                           These types are used for different purposes. A c l o c k _ t value is good only
                                      for representing a time duration; t i m e _ t and s t r u c t tm values can store an
                                      entire date and time, t i m e _ t values arc tightly encoded, so they occupy little
                                      space, s t r u c t tm values require much more space, but they’re often easier to
                                      work with. The C standard states that c l o c k _ t and t i m e _ t must be “arithmetic
                                      types,” but leaves it at that. We don’t even know if c l o c k _ t and t i m e _ t values
                                      are stored as integers or floating-point numbers.
                                           W e’re now ready to look at the functions in < t i m e . h > , which fall into two
                                      groups: tim e manipulation functions and tim e conversion functions.
                                     2 6 .3     T h e < t i m e . h > H e a d e r : D a te a n d T im e hgfedcbaZYXWVUTSRQPONMLKJIHGF
                                                                                                                6 9 3 dcbaZYXWVUTSRQPO


        T im e M a n ip u l a t io n F u n c ti o n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


          c lo c k _ t c lo c k ( v o id ) ;
          d o u b le d i f f t i m e ( t i m e _ t t i m e l , tim e _ t tim e O );
          t i m e _ t m k t i m e ( s t r u c t tm * t i m e p t r ) ;
          tim e _ t tim e (tim e _ t * tim e r ) ;

clock   The c l o c k function returns a c l o c k _ t value representing the processor time
        used by the program since execution began. To convert this value to seconds, we
        can divide it by CLOCKS_PER_SEC, a macro defined in < t i m e . h>.
            When c l o c k is used to determine how long a program has been running, it’s
        customary to call it twice: once at. the beginning of m a in and o n ceju st before the
        program terminates:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

        #include <stdio.h>
        #include <time.h>

        int main(void)

             clock_t start_clock = clock();
             •••
             printf("Processor time used: %g sec.\n",
                    (clock() - start_clock) / (double) CLOCKS_PER_SEC);
             return 0;


        The reason for the initial call of c l o c k is that the program will use some proces­
        sor time before it reaches m a in , thanks to hidden “start-up” code. Calling c l o c k
        at the beginning o f m a i n determines how much time the start-up code requires so
        that we can subtract it later.
             The C89 standard says only that c l o c k _ t is an arithmetic type; the type of
        CLOCKS_PER_SEC is unspecified. As a result, the type of the expression

        (clock() - start_clock) / CLOCKS_PER_SEC

        may vary from one implementation to another, making il difficult to display using
        p r i n t f . To solve the problem. our example converts CLOCKS_PER_SEC to
<*^p>   d o u b l e , forcing the entire expression to have type d o u b l e . In C99, the type of
        CLOCKS_PER_SEC is specified to be c l o c k _ t , but c l o c k _ t is still an imple­
        mentation-defined type.
 time         The t i m e function returns the current calendar time. If its argument isn’t a
        null pointer, t i m e also stores the calendar time in the object that the argument
        points to. t i m e 's ability to return a time in two different ways is an historical
        quirk, but it gives us the option o f writing either

        cur_time = time(NULL);

        or
694 ZYXWVUTSRQPONMLKJIHGFEDCBA
         C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     time(&cur_time) ;

                                     where c u r _ t i m e is a variable o fty p e t i m e _ t .
                       difftime           The d i f f t i m e function returns the difference between tim e O (the earlier
                                     time) and t i m e l , measured in seconds. Thus, to compute the actual running time
                                     of a program (not the processor time), we could use the following code:

                                     #include <stdio.h>
                                     #include <time.h>

                                     int main(void)

                                           time_t start_time = time (NULL) ;
                                           •••
                                           printf("Running time: %g sec.\n",
                                                  difftime(time(NULL), start_time));
                                           return 0;


                       mktime             The m k tim e function converts a broken-down time (stored in the structure
                                     that its argument points to) into a calendar time, which it then returns. As a side
                                     effect, m k tim e adjusts the members of the structure according to the following
                                     rules:
                                           ■ m k tim e change s any members whose values aren’t within their legal ranges
                                              (see Table 26.1). Those alterations may in turn require changes to other mem­
                                              bers. If t m _ s e c is too large, for example, m k tim e reduces it to the proper
                                              range (0-59), adding the extra minutes to tm _ m in . If tm _ m in is now too
                                              large, m k tim e reduces it and adds the extra hours to tm _ h o u r . If necessary,
                                              the process will continue to the tm _m day, tm _m on. and t m _ y e a r mem­
                                              bers.
                                       ■     After adjusting the other members of the structure (if necessary), m k tim e
                                             sets tm _ w d a y (day o fth e week) and tm _ y d a y (day of the year) to their cor­
                                             rect values. T here’s never any need to initialize the values of tm _ w d a y and
                                             tm _ y d a y before calling m k tim e ; il ignores the original values of these
                                             members.
                                         m k tim e ’s ability to adjust the members of a tm structure makes it useful for
                                     time-related arithmetic. As a example, let’s use m k tim e to answer the following
                                     question: Ifth e 2012 Olympics begin on July 27 and end 16 days later, what is the
                                     ending date? W e’ll start by storing July 27, 2012 in a tm structure:

                                     struct tm t;

                                     t .tm_mday = 27;
                                     t.tm_mon = 6;                      /♦ July */
                                     t.tm_year = 112;                   /* 2012 */

                                     We’ll also initialize the other members of the structure (except tm _ w d a y and
                                     tm _ y d a y ) to ensure that they don’t contain undefined values that could affect the
                                     answer:
                          2 6 .3                                                                 695onmlkjihgfedcbaZYXWVU
                                   T h e < t i m e . h > H e a d e r: D a te a n d T im e kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


t . tin _ s e c = 0 ;
t . tm _ m in = 0 ;
t . tm _ h o u r = 0 ;
t.tm _ is d s t = -1 ;

Next, w e’ll add 16 to the tm m d ay member:

t.tm _ m d a y += 1 6 ;

That leaves 43 in tm _ m d ay , which is out o f range for that member. Calling
m k tim e will bring the m em bers of the structure back into their proper ranges:

m k tim e (& t ) ;

W e’ll discard m k t i m e ’s return value, since w e’re interested only in the function's
effect on t . The relevant m em bers of t now have the following values:PONMLKJIHGFEDCBA

     Member           Value        Meaning
     tm_mday            12         12
     tm_mon              7         August
     tm_year           112         20f2
     tm_wday             0         Sunday
     tm_yday           224         225th day of the year dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


T im e C o n v e r s io n F u n c tio n s


  char *asctime(const struct tm *timeptr);
  char *ctime(const time_t *timer);
  struct tm *gmtime(const time_t *timer);
  struct tm *localtime(const time_t *timer);
  size_t strftime(char * restrict s, size_t maxsize,
                  const char * restrict format,
                  const struct tm * restrict timeptr);

The time conversion functions make it possible to convert calendar times to bro-
ken-down times. They can also convert times (calendar or broken-down) to string
form. The following figure shows how these functions are related:
            C h a p te r 2 6   M is c e lla n e o u s L ib r a r y F u n c tio n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
6 9 6 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                       The figure includes the m k tim e function, which the C standard classifies as a
                                        “manipulation” function rather than a “conversion” function.
                            gmtime               The g m tim e and l o c a l t i m e functions are similar. When passed a pointer
                          localtime t0 a calendar time, both return a pointer to a structure containing the equivalent
                                        broken-down time, l o c a l t i m e produces a local time, while g m ti m e ’s return
                              Q&A onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        value is expressed in UTC (Coordinated Universal Time). The return value of
                                       g m tim e and l o c a l t i m e points to a statically allocated structure that may be
                                       changed by a later call of either function.
                           asctime              The a s c t i m e (ASCII time) function returns a pointer to a null-terminated
                                        string of the form kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                 Sun Jun      3 17:48:34 2007\n

                                                 constructed from the broken-down time pointed to by its argument.
                                  ctime                 The c t i m e function returns a pointer to a string describing a local time. If
                                                 c u r _ _ tim e is a variable of type t i m e _ t . the call

                                                 ctime (&cur_time)

                                                 is equivalent to

                                                 asctime(localtime(&cur_time))

                                                 The return value of a s c t i m e and c t i m e points to a statically allocated string
                                                 that may be changed by a later call o feith er function.
                             s trftim e               The s t r f t i m e function, like the a s c t i m e function, converts a broken-
                                                 down time to string form. Unlike a s c t i m e , however, it gives us a great deal of
                                                                     <_-                                            £7       O


        s p r i n t f fu n c tio n > 2 2 . 8     control over how the time is formatted. In fact, s t r f t i m e resembles s p r i n t f
                                                 in that it writes characters into a string s (the first argument) according to a for­
                                                 mat string (the third argument). The format string may contain ordinary characters
                                                 (which are copied into s unchanged) along with the conversion specifiers shown
                                                 in Table 26.2 (which are replaced by the indicated strings). The last argument
                                                 points to a tm structure, which is used as the source o fd a te and time information.
                                                 The second argument is a limit on the number of characters that can be stored in
                                                 S.

                                                      The s t r f t i m e function, unlike the other functions in < t i m e .h > , is sensi­
                         lo c a le s > 2 5 . 1   tive to the current locale. Changing the LC_TIME category may affect the behav­
                                                 ior o fth e conversion specifiers. The examples in Table 26.2 are strictly for the "C"
                                                 locale: in a German locale, the replacement for %A might be D i e n s t a g instead of
                                                 T uesday.
                                                      The C99 standard spells out the exact replacement strings for some of the con­
                                                 version specifiers in thc "C" locale. (C89 didn’t go into this level of detail.) Table
                                                 26.3 lists these conversion specifiers and the strings they're replaced by.
                                                      C99 also adds a number of s t r f t i m e conversion specifiers, as Table 26.2
                                                 shows. One of the reasons for the additional conversion specifiers is the desire to
                                                 support the lSO 8601 standard.
                                                                  2 6 .3                                                                      697 dcbaZYXW
                                                                             T h e < t i m e . h > H e a d e r: D a te a n d T im e onmlkjihgfedcbaZYXWVUTSR


                  T a b le 2 6 .2         Con version                                        R eplacem ent
Conversion Specifiers for                     %a              Abbreviated weekday name (e.g., S un)
the s t r f t i m e Function cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                              %A              Full weekday name (e.g.. S u n d a y )
                                              %b              Abbreviated month name (e.g.. J u n )
                                              %B              Fu!l month name (e.g., J u n e )
                                              %c             C o m p le te d a y a n d tim e (e .g ..S u n J u n  31 7 : 4 8 : 3 4 2 0 0 7 )
                                              %Cf           Year divided by 100 and truncated toan integer                     (0 0 -9 9 )
                                              %d            Day of month (0 1 -3 1 )
                                              %Df           Equivalent to %m/%d/%y
                                              %e'             Day of month (1 -3 1 ): a single digit is preceded by a space
                                              %F*           Equivalcntto% Y-%m-%d
                                              %g1             Last two digits of ISO 8601 week-based year (0 0 -9 9 )
                                              %G^           ISO 8601 week-based year
                                              %h'           Equivalent to %b
                                              %H            Hour on 24-hour clock (0 0 -2 3 )
                                              %I            H ouron 1 2 -h o u rc lo c k (0 1 -1 2 )
                                              %j             Day of year (0 0 1 -3 6 6)
                                              %m             M o n th (0 1 -1 2 )
                                              %M             M in u te (0 0 -5 9 )
                                              %nf            New-line character
                                              %p             AMfl*M designator (AM or PM)
                                              %r^            1 2 -h o u rc lo c k tim e (e .g ..0 5 :4 8 :3 4 PM)
                                              %R^            Equivalent to %H: %M
                                              %S             Second (0 0 -6 1 ): maximum value in C99 is 60
                                              % tf           Horizontal-tab character
                                              %Tf            Equivalent lo %H : %M: %S
                                              %u^            ISO 8601 weekday (1 -7 ); Monday is 1
                                              %U              Week number (0 0 -5 3 ): first Sunday is beginning of week 1
                                              %V^            ISO 8601 week n u m b e r(0 1 -5 3 )
                                              %w             Weekday (0 -6 ): Sunday is 0
                                              %W              Week number (0 0 -5 3 ); first Monday is beginning ofw eek 1
                                              %x             Complete date (e.g., 0 6 / 03 / 0 7)
                                              %X             Complete time (e.g.. 17 :4 8 : 34)
                                              %y             Last two digits o fy ear (0 0 -9 9 )
                                              %Y             Year
                                              %z*             Offset from UTC in ISO 8601 format (e.g., - 0 5 3 0 or + 0 2 0 0 )
                                              %Z             Time zone name or abbreviation (e.g.. EST)
                                              ^&
                                               □ o         o
                                                             ?- GFEDCBA
                                          ^C 9 9 o n ly


                  T a b le 2 6 .3                Conversion                                   R eplacem ent
 Replacement Strings for                           %a           First three characters of %A
 s t r f t i m e Conversion                        %A           O n co f ’’S u n d a y ” . ’’M o n d a y ” ...... ’’S a t u r d a y ”
             Specifiers in the                     %b           First three characters of %B
                 ” C" Locale hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                   %B           O n eo f ’’J a n u a r y ” , ’’F e b r u a r y ” . .... " D e c e m b e r ”
                                                   %c           E quivalentto"% a %b %e %T %Y”
                                                   %p           One of "AM” or "PM”
                                                   %r           Equivalent to " %I : %M: %S %p"
                                                   %x           Equivalent to "% m/% d/% y"
                                                   %X           Equivalent to %T
                                                   %Z           Implementation-defined
6 9 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c tio n s RQPONMLKJIHGFEDCBA



                                                                                          IS O 8601

                                     IS O 8601 is a n in te rn a tio n a l s ta n d a rd th a t d e s c rib e s w a y s o f re p re s e n tin g d a te s
                                    a n d tim e s . It w a s o rig in a lly p u b lis h e d in 1 9 8 8 a n d la te r u p d a te d in 2 0 0 0 a n d 2 0 0 4 .
                                    A c c o rd in g to th is s ta n d a rd , d a te s a n d tim e s a re e n tire ly n u m e ric (i.e., m o n th s a re
                                     n o t re p re s e n te d by n a m e s ) a n d h o u rs a re e x p re s s e d u s in g th e 2 4 -h o u r c lo c k .
                                           T h e re a re a n u m b e r of IS O 8601 d a te a n d tim e fo rm a ts , s o m e o f w h ic h are
                                     d ire c tly s u p p o rte d by s t r f t i m e      c o n v e rs io n s p e c ifie rs in C 9 9 . T h e p rim a ry IS O
                                     8601 d a te fo rm a t ( Y Y Y Y - M M - D D ) a n d th e p r im a r y tim e fo rm a t (h h :m m :s s ) c o rr e ­
                                    s p o n d to th e %F a n d %T c o n v e rs io n s p e c ifie rs , re s p e c tiv e ly.
                                           IS O 8601 h a s a s ys te m o f n u m b e rin g th e w e e k s o f a y e a r; th is s y s te m is s u p ­
                                     p o rte d by th e %g, %G, a n d %v c o n v e rs io n s p e c ifie rs . W e e k s b e g in o n M o n d a y, a n d
                                    w e e k 1 is the w e e k c o n ta in in g th e firs t T h u rs d a y o f th e yea r. C o n s e q u e n tly , th e first
                                    fe w d a ys o f J a n u a ry (a s m a n y a s th re e ) m a y b e lo n g to th e la s t w e e k o f th e p re v io u s
                                     year. F o r e x a m p le , c o n s id e r th e c a le n d a r fo r J a n u a ry 2 0 1 1 : dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                                           J a n u a r y 2 0 1 1 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                         Mo       Tti      We       Th       Fr      Sa      Su           Year      W eek onmlkjihgfedcbaZYXWVUTSRQPONMLK
                                                                                                       r      o+*         2010        52
                                                          3        4        5        6       7        8       9           2011          I
                                                          10       11       12      13       14      15       16          2011         9M
                                                          17       18       19      20       21 aZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                     99
                                                                                                     ^^ 4^ 23         2011             3
                                                          24      25       26       27       28      29      30           2011         4
                                                          31                                                              2011         5

                                    J a n u a ry 6 is th e firs t T h u rs d a y o f th e yea r, s o th e w e e k o f J a n u a ry 3 - 9 is w e e k 1.
                                    J a n u a ry 1 a n d J a n u a ry 2 b e lo n g to th e la s t w e e k (w e e k 5 2 ) o f th e p re v io u s yea r. For
                                    th e s e tw o d a te s , s t r f t i m e w ill re p la c e %g by 1 0 , %G by 2 0 1 0 , a n d %v b y 5 2 . N ote
                                    th a t th e la s t fe w d a ys o f D e c e m b e r w ill s o m e tim e s b e lo n g to w e e k 1 o f th e fo llo w in g
                                    y e a r; th is h a p p e n s w h e n e v e r D e c e m b e r 2 9 , 3 0 , o r 31 is a M on d a y.
                                           T h e %z c o n v e rs io n s p e c ifie r c o rre s p o n d s to th e IS O 8601 tim e z o n e s p e c ific a ­
                                    tio n : - h h m m m e a n s th a t a tim e z o n e is h h h o u rs a n d m m m in u te s b e h in d U T C ; the
                                    s trin g + h h m m in d ic a te s th e a m o u n t by w h ic h a tim e z o n e is a h e a d o f U T C .



                                           C99 allows the use of an E or O character to modify the meaning of certain
                                    s t r f t i m e conversion specifiers. Conversion specifiers that begin with an E orO
                                    modifier cause a replacement to be performed using an alternative format that
                                    depends on the current locale. If an alternative representation doesn’t exist in the
                                    current locale, the modifier has no effect. (In the " C ” locale, E and O are ignored.)
                                    Table 26.4 lists all conversion specifiers thal are allowed to have E or O modifiers.


               PROGRAM               D is p la y in g th e D a t e a n d T im e
                                     Let’s say we need a program that displays the current date and time. The program’s
                                     first step, of course, is to call the t i m e function to obtain the calendar time. The
                                                          2 6 .3                                                                    699 dcbaZYXWVUTSR
                                                                   T h e < t i m e . h > H e a d e r: D a te a n d T im e onmlkjihgfedcbaZYXWVUTSRQPONM


            T a b le 2 6 .4 RQPONMLKJIHGFEDCBA
                                    C o n v e rsio n                               R e p la c e m e n t
  E- and O-Modified kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   %Ec            Alternative date and tim e representation
Conversion Specifiers              %EC            Nam e o fb a se year (period) in alternative representation
  for the s t r f t i m e          %Ex            Alternative date representation
 Function (C99 only)               %EX            Alternative lime representation
                                   %Ey            Offset from %EC (year only) in altem ativcrepresentation
                                   %EY            Full alternative year representation
                                   %Od            Day of month, using alternative num eric symbols (filled with leading
                                                  zeros or with leading spaces if there is no alternative sym bol for zero)
                                   %Oe            Day o fm o n th , using alternative num eric sym bols (filled with leading
                                                  spaces)
                                   %OH            H our on 24-hourclock. using alternative numeric symbols
                                   %OI            H o u ro n 12-hourclock, using alternative num eric symbols
                                   %Om            M onth, using alternative num eric sym bols
                                   %OM            M inute, using alternative num eric symbols
                                   %OS            Second, using alternative num eric sym bols
                                   %Ou            ISO 8601 weekday as a num ber in alternative representation,
                                                  where M onday is 1
                                   %OU            Week number, using alternative num eric sym bols
                                   %OV            ISO 8601 week number, using alternative num eric sym bols
                                   %Ow            W eekday as a number, using alternative num eric symbols
                                   %OW            Week number, using alternative num eric sym bols
                                        y__^^^^^_ Last two digits o f year, using alternative num eric symbols
                           t^^__^^^%^^O__

                                second step is to convert the time to string form and print it. The easiest way to do
                                the second step is to call c t i m e , which returns a pointer to a string containing a
                                date and time, then pass this pointer to p u t s or p r i n t f .
                                     So far, so good. But what if we want the program to display the date and time
                                in a particular way? Let’s assume that we need the following form at where 06 is
                                the month and 03 is the day of the month:

                                06-03-2007             5:48p

                                The c t i m e function always uses the same format for the date and time, so it's no
                                help. The s t r f t i m e function is better; using it, we can almost achieve the
                                appearance that we want. Unfortunately, s t r f t i m e w on't let us display a one-
                                di^e it hour without a leadic^ng zero. Als7o, s t r f t i m e uses AM and PM instead of a
                                and p.
                                       When s t r f t i m e isn’t good enough, we have another alternative: convert the
                                calendar time to a broken-down time, then extract the relevant information from
                                the tm structure and format it ourselves using p r i n t f or a similar function. We
                                might even use s t r f t i m e to do some of the formatting before having other func­
                                tions complete the job.
                                       The following program illustrates the options. It displays the cunent date and
                                time in three formats: the one used by c t i m e . one close to what we want (created
                                using s t r f t i m e ) , and the desired format (created using p r i n t f ) . The c t i m e
                                version is easy to do, the s t r f t i m e version is a little harder, and the p r i n t f
                                version is the most difficult.
7 0 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r 2 6    M is c e lla n e o u s L ib r a r y F u n c t io n s


                                          / ★ Displays the current
                  d a t e t i m e . c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA        date and time in three formats */

                                      #include <stdio.h>
                                      #include <time.h>

                                      int main(void)
                                      {
                                        time_t current = time(NULL);
                                        struct tm *ptr;
                                        char date_time[21];
                                        int hour;
                                        char am_or_pm,-

                                          /* Print date and time in default format */
                                          puts(ctime(&current));

                                          /* Print date and time, using strftime to format */
                                          strftime(date_time, sizeof(date_time),
                                                   ”%m-%d-%Y %I:%M%p\n", localtime(&current));
                                          puts(date_time);

                                          /* Print date and time, using printf to format */
                                          ptr = localtime(&current);
                                          hour = ptr->tm_hour;
                                          if (hour <= 11)
                                            am_or_pm = •a ’;
                                          else {
                                            hour -= 12;
                                            am_or_pm = 'p ’;

                                          if (hour == 0)
                                            hour = 12;
                                          printf("%.2d-%.2d-%d %2d:%.2d%c\n", ptr->tm_mon + 1,
                                                 ptr->tm_mday, ptr->tm_year + 1900, hour,
                                                 ptr->tm_min, am_or_pm);

                                          return 0;
                                      }

                                            The outpul o f d a t e t i m e . c wiII have the following appearance:
                                      Sun Jun           3 17:48:34 2007

                                      06-03-2007              05:48PM

                                      06-03-2007                5:48paZYXWVUTSRQPONMLKJIHGFEDCBA




                                      Q & A dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              Q:      A lt h o u g h < s t d l i b . h >   p r o v id e s a n u m b e r o f fu n c t io n s th a t c o n v e r t str in g s
                                      to n u m b e r s , th e r e d o n ’t a p p e a r to b e a n y fu n c ti o n s th a t c o n v e r t n u m b e r s to
                                      s tr in g s . W h a t g iv e s ?
                                                                                                                                                                     701onmlkjihgfedcbaZY
                                                                                                                                                        Q & A kjihgfedcbaZYXWVUTSRQPONML


                                                  A:     Some C libraries supply functions with names like i t o a that convert numbers to
                                                         strings. Using these (unctions isn't a great idea, though: they aren’t part of the C
                                                         standard and won’t be portable. The best way to perform this kind ofconversion is
            sprintffunction>22.s                         to call a function such as s p r i n t f that writes formatted output into a string:

                                                         char str [20] ;
                                                         int i;hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                         •••


                                                         sprintf(str, "%d", i);                         /* writes i into the string str */

                                                         Not only is s p r i n t f portable, but il also provides a great deal of control over the
                                                         appearance of the number.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              *Q :       T h e d e s c r ip tio n o f th e s t r t o d fu n c tio n s a y s th a t C 9 9 a llo w s th e s tr in g a r g u ­
                                                         m e n t to c o n ta in a h e x a d e c im a l flo a t in g - p o in t n u m b e r , in fin ity , o r N a N . W h a t
                                                         is th e fo r m a t o f th e se n u m b e r s ? [p . 6 8 4 ]
                                                  A:     A hexadecimal floating-point number begins with 0x or 0X. followed by one or
                                                         more hexadecimal digits (possibly including a decimal-point character), and then
                                                         possibly a binary exponent. (See the Q&A at ihe end of Chapter 7 for a discus­
                                                         sion of hexadecimal floating^> constants, which have a similar— but not identical—
                                                         format.) Infinity has the form IN F or IN FIN IT Y ; any or all o fth e letters may be
                                                         lower-case. NaN is represented by the string NAN (again ignoring case), possibly
                                                         followed by a pair of parentheses. The parentheses may be empty or they may
                                                         contain a series of characters, where each character is a letter, digit, or under­
                                                         score. The characters may be used to specify some of the bits in the binary repre­
                                                         sentation of the NaN value, but their exact meaning is implementation-defined.
                                                                                                                                         n-char- aZYXWVUTSRQP
                                                         The same kind of character sequence— which the C99 standard calls an cbaZYXWVUTSRQPONMLKJIHGF
                                          > 2 3 .4
                      n a n f u n c tio n BA             sequence— is also used in calls of the n a n function.

                                              *Q :       Y ou sa id th a t p e r fo r m in g th e c a ll e x i t ( n ) a n y w h e r e in a p r o g r a m is nor­
                                                         m ally e q u iv a le n t to e x e c u tin g th e s ta te m e n t r e t u r n n ; in m a i n . W h e n w o u ld
                                                         it n o t b e e q u iv a le n t? [p . 6 8 8 ]
                                                  A:     There are two issues. First, when the m a in function returns, the lifetime of its
a u t o m a t ic s t o r a g e d u r a t io n >   18.2   local variables ends (assuming that they have automatic storage duration, as they
                                                         will unless they're declared to be s t a t i c ) . which isn’t true if the e x i t function
                                                         is called. A problem will occur ifan y action that takes place at program termina­
                                                         tion— such as calling a function previously registered using a t e x i t or flushing
                                                         an output stream buffer— requires access to one of these variables. In particular, a
            setvbuffunction>22.2                         program might have called s e t v b u f and used one of m a i n ’s variables as a
                                                         buffer. Thus, in rare cases a program may behave improperly if it attempts to return
                                                         from m a in but work if it calls e x i t instead.
                                                               The other issue occurs only in C99. which makes it legal for m a in to have a
                                                         return type other than i n t if an implementation explicitly allows the programmer
                                                         to do so. In these circumstances, the call e x i t (n) isn’t necessarily equivalent to
                                                         executing r e t u r n //; in m a in . In fact, the statement r e t u r n n ; may be illegal
                                                         ( if m a in is declared to return v o i d , for example).
7 0 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
            C h a p te r2 6      M is c e lla n e o u s L ib r a r y F u n c t io n s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     *Q :       Is th e r e a r e la tio n s h ip b e tw e e n th e a b o r t fu n c tio n a n d S IG A B R T s ig n a l? [p.
                                                6 8 8 ] onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        A:      Yes. A caH of a b o r t actually raises the SIGABRT signal. If there’s no handler for
                                                SIGABRT, lhe program terminates abnormally as described in Section 26.2. If a
            s ig n a ifu n c tio n > 2 4 .3     handler has been installed for SIGABRT (by a call of the s i g n a l function), the
                                                handler is called. If the handler returns, the program then terminates abnormally.
          io n g jm p fu n c t io n > 2 4 . 4                              d o e s n ’t return (it calls l o n g j m p , for example), then the
                                                However, if the handler cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                program doesnT terminate.

                                        Q:      W h y d o th e d i v a n d l d i v                  fu n c tio n s e x is t? C a n ’t w e j u s t u s e th e / a n d %
                                                o p e r a to r s ? [p . 6 9 2 ]
                                        A:      d i v and l d i v aren’t quite the same as / and %. Recall from Section 4.1 that
                                                applying / and % to negative operands doesn’t give a portable result in C89. lf i or
                                                j is negative, whether the value of i / j is rounded up or down is implementation-
                                                defined, as is the sign of i % j . The answers computed by d i v and l d i v , on the
                                                other hand, don’t depend on the implementation. The quotient is rounded toward
                                                zero: the remainder is computed according to the form ula n = q x d + r, where n is
                                                the original number, q is the quotient, d is the divisor, and r is the remainder. Here
                                                are a few examples:
                                                        n         d          <1          /

                                                        7         3          2            I
                                                       -7         3         -2         -1
                                                        7        -3         -2            1
                                                       -7        -3          ?^^       - I aZYXWVUTSRQPONMLKJIHGFEDCBA
                                    C 99        In C99, the / and % operators are guaranteed to produce the same result as d i v
                                                and l d i v .
                                                      Efficiency is the other reason that d i v and l d i v exist. Many machines have
                                                an instruction that can compute both the quotient and remainder, so calling d i v or
                                                l d i v may be foster than using the / and % operators separately.

                                        Q:      W h e r e d o e s th e n a m e o f th e g m t i m e fu n c tio n c o m e fr o m ? [p . 6 9 6 ]
                                        A:      The name g m tim e stands for Greenwich Mean Time (GMT), referring to the local
                                                (solar) time at the Royal Observatory in Greenwich, England. In 1884, GMT was
                                                adopted as an international reference time, with other time zones expressed as
                                                hours “behind GM T” or “ahead ofG M T .” In 1972, Coordinated Universal Timc
                                                (UTC)— a system based on atomic clocks rather than so.lar observations— replaced
                                                GMT as the international time reference. By adding a “leap second” once every
                                                few years, UTC is kept synchronized with GMT to within 0.9 second, so for all bul
                                                the most precise time measurements the two systems are identical.



                                                E x e r c is e s
S e c t i o n 2 6 .1                      1.    Rewrite the m a x _ i n t function so that, instead of passing the number o f integers as the first
                                                argument, we must supply 0 as the last argument. Hint: m ax i n t must have at least one
                                                                                                                                              703
                                                                                                                      E x e rc is e s hgfedcbaZYXWVUTSRQPONMLKJIHGF


                                “norm ar’ parameter, so you can’t remove the param etern. Instead, assume that it represents
                                one of the numbers to be compared.

                     ©    2.    Write a simplified version o f p r i n t f in which the only conversion specification is %d, and
                                all arguments afier the first are assumed to have i n t type. Lf the function encounters a %
                                character that’s not immediately followed by a d character, it should ignore both characters.
                                The function should use calls of p u t c h a r to produce all output. You may assume that the
                                formal string doesnT contain escape sequences.

                          3.    Extend the function of Exercise 2 so that it allows two conversion specifications: %d and
                                %s. Each %d in the format string indicates an i n t argument, and each %s indicates a c h a r
                                * (string) argument.

                          4.    Write a function named d i s p l a y that takes any number of arguments. The first argument
                                must be an integer. The remaining arguments will be strings. The firsi argument specifies
                                how many strings the call contains. The function will print the strings on a single line, with
                                adjacent strings separated by one space. For example, the call
                                d is p la y (4 ,     " S p e c ia l" ,   " A g e n t" ,    " D a le " ,   "C o o p e r");
                                will produce the following output:
                                S p e c i a l A g e n t D a le C o o p e r

                          5.    Write thc following function:
                                ch ar * v s trc a t(c o n s t        char * firs t,            ...) ;
                                All arguments of v s t r c a t are assumed to be strings, except for the last argument, which
                                must be a null pointer (cast to c h a r * type). The function returns a pointcr to a dynamically
                                allocated string containing thc concatenation of thc arguments, v s t r c a t should rcturn a
                                null pointer if not enough mcmory is available. cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                   H im : Have v s t r c a t go through the argu­
                                ments twice: once to determine thc amount of memory required for the returned string and
                                once to copy the arguments into the string.

                          6.    Write the followine«*~function:
                                c h a r * m a x _ p a i r ( i n t n u m _ jp a ir s ,     ...) ;
                                The arguments o f m a x _ p a i r are assumed to be “pairs” of integers and strings: the value of
                                n u m _ p a i r s indicates how many pairs will follow. (A pair consists of an i n t argument
                                followed by a c h a r * argument). The function searches the integers to find the largest one;
                                it then relums the string argument that follows it. Consider the following call:
                                m a x _ p a ir(5 ,    180, " S e in f e ld " , 180, " I Love L u cy ",
                                                      3 9 , "T h e H o n e y m o o n e r s " , 2 1 0 , " A l l i n          th e   F a m ily " ,
                                                      8 6 , "T h e S o p r a n o s " )
                                The largest i n t argument is 210, so the function returns " A l l i n t h e F a m i l y " , which
                                follows it in the amwument list,


                          © 7.         Explain the meaning of the following statement, assuming that v a l u e is a variable of type
S e c tio n 26.2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                l o n g i n t and p is a variable of type c h a r *:
                                v a lu e   = s trto l(p ,         &p,    1 0 );

                          8.    Write a statement that randomly assigns one of the numbers 7, 1 1, 15, or 19 lo the variable n.

                     ©    9.    Write a function that returns a random d o u b l e value d in the range 0.0 < d < 1.0.

                          10.   Convert the following calls of a t o i , a t o l . and a t o l l into calls of s t r t o l , s t r t o l ,
                                and s t r t o l l , respectively.
704 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 6   M is c e lla n e o u s L ib r a r y F u n c tio n s hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    (a) a t o i ( s t r )
                                    (b) a t o l ( s t r )
                                    (c) a t o l l ( s t r )

                             11.    Although lhe b s e a r c h function is normally used with a sorted array, it will sometimes
                                    work corrcctly with an array that is only partially sorted. Whal condition must an array sat­
                                    isfy to guarantee that b s e a r c h works properly for a particular key? cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                               Hint: The answer
                                    appears in the C standard.

S e c tio n 26 .3            12.    Write a function that, when passed a year, returns a t i m e _ t value representing 12:00 a.m.
                                    on the first day of that year.

                             13.    Section 26.3 described some of the ISO 8601 date and time formats. Here are a few more:
                                    (a) Year followed by day o fy ear: YYYY-DDD> where D D D is a number between 001 and
                                        366
                                    (b) Year, week, and day of week: Y Y Y Y -W w \v -lX where nnv is a number between 01 and
                                        53, and D is a digit between 1 through 7, beginning with Monday and ending with Sun­
                                        day
                                    (c) Com bined date and time: Y Y Y Y-M M -D D T hli:m nr.ss
                                    Give s t r f t i m e strings that correspond to each o fth ese formats.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                    P r o g r a m m in g P r o je c t s

                        ©     I.    (a) Write a program that calls the r a n d function 1000 limes, printing the low-order bit of
                                    each value it returns (0 if the return value is even, I if it's odd). Do you see any patterns?
                                    (Often, the last few bits o f r a n d ’s relum value aren't especially random.)
                                    (b) How can wc improve the randomness of r a n d for generating numbers within a small
                                    ranec? GFEDCBA
                                        *w*




                              2 .    W rite a program that tests the a t e x i t function. The program should have two functions
                                    (in addition to m a in ), one of which prints T h a t • s a l l , and the other f o l k s ’ . Use the
                                    a t e x i t function lo register both lo bc called al program termination. Make sure they’re
                                    called in lhe proper order, so that we sec the message T h a t ’ s a l l , f o l k s ! on the
                                    screen.

                        ©     3.    W rite a program lhai uses the c l o c k function to measure how long ii lakes q s o r t to sort
                                    an array of 1000 integers thai are originally in reverse order. Run the program for arrays of
                                    10000 and 100000 integers as well.

                        ©     4.    Write a program thai prompts the user for a dale (monlh, day, and year) and an inlcger n,
                                    ihen prints lhe date that’s n days later.

                              5.    Wrile a program that prompts the user to enter two dales, ihen prinls the difference between
                                    lhem, measured in days. H int: Use lhe m k tim e and d i f f t i m e functions.

                        ©     6.    Write programs thai display the current date and time in each o flh e following formats. Use
                                    s t r f t i m e to do aII or most of the form attina .  K^



                                    (a) S u n d a y , J u n e 3 , 2 0 0 7         0 5 : 4 8 p kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    (b) Sun, 3 Jun 07 17:48
                                    (c) 0 6 / 0 3 / 0 7   5 : 4 8 : 3 4 PM
2 7       A d d it io n a l C 9 9 S u p p o r t fo r
          M a t h e m a t ic s                   ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                S im p lic ity d o e s n o t p r e c e d e c o m p le x ity b u t fo llo w s it. onmlkjihgfedcbaZYXWVUT




          This chapler completes our coverage of the standard library by describing five
          headers that are new in C99. These headers, like some of the older ones, provide
          support for working with numbers. However, the new headers are more specialized
          than the old ones. Some of them will appeal primarily to engineers., scientists, and
          mathematicians, who may need complex numbers as well as greater control over
          the representation of numbers and the way fioating-point arithmetic is performed.
                The first two sections discuss headers related to the integer types. The
          < s t d i n t . h > header (Section 27.1) declares integer types that have a specified
          number of bits. The < i n t t y p e s . h> header (Section 27.2) provides macros that
          are useful for reading and writing values of the < s t d i n t . h> types.
                The next two sections describe C99 ?s support for complex numbers. Section
          27.3 includes a review ofcom plex numbers as well as a discussion o fC 9 9 's com ­
          plex types. Section 27.4 then covers the < c o m p l e x .h > header, which supplies
          functions that perform mathematical operations on complex numbers.
                The headers discussed in the last two sections are related to the floating types.
          The < t g m a t h . h > header (Section 27.5) provides type-generic macros that make
          it easier to call library functions in < c o m p l e x .h > and < m a th .h > . The func­
          tions in the < f e n v . h > header (Section 27.6) give programs access to floating­
          point status flags and control modes.




 2 7 .1   T h e < s t d i n t . h > H e a d e r (C 9 9 ): In t e g e r T y p e s

          The < s t d i n t . h > header declares integer types containing a specified number
          of bits. In addition, it defines macros that represent the minimum and maxi­
          mum values of these types as well as of integer types declared in other headers.hgfedcbaZYXWVUTSRQP



                                                                                                                        705
706 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 7    A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s


    <iimics.h>header>23.2          (These macros augment the ones in the < l i m i t s . h > header.) < s t d i n t . h >
                                   also defines parameterized macros that construct integer constants with specific
                                   types. There are no functions in < s t d i n t . h>.
                                        The primary motivation for the < s t d i n t .h > header lies in an observation
                                   made in Section 7.5, which discussed the role of type definitions in making pro­
                                   grams portable. For example, if i is an i n t variable, the assignmentkjihgfedcbaZYXWVUTSRQPONMLKJ
                                   i = 100000;
                                   is fine if i n t is a 32-bit type but will fail if i n t is a 16-bit type. The problem is
                                   that the C standard doesn’t specify exactly how many bits an i n t value has. The
                                               does guarantee that the values of the i n t type must include all numbers
                                   standard cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   between -32767 and +32767 (which requires at least 16 bits), but that’s all it has to
                                   say on the matter. In the case of the variable i , which needs to be able to store
                                   100000, the traditional solution is to declare i to be of some type T, where T is a
                                   type name created using t y p e d e f . The declaration of T can then be adjusted
                                   based on the sizes of integers in a particular implementation. (On a 16-bit machine.
                                   T would need to be l o n g i n t , but on a 32-bit machine, it can be i n t . ) This is the
                                   strategy that Section 7.5 discusses.
                                         If your compiler supports C99, there’s a better technique. The < s t d i n t . h>
                                   header declares names for types based on the width of the type (the number of bits
                    signbit>7j     used to store values of the type, including the sign bit, if any). The t y p e d e f
                                   names declared in < s t d i n t . h > may refer to basic types (such as i n t , u n ­
                                   s i g n e d i n t , and l o n g i n t ) or to extended integer types that are supported by a
                                   particular implementation.


                                    < s t d i n t . h> Types
                                   The types declared in < s t d i n t . h> fall into five groups:
                                      ■ E xact-w idth in teger types. Each name of the foi*m in tN _ _ t represents a
                                        signed integer type with N bits, stored in two’s-complement form. (Two’s
                                        complement, a technique used to represent signed integers in binary, is nearly
                                        universal among modern computers.) For example, a value o fty p e i n t l 6 _ t
                                        would be a 16-bit signed integer. A name of the form uint7V __t represents an
                                        unsigned integer type with N bits. An implementation is required to provide
                                        both in tN _ _ t and u in t7 V _ t for /V = 8, 16, 32, and 64 if it supports integers
                                        with these widths.
                                      ■ M in im u m -w id th integertypes. Each name o fth efo rm i n t _ l e a s t N _ t rep­
                                        resents a signed integer type with at least N bits. A name of the form
                                        u i n t _ _ l e a s t N _ t represents an unsigned integer type with N or more bits,
                                        < s t d i n t .h > is required to provide at least the following minimum-width
                                        types:
                                          in t_ le a s t8 _ _ t           u in t_ le a s t8 _ t
                                          in t_ le a s tl6 _ t            u in t_ le a s tl6 _ t
                        2 7 .1                                                                                   707onmlkjihgfedcbaZYXWV
                                     T h e < s t d i n t . h > H e a d e r (C 9 9 ): In te g e r T yp e s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


          in t_ le a s t3 2 _ t                   u in t_ le a s t3 2 _ t
          in t_ le a s t6 4 _ t                   u i n t _ l e a s t 6 4 _ tRQPONMLKJIHGFEDCBA
      ■ F a s te s t     m in im u m -w id th                    Each nam e of the form
                                                          in te g e r   ty p e s .
          i n t _ f a s t 7 V _ t represents the fastest signed integer type with al least N bits.
          (The meaning of “fastest" is up to the im plem entation. If there's no reason to
          classify a particular type as the fastest, the im plem entation may choose any
          signed integer type with at least N bits.) Each nam e of the form
          u i n t _ f a s t N _ t represents the fastest unsigned integer type with N or more
          bits, < s t d i n t .h > is required to provide at least the following fastest m ini­
          mum-width types:
          in t_ fa s t8 _ t                       u in t_ fa s t8 _ t
          in t_ fa s tl6 _ t                      u in t_ fa s tl6 _ t
          in t_ fa s t3 2 _ t                     u in t_ fa s t3 2 _ t
          in t_ fa s t6 4 _ t                     u in t_ fa s t6 4 _ t
      ■ I n te g e r   t y p e s c a p a b l e o f h o l d i n g o b j e c t p o i n t e r s . The i n t p t r _ t
                                                                                      type repre­
          sents a signed integer type that can safely store any v o i d * value. M ore pre­
          cisely, if a v o i d * pointer is converted to i n t p t r _ t type and then back to
          v o i d *, the resulting pointer and the original pointer will com pare equal. The
          u i n t p t r _ t type is an unsigned integer type with the sam e property as
          i n t p t r _ t . The < s t d i n t .h > header isn’t required to provide either type.
  ■       G r e a te s t- w id th   in te g e ri n t m a x _ t is a signed integer type that
                                                   ty p e s ,
          includes all values that belong to any signed integer type, u i n t m a x _ t is an
          unsigned integer type that includes all values that belong to any unsigned inte­
          ger type, < s t d i n t . h > is required to provide both types, which m ight be
          wider than l o n g l o n g i n t .

The names in the first three groups are declared using t y p e d e f .
     An im plem entation may provide exact-width integer types, m inim um -w idth
integer types, and fastest m inim um-w idth integer types for values o f N in addition
to the ones listed above. Also, N isn’t required to be a power of 2 (although it will
normally be a m ultiple of 8). For example, an im plem entation m ight provide types
named i n t 2 4 t and u i n t 2 4 t .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


L im its o f S p e c ifie d -W id th I n te g e r T y p e s

For each signed integer type declared in < s t d i n t . h > , the header defines m acros
that specify the type’s minim um and m axim um values. For each unsigned integer
type, < s t d i n t . h> defines a macro that specifies the type’s m axim um value. The
first three rows ofT ab le 27.1 show the values of these macros for the exact-w idth
integer types. The rem aining rows show the constraints imposed by the C99 stan­
dard on the minim um and maxim um values of the other < s t d i n t . h> types. (The
precise values of these macros are im plem entation-defined.) All macros in the
table represent constant expressions.
708 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 7   A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                         T a b le 2 7 .1                             N a in e                V a lu e                         D e s c r ip tio n
     < s t d i n t . h> Limit         IN T W _ M IN                                            - ( 2 ,v - 1 )   Minimum i n t N _ t value
     Macros for Specified-            IN T A '_M A X                                            2 ^ -L |        Maximum in U V _ t value
      Width IntegerTypes RQPONMLKJIHGFEDCBA
                                                          U I N T /V j'lA X                        2 A-1        Maximum u i n t / V _ t value
                                                           IN T _ L E A S T A '_ M IN    < -(2 ,v - '- l )      Minimum i n t _ l e a s t N _ t value
                                                           IN T _ L E A S T A '_ M A X       >2'v - '- I        Maximum i n t _ l e a s t 7 V _ t value
                                                          U IN T _ L E A S T W _ M A X          >2'V-1          Maximum u i n t _ l e a s t N _ t value
                                                           IN T _ F A S T /V _ M I N     < -(2 ^ '-'-l)         Minimum i n t _ f a s t N _ t value
                                                           IN T _ F A S T W _ M A X         > 2 * -'-l          Maximum i n t _ f a s U V _ t value
                                                          U IN T _ F A S W _ M A X              >2^'-l          Maximum u i n t _ f a s t / V _ t value
                                                           IN T P T R _ M IN              ^ - ( 2 I5 - I )      Minimum i n t p t r _ t value
                                                           IN T P T R _ M A X                  > 2 I5 - I       Maximum i n t p t r _ t value
                                                          U IN T P T R _ M A X                 > 2 I6 - I       Maximum u i n t p t r _ t value
                                                           IN T M A X _ M IN              < -(2 63 - 1)         Minimum i n t m a x _ t value
                                                           IN TM A X _M A X                    >2 63 - 1        Maximum i n t m a x _ t value
                                                          U IN T M A X   ^ ^ »
                                                                                 MAX           >2 64 - !        Maximum u i n t m a x •^“-t value hgfedcbaZYXWVUTSRQPONMLK



                                                   L im its o f O t h e r I n t e g e r T y p e s

                                   When the C99 com m ittee created the < s t d i n t . h > header, they decided that it
                                   would be a good place to put macros describing the limits of integer types besides
                                   th e o n e s declared in < s t d i n t . h > itself.T hese t y p e s a r e p t r d i f f _ t , s i z e _ t ,
    <stddef . h> header >21.4      and w c h a r _ t (which belong to < s t d d e f . h > ) . s i g _ a t o m i c _ t (declared in
                        cbaZYXWVUTSRQPONMLKJIHGFEDCBA

    < signal. h> header >24.3 < s i g n a l . h > ) , and w i n t _ t (declared in < w c h a r .h > ) . Table 27.2 lists these
     <wchar. h> header >25.5 macros and shows the value of each (or any constraints on the value imposed by
                                   the C99 standard). In some cases, the constraints on the minimum and maximum
                                   values of a type depend on whether the type is signed or unsigned. The macros in
                                   Table 27.2, like the ones in Table 27.1, represent constant expressions.


                                                   M a c r o s fo r I n t e g e r C o n s t a n ts

                                                   The < s t d i n t . h> header also provides function-like macros that are able to con-
            in te g e r c o n s ta n ts >   *7.1   vert an integer constant (expressed in decimal, octal, or hexadecimal, but without a
                                                   U and/or L suffix) into a constant expression belonging to a minim um-w idth inte­
                                                   ger type or greatest-width integer type.
                                                        For each i n t _ l e a s t A ' _ t type declared in < s t d i n t . h > , the header
                                                   defines a parameterized macro named INT;V_C that converts an integer constant to
          In te g e r p r o m o tio n s )   *7.4   this type (possibly using the integer promotions). For each u i n t _ l e a s t N _ t
                                                   type, there\s a similar parameterized macro named UINTN_C. These macros are
                                                   useful for initializing variables, am ong other things. Forexam ple, if i is a variable
                                                   of type i n t _ l e a s t 3 2 _ t . writing
                                                                     27.2                                                            709dcbaZYXWVUTSRQPO
                                                                              T h e < in tty p e s .h > H e a d e r ( C 9 9 ) kjihgfedcbaZYXWVUTSRQPONMLKJIHG

         T a b le 2 7 .2 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                             N am e                V a lu e                                  D e s c r ip tio n
< s t d i n t . h > Limit     PTRDIFF_MIN                        <^55535                       M i n i m u m p t r d i f f _ t value
    M acros for Other         PTRDIFF_MAX                        >4-65535                      M a x i m u m p t r d i f f _ t value
         Integer Types RQPONMLKJIHGFEDCBA                           <—127 (ifsigned)
                              SIG_ATOMIC_MIN                                                   M inim um s i g _ a t o m i c _ t value
                                                                         0 (ifunsigned)
                                                                    >4-127 (ifsigned)
                                SIG_ATOMIC_MAX                                                 M axim um s i g _ a t o m i c _ t value
                                                                     >255 (if unsigned)
                                SIZE_MAX                           >65535                      M aximum s i z e _ t value
                                                                     <—127 (ifsigned)
                                WCHAR_MIN                                                      Minimum w c h a r _ t value
                                                                         0 (if unsigned)
                                                                    >4-127 (ifsigned)
                                WCHAR_MAX                                                      Maximum w c h a r _ t value
                                                                     >255 (ifunsigned)
                                                                 <-32767 (ifsigned)
                                WINT_MIN                                                       M inim um w i n t _ t value
                                                                       0 (ifunsigned)
                                                                 >4-32767 (if signed)
                                WINT_MAX                                                       Maximum w i n t _ t value
                                                                  >65535 (if unsigned)


                            i = 100000;

                            is problematic, because the constant 10 00 00 might be too large to represent using
                            type i n t (if i n t is a 16-bit type). However, the statement

                            i = INT32_C(100000);

                            is safe. If i n t _ l e a s t 3 2 _ _ t represents the i n t type, then IN T 3 2 _ C ( 1 0 0 0 0 0 )
                            has type i n t . But if i n t _ l e a s t 3 2 _ t corresponds to l o n g i n t . then
                            IN T 32_C ( 1 0 0 0 0 0 ) has type l o n g i n t .
                                 < s t d i n t .h > has two other parameterized macros. INTMAX__C converts an
                            integer constant lo type i n t m a x _ t , and UINTMAX_C converts an integer con­
                            stant to type u i n t m a x _ t .aZYXWVUTSRQPONMLKJIHGFEDCBA




             2 7 .2         T h e < i n t t y p e s .h > H e a d e r (C 9 9 )
                            F o r m a t C o n v e r s io n o f In t e g e r T y p e s

                            The < i n t t y p e s .h > header is closely related to the < s t d i n t .h > header, the
                            topic of Section 27.1. In fact, < i n t t y p e s .h > includes < s t d i n t .h > , so pro­
                Q&A         grams that include < i n t t y p e s . h> don’t need to include < s t d i n t . h> as well.
                            The < i n t t y p e s . h> header extends < s t d i n t . h> in two ways. First, it defines
                            macros that can be used in . . . p r i n t f and ...s c a n f format strings for inpuL'output
                            o fth e integer types declared in < s t d i n t . h > . Second, it provides functions for
                            workinO  s with Og reatest-width
                                                         G
                                                             integers.PONMLKJIHGFEDCBA
           C h a p te r 2 7   A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
7 1 0 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                   M a c r o s fo r F o r m a t S p e c ifie r s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   The types declared in the < s t d i n t . h> header can be used to make programs more
                                   portable, but they create new headaches fbr the programmer. Consider the problem
                                   ofdisplaying the value o fth e variable i , where i has type i n t _ l e a s t 3 2 _ t . The
                                   statementkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   printf("i = %d\n", i);

                                    may not work, because i doesn’t necessarily have i n t type. If i n t _ l e a s t 3 2 _ t
                                    is another name for the l o n g i n t type, then the correct conversion specification is
                                    % ld, not %d. In order to use the . . . p r i n t f and ...s c a n f functions in a portable
                                    manner, we need a way to write conversion specifications that correspond to each
                                    o fth e types declared in < s t d i n t . h>. T hat’s where the < i n t t y p e s . h> header
                                    comes in. For each < s t d i n t .h > type, < i n t t y p e s .h > provides a macro that
                                    expands into a string literal containing the proper conversion specifier for that type.
                                          Each macro name has three parts:

                                      ■       The name begins with either P R I or SCN, depending on whether the macro
                                              will be used in a call of a . . . p r i n t f function or a ...s c a n f function.
                                          ■ Next c omes a one-letter conversion specifier (d or i for a signed type; o, u, x.
                                             or X for an unsigned type).
                                          ■   The last part of the name indicates which < s t d i n t . h> type is involved. For
                                              example, the name o f a macro that corresponds to the i n t _ l e a s t N _ t type
                                              would end with LEASTjV.
                                        Let's return to our previous example, which involved displaying an integer of
                                    type i n t _ l e a s t 3 2 _ _ t . Instead of using d as the conversion specifier, w e’ll
                                    switch to the P R IdL E A S T 32 macro. To use the macro, we’ll split the p r i n t f
                                    format string into three pieces and replace the d in %d by P R IdL E A S T 32:

                                    printf("i = %" PRIdLEAST32 "\n", i);

                                    The value of P R IdL E A S T 32 is probably either " d " (if i n t _ l e a s t 3 2 _ t is the
                                    same as the i n t type) or " l d " (if i n t _ l e a s t 3 2 _ t is the same as l o n g i n t ) .
                                    L et’s assume that it’s " l d " for the sake of discussion. After macro replacem ent,
                                    the statement becomes

                                    printf("i = % ” "ld" "\n”, i);

                                    Once the com piler joins the three string literals into one (which it will do autom at­
                                    ically). the statement will have the following appearance:

                                    printf("i = %ld\n", i);

                                    Note that we can still include flags, a field width, and other options in our conver­
                                    sion specification; P R IdL E A S T 32 supplies only the conversion specifier and pos­
                                    sibly a length modifier, such as the letter 1.
                                         Table 27.3 lists the < i n t t y p e s . h> macros.
                                                                     27.2              The<inttypes.h>Header(C99)onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH
                                                                                                                          711 dcbaZYXWVUTSRQPONM


                T a b le 2 7 .3                                                  M a c r o s f o r S i g n e d I n te g e r s
                                                               . . . p r i n t f cbaZYXWVUTSRQPONMLKJIHGFEDCBA
Formal-Specifier Macros                      P R Id jV   P R Id L E A S T A /          P R Id F A S T N         PR IdM A X       P R Id P T R
    in < i n t t y p e s .h >                P R IiN     P R IiL E A S T W             P R IiF A S T A '        P R IiM A X      P R IiP T R
                                                             . . . p r i n t f M a c r o s f o r U n s ig n e d I n te g e r s
                                            P R Io A /   P R Io L E A S T W            P R Io F A S T N         PR IoM A X       P R Io P T R
                                            P R Iu N     P R IuL E A ST 2V             P R Iu F A S T A /       PR IuM A X       P R Iu P T R
                                            P R Ix A /   P R Ix L E A S T A '          P R Ix F A S T A '       PR IxM A X       P R Ix P T R
                                            PR IX W      PR IX LEA STA ^               P R IX F A S T W         PRIXMAX          P R IX P T R
                                                                . . . s c a n f M a c ro s f o r S i g n e d In te g e r s
                                            SCNdA/       SC N dLEA STN                 SC N dFA ST A '          SCNdMAX          SC N dPTR
                                            S C N iW     S C N iL E A S T W            S C N iF A S T N         SCNiM AX         S C N iP T R
                                                              . . . s c a n f M la c ro s f o r U n s ig n e d I n t e g e r s
                                            S C N oN     SC N oL E A ST W              SC N oFA STA /           SCNoMAX          SC N oPTR
                                            SCNujV       SC N uLEA STN                 SCNuFAST7V               SCNuMAX          S C N uP T R
                                            S C N xN     SC N xL E A ST W              SC N xFA STN             SCNxMAX          SC N xPTR



                                  F u n c tio n s fo r G r e a te s t -W id th I n te g e r T y p e s

                                   intmax_t imaxabs(intmax_t j);
                                   imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
                                   intmax_t strtoimax(const char * restrict nptr,
                                                      char ** restrict endptr,
                                                      int base);
                                   uintmax_t strtoumax(const char * restrict nptr,
                                                       char ** restrict endptr,
                                                       int base);
                                   intmax_t wcstoimax(const wchar_t * restrict nptr,
                                                      wchar_t ** restrict endptr,
                                                      int base);
                                   uintmax_t wcstoumax(const wchar_t * restrict nptr,
                                                       wchar_t ** restrict endptr,
                                                       int base);ZYXWVUTSRQPONMLKJIHGFEDCBA

                                           In addition to defining macros, the < i n t t y p e s . h> header provides functions for
                                           working with greatest-width integers, which were introduced in Section 2 7 .l. A
                                           greatest-width integer has type i n t m a x _ t (the widest signed integer type sup­
                                           ported by an implementation) or u i n t m a x _ t (the widest unsigned integer type).
                                           These types might be the same width as the l o n g l o n g i n t type, but they could
                                           be wider. For example, l o n g l o n g i n t might be 64 bits wide and i n t m a x _ t
                                           and u i n t m a x _ t might be 128 bits wide.
                        im a x a b s             The i m a x a b s and i m a x d i v functions are greatest-width versions of the
                          im a x d iv hgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                           integer arithmetic functions declared in < s t d l i b . h > . The i m a x a b s function
  < s t d l i b . h > h e a d e r> 2 6 .2  returns the absolute value of its argument. Both the areument
                                                                                 ^ r                   K
                                                                                                       ^»      and the return value
                                           have type i n t m a x _ t . The i m a x d i v function divides its first argument by its
            C h a p te r 2 7 A d d it io n a l C 9 9 S u p p o rt f o r M a th e m a tic s
7 1 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                                   second, returning an i m a x d i v _ t value, i m a x d i v _ t is a structure that contains
                                                   both a quotient member (named q u o t ) and a remainder member (rem ); both
                                                   members have type i n t m a x _ t .
                        s tr to im a x                      The s t r t o i m a x and s t r t o u m a x functions are us^reatest-width versions of
                       s tr to u m a x             the numeric conversion functions of < s t d l i b . h>. The s t r t o i m a x function is
                                                   the same as s t r t o l and s t r t o l l , except that il returns a value of type i n t ­
                                                   m a x _ t. The s t r t o u m a x function is equivalent to s t r t o u l and s t r t o u l l ,
                                                   except that il returns a value o fty p e u i n t m a x _ t . Both s t r t o i m a x and s t r ­
                                                    to u m a x return zero if no conversion could be performed. Both functions store
                                                   ERANGE in e r r n o if a conversion produces a value that's outside the range of the
                                                    function's return type. In addition, s t r t o i m a x returns the smallest or largest
                                                    i n t m a x _ t value (INTMAX_MIN or INTMAX_MAX): s t r t o u m a x returns the
                                                    largest u i n t m a x _ t value, UINTMAX_MAX.
                       w c s to im a x                      The w c s t o i m a x and w c s to u m a x functions are greatest-width versions of
                      w c s to u m a x              the wide-string^> numeric conversion functions of < w c h a r .h > . The w c s t o i m a x
                                                    function is the same as w c s t o l and w c s t o l l , except that it returns a value of
      < w c h a r . h > h e a d e r > 2 5 . 5 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                   type i n t m a x _ t . The w c s to u m a x function is equivalent to w c s t o u l and w c s -
                                                    t o u l l , except that it returns a value of type u i n t m a x _ t . Both w c s t o i m a x and
                                                   w c s to u m a x return zero if no conversion could be performed. Both functions
                                                    store ERANGE in e r r n o if a conversion produces a value that's outside the range
                                                    of the function's return type. In addition, w c s t o i m a x returns the smallest or larg­
                                                   est i n t m a x _ t value (INTMAX_MIN or INTMAX_MAX): w c s to u m a x returns
                                                    the largest u i n t m a x _ t value, UINTMAX_MAX.aZYXWVUTSRQPONMLKJIHGFEDCBA




                       2 7 .3       C o m p le x N u m b e r s ( C 9 9 )

                                    Complex numbers are used in scientific and engineering applications as well as
                                    in mathematics. C99 provides several complex types, allows operators to have
                                    complex operands, and adds a header named < c o m p l e x .h > to the standard
                                    library. There’s a catch, though: complex numbers aren't supported by all im­
                                    plementations of C99. Section 14.3 discussed the difference between a cbaZYXWVUTSRQPONM           hosted
                                    C99 implementation and a freestanding implementation. A hosted implementa­
                                    tion must accept any program that conforms to the C99 standard, whereas a
                                    freestanding implementation doesn't have to compile programs that use com­
                                    plex types or standard headers other than < f l o a t . h > , < i s o 6 4 6 . h > , < l i m -
                                    i t s . h > , < s t d a r g . h > , < s t d b o o l . h > , < s t d d e f . h > , and < s t d i n t . h > .
                                    Thus, a freestanding implementation may lack both complex types and the
                                    < c o m p l e x . h> header.
                                            We’ll start with a review o fth e mathematical definition ofcom plex numbers
                                    and complex arithmetic. We'll then look at C 99’s complex types and the operations
                                    that can be performed on values of these types. Coverage ofcom plex numbers con­
                                    tinues in Section 27.4, which describes the < c o m p l e x .h > header.
                                            2 7 .3                                                 7 1 3 dcbaZYXWVUTSRQPON
                                                      C o m p le x N u m b e r s ( C 9 9 ) hgfedcbaZYXWVUTSRQPONMLKJIHGFE


D e fin itio n o f C o m p le x N u m b e r s
                                                           rj   onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
       i be the square root o f - I (a num ber such that r = - l ) . i is known as the im a g i­
Let cbaZYXWVUTSRQPONMLKJIHGFEDCBA
n a ry u n it; engineers often represent it by the symbol j instead o f i. A c o m p le x
n u m b e r has the form a 4- hi. where a and b are real numbers, a is said to be the rea l
p a r t of the number, and b is the im a g in a ry part. Note that the complex numbers
include the real numbers as a special case (when b = 0).
        Why are complex numbers useful? For one thing, they allow solutions to prob­
lems that are otherwise unsolvable. Consider the equation x 2 + 1 = 0, which has no
solution ifA' is restricted to the real numbers. If complex numbers are allowed,
there are two solutions: .v = i and .r = - i .
        Complex numbers can be lhoughl of as points in a two-dimensional space
known as the c o m p le x p la n e. Each complex number— a point in the com plex
plane— is represented by Cartesian coordinates, where the real part of the num ber
corresponds to the A-coordinate o f the point, and the imaginary part corresponds
to the y-coordinate. For exam ple, the complex numbers 2 + 2.5/, 1 - 3/, - 3 - 2/,
and -3 .5 + 1.5/ can be plotted as follows:
                                         Im aginary
                                            axis
                                             i   1

                                           3—




                                                                         Real
                                                                         axis




      An alternative system known as p o la r co o rd in a tes can also be used to specify
a point on the complex plane. With polar coordinates, a complex num ber z is repre­
sented by the values r and 6. where r is the length of a line segment from the origin
to z, and 0 is the angle between this segment and the real axis:
7 1 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7 A d d itio n a l C 9 9 S u p p o rt fo r M a th e m a tic s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      is called the a b s o lu te v a lu e o f z. (The absolute value is also know n as the norm ,
                                   r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   m o d u lu s, or m a g n itu d e .) 0 is said to be the a r g u m e n t (or p h a s e a n g le ) o f z. T he
                                   absolute value o f a 4- bi is given by the follow ing equation:

                                                                             I# + bi\ = J a 2 4- b 2

                                       For additional inform ation about converting^> from C artesian coordinates to
                                   polar coordinates and vice versa, see the Program m ing Projects at ihe end o f the
                                   chapter.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                    C o m p le x A r ith m e tic

                                   T he sum o f two com plex num bers is found by separately adding the real parts o f
                                   the tw o num bers and the im aginary parts. For exam ple,

                                                        ( 3 - 2 z ) 4- (1.5 4- 3i) = (3 4- 1.5) 4- (-2 4- 3)7 = 4.5 4- i

                                   T he difference o f tw o com plex num bers is com puted in a sim ilar m anner, by sepa­
                                   rately subtracting the real parts and the im aginary parts. For exam ple,

                                                        (3 - 2i) - ( 1 . 5 4- 3i) = (3 - 1.5) 4- ( - 2 - 3 ) 7 = 1.5 - 57

                                        M ultiplying com plex num bers is done by m ultiplying each term o f the first
                                    num ber by each term o f the second and then sum m ing the products:

                                              (3 - 27) x ( 1.5 4- 3i) = (3 x 1.5) 4- (3 x 3i) 4- (-27 x 1.5) 4- (-27 x 3i)
                                                                      = 4.5 4 - 9 / - 3 / - 6 / - = 1 0 . 5 4-6/

                                    N ote that the identity 72 = -1 is used to sim plify the result.
                                         D ividing com plex num bers is a bit harder. First, we need the concept o f the
                                   c o m p le x c o n ju g a te o f a num ber, w hich is found by sw itching the sign o f the num ­
                                   b er’s im aginary part. For exam ple, 7 - 47 is the conjugate of 7 4- 47, and 7 4- 47 is the
                                   conjugate o f 7 - 47. W e’ll use z* to denote the conjugate of a com plex num ber z.
                                         T he quotient o f two com plex num bers y and z is given by the form ula

                                                                                  y!z. = yz*/zz*

                                    It turns out that zz* is alw ays a real num ber, so dividing zz* into yz* is easy ^ u st
                                    divide both the real part and the im aginary part o fy z * separately). T he follow ing
                                    exam ple show s how to divide 10.5 4- 67 by 3 - 27:

                                                  10.5 4-67 = (10.5 4-67)(3 4- 27)            =   19.5 4-397 =          j 5   3 /
                                                   3 -2 7       (3 - 2 7 ) ( 3 4- 27)                 13


                                    C o m p le x T y p e s in RQPONMLKJIHGFEDCBA
                                                              C 99

                                    C 99 has considerable built-in support for com plex num bers. W ithout including any
                                    library headers, we can declare variables that represent com plex num bers and then
                                    perform arithm etic and other operations on these variables.
                                                 2 7 .3                                               715
                                                          C o m p le x N u m b e rs (C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJI


      C99 provides three complex types, which were first introduced in Section 7.2:
t l o a t _ C o m p le x , d o u b l e _ C o m p le x . and l o n g d o u b l e _ C o m p le x .
These types can be used in the same way as other types in C: to declare variables,
parameters, return types, array elements, members of structures and unions, and so
forth. For example, we could declare three variables as follows:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

float _Complex x;
double _Complex y;
long double _Complex z;

Each of these variables is stored just like an array of two ordinary floating-point
numbers. Thus, y is stored as two adjacent d o u b l e values, with the first value
containing the real part o f y a n d the second containing the imaginary part.
     C99 also allows implem entations to provide imaginary types (the keyword
_ I m a g i n a r y is reserved for this puipose) but doesn’t make this a requirem ent.dcbaZYXWVUTSRQPONML


O p e r a tio n s o n C o m p le x N u m b e r s

Complex numbers may be used in expressions, although only the following opera­
tors allow complex operands:

  ■ Unary 4- and -
  ■ Logical negation ( ! )
  ■ s iz e o f
  ■ Cast
  ■ M ultiplicative (* and / only)
  ■ Additive (+ and -)
  ■ Equality (== and l =)
  ■ Logical      a nd (&&)
                 cbaZYXWVUTSRQPONMLKJIHGFEDCBA


  ■ Logical      or ( | | )
  ■ C o n d itio n a l(? :)
  ■ Simple assignment (=)
  ■ Com pound assignment (*=, / = , +=, and - = only)
  ■ Com ma ( , )
Some notable om issions from the list include the relational operators (<, <=, >,
and >=), along with the increment (++) and decrem ent ( - - ) operators.


C o n v e r s io n R u le s fo r C o m p le x T y p e s

Section 7.4 described the C99 rules for type conversion, but without covering the
complex types. It’s now time to rectify that situation. Before we get to the conver­
sion rules, though, w e’ll need some new terminology. Foreach floating type there is
a co rresponding real type. In the case of the real floating types ( f l o a t , d o u b l e ,
and l o n g d o u b l e ) , the corresponding real type is the same as the original type.
             C h a p te r 2 7 A d d itio n a l C 9 9 S u p p o r t for M a th e m a tic s
7 1 6 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   For the complex types, the corresponding real type is the original type without the
                                   word _ C o m p le x . (The corresponding real type for f l o a t _ C o m p le x is f l o a t ,
                                   for example.)
                                        W e're now ready to discuss the general rules that govern type conversions
                                   involving complex types. I’ll group them into three categories.

                                     ■ C om plex to com plex. The first rule concerns conversions from one complex
                                       type to another, such as converting from f l o a t _ C o m p le x to d o u b l e
                                       _ C o m p le x . In this situation, the real and imaginary parts are converted sepa­
                                       rately, using the rules for the corresponding real types (see Section 7.4). In our
                                       example, the real part o fth e f l o a t _ C o m p le x value would be converted to
                                       d o u b l e , yielding the real part of the d o u b l e _ C o m p le x value: the imagi­
                                       nary part would be converted to d o u b l e in a sim ilar fashion.
                                     ■ R e a l to com plex. When a value of a real type is converted to a complex type,
                                       the real part o fth e number is converted using the rules for converting from one
                                       real type to another. The imaginary part of the result is set to positive or
                                       unsigned zero.
                                     ■ C om plex to real. When a value of a complex type is converted to a real type,
                                       the imaginary part of lhe number is discarded: the real part is converted using
                                       the rules for converting from one real type to another.

                                        One particular set of type conversions, known as the usual arithmetic conver­
                                   sions, are automatically applied to the operands of most binary operators. There
                                   are special rules for performing the usual arithmetic conversions when at least one
                                   of the two operands has a complex type:

                                         1. If the corresponding real type of either operand is l o n g d o u b l e , convert
                                            the other operand so that its corresponding real type is l o n g d o u b l e .
                                         2. Otherwise, if the corresponding real type of either operand is d o u b l e ,
                                            convert the other operand so that its corresponding real type is d o u b l e .
                                         3. Otherwise, one o fth e operands must have f l o a t as its corresponding real
                                            type. Convert the other operand so that its corresponding real type is also
                                            flo a t.

                                   A real operand still belongs to a real type after conversion, and a complex operand
                                   still belongs to a complex type.
                                         Normally, the goal of the usual arithmetic conversions is to convert both
                                   operands to a common type. However, when a real operand is mixed with a com­
                                   plex operand, performing the usual arithmetic conversions causes the operands to
                                   have a common real type, but not necessarily the sam e type. For example, add­
                                   ing a f l o a t operand and a d o u b l e _ C o m p le x operand causes the f l o a t
                                   operand to be converted to d o u b l e rather than d o u b l e _ C o m p le x . The type
                                   of the result will be the complex type whose corresponding real type matches the
                                   common real type. In our example, the type o f the result will be d o u b l e
                                   _ C o m p le x .
                                               2 7 .4                                                                                               717hgfedcbaZYXWVUTSRQ
                                                         T h e < c o m p le x . h > H e a d e r ( C 9 9 ) : C o m p le x A r it h r n e t ic kjihgfedcbaZYXWVUTSRQPONMLKJIHG




                         2 7 .4         T h e < c o m p le x . h > H e a d e r (C 9 9 ): C o m p le x
                                        A r ith m e tic onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                        As we saw in Section 27.3, C99 has significant built-in support for complex num­
                                        bers. The < c o m p l e x . h> header provides additional support in the form of math­
                                        ematical functions on complex numbers, as well as some very useful macros and a
                                        pragma. Let’s look at the macros first.


                                        < c o m p le x . h> Macros
                                        The < c o m p l e x . h> header defines the macros shown in Table 27.4.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                    T a b le 2 7 .4                     N am e                                          V a lu e
c o m p l e x . h> Macros RQPONMLKJIHGFEDCBA
                                         c o m p le x                     _ C o m p le x
                                                   _ C o m p le x _ I     Imaginary unit; has type c o n s t f l o a t _ C o m p le x
                                                   I                      _ C o m p le x _ I

                                        c o m p le x serves as an alternative name for the awkward _ C o m p le x keyword.
                                        We’ve seen a situation like this before with the Boolean type: the C99 committee
                                        chose a new keyword (_ B o o l) that shouldn’t break existing programs, but pro­
< s t d b o o l . h > header > 2 1 .5   vided a better name ( b o o l) as a macro defined in the < s t d b o o l . h > header.
                                        Programs that include < c o m p le x .h > may use c o m p le x instead o f_ C o m p le x ,
                                        just as programs that include < s t d b o o l .h > may use b o o l rather than _ B o o l.
                                             The I macro plays an important role in C99. There’s no special language fea­
                                        ture for creating a complex number from its real part and imaginary part. Instead, a
                                        complex number can be constructed by multiplying the imaginary part by I and
                                        adding the real part:

                                        d o u b l e c o m p le x d c = 2 . 0       + 3 .5     * I;

                                        The value ofthe variable d c is 2 + 3.5z.
                                                                                                                   i. Presum­
                                             Note that both _ C o m p le x _ I and I represent the imaginary unit cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        ably most programmers will use I rather than _ C o m p le x _ I . However, since I
                                        might already be used in existing code for some other purpose, _ C o m p le x _ I is
                                        available as a backup. If the name I causes a conflict, it can always be undefined:

                                        # i n c l u d e < c o m p le x .h >
                                        #undef I

                                        The programmer might then define a different— but still short— name for /, such as
                                        J:

                                        # d e f i n e J _ C o m p le x _ I
7 1 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7   A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                  Also note that the type o f _ C o m p l e x _ I (and hence the type of I ) is f l o a t
                                              __C om plex, not d o u b l e _ C o m p le x . W hen it’s used in expressions, I will auto­
                                              matically be widened to d o u b l e _ C o m p le x or l o n g d o u b l e _ C o m p le x if
                                              necessary.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                              T h e C X _L IM IT E D _R A N G E P r a g m a

        # p r a g m a d ir e c tiv e > M .5   The < c o m p l e x .h > header provides a pragm a named CX_LIMITED_RANGE
                                              that allows the com piler to use the following standard form ulas for m ultiplication,
                                              division, and absolute value:

                                                                                            ( a c - b d ) + (b c + a d ) i
                                                                 (a + 6 / ) x ( c + d /) = cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                                          (a + b i ) / ( c + dF) = [(a c + b d ) + ( b c - a d ) i ] / ( c 2 + d 2 )

                                                                                  \a + hi\ = J a 2 + b 2
                                              Using these formulas may cause anomalous results in some cases because o fo v er-
                                              flow or underflow; moreover, the form ulas don’t handle infinities properly.
                                              Because of these potential problems, C99 doesn’t use the form ulas without the
                                              program m er’s permission.
                                                  The CX_LIMITED_RANGE pragm a has the following appearance:kjihgfedcbaZYXWVUTSRQPONMLK

                                              #pragma STDC CX_LIMITED_RANGE on-off-switch

                                              where on-off-sw itch is either ON, OFF, or DEFAULT. If the pragma is used with the
                                              value ON, it allows the com piler to use the formulas listed above. The value OFF
                                              causes the com piler to perform the calculations in a way that’s safer but possibly
                                              slower. The default setting, indicated by the DEFAULT choice, is equivalent to
                                              OFF.
                                                   The duration of the CX_LIMITED_RANGE pragm a depends on where it’s
                                              used in a program . When it appears at the top level of a source file, outside any
                                              external declarations, it remains in effect until the next CX_LIMITED_RANGE
                                              pragma or the end of the file. The only other place that a CX_LIMITED_RANGE
                                              pragm a might appear is at the beginning of a compound statement (possibly the
                                              body of a function); in that case, the pragma remains in effect until the next
                                              CX_LIMITED_RANGE pragm a (even one inside a nested com pound statement) or
                                              the end of the compound statement. At the end o f a com pound statement, the state
                                              of the switch returns to its value before the compound statem ent was entered.


                                              < c o m p l e x . h > F u n c tio n s

                                              The < c o m p l e x . h > header provides functions sim ilar to those in the C99 version
                                              of < m a t h .h > . The < c o m p l e x . h> functions are divided into groups,just as they
                                              were in < m a t h .h > : trigonom etric, hyperbolic, exponential and logarithmic, and
                                              power and absolute-value. The only functions that are unique to complex numbers
                                              are the manipulation functions, the last group discussed in this section.
                                           2 7 .4                                                                                           719
                                                     T h e < c o m p l e x . h > H e a d e r (C 9 9 ): C o m p le x A r ith m e tic onmlkjihgfedcbaZYXWVUTSRQPONMLK


                                         Each < c o m p l e x .h > function comes in three versions: a f l o a t c o m p le x
                                   version, a d o u b l e c o m p le x version, and a l o n g d o u b l e c o m p l e x version.
                                   The name of the f l o a t c o m p l e x version ends with f , and the name of the
                                   l o n g d o u b l e c o m p le x version ends with 1.
                                         Before we delve into the < c o m p l e x . h> functions, a few general comments
                                   are in order. First, as with the < m a t h . h> functions, the < c o m p l e x . h> functions
                                   expect angie measurements to be in radians, not degrees. Second, when an error dcbaZYXWVUTSRQPO
e r r n o v a r ia b io > 2 4 .2   occurs, the < c o m p l e x .h > functions may store a value in the e r r n o variable,
                                   but aren't required to.
                                         There's one last thing we’ll need before tackling the < c o m p l e x .h > func­
                                                       branch cut often appears in descriptions of functions that might
                                   tions. The term PONMLKJIHGFEDCBA
                                   conceivably have more than one possible return value. In the realm of complex
                                   numbers, choosing which value to return creates a branch cut: a curve (often just a
                                   line) in the complex plane around which a function is discontinuous. Branch cuts
                                   are usually not unique, but rather are determined by convention. An exact definition
                                   of branch cuts takes us further into complex analysis than I’d like to go, so I’ll sim ­
                                   ply reproduce the restrictions from the C99 standard without further explanation.


                                   T r ig o n o m e t r ic F u n c t io n s

                                     double complex cacos (double complex z);
                                     float complex cacosf(float complex z);
                                     long double complex cacosl(long double complex z);
                                     double complex casin(double complex z);
                                     float complex casinf(float complex z);
                                     long double complex casinl(long double complex z);
                                     double complex catan(double complex z);
                                     float complex catanf(float complex z);
                                     long double complex catanl(long double complex z);
                                     double complex ccos(double complex z);
                                     float complex ccosf(float complex z);
                                     long double complex ccosl(long double complex z);
                                     double complex csin(double complex z);
                                     float complex csinf(float complex z);
                                     long double complex csinl(long double complex z);
                                     double complex ctan(double complex z);
                                     float complex ctanf(float complex z);
                                     long double complex ctanl(long double complex z)f

                    cacos          The c a c o s function computes the complex arc cosine, with branch cuts outside the
                                   interval [-1, 4-1] along the real axis. The return value lies in a strip mathematically
                                   unbounded along the imaginary axis and in the interval f0,7t] along the real axis.
7 2 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
          C h a p te r 2 7    A d d it io n a l C 9 9 S u p p o rt fo r M a th e m a tic s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                         casin onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                             The c a s i n function com putes the com plex arc sine, with branch cuts outside
                                    the interval [-1 , 4-1] along the real axis. The retum value lies in a strip m athem ati­
                                    cally unbounded along the im aginary axis and in the interval [-7t/2. 4-7t/2] along the
                                    real axis.
                         catan               The c a t a n function com putes the com plex arc tangent, with branch cuts out­
                                    side the interval [-z, 4-z] along the im aginary axis. T hereturn value lies in a s trip m ath­
                                    em atically unbounded along the im aginary axis and in the interval [-K/2,4-7t/2] along
                                    the real axis.
                          ccos               The c c o s function com putes the com plex cosine, the c s i n function com -
                           cs/n     putes the com plex sine, and the c t a n function com putes the com plex tangent.
                          ctan dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    H y p e r b o lic F u n c t io n s


                                       d o u b le c o m p le x c a c o s h ( d o u b le c o m p le x z ) ;
                                       f l o a t c o m p le x c a c o s h f ( f l o a t c o m p le x z ) ;
                                       lo n g d o u b le c o m p le x c a c o s h l ( lo n g d o u b le c o m p le x z ) ;

                                       d o u b le c o m p le x c a s i n h ( d o u b l e c o m p le x z ) ;
                                       f l o a t c o m p le x c a s i n h f ( f l o a t c o m p le x z ) ;
                                       lo n g d o u b le c o m p le x c a s i n h l ( lo n g d o u b le c o m p le x z ) ;

                                       d o u b le c o m p le x c a ta n h ( d o u b le c o m p le x z ) ;
                                       f l o a t c o m p le x c a t a n h f ( f l o a t c o m p le x z ) ;
                                       lo n g d o u b le c o m p le x c a t a n h l ( lo n g d o u b le c o m p le x z ) ;

                                       d o u b le c o m p le x c c o s h ( d o u b le c o m p le x z ) ;
                                       f l o a t c o m p le x c c o s h f ( f l o a t c o m p le x z ) ;
                                       lo n g d o u b le c o m p le x c c o s h l ( lo n g d o u b le c o m p le x z ) ;

                                       d o u b le c o m p le x c s i n h ( d o u b l e c o m p le x z ) ;
                                       f l o a t c o m p le x c s i n h f ( f l o a t c o m p le x z ) ;
                                       lo n g d o u b le c o m p le x c s i n h l ( l o n g d o u b le c o m p le x z ) ;

                                       d o u b le c o m p le x c ta n h ( d o u b l e c o m p le x z ) ;
                                       f l o a t c o m p le x c t a n h f ( f l o a t c o m p le x z ) ;
                                       lo n g d o u b le c o m p le x c t a n h l ( l o n g d o u b le c o m p le x z ) ;

                       cacosh       The c a c o s h function com putes the com plex arc hyperbolic cosine, with a branch
                                    cut at values less than 1 along the real axis. The return value lies in a half-strip of
                                    nonnegGa&t ive values along the real axis andU in ■ the inJ tervaC
                                                                                                     l [-zn, 4-z&
                                                                                                                K] along the imag-
                                    inary axis.
                       casinh             The c a s i n h function com putes the complex arc hyperbolic sine, with branch
                                    cuts outside the interval [-z, 4-z] along the im aginary axis. T he return value lies in a
                                    strip m athem atically unbounded along the real axis and in the interval [-m /2,
                                    4-z7t/2] along the im aginary axis.
                       catanh             The c a t a n h function com putes the com plex arc hyperbolic tangent, with
                                    branch cuts outside the interval [-1,4-1] along the real axis. The retum value lies in
                27A                                                                                              721 onmlkjihgfedcbaZYXWVUT
                         T h e < c o m p l e x . h > H e a d e r (C 9 9 ): C o m p le x A r it h m e t ic hgfedcbaZYXWVUTSRQPONMLKJIHGF


         a strip mathematically unbounded along the real axis and in the interval [-m /2,
         4-z7i/2] along the imaginary axis.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
ccosh            The c c o s h function com putes the complex hyperbolic cosine, the c s i n h
 csinh   function computes the complex hyperbolic sine, and the c t a n h function com-
ctanh    p U t e s L|i e complex hyperbolic tangent.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


         E x p o n e n tia l a n d L o g a r ith m ic F u n c tio n s


          d o u b le c o m p le x c e x p ( d o u b le c o m p le x z ) ;
          f l o a t c o m p le x c e x p f ( f l o a t c o m p le x z ) ;
          lo n g d o u b le c o m p le x c e x p l ( l o n g d o u b le c o m p le x z ) ;

          d o u b le c o m p le x c l o g ( d o u b l e c o m p le x z ) ;
          f l o a t c o m p le x c l o g f ( f l o a t c o m p le x z ) ;
          lo n g d o u b le c o m p le x c l o g l ( lo n g d o u b le c o m p le x z ) ;

 cexp    The c e x p function computes the complex base-e exponential value.
 clog         The c l o g function com putes the complex natural (base-e) logarithm, with a
         branch cut along the negative real axis. The return value lies in a strip m athem ati­
         cally unbounded along the real axis and in the interval [-/7i, +/7i] along the im agi­
         nary axis.


         P o w e r a n d A b s o lu te -V a lu e F u n c tio n s


           d o u b le c a b s ( d o u b le c o m p le x z ) ;
           f l o a t c a b s f ( f l o a t c o m p le x z ) ;
           lo n g d o u b le c a b s l ( lo n g d o u b le c o m p le x                z);

           d o u b le  c o m p le x c p o w (d o u b le c o m p le x x ,
                                             d o u b le c o m p le x y ) ;
           f l o a t c o m p le x c p o w f ( f l o a t c o m p le x x ,
                                             f l o a t c o m p le x y ) ;
           lo n g d o u b le c o m p le x c p o w l ( lo n g d o u b le c o m p le x x ,
                                                        lo n g d o u b le c o m p le x y ) ;

           d o u b le c o m p le x c s q r t ( d o u b l e c o m p le x z ) ;
           f l o a t c o m p le x c s q r t f ( f l o a t c o m p le x z ) ;
           lo n g d o u b le c o m p le x c s q r t l ( lo n g d o u b le c o m p le x z ) ;

cabs     The c a b s function computes the complex absolute value.
cpow           The cp o w function returns x raised to the power y, with a branch cut for the
         first param eter along the negative real axis.
 csqrt         The c s q r t function com putes the complex square root, with a branch cut
         along the negative real axis. The return value lies in the right half-plane (including
         the imaginary axis).
           C h a p te r 2 7 A d d itio n a l C 9 9 S u p p o rt fo r M a th e m a tic s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA
7 2 2 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                   M a n ip u la tio n F u n c t io n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     d o u b le c a r g ( d o u b le c o m p le x z ) ;
                                     f l o a t c a r g f ( f l o a t c o m p le x z ) ;
                                     lo n g d o u b le c a r g l ( l o n g d o u b le c o m p le x z ) ;

                                     d o u b le c im a g ( d o u b le c o m p le x z ) ;
                                     f l o a t c i m a g f ( f l o a t c o m p le x z ) ;
                                     lo n g d o u b le c i m a g l ( lo n g d o u b le c o m p le x z ) ;

                                     d o u b le c o m p le x c o n j (d o u b le c o m p le x z ) ;
                                     f l o a t c o m p le x c o n j f ( f l o a t c o m p le x z ) ;
                                     lo n g d o u b le c o m p le x c o n j l ( lo n g d o u b le c o m p le x z ) ;

                                     d o u b le c o m p le x c p r o j (d o u b le c o m p le x z ) ;
                                     f l o a t c o m p le x c p r o j f ( f l o a t c o m p le x z ) ;
                                     lo n g d o u b le c o m p le x c p r o j l ( l o n g d o u b le c o m p le x z ) ;

                                     d o u b le c r e a l ( d o u b le c o m p le x z ) ;
                                     f l o a t c r e a l f ( f l o a t c o m p le x z ) ;
                                     lo n g d o u b le c r e a l l ( lo n g d o u b le c o m p le x z ) ;

                         carg onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   The c a r g function returns the argument (phase angle) of z, with a branch cut
                                   along the negative real axis. The return value lies in the interval [-7t, 4-7t].
                       cimag                The c im a g function returns the imaginary part of z.
                         conj               The c o n j function returns the complex conjugate of z.
                        cproj               The c p r o j function com putes a projection of z onto the Riemann sphere.
                                   The return value is equal to z unless one of its parts is infinite, in which case
                                   c p r o j returns IN F IN IT Y + I * c o p y s i g n ( 0 . 0 , c i m a g ( z ) ).
                        creal               The c r e a l function retum s the real part of z.


               PROGRAM             F in d in g th e R o o ts o f a Q u a d r a tic E q u a tio n

                                   The roots of the quadratic equation

                                                                              ax 2 + bx + c = 0

                                   are given by the quadratic fo rm u la :

                                                                              _ ~b + Jb^-< X ac
                                                                                      2a
                                                                                                                     ^
                                   In general, the value oLv will be a complex number, because the square root of b~ -
                                                         ^
                                   4ac is im aginary if b~ - 4ac (known as the discrim inant) is less than 0.
                                        For example, suppose that a = 5, b = 2, and c = I , which gives us the equation

                                                                              5 .r + 2_v + 1 = 0

                                   The value of the discrim inant is 4 - 20 = -1 6 , so the roots of the equation will be
                                 2 7 .5                                                                                           7 2 3 onmlkjihgfedcbaZYXWV
                                              T h e < t g m a t h . h > H e a d e r (C 9 9 ): T y p e -G e n e ric M a th hgfedcbaZYXWVUTSRQPONMLKJIHGF


                      complex numbers. The following program, which uses several < c o m p l e x .h >
                      functions, computes and displays the roots.RQPONMLKJIHGFEDCBA

                          / ★ Finds the roots
q u a d r a t i c . c kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   of the equation 5x**2 + 2x + 1 = 0 */

                      #include <complex.h>
                      #include <stdio.h>

                      int main(void)

                           double a = 5 , b = 2 , c = 1;
                           double complex discriminant_sqrt = csqrt(b * b - 4 * a * c) ;
                           double complex rootl = (-b + discriminant_sqrt) / (2 * a ) ;
                           double complex root2 = (-b - discriminant_sqrt) / (2 * a ) ;

                           printf("rootl = %g + %gi\n", creal(rootl), cimag(rootl));
                           printf("root2 = %g + %gi\n", creal(root2), cimag(root2));

                           return 0;
                       }
                      Here’s the output of the program:

                      rootl = -0.2 + 0.4i
                      root2 = -0.2 + -0.4i

                           The q u a d r a t i c . c program shows how to display a complex number by
                      extracting the real and imaginary parts and then writing each as a floating-point
                      number, p r i n t f lacks conversion specifiers for complex numbers, so there’s no
                      easier technique. There’s also no shortcut for reading complex numbers; a program
                      will need to obtain the real and imaginary parts separately and then combine them
                      into a single complex number.aZYXWVUTSRQPONMLKJIHGFEDCBA




       2 7 .5         T h e < t g m a t h . h > H e a d e r (C 9 9 ): T y p e - G e n e r ic
                      M a th

                      The < t g m a t h . h> header provides parameterized macros with names that match
                      functions in < m a th .h > and < c o m p le x .h > . These t y p e - g e n e r i c m a c r o s can
                      detect the types of the arguments passed to them and substitute a call of the appro­
                      priate version of a < m a t h . h> or < c o m p l e x . h> function.
                            In C99, there are multiple versions of many math functions, as we saw in Sec­
                      tions 23.3, 23.4, and 27.4. For example, the s q r t function comes in a d o u b l e
                      version ( s q r t ) , a f l o a t version ( s q r t f ) , and a l o n g d o u b l e version
                      ( s q r t l ) , as well as three versions for complex numbers ( c s q r t , c s q r t f , and
                      c s q r t l ) . By using < t g m a t h .h > , the programmer can simply invoke s q r t
                      without having to worry about which version is needed: the call s q r t (x ) could
                      be a cal) of any of the six versions of s q r t , depending on the type of x.
7 2 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7   A d d itio n a l C 9 9 S u p p o rt fo r M a th e m a tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                          One advantage of using < t g m a t h . h > is that calls o f math functions becom e
                                     easier to write (and read!). M ore importantly, a call o f a type-generic macro w on’t
                                     have to be modified in the future should the type of its argum ent(s) change.
                                          The < t g m a t h . h > headerincludes both < m a t h .h > and < c o m p l e x .h > . by
                                     the way, so including < t g m a t h . h> provides access to the functions in both headers.dcbaZYXWVU

                                     T y p e -G e n e r ic M a c r o s
                                     The type-generic macros defined in the < t g m a t h . h > header fall into three
                                     groups, depending on w hether they correspond to functions in < m a t h .h > ,
                                     < c o m p l e x . h > , or both headers.
                                          Table 27.5 lists the type-generic macros that correspond to functions in both
                                     < m a t h .h > and < c o m p l e x .h > . Note that the nam e o fe a c h type-generic macro
                                     m atches the name o fth e “unsuffixed” < m a t h .h > function ( a c o s as opposed to
                                     a c o s f or a c o s l , for exam ple).

                   T a b le 2 7 .5                            <math.h>           <complex.h>             Type-Generic
  Type-Generic M acros in                                      Function            Function                 Mucro
 < t g m a t h . h > (Group 1) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                 acos               cacos                   acos
                                                                 asin               casin                   asin
                                                                 atan               catan                   atan
                                                                 acosh              cacosh                  acosh
                                                                 asinh              casinh                  asinh
                                                                 atanh              catanh                  atanh
                                                                 cos                ccos                    cos
                                                                 sin                csin                    sin
                                                                 tan                ctan                    tan
                                                                 cosh               ccosh                   cosh
                                                                 sinh               csinh                   sinh
                                                                 tanh               ctanh                   tanh
                                                                 exp                cexp                    exp
                                                                 log                clog                    log
                                                                 pow                cpow                    pow
                                                                 sqrt               csqrt                   sqrt
                                                                 fabs               cabs                    fabs

                                          The macros in the second group (Table 27.6) correspond only to functions in
                                     < m a t h .h > . Each macro has the sam e nam e as the unsuffixed < m a t h . h > func­
                                     tion. Passing a complex argum ent to any ofthese macros causes undefined behavior.

                   T a b le 2 7 .6                      atan2             fma             llround               remainder
  Type-Generic M acros in                               cbrt              fmax            loglO                 remquo
 < t g m a t h . h > (Group 2)                          ceil              fmin            loglp                 rint
                                                        copysign          fmod            log2                  round
                                                        erf               frexp           logb                  scalbn
                                                        erfc              hypot           lrint                 scalbln
                                                        exp2              ilogb           lround                tgamma
                                                        expml             ldexp           nearbyint             trunc
                                                        fdim              lgamma          nextafter
                                                        floor             llrint          nexttoward
                                             2 7 .5                                                                                        7 2 5 onmlkjihgfedcbaZYXWV
                                                       T h e < t g m a t h . h > H e a d e r (C 9 9 ): T y p e -G e n e ric M a th hgfedcbaZYXWVUTSRQPONMLKJIHG


                                        The macros in the final group (Table 27.7) correspond only to functions in
                                   < c o m p le x .h > .dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                 T a b le 2 7 .7                                        carg          conj     creal
 Type-Generic Macros in                                                 cimag         cprojaZYXWVUTSRQPONMLKJIHGFEDCBA
< t g m a t h . h> (Group 3) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        Between the three tables, all functions in < m a th .h > and < c o m p l e x .h >
                        Q&A        that have multiple versions are accounted for, with the exception o fm o d f.

                                   I n v o k in g a T y p e -G e n e r ic M a c r o
                                   To understand what happens when a type-generic macro is invoked, we first need
                                   the concept of a gRQPONMLKJIHGFEDCBA
                                                          e n e r i c p a r a m e t e r Consider the prototypes for the three versions
                                   o f the n e x t a f t e r function (from < m a t h . h>):
                                   double nextafter(double x, double y);
                                   float nextafterf(float x, float y);
                                   long double nextafterl(long double x, long double y);
                                   The types of both x and y change depending on the version o f n e x t a f t e r , so
                                   both parameters are generic. Now consider the prototypes for the three versions of
                                   the n e x t t o w a r d function:
                                   double nexttoward(double x, long double y);
                                   float nexttowardf(float x, long double y);
                                   long double nexttowardl(long double x, long double y);
                                   The first parameter is generic, but the second is not (it always has type l o n g
                                    d o u b l e ) . Generic parameters always have type d o u b l e (or d o u b l e c o m p le x )
                                   in the unsuffixed version o fa function.
                                          When a type-generic macro is invoked, the first step is to determine whether it
                                    should be replaced by a < m a t h . h> function or a < c o m p le x . h> function. (This
                                    step doesn’t apply to the macros in Table 27.6. which are always replaced by a
                                    < m a t h . h> function, or the macros in Table 27.7, which are always replaced by a
                                    < c o m p le x .h > function.) The rule is simple: ifan y argument corresponding to a
                                   generic parameter is complex, then a < c o m p le x .h > function is chosen; other­
                                    wise. a < m a th .h > function is selected.
                                          The next step is to deduce which version of the < m a th .h > function or
                                    < c o m p le x .h > function is being called. L et’s assume that the function being
                                   called belongs to < m a th .h > . (The rules for the < c o m p l e x .h > case are analo­
                                   gc ous.)' The following rules are used, in the order listed:
                                                             G>




                                         1. Lfany aigument corresponding to a generic parameter has type l o n g d o u ­
                                            b l e , the l o n g d o u b l e version o fth e function is called.
                                         2. If any argument corresponding to a generic parameter has type d o u b l e or
                                            any integer type, the d o u b l e version of the function is called.
                                         3. Otherwise, the f l o a t version o fth e function is called.
                                   Rule 2 is a little unusual: it states that an integer argument causes the d o u b l e ver­
                        Q&A        sion o fafu n ctio n to be called, not the f l o a t version, which you might expect.
7 2 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7    A d d itio n a l C 9 9 S u p p o rt fo r M a th e m a tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                           As an exam ple, assume that the following variables have been declared:kjihgfedcbaZYXWVUT

                                     int i ;
                                     float f;
                                     double d;
                                     long double ld;
                                     float complex fc;
                                     double complex dc;
                                     long double complex ldc;

                                     For each macro invocation in the left column below, the corresponding function
                                     calJ appears in the right column:PONMLKJIHGFEDCBA

                                                                         Macro                 Equivalent
                                                                         Invocation            Function Call
                                                                          sqrt(i)               s q r t (i)
                                                                          sqrt(f)               s q r t f (f)
                                                                          sqrt(d)               sqrt(d)
                                                                          sqrt (ld)             sqrtl(ld)
                                                                          s qrt (fc)            csqrtf(fc)
                                                                          s q r t (dc)          csqrt(dc)
                                                                          s q r t (ldc)         c sqr tl(ldc)

                                     Note that writing s q r t ( i ) causes the d o u b l e version of s q r t to be called, not
                                     the f l o a t version.
                                           These rules also cover macros with more than one parameter. For exam ple, the
                                     in a c ro in v o c a tio n p o w (ld , f ) w i l l b e r e p l a c e d b y t h e c a U p o w l ( l d , f ) . B o t h
                                     of p o w ’s param eters are generic; because one of the argum ents has type l o n g
                                     d o u b l e , rule 1 states that the l o n g d o u b l e version o fp o w will be called.aZYXWVUTSRQPONM




                        2 7 .6       T h e < f e n v . h > H e a d e r ( C 9 9 ) : F l o a t in g - P o i n t
                                     E n v iro n m e n t

                                     IEEE Standard 754 is the most widely used representation for floating-point num ­
                                     bers. (This standard is also known as IEC 60559, which is how the C99 standard
                                     refers to it.) The purpose of the < f e n v . h > header is to give program s access to
                                     the floating-point status flags and control m odes specified in the IEEE standard.
                                     Although < f e n v . h> was designed in a general fashion that allows it to work with
                                     other floating-point representations, supporting the lEEE standard was the reason
                                     for the header's creation.
                                          A discussion of why programs might need access to status flags and control
                                     modes is beyond the scope of this book. For good exam ples, see “W hat every com ­
                                     puter scientist should know about floating-point arithm etic" by David Goldberg cbaZYXWVU
                                     (A C M C om puting Surveys, vol. 23, no. 1 (M arch 1991): 5 ^f8 ), which can be found
                                     on the Web.
  2 7 .6                                                                                                  727dcbaZYXWVUTSRQPONM
            T h e < f e n v . h > H e a d e r (C 9 9 ): F lo a tin g - P o in t E n v iro n m e n t kjihgfedcbaZYXWVUTSRQPONMLKJIHGF


F lo a ti n g -P o in t S ta tu s F la g s a n d C o n tr o l M o d e s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

Section 7.2 discussed some of the basic properties of IEEE Standard 754. Sec­
tion 23.4, which covered the C99 additions to the < m a th .h > header, gave addi­
tional detail. Some of that discussion, particularly concerning exceptions and
rounding directions, is directly relevant to the < f e n v . h> header. Before we con­
tinue, let’s review some o fth e material from Section 23.4 as well as define a few
new terms.
        flo a tin g -p o in t status fla g is a system variable that’s set when a floating­
      A cbaZYXWVUTSRQPONMLKJIHGFEDCBA
point exception is raised. In the IEEE standard, there are five types of floating­
point exceptions: overflow, underflow, division by zero, invalid operation (the
result of an arithmetic operation was NaN), and inexact (the result of an arithmetic
operation had to be rounded). Each exception has a corresponding status flag.
      The < f e n v . h > header declares a type named f e x c e p t _ t that’s used for
working with the floating-point status flags. An f e x c e p t _ t object represents
the collective value ofthese flags. Although f e x c e p t _ t can simply be an inte­
ger type, with single bits representing individual flags, the C99 standard doesn’t
make this a requirement. Other alternatives exist, including the possibility that
f e x c e p t _ t is a structure, with one member for each exception. This member
could store additional information about the corresponding exception, such as the
address of the floating-point instruction that caused the exception to be raised.
      A flo a tin g -p o in t control m ode is a system variable that may be set by a pro­
gram to change the future behavior of floating-point arithmetic. The fEEE standard
requires a "directed-rounding” mode that controls the rounding direction when a
number can’t be represented exactly using a floating-point representation. There
are four rounding directions: (1) R ound toward nearest. Rounds io the nearest rep­
resentable value, lf a number falls halfway between two values, it’s rounded to the
“even” value (the one whose least significant bit is zero). (2) R ound toward zero.
(3) Round toward positive infinity. (4) R ound toward negative infinity. The default
rounding direction is round toward nearest. Some implementations of the IEEE
standard provide two additional control modes: a modc that controls rounding pre­
cision and a “trap enablement” mode that determines whether a floating-point pro­
cessor will trap (or stop) when an exception is raised.
      The te m flo a tin g - p o in t environm ent refers to the combination of floating­
point status flags and control modes supported by a particular implementation. A
value of type f e n v _ t represents an entire floating-point environment. The
f e n v _ t type, like the f e x c e p t _ t type, is declared in < f e n v . h>.


< f e n v • h> M acros

The < f e n v . h > header potentially defines the macros listed in Table 27.8. Only
two of these macros (FE_ALL_EXCEPT and FE_DFL_ENV) are required, how­
ever. An implementation may define additional macros not listed in the table; the
names ofthese macros must begin with FE_ and an uppercase letter.
7 2 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7   A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                         Name
                       T a b le 2 7 .8 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   Value                            DescriptionkjihgfedcbaZYXWVUTSRQPONMLKJIHGF
       < f e n v . h > M acros PONMLKJIHGFEDCBA
                                      FE_DIVBYZERO                        Integer constant        Defined only ifth e corresponding floating­
                                               FE_INEXACT                 expressions whose       point exception is supported by the imple­
                                               FE_INVALID                 bits do not overlap     mentation. An implementation may define
                                               FE_OVERFLOW                                        additional macros that represent floating­
                                               FE_UNDERFLOW                                       point exceptions.
                                               FE_ALL_EXCEPT              See description         Bitwise oRQPONMLKJIHGFEDCBA
                                                                                                            r of all floating-point exception

                                                                                                  macros defined by the implementation. Has
                                                                                                  the value 0 if no such macros are defined.
                                               FE_DOWNWARD                Inte^ger constant        Defined only ifthe corresponding rounding
                                               FE_TONEAREST               expressions with         direction can bc retrieved and set via the
                                               FE_TOWARDZERO              distinct nonnega­       f e g e t r o u n d and f e s e t r o u n d func­
                                               FE_UPWARD                  tive values              tions. An implementation may define addi­
                                                                                                   tional macros (hat represent rounding
                                                                                                   directions.
                                               FE_DFL_ENV                 A value of type         Represents the default (program start-up)
                                                                          c o n st fe n v _ t *   floating-point environment. An implemen­
                                                                                                  tation may define additional macros that
                                                                                                  represent floating-point environments.


                                              T h e FE N V _A C C E SS P ra g m a

       # p r a g m a d ire c tlv o > 1 4 .5   The < f e n v . h > header provides a pragm a named FENV_ACCESS that's used to
                                              notify the com piler of a program ’s intention to use the functions provided by this
                                              header. Knowing which portions of a program will use the capabilities of
                                              < f e n v . h > is im portant for the compiler, because some com m on optim izations
                                              can 't be perform ed if control modes do n 't have their custom ary settings or may
                                              change during program execution.
                                                    The FENV_ACCESS pragm a has the following appearance:

                                              #pragma STDC FENV_ACCESS on-off-switch
                                                      on-o ff-sw itch is either ON. OFF, or DEFAULT. If the pragm a is used with the
                                              where cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                              value ON. it informs the com piler that the program might test floating-point status
                                              hags or alter a floating-point control mode. The value OFF indicates that flags
                                              w on't be tested and default control modes are in effect. The meaningL_^ ofD EFAULT
                                              is im plem entation-defined: it represents either ON or OFF.
                                                   The duration of the FENV_ACCESS pragm a depends on where it's used in a
                                              program. W hen it appears at the top level of a source file, outside any external dec­
                                              larations, it rem ains in effect until the next FENV_ACCESS pragm a or the end of
                                              the file. The only other place that an FENV_ACCESS pragm a might appear is at
                                              the beginning o f a com pound statem ent (possibly the body of a function); in that
                                              case, the pragm a rem ains in effect until the next FENV_ACCESS pragm a (even
                                              one inside a nested com pound statem ent) or the end of the com pound statem ent. At
                                              the end o f a com pound statem ent, the state of the switch returns to its value before
                                              the com pound statem ent was entered.
                                                   Tt\s the program m er's responsibility to use the FENV_ACCESS pragm a to
                                              indicate regions o f a program in which low-level access to floating-point hardware
                    27.6      The < fe n v .h > Header (C99): Floating-Point Environment onmlkjihgfedcbaZYXWVUTSRQPONML
                                                                                                 729

                  is needed. Undefined behavior occurs if a program tests floating-point status llags
                  or runs under non-default control modes in a region for which the value of the
                  pragm a switch is OFF.
                       Typically, an FENV_ACCESS pragm a that specifies the ON sw itch would be
                  placed at the beginning o f a function body:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  void f (double x, double y)

                     #pragma STDC FENV_ACCESS ON
                     •••


                  The function f may test floating-point status flags or changc control m odes as
                  needed. At the end of f ’s body, the pragm a switch will return to its previous state.
                      W hen a program goes from an FENV_ACCESS "o fT region to an i ; on ?’ region
                  during execution, the floating-point status flags have unspecified values and the
                  control modes have their default settings.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                  F lo a tin g - P o in t E x c e p t io n F u n c t io n s

                    in t fe c le a r e x c e p t( in t e x c e p ts );
                    in t f e g e t e x c e p t f l a g ( f e x c e p t _ t * fla g p , i n t e x c e p ts ) ;
                    in t fe r a is e e x c e p t (in t e x c e p ts ) ;
                    in t f e s e t e x c e p t f l a g ( c o n s t f e x c e p t _ t * fla g p ,
                                                          in t e x c e p ts );
                    in t f e t e s t e x c e p t ( i n t e x c e p ts );

                  The < f e n v . h > functions are divided into lhree groups. Functions in the first
                  group deal with the floating-point status flags. Each o f the five functions has an
                  i n t param eter nam ed e x c e p t s , which is the bitw ise or of one or m ore of the
                  floating-point exception macros (the first group o f macros listed in Table 27.8). For
                  exam ple, the argum ent passed to one o fth e se functions m ight be F E _IN V A L ID |
                  FE_OVERFLOW | FE_UNDERFLOW, to represent the com bination o f these three
                  status flags. The argument may also be zero, to indicate that no flags are selected.
 feclearexcept          The f e c l e a r e x c e p t function attem pts to clear the floating-point excep­
                  tions represented by e x c e p t s . It returns zero if e x c e p t s is zero or if all
                  specified exceptions were successfully cleared; otherw ise, ii returns a nonzero
                  value.
fegetexceptflag         The f e g e t e x c e p t f l a g function attem pts to retrieve the states o f the
                  floating-point status flags represented by e x c e p t s . This data is stored in the
                  f e x c e p t _ t object pointed to by f l a g p . The f e g e t e x c e p t f l a g function
                  returns zero if the states o f the status flags were successfully stored; otherw ise, it
                  returns a nonzero value.
 feraiseexcept          The f e r a i s e e x c e p t function attem pts to raise supported floating-point
                  exceptions represented by e x c e p t s . It is im plem entation-defined w hether
                  f e r a i s e e x c e p t also raises the inexact floating-point exception w henever il
7 3 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7 A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                    overflow or und erflo w exception. (knpIem entations that conform to the
                                      raises the cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      IEEE standai*d will have this property.) f e r a i s e e x c e p t returns zero if
                                      e x c e p t s is zero or ifall specified exceptions were successfully raised; otherwise,
                                      it returns a nonzero value.
            fesetexcep tfla g               The f e s e t e x c e p t f l a g function attempts to set the floating-point status
                                      flags represented by e x c e p t s . The states of the fiags are stored in the
                                      f e x c e p t _ t object pointed lo by f l a g p ; this object must have been set by a pre­
                                      vious call of f e g e t e x c e p t f l a g . Moreover, the second argum ent in the prior
                                      call of f e g e t e x c e p t f l a g must have included all floating-point exceptions rep­
                                      resented by e x c e p t s . The f e s e t e x c e p t f l a g function returns zero if
                                      e x c e p t s is zero or if all specified exceptions were successfully set; otherwise, it
                                      returns a nonzero value.
                fe te ste x c e p t         The f e t e s t e x c e p t function tests only those floating-point status flags
                                      represented by e x c e p t s . It returns the bitwise or of the floating-point excep­
                                      tion macros corresponding to the flags that are currently set. For example, if the
                                      value of e x c e p t s is FE_IN V A LID | FE_OVERFLOW | FE_UNDERFLOW, the
                                      f e t e s t e x c e p t function might return FE_IN V A LID | FE_UNDERFLOW, in­
                                      dicating that, of the exceptions represented by FE_IN V A LID , FE_OVERFLOW,
                                      and FE_UNDERFLOW, only the flags for FE_IN V A LID and FE_UNDERFLOW
                                      are currently set.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      R o u n d in g F u n c tio n s




                                      The f e g e t r o u n d and f e s e t r o u n d functions are used to determ ine the round­
                                      ing direction and modify it. Both functions rely on the rounding-direction macros
                                      (the third group in Table 27.8).
                  fegetround               The f e g e t r o u n d function returns the value of the rounding-direction macro
                                      that matches the current rounding direction. If the current rounding direction c a n l
                                      be determ ined or doesn’t match any rounding-direction macro, f e g e t r o u n d
                                      returns a negative number.
                  fesetround               When passed the value of a rounding-direction macro, the f e s e t r o u n d
                                      function attempts to establish the corresponding rounding direction. If the call is
                                      successful, f e s e t r o u n d retum s zero; otherwise, it returns a nonzero value.


                                      E n v ir o n m e n t F u n c tio n s

                                        in t   fe g e te n v ( fe n v _ t * e n v p );
                                        in t   f e h o l d e x c e p t (fe n v _ _ t * e n v p ) ;
                                        in t   fe s e te n v ( c o n s t fe n v _ t * e n v p );
                                        in t   fe u p d a te e n v (c o n s t fe n v _ t * e n v p );
                                                                                                                              Q ZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                                & A        731


                                        The last four functions in < f e n v . h > deal with the entire floating-point environ­
                                        ment, notjust the status flags or control modes. Each function returns zero if it suc­
                                        ceeds at the operation it was asked to perform. Otherwise, it returns a nonzero
                                        value.
                     fe g e te n v                The f e g e t e n v function attempts to retrieve the current floating-point envi­
                                        ronment from the processor and store it in the object pointed to by e n v p .
              fe h o ld e x c e p t               The f e h o l d e x c e p t function (!) stores the current floating-point environ­
                                        ment in the object pointed to by e n v p , (2) clears the floating-point status flags,
                                        and (3) attempts to install a non-stop mode— if available— for all floating-point
                                        exceptions (so that future exceptions w on't cause a trap or stop).
                     fe s e te n v                The f e s e t e n v function attempts to establish the floating-point environment
                                        represented by e n v p , which either points to a floating-point environment stored
                                        by a previous call of f e g e t e n v or f e h o l d e x c e p t , or is equal to a floating­
                                        point environment macro such as FE_DFL_EW . Unlike the f e u p d a t e e n v
                                        function, f e s e t e n v doesn’t raise any exceptions, l f a call of f e g e t e n v is used
                                        to save the current floating-point environment, then a later call of f e s e t e n v can
                                        restore the environment to its previous state.
                                                  The f e u p d a t e e n v function attempts to (!) save the currently raised float­
               fe u p d a te e n v onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                        ing-point exceptions, (2) install the floating-point environment pointed to by
                                        e n v p , and (3) raise the saved exceptions, e n v p either points to a floating-point
                                        environment stored by a previous call of f e g e t e n v or f e h o l d e x c e p t , or is
                                        equal to a floating-point environment macro such as FE_DFL_ENV.aZYXWVUTSRQPONMLKJIHGFEDCBA




                                    Q & A

                             Q:     I f th e < i n t t y p e s . h > h e a d e r in c lu d e s th e < s t d i n t . h > h e a d e r , w h y d o w e
                                    n e e d th e < s t d i n t . h > h e a d e r a t a ll? [p . 7 0 9 ]
                             A:     The primary reason that < s t d i n t .h > exists as a separate header is so that pro-
frees:andingim piem entation>/4.3   grams in a freestanding implementation may include it. (C99 requires conforming
                                    implementations— both hosted and freestanding— to provide the < s t d i n t . h >
                                    header, but < i n t t y p e s .h > is required only for hosted implementations.) Even
                                    in a hosted environment, it may be advantageous to include < s t d i n t .h > rather
                                    than < i n t t y p e s .h > to avoid defining all the macros that belong to the latter.

                           *Q :     T h e r e a r e th r e e v e r s io n s o f th e m o d f fu n c tio n in < m a t h . h > , s o w h y i s n ’t
                                    th e r e a ty p e -g e n e r ic m a c r o n a m e d m o d f ? [p . 7 2 5 ]
                             A:     Let’s take a look at the prototypes for the three versions o fm o d f:kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    double modf(double value, double *iptr);
                                    float modff(float value, float *iptr);
                                    long double modfl(long double value, long double *iptr);

                                    m o d f is unusual in that it has a pointer parameter, and the type of the pointer isn’t
                                    the same among the three versions o fth e function, ( f r e x p and re m q u o have a
7 3 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           C h a p te r 2 7   A d d it io n a l C 9 9 S u p p o rt fo r M a th e m a tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                       pointer parameter, but it always has i n t * type.) Having a type-generic macro for
                                                       m o d f would posesom edifficultproblem s.Forexam ple, the meaning o fm o d f (d ,
                                                       & f ) , where d has type d o u b l e and f has type f l o a t , is unclear: are we calling
                                                       the m o d f function or the m o d f f function? Rather than develop a complicated set
                                                       of rules for a single function (and probably taking into account that m o d f isn't a
                                                       very popular function), the C99 committee chose not to provide a type-generic
                                                       m o d f macro.dcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                              Q:       W h e n a < t g m a t h . h > m a c r o is in v o k e d w ith a n in t e g e r a r g u m e n t, th e d o u b l e
                                                       v e r sio n o f t h e c o r r e s p o n d in g fu n c tio n is c a lle d . S h o u ld n ’t th e f l o a t v e r s io n b e
 u s u a ia rith m o tic c o n v e rs io n s > 7 . 4   c a lle d , a c c o r d in g to th e u su a l a r it h m e tic c o n v e r s io n s ? [p. 7 2 5 ]
                                               A:      W e’re dealing^^ with a macro, not a function, so the usual arithmetic conversions
                                                       don’t come into play. The C99 committee had to create a rule for determining
                                                       which version o f a function would be called when an integer argument is passed to
                                                       a < t g m a t h .h > macro. Although the committee at one point considered having
                                                       the f l o a t version called (for consistency with the usual arithmetic conversions),
                                                       they eventually decided that choosing the d o u b l e version was better. First, it’s
                                                       safer: converting an integer to f l o a t may cause a loss ofaccuracy, especially for
                                                       integer types whose width is 32 bits or more. Second, it causes fewer surprises for
                                                       the programmer. Suppose that i is an integer variable. If the < t g m a t h . h> header
                                                       isn’t included, the call s i n ( i ) calls the s i n function. On the other hand, if
                                                       < t g m a t h . h> cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                           is included, the caU s i n ( i ) invokes the s i n macro; because i is
                                                       an integer, the preprocessor replaces the s i n macro with the s i n function, and the
                                                       end result is the same.

                                              Q:       W h e n a p r o g r a m in v o k e s o n e o f th e ty p e -g e n e r ic m a c r o s in < t g m a t h . h > ,
                                                       h o w d o e s th e im p le m e n ta tio n d e te r m in e w h ic h fu n c tio n to c a ll? Is th e r e a w a y
                                                       fo r a m a c r o to te st th e ty p e s o f its a r g u m e n ts ?
                                               A:      One unusual aspect of < t g m a t h .h > is that its macros need to be able to test the
                                                       types of the arguments that are passed to them. C has no features for testing types,
                                                       so it would normally be impossible to write such a macro. The < t g m a t h .h >
                                                       macros rely on special facilities provided by a particular compiler to make such
                                                       testing possible. We don’t know what these facilities are, and they’re not guaran­
                                                       teed to be portable from one compiler to another.




                                                       E x e rc is e s aZYXWVUTSRQPONMLKJIHGFEDCBA

S e c t i o n 2 7 .1                             l.    (C99) Locaie the declarations of the i n t A '_ t and u in tv V _ t types in the < s t d i n c . h >
                                                       header installed on your system. Which values o fN a re supported?

                                                 2.    (C99) Write the parameterized macros IN T 3 2 _ C (n ), U IN T 3 2 _ C (n ). IN T 6 4 _ C (n ),
                                                       and U IN T64_C ( n ) . assuming that the i n t type and l o n g i n t types are 32 bits wide and
                                                       the l o n g l o n g i n t type is 64 bits wide. H im : Use the ## preprocessor operator to attach
                                                                                              P ro g ra m m in g P ro je c ts     733onmlkjihgfedcbaZYXWV

                               a suffix to n containing a combination of L and/or U characters. (See Section 7.1 for a dis­
                               cussion of how to use the L and U suffixes with integer constants.)

S e c tio n 27.2          3.   (C99) In each of the following statements, assume that the variable i has lhe indicated orig­
                               inal type. Using macros from the < i n t t y p e s . h> header, modify each statement so that it
                               will work correctly ifth e type of i is changed to the indicated new type.
                               (a) p r i n t f ( " % d " , i ) ;         Original type: i n t                 New type: i n t 8 _ t
                               (b) p r i n t f ( " % 1 2 . 4 d " , i   ; Original type: i n t                 New type: i n t 3 2 _ t
                               (c) p r i n t f ( " % - 6 o " , i ) ;     Original type: u n s i g n e d i n t New type: u i n t l 6 _ t
                               (d) p r i n t f ( " % # x " , i ) ;       Original type: u n s i g n e d i n t New type: u i n t 6 4 _ t

                            4.     (C99) Assume that die following variable declarations are in effect:
S e c tio n 27.5 ZYXWVUTSRQPONMLKJIHGFEDCBA
                               in t i ;
                               flo a t f;
                               d o u b le d ;
                               lo n g d o u b le l d ;
                               f l o a t c o m p le x f c ;
                               d o u b l e c o m p le x d c ;
                               l o n g d o u b l e c o m p le x l d c ;
                               Each of the following is an invocation of a macro in < t g m a t h . h>. Show what it will look
                               like after preprocessing, when the macro has been replaced by a function from < m a th .h >
                               or < c o m p le x .h > .
                               (a) t a n ( i )
                               (b) f a b s ( f )
                               (c) a s i n ( d )
                               (d) e x p ( l d )
                               (e) l o g ( f c )
                               (0 a c o s h ( d c )
                               (g) n e x t t o w a r d ( d , l d )
                               (h) r e m a i n d e r ( f , i )
                               fi) c o p y s i g n ( d , l d )
                               (j) c a r g ( i )
                               (k) c i m a g ( f )
                               (1) c o n j ( l d c ) aZYXWVUTSRQPONMLKJIHGFEDCBA




                                P r o g r a m m in g P r o je c t s

                          1.   (C99) Make the following modifications to the q u a d r a t i c . c program ofS ection 27.4:
                               (a) Have the user enter the coefficients of the polynomial (the values of the variables a , b,
                               and c).
                               (b) Have the program test the discriminant before displaying the values o f the roots. If the
                               discriminant is negative, have the program display the roots in the same way as before. If it’s
                               nonnegative, have the program display the roots as real numbers (without an imaginary part).
                                                                            2
                               For example, if the quadratic equation is xcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                              4- ,v - 2 = 0, the output of the program would be
                                ro o tl      1
                                ro o t2      -2
            C h a p te r 2 7
7 3 4 ZYXWVUTSRQPONMLKJIHGFEDCBA A d d itio n a l C 9 9 S u p p o r t fo r M a th e m a tic s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                      (c) Modify the program so that it displays a complex nuinber with a negative imaginary
                                              a - bi instead of a 4* - b i. For example, the output of the program with the original
                                      part as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      coefficients would be kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                      rootl = -0.2 + 0.4i
                                      root2 = -0.2 - 0.4i

                               2.     (C99) W rite a program that converts a complex num ber in Cartesian coordinates to polar
                                      form. The user will enlcr a and b (the real and imaginary parts of the number); the program
                                      will display the values o f r and 0.

                               3.     (C99) W rite a program that converts a complex number in polar coordinates to Cartesian
                                      form. After the user enters the values of r and ft the program will display the num ber in the
                                      form a + bi, where
                                      a = r cos ft
                                      b = r sin ft

                               4.     (C99) W rite a program that displays the /ith roots of unity when given a positive integer n.
                                      The nth roots of unity are given by the formula e 2 n ik /n , where k is an integer between 0 and
                                      n - 1.
A P P E N D IX A              aZYXWVUTSRQPONMLKJIHGFEDCBA



C O p e ra to rs                       cbaZYXWVUTSRQPONMLKJIHGFEDCBA




Precedence                 N am e                                      Sym bol(s)     A ssociativity onmlkjihgfedcbaZYXWVU
     i        Array subscripting         “ n                                                Left
     I        Function call                 0                                               Left
    1         Structure and union member    • **>                                           Left
    I         Increment (postfix)          H—F*                                             Left
    I         Decrement (postfix)          —                                                Left
    2            Increment (prefix)                    + *4*                               Right
    2            Decrement (prefix)                    —                                   RightdcbaZYXWVUTSRQPONMLKJ
    7te          Address                               &                                   Right
    2            Indirection                           *
                                                                                           Right
                 Unary plus
    ^7 ZYXWVUTSRQPONMLKJIHGFEDCBA                      +                                   Right
     2           Unary minus                           —                                   Right
    2            Bitwise complement                    4W                                  Right
    2            Logical negation                       •I                                 Riw
                                                                                             "-ht
    9A^          Size                                  s iz e o f                          Right
    3         Cast                                         0                               Right
    4         Multiplicative                           *           /        %               Left
    5         Additive                                 +                                    Left
    6         Bitwise shift                            <<              >>                   Left
    7         Relational                               <           >        <=   >=         Left
    8         Equality                                 --              !=                   Left
    9         Bitwise and                              &                                    Left
    io        Bitwise exclusive or
                                                       A.
                                                                                            Left
    i1        Bitwise inclusive or                                                          Left
    i2        Logc ical and                            Sc&                                  Left
    i3        Logical or                                                                    Left
    u         Conditional                              7-
                                                       •       •                           Right
    il        Assignment                           ~        *I   J2       %^               Rigoht
                                                       += -=      <<= >>=
                                                       k&-- ^ --   II -- ________
    ie        Comma                                     t                                   Left



                                                                                                    735
                            A P P E N D IX B                 aZYXWVUTSRQPONMLKJIHGFEDCBA



                            C 9 9 v e rs u s C 8 9                                   onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




                            This appendix lists many o fth e most significant differences betw een C89 and C99.
                            (The sm aller differences are too numerous to mention here.) The headings indicate
                            which chapter contains the primary discussion o f each C99 feature. Some of the
                            changes attributed to C99 actually occurred earlier, in A m endm ent 1 to the C89
                            standard: the.se chango es are marked “A m endm ent 1.”


                      2     C F u n d a m e n t a ls cbaZYXWVUTSRQPONMLKJIHGFEDCBA

       / / c o m m e n ts   C99 adds a second kind ofcom m ent, which begins with | | .

            identifiers     C89 requires com pilers to rem em ber the first 31 characters of identifiers: in C99,
                            the requirem ent is 63 characters. Only the first six characters ofnam es with external
                            linkage are significant in C89. Moreover, the case o fletters may not matter. In C99,
                            the first 31 characters are significant, and the case of letters is taken into account.

            keyw ords       Five keywords are new in C99: i n l i n e , r e s t r i c t , _ B o o l , _ C o m p le x , and
                              Im a g in a ry .

returning from kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                main In C89, if a program reaches the end o f the m a in function without executing a
                            r e t u r n statement, the value returned to the operating system is undefined. In C99,
                            i f m a i n is declared to return an i n t , the program returns 0 to the operating system.


                       4    E x p r e s s io n s

  / a n d % operators       The C89 standard states that if either operand is negative, the result o f an integer
                            division can be rounded either up or down. Moreover, if i or j is negative, the sign
                            of i % j depends on the implementation. In C99, the result o f a division is always
                            truncated toward zero and the value of i % j has the sam e sign as i .



                                                                                                                                 737
           A p p e n d ix B
7 3 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
                               0 9 9 v e rs u s C 8 9 aZYXWVUTSRQPONMLKJIHGFEDCBA


                                        S e le c t io n S t a t e m e n t s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                  5 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                  _Bool ty p e          C99 provides a Boolean type named _ B o o l; C89 has no Boolean type.


                                  6     Loops

            for s ta te m e n ts        ln C99, the first expression in a f o r statement can be replaced by a declaration,
                                        allowing the statement to declare its own control variable(s).


                                        B a s ic T y p e s

                  long long             C99 provides two additional standard integer types, l o n g l o n g i n t and u n ­
                in te g e r ty p e s    s ig n e d lo n g lo n g i n t .

 e x te n d e d in te g e r ty p e s    In addition to the standard integer types, C99 allows implementation-defined
                                        extended signed and unsigned integer types.

      long long in te g e r             C99 provides a way to indicate that an integer constant has type l o n g l o n g i n t
                     c o n s ta n ts    or u n s i g n e d l o n g l o n g i n t .

            ty p e s o f in te g e r    C 99’s rules for determining the type o fan integer constant are different from those
                     c o n s ta n ts    in C89.

    h e x a d e c im a l flo a tin g    C99 provides a way to write floating constants in hexadecimal.
                     c o n s ta n ts

      im p lic it c o n v e rs io n s   The rules for implicit conversions in C99 are somewhat different from the rules in
                                        C89, primarily because o fC 9 9 's additional basic types.


                                  8     A rra y s

   d e s ig n a te d in itia liz e rs   C99 supports designated initializers, which can be used to initialize arrays, struc­
                                        tures, and unions.

   v a ria b le -le n g th a rra y s    In C99, the length of an array may be specified by an expression that’s not con­
                                        stant, provided that Lhe array doesn’t have static storage duration and its declara­
                                        tion doesn’t contain an initializer.


                                  9     F u n c t io n s

   n o d e fa u lt re tu rn ty p e      If the return type of a function is omitted in C89, the function is presumed lo retum
                                        a value oftype i n t . In C99, it's illegal to omit the return type o f a function.

       m ix e d d e c la ra tio n s     In C89, declarations must precede statements within a block (including the body of
            a n d s ta te m e n t s     a function). In C99, declarations and statements can be mixed, as long as each vari­
                                        able is declared prior to the first statement that uses the variable.
                                                                                     A p p e n d ix B                                  739
                                                                                                         C 9 9 v e rs u s C 8 9 kjihgfedcbaZYXWVUTSRQPONMLKJIH

d e c la ra tio n o r d e fin itio n   C99 requires Lhal either a declaration or a definition o f a function be present prior
           re q u ire d p r io r to    to any call of the function. C89 doesn’t have this requirement; if a function is
                 fu n c tio n c a ll   called without a prior declaration or definition, the compiler assumes that the func­
                                       tion retums an i n t value.

             v a ria b le -le n g th     C99 allows variable-length array parameters. In a function declaration, the * sym­
                                         bol may appear inside brackets to indicate a variable-length array parameter.
         a r ra y p a r a m e te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


              s t a t i c a rra y      C99 allows the use of the word s t a t i c in the declaration of an array parameter,
                  p a r a m e te rs    indicating a minimum length for the first dimension o fth e array.

        c o m p o u n d lite ra ls     C99 supports the use of compound literals, which allow the creation of unnamed
                                       array and structure values.

     d e c la r a tio n o f n ia in    C99 allows m a in to be declared in an implementation-defined manner, with a
                                       return type other than i n t and/or parameters other than those specified by the
                                       standard.

       r e t u r n s ta te m e n t       In C89, executing a r e t u r n statement without an expression in a n o n - v o id func­
                                         tion causes undefined behavior (but only if the program attempts to use the value
       w ith o u t e x p re s s io n aZYXWVUTSRQPONMLKJIHGFEDCBA
                                         returned by the function). In C99, such a statement is illegal.


                               14      T h e P re p ro c e s s o r

   a d d itio n a l p re d e fin e d   C99 provides several new predefined macros.
                        m a c ro s

                e m p ty m a c ro      C99 allows any or all of the arguments in a macro call to be empty, provided that
                   a rg u m e n ts     the call contains the correct number of commas.

 m a c ro s w ith a v a ria b le       fri C89, a macro must have a fixed number of arguments, if it has any at all. C99
  n u m b e r o f a rg u m e n ts      allows macros that take an unlimited number of aroguments.

      __ f u n c __ id e n tifie r     ln C99,Z the «w»f u n c ^^^^^—identifier behaves likev*a string variable that stores the
                                       name o fth e currently executing function.

       s ta n d a rd p ra g m a s      In C89, there are no standard pragmas. C99 has three: CX_LIMITED_RANGE,
                                       FENV_ACCESS, and FP_CONTRACT.

       _ P r a g m a o p e ra to r     C99 provides the _ P ra g m a operator, which is used in conjunction with the
                                       # p r a g m a directive.


                               16      S t r u c t u r e s , U n io n s , a n d E n u m e r a t io n s

              s tr u c tu re ty p e    In C89, structures defined in different files are compatible if their members have
                 c o m p a tib ility   the same names and appear in the same order, with corresponding members having
740 ZYXWVUTSRQPONMLKJIHGFEDCBA
         A p p e n d ix B    C 9 9 v e rs u s C 8 9


                                        com patible types. C99 also requires that either both structures have the sam e tag or
                                        neither has a ta s .
                                                         V-r




         tra ilin g c o m m a in        In C99. the last constant in an enum eration may be followed by a comma.
               e n u m e ra tio n s aZYXWVUTSRQPONMLKJIHGFEDCBA


                                17      A d v a n c e d U s e s o f P o in te r s

        re s tr ic te d p o in te r s   C99 has a new keyword, r e s t r i c t , that can appear in the declaration of a pointer.

 fle x ib le a rra y m e m b e rs       C99 allows the last m em ber of a structure to be an array of unspecified length.


                                18      D e c la r a tio n s

          b lo c k s c o p e s fo r     ln C99. selection statem ents ( i f and s w i t c h ) and iteration statem ents ( w h i l e ,
  s e le c tio n a n d ite ra tio n     d o . and f o r ) — along with the “in n e f statem ents that they control— are consid­
                   s ta te m e n ts     ered to be blocks.

     array, s tru c tu re , a n d       In C89. a brace-enclosed initializer for an array, structure, or union m ust contain
           u n io n in itia liz e rs    only constant expressions. In C99, this restriction applies only if the variable has
                                        static storage duration.

            in lin e fu n c tio n s     C99 allows functions to be declared i n l i n e .


                               21 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                       T h e S t a n d a r d L ib r a r y

 <stdbool.h> h e a d e r cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                              The < s t d b o o l . h> header, which defines the b o o l , t r u e , and f a l s e macros,
                                        is new in C99.


                               22       ln p u t /O u t p u t

   ...printf c o n v e rs io n          The conversion specifications for the . . . p r i n t f functions have undergone a num ­
               s p e c ific a tio n s   ber of changes in C99. with new length modifiers, new conversion specifiers, the
                                        ability to write infinity and NaN, and support lbr wide characters. Also, the % le,
                                        % lE, % lf , % lg, and %lG conversions are legal in C99; they caused undefined
                                        behavior in C89.

     ...scanf c o n v e rs io n         In C99. the conversion specifications for the . . . s c a n f functions have new length
               s p e c ific a tio n s   modifiers, new conversion specifiers, the ability to read infinity and NaN, and sup­
                                        port for wide characters.

     snprintf fu n c tio n              C99 adds the s n p r i n t f function to the < s t d i o . h> header.


                               23       L ib r a r y S u p p o r t f o r N u m b e r s a n d C h a r a c t e r D a ta

    a d d itio n a l m a c ro s in      C99 adds the DECIM AL_DIG                and   FLT_EVAL_METHOD             macros    to   the
     <float.h> h e a d e r              < f l o a t . h> header.
                                                                                      A p p e n d ix B                                  741
                                                                                                         C 9 9 v e rs u s C 8 9 hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                                     ln C99, the < l i m i t s . h >
  a d d itio n a l m a c ro s in kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   header contains three new macros that describe the
 <limits .h> h e a d e r               characteristics o fth e l o n g l o n g i n t types.

math_errhandling                       C99 gives implementations a choice of how to inform a program that an error
                         m a c ro      has occurred in a mathematical function: via a value stored in e r r n o , via a
                                       floating-point exception, or both. The value of the m a t h _ e r r h a n d l i n g mac­
                                       ro (defined in < m a th .h > ) indicates how errors are signaled by a particular
                                       implementation.

                              C99 adds two new versions of most < m a t h . h> functions, one for f l o a t and one
a d d itio n a l fu n c tio n s in
                              for l o n g d o u b l e . C99 also adds a number of completely new functions and
     <math.h> h e a d e r aZYXWVUTSRQPONMLKJIHGFEDCBA
                              function-like macros to < m a t h . h>.


                              24       E r r o r H a n d lin g

          EiLSEQ m a c ro              C99 adds the EILSEQ macro to the < e r r n o . h> header.


                              25       In t e r n a t i o n a l F e a tu r e s

                     d ig ra p h s     Digraphs, which are two-character symbols that can be used as substitutes for the
                                       [, ] . {. }. #, and ## tokens, are new in C99. (Amendment l)

 <iso646.h> h e a d e r                The < i s o 6 4 6 .h > header, which defines macros that represent operators contain­
                                       ing the characters &. | . ~, !, and ^. is new in C99. (Amendment 1)

    u n iv e r s a l c h a ra c te r   Universal character names, which provide a way to embed UCS characters in the
                        nam es         source code of a program, are new in C99.

   <wchar.h> h e a d e r               The < w c h a r . h> header, which provides functions for wide-character input/out-
                                       put and wide string manipulation, is new in C99. (Amendment 1)

 <wctype.h> h e a d e r                The < w c ty p e . h> header, the wide-character version of < c t y p e . h>. is new in
                                       C99. < w c ty p e .h > provides functions for classifying and changing the case of
                                       wide characters. (Amendment 1)


                              26       M is c e lla n e o u s L ib r a r y F u n c t io n s

        va_copy m a c ro               C99 adds a function-like macro named v a _ c o p y to the < s t d a r g . h> header.

a d d itio n a l fu n c tio n s in     C99 adds the v s n p r i n t f , v f s c a n f , v s c a n f . and v s s c a n f functions to the
   <stdio.h> h e a d e r               < s t d i o . h > header.

a d d itio n a l fu n c tio n s in     C99 adds five numeric conversion functions, the _ E x i t function, and l o n g l o n g
<stdlib.h> h e a d e r                 versions of the a b s and d i v functions to the < s t d l i b . h> header.

a d d itio n a l strf time              C99 adds a number ofnew s t r f t i m e conversion specifiers. It also allows the use
                                        o f an E or 0 character to modify the meaning ofcertain conversion specifiers.
 c o n v e rs io n s p e c ifie rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
7 4 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix B     C 9 9 v e r s u s C 8 9 aZYXWVUTSRQPONMLKJIHGFEDCBA


                            2 7 kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     A d d it io n a l C 9 9 S u p p o r t f o r M a t h e m a t i c s

   <stdint.h> h e a d e r           The < s t d i n t . h > header, which declares integer types with specified widths, is
                                    new in C99.

<inttypes.h> h e a d e r            The < i n t t y p e s . h> header, which provides macros that are useful for input/out-
                                    put of the integer types in < s t d i n t . h > , is new in C99.

            c o m p le x ty p e s   C99 provides three complex types: f l o a t _ C o m p le x , d o u b l e _ C o m p le x ,
                                    and l o n g d o u b l e _ C o m p le x .

  <complex.h> h e a d e r           The < c o m p l e x .h > header, which provides functions that perform mathematical
                                    operations on complex numbers, is new in C99.

   <tgmath.h> h e a d e r           The < t g m a t h . h> header, which provides type-generic macros that make it easier
                                    to call library functions in < m a t h . h> and < c o m p l e x . h> . is new in C99.

       <fenv.h> h e a d e r         The < f e n v . h> header, which gives programs access to floating-point status flags
                                    and control modes, is new in C99.
              A P P E N D IX C               aZYXWVUTSRQPONMLKJIHGFEDCBA



              C 8 9 v e rs u s K & R C                                     onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA




              This appendix lists most o f th e significant differences between C89 and K&R C
                                                                                           The C Pro­
              (the language described in the first edition of Kernighan and Ritchie’s cbaZYXWVUTSRQPONMLKJIHGFEDCBA
              gram m ing Language). The headings indicate which chapter of this book discusses
              each C89 feature. This appendix doesn’t address the C library, which has changed
              much over the years. For other (less important) differences between C89 and K&R
              C, consult Appendices A and C in the second edition ofK & R .
                   Most o fto d a y ’s C compilers can handle all ofC 8 9 , but this appendix is useful
              if you to happen to encounter older programs that were originally written for pre-
              C89 compilers.


         2    C F u n d a m e n t a ls

identifiers   In K&R C, only the first eight characters of an identifier are significant.

keyw ords     K&R C lacks the keywords c o n s t , enum , s i g n e d , v o i d , and v o l a t i l e . In
              K&R C, the word e n t r y is a keyword.


         4    E x p r e s s io n s

  unary +     K&R C doesn’t support the unary + operator.


         5    S e le c t io n S t a t e m e n t s

 s w itc h    ln K&R C, the controlling expression (and case labels) in a s w i t c h statement
              must have type i n t after promotion. In C89. the expression and labels may be of
              any integral type, including u n s i g n e d i n t and l o n g i n t .




                                                                                                                  743
74 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix C     C 8 9 v e rs u s K & R C aZYXWVUTSRQPONMLKJIHGFEDCBA


                             7    B a s ic T y p e s cbaZYXWVUTSRQPONMLKJIHGFEDCBA

           unsigned types         K&R C provides only one unsigned type ( u n s i g n e d i n t ) .

                    s ig n e d    K&R C doesn’t support the s i g n e d type specifier.

          num b ersu ffixes       K&R C doesn’t support the U (or u) suffix to specify that an integer constant is
                                  unsigned, nor does it support the F (or f ) suffix to indicate that a floating constant
                                  is to be stored as a f l o a t value instead of a d o u b l e value. In K&R C. the L (or
                                  1) suffix can’t be used with floating constants.

              lo n g f l o a t    K&R C allows the use of l o n g f l o a t as a synonym for d o u b l e ; this usage
                                  isn’t le<s^*al in C89.

            lo n g d o u b le     K&R C doesn’t support the l o n g d o u b l e type.

      esca p e se q u e n c e s   The escape sequences \ a . \v . and \ ? don’t exist in K&R C. Also, K&R C doesn't
                                  support hexadecimal escape sequences.

                    s iz e _ t    In K&R C. the s i z e o f operator returns a value of type i n t : in C89, it returns a
                                  value o fty p e s i z e _ t .

          usual arithmetic        K&R C requires that f l o a t operands be converted to d o u b l e . Also, K&R C
             conversions          specifies that combining a shorter unsigned integer with a longer signed integer
                                  always produces an unsigned result.


                             9    F u n c t io n s

      function definitions        ln a C89 function definition, the types o fth e parameters are included in the param-
                                  eter list:
                                  d o u b le s q u a r e ( d o u b le x)

                                     r e tu r n x * x;


                                  K&R C requires that the types ofparam eters be specified in separate lists:
                                  d o u b le s q u a r e (x)
                                  d o u b le x ;

                                     re tu rn x * x;


    function declarations         A C89 function declaration (prototype) specifies the types of the function’s param­
                                  eters (and the names as well, ifdesired):
                                  d o u b le s q u a r e ( d o u b le x ) ;
                                  d o u b le s q u a r e ( d o u b l e ) ;      /* a l t e r n a t e form * /
                                  i n t ra n d (v o id );                       /* no p a r a m e te r s  */
                                                                              A p p e n d ix C                                       745
                                                                                                 C 8 9 v e r s u s K & R C onmlkjihgfedcbaZYXWVUTSRQPONMLKJ


                                    A K&R C function declaration omits all information about parameters:

                                    double s q u a r e ();
                                    int r a n d ();

                                   When a K&R C definition or declaration is used, the com piler doesn’t check that
          fu n c tio n c a lls kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    the function is called with argum ents of the proper number and type. Furtherm ore,
                                    the argum ents aren’t autom atically converted to the types of the corresponding
                                    parameters. Instead, the integral prom otions are perform ed, and f l o a t arguments
                                    are converted to d o u b l e .

                                K&R C doesn’t support the v o i d type.
                       voidaZYXWVUTSRQPONMLKJIHGFEDCBA


                           12       P o in t e r s a n d A r r a y s

 p o in t e r s u b tr a c tio n    Subtracting two pointers produces an i n t value in K&R C but a p t r d i f f _ t
                                    value in C89.


                           13       S t r in g s

           s t r in g lite r a ls   In K&R C, adjacent string literals aren’t concatenated. Also. K&R C doesn’t pro­
                                    hibit the modification of string literals.

  s t r in g in itia liz a tio n    In K&R C, an initializer for a character array of length n is limited to n - l charac­
                                    ters (leaving room for a null character at the end). C89 allows the initializer to have
                                    lengoth n.


                           14       T h e P re p ro c e s s o r

    #elif, #error,                  K&R C doesn’t support the # e l i f , # e r r o r . and # p r a g m a directives.
                #pragma

     #, ##, defined                 K&R C doesn’t support the #, # # . and d e f i n e d operators.


                           16       S t r u c tu r e s , U n io n s , a n d E n u m e r a t io n s

s tr u c tu r e a n d u n io n      ln C89, each structure and union has its own nam e space for mem bers; structure
 m e m b e rs a n d ta g s          and union tags are kept in a separate name space. K&R C uses a single name space
                                    for members and tags, so m em bers can’t have the sam e name (with some excep­
                                    tions). and members and tags can ’t overlap.

      w h o le -s tr u c tu re      K&R C doesn’t allow structures to be assig^^ned, 1p- assed as arsg^uments, or returned
              o p e ra tio n s      by functions.

         e n u m e ra tio n s       K&R C doesn’t support enum erations.
7 4 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix C aZYXWVUTSRQPONMLKJIHGFEDCBA
                                C 8 9 v e rs u s K & R C


                                 1 7 onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                          A d v a n c e d U s e s o f P o in t e r s

                          v o id *       In C89, v o i d * is used as a “generic” pointer type; for example, m a l l o c returns
                                         a value of type v o i d *. In K&R C, c h a r * is used for this purpose.

               p o in t e r m ix in g    K&R C allows pointers of different types to be mixed in assignments and com par­
                                         isons. In C89, pointers of type v o i d * can be mixed with pointers o fo th e r types,
                                         but any other mixing isn’t allowed without casting. Similarly, K&R C allows the
                                         mixing of integers and pointers in assignments and comparisons; C89 requires
                                         casting.

     p o in te r s to fu n c tio n s     Ifp fis a p o in te rto a fu n c tio n ,C 8 9 p e rm its u s in g e ith e r ( * p f ) (...) o r p f ( ...) to
                                         c a llth e fu n c tio n .K & R C a llo w so n ly ( * p f ) (...).


                                 18      D e c la r a t i o n s

 co n st a n d v o la tile               K&R C doesn’t supportthe c o n s t and v o l a t i l e type qualifiers.

   in itia liz a tio n o f a rra y s ,   K&R C doesn’t allow the initialization ofauiom atic arrays and structures, nor does
  s tru c tu re s , a n d u n io n s     it allow initialization of unions (regardless of storage duration).


                                25       In t e r n a t io n a l F e a t u r e s

            w id e c h a r a c te rs     K&R C doesn’t support wide character constants and wide string literals.

       trig ra p h s e q u e n c e s     K&R C doesn’t support trigraph sequences.


                                 26      M is c e ll a n e o u s L ib r a r y F u n c t i o n s

       v a ria b le a r g u m e n ts     K&R C doesn’t provide a portable way to write functions with a variable number
                                         ofargum ents, and it lacks the . . . (ellipsis) notation.
A P P E N D IX D                                    aZYXWVUTSRQPONMLKJIHGFEDCBA



S t a n d a r d L ib r a r y F u n c t io n s                                                                        onmlkjihgfedcbaZYXWVUTSRQP




This appendix describes all library functions supported by C89 and C99.* When
using this appendix, please keep the following points in mind:
   ■ In the interest ofbrevity and clarity, Fve omitte d many details. Some functions
       (notably p r i n t f and s c a n f and their variants) are covered in depth else­
       where in the book, so their descriptions here are minimal. For more informa­
       tion about a function (including examples of how it’s used), see the section(s)
       listed in italic at the lower right corner of the function’s description.
   ■ As in other parts of the book, italics are used t o indicate C99 differences. The
      names and prototypes offunctions that were added in C99 are shown in italics.
      Changes to C89 prototypes (the addition o fth e word r e s t r i c t to the decla­
      ration ofcertain parameters) are also italicized.
   ■ Function-like macros are included in this appendi x (with the exception of the
      type-generic macros in < tg m a th .h > ) . Each prototype for a macro is fol­
                         macro.
      lowed by the word cbaZYXWVUTSRQPONMLKJIHGFEDCBA
   ■ In C99. some < m a th . h> functions have three versi ons (one each for f l o a t ,
       d o u b l e , and l o n g d o u b l e ) . All three are grouped into a single entry,
       under the name of the d o u b l e version. For example, there’s only one entry
       (under a c o s ) for the a c o s , a c o s f , and a c o s l functions. The name ofeach
       additional version ( a c o s f and a c o s l , in this example) appears to the left of
       its prototype. The < c o m p le x .h > functions, which also come in three ver­
       sions, are treated in a similar fashion.
   ■ Most of the < w c h a r .h > functions are wide-characte r versions of functions
      found in other headers. Unless there’s a significant difference in behavior, the


* T h is m a te r ia l is a d a p te d f r o m in t e r n a tio n a l s ta n d a rd lS O / lE C 9 8 9 9 :1 9 9 9 .




                                                                                                                     747
7 4 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D      S ta n d a rd L ib ra ry F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                             description of each wide-character function simply refers the reader to the cor­
                                             responding function found elsewhere.
                                                                                                          im plem entation-
                                        ■ If some aspect of a function's behavior is descri bed as cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                            defined, that means that it depends on how the C library is im plemented. The
                                            function will always behave consistently, but the results may vary from one
                                            system to another. (In other words, check the manual to see what happens.)
                                            U ndefined behavior, on the other hand, is bad news: not only may the behavior
                                            vary betw een systems, but the program may act strangely or even crash.
                                        ■ The descriptions of many < m a t h .h > functions refer to the terms dom ain
                                           error and range error. The way in which these errors are indicated changed
                                           between C89 and C99. For the C89 treatm ent of these errors, see Section 23.3.
                                           For the C99 treatm ent, see Section 23.4.
                                        ■ The behavior of the following functions is affect ed by the current locale:
                                             < c t y p e . h > All functions kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                             <stdio.h>            Formatted input/output functions
                                             <stdlib.h> M ultibyte/w ide-character conversion functions, numeric
                                                                  conversion functions
                                             <string.h>                strcoll, strxfrm
                                             <time.h>                  strftime
                                             < w c h a r . h>          w c s c o l l , w c s f t i m e , w c s x f r m , formatted input/output
                                                                       functions, numeric conversion functions, extended
                                                                       m ultibyte/wide-character conversion functions
                                             <wctype .h>               All functions
                                             The i s a l p h a function, for example, usually checks whether a character lies
                                             between a and z or A and Z. In some locales, other characters are considered
                                             alphabetic as well.

                   abort             A b o r t P ro g ra m                                                                    < s t d l i b . h>
                                     v o id     a b o rt(v o id );
                                     Raises the SIGABRT signal. Tf the signal isn't caught (or if the signal handler re­
                                     turns), the program term inates abnorm ally and returns an im plem entation-defined
                                     code indicating unsuccessful term ination. W hether output buffers are flushed, open
                                     streams are closed, or temporary files are removed is implementation-defined.
                                                                                                                      26.2

                         abs          ln te g e r A b s o lu te V alue                                                        < s td lib .h >
                                      in t    a b s (in t       j );
                      Returns        Absolute value of j . The behavior is undefined ifth e absolute value of j can 't be
                                     represented.                                                                    26.2

                      acos           A r c C o s in e                                                                             < m a t h . h>
                                     d o u b le a c o s ( d o u b le x ) ;
                       acosf         flo a t a c o s f(flo a t x );
                       acosl         lo n g d o u b le a c o s l (lo n g d o u b le x ) ;
                                                       A p p e n d ix D                                                           749 cbaZYXWVUTSRQPONMLK
                                                                             S ta n d a r d L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIH


   R etu rn s   Arc cosine of x; the return value is in the range 0 to 7i. A domain error occurs lf x
                isn’t between -1 and +1.                                                         23.3 PONMLKJIHGFEDCBA

  acosh         A r c H y p e r b o lic C o s in e (C 9 9 )                                                         < m a t h . h>
                d o u b le a c o s h ( d o u b le x ) ;
  acoshf        flo a t a c o s h f(flo a t x );
  acoshl        lo n g d o u b le a c o s h l( lo n g             d o u b le x ) ;
   R etu rn s   Arc hyperbolic cosine o f x ; the retum value is in the range 0 to +«>. A domain error
                occurs i f x is less than 1.                                                      23.4 kjihgfedcbaZYXWVUTSR

asctime         C o n v e rt B ro k e n - D o w n T im e to S tr in g                                               < t i m e . h>
                c h a r * a s c tim e (c o n s t            s tru c t     tm * t i m e p t r ) ;
   R etu rn s   A pointer to a null-term inated string o ftb e form
                Sun Jun          3 17:48:34 2007\n
                constructed from the broken-down time in the structure pointed to by t i m e p t r .
                                                                                                 26.3

   asin         A r c S in e                                                                                        < m a t h .h >
                d o u b le a s in ( d o u b le x ) ;
   a s in f     flo a t a s in f( flo a t x );
   a s in l     lo n g d o u b le a s i n l (lo n g d o u b le x ) ;
   R etu rn s   Arc sine o f x ; the return value is in the range -x /2 to 4-rc/2. A domain error occurs
                if x isn’t between -1 and +1.                                                       23.3

  asinh         A rc H y p e r b o lic S in e (C 9 9 )                                                              < m a t h . h>
                d o u b le a s in h ( d o u b le x ) ;
  a s in h f    flo a t a s in h f(flo a t x );
  a s in h l    lo n g d o u b le a s i n h l ( l o n g           d o u b le x ) ;
   R eturns     Arc hyperbolic sine of x.                                                                                       23.4

 assert         A s s e r t T ru th o f E x p re s s io n                                                       < a s s e r t . h>
                v o id    a s s e x t(s c a la r e x p r e s s io n ) ;                                                      m acro
                If the value of e x p r e s s i o n is nonzero, a s s e r t does nothing. If the value is
                zero, a s s e r t writes a message to s t d e r r (specifying the text of e x p r e s s i o n ,
                the name of the source file containingc** the a s s e r t , and the line num ber of the
                a s s e r t ) ; it then term inates the program by calling a b o r t . To disable a s s e r t ,
                define the macro NDEBUG before including < a s s e r t . h > . C99 changes: The
                argument is allowed to have any scalar type; C89 specifies that the type is i n t .
                Also, C99 requires that the message written by a s s e r t include the nam e of the
                function in which the a s s e r t appears; C89 doesn’t have this requirement.             24.1

   atan         A rc T a n ge nt                                                                                   < m a th . h>
                d o u b le a ta n ( d o u b le x ) ;
   a ta n f     flo a t a ta n f(flo a t x );
7 5 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D      S ta n d a r d L ib r a r y F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                       a ta n l       lo n g     d o u b le     a ta n l(lo n g          d o u b le x ) ;
                                        Arc tangent        o f x : the return value is in the range
                      R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                    ^^
                                                                                                      -7t/2 to +rr/2.
                                                                                                 t^kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                                               23.3 GFEDCBA

                   atan2              A r c T a n g e n t o f Q u o tie n t                                                           < m a t h . h>
                                      d o u b le a t a n 2 (d o u b le y z d o u b le x ) ;
                     a ta n 2 f       flo a t a ta n 2 f(flo a t y t flo a t x );
                     a ta n 2 1       lo n g d o u b le a ta n 2 1 ( lo n g d o u b le y , lo n g d o u b le x ) ;
                      R e tu rn s     Arc tangent o f y / x : the return value is in the range - x to +7i. A domain error may
                                      occur if x and y are both zero.                                                     23.3 PONMLKJIHG

                   atanh              A r c H y p e r b o lic T a n g e n t (C 9 9 )                                                 < m a t h . h>
                                      d o u b le a ta n h ( d o u b le x ) ;
                     a ta n h f       flo a t a ta n h f(flo a t x );
                     a ta n h l       lo n g d o u b le a t a n h l (lo n g               d o u b le x ) ;
                      R e tu rn s     Arc hyperbolic tangent o f x . A domain error occurs if x is not between -1 and +1.
                                      A range error may occur if x is equal to -1 or +1.                             23.4

                atexit                R e g is te r F u n c tio n to B e C a lle d a t P r o g r a m E x it                      < s t d l i b . h>
                                      in t     a te x it(v o id           (* fu n c )(v o id ));
                                      Registers the function pointed to by f u n c as a term ination function. The function
                                      will be called if the program terminates normally (via r e t u r n or e x i t but not
                                      a b o rt).
                      R e tu r n s    Zero if successful, nonzero if unsuccessful (an im plem entation-dependent limit
                                      has been reached).                                                          26.2

                      atof            C o n v e r t S trin g to F lo a tin g - P o in t N u m b e r                             < s t d l i b . h>
                                      d o u b le     a to f(c o n s t         ch ar * n p tr);
                      R e tu rn s     A d o u b l e value corresponding to the longest initial part of the string pointed to
                                      by n p t r that has the form of a floating-point number. Returns zero if no conver­
                                      sion could be performed. The function’s behavior is undefined ifth e num ber can’t
                                      be represented.                                                                   26.2

                      atoi            C o n v e r t S tr in g to I n t e g e r                                                   < s t d l i b . h>
                                      in t     a to i(c o n s t        char      * n p tr);
                      R e tu rn s    An i n t value corresponding to the longest initial part of the string pointed to by
                                     n p t r that has the form of an integer. Returns zero if no conversion could be per­
                                     form ed. The function’s behavior is undefined if the number can’t be represented.
                                                                                                                     26.2

                      atol            C o n v e r t S tr in g to L o n g I n t e g e r                                           < s t d l i b . h>
                                      lo n g    in t     a to l(c o n s t        char       * n p tr);
                      R e tu rn s    A l o n g i n t value corresponding to the longest initial part of the string point­
                                     ed to by n p t r that has the form of an integer. Returns zero if no conversion
                                                   A p p e n d ix D                                                          751
                                                                         S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                                   onmlkjihgfedcbaZYXWV




               could be performed. The function’s behavior is undefined if the number can’t be
               represented.cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                  26.2 PONMLKJIHGFEDCBA

 atol 1        C o n v e rt S tr in g to L o n g L o n g In te g e r (C 9 9 )                                < s t d l i b . h>
               lo n g   lo n g     in t   a to ll(c o n s t        char         * n p tr );
  P eturns     A l o n g l o n g i n t value corresponding to the longest initial part of the string
               pointed to by n p t r that has the form of an integer. Returns zero if no conversion
               could be performed. The function’s behavior is undefined if the number can’t be
                           represented.                                                         26.2

bsearch        B in a r y S e a r c h                                                                        < s td lib .h >
               v o id    * b s e a r c h (c o n s t v o id *k ey , c o n s t v o id * b a se ,
                                          s i z e _ t memb, s i z e _ t s i z e ,
                                          i n t (* c o m p a r)(c o n s t v o id *,
                                                                c o n s t v o id * ) ) ;
               Searches for the value pointed to by k e y in the sorted array pointed to by b a s e .
               The array has nmemb elements, each s i z e bytes long, c o m p a r is a pointer to a
               comparison function. When passed pointers to the key and an array element, in
               that order, the comparison function must return a negative, zero, or positive inte­
               ger, depending on whether the key is less than, equal to, or greater than the array
               element.
   R eturns    A pointer to an array element that tests equal to the key. Returns a null pointer if
               the key isn’t found.                                                           26.2

 btowc         C o n v e rt B y te to W id e C h a ra c te r (C 9 9 )                                          < w c h a r . h>
               w in t_ t b to w c (in t          c );
   R eturns    W ide-character representation of c. Returns WEOF if c is equal to EOF or if c
               (when cast to u n s i g n e d c h a r ) isn’t a valid single-byte character in the initial
               shift state.                                                                         25.5

  cabs         C o m p le x A b s o lu te V a lu e (C 9 9 )                                                < c o m p l e x . h>
               d o u b le c a b s ( d o u b le c o m p le x z ) ;
   cabsf       f l o a t c a b s f ( f l o a t c o m p le x z ) ;
   cabsl       lo n g d o u b le c a b s l ( l o n g d o u b le c o m p le x z ) ;
   R eturns    Complex absolute value of z.                                                                                   27.4

 cacos         C o m p le x A rc C o s in e (C 9 9 )                                                      < c omp 1 e x . h >
               d o u b le c o m p le x c a c o s ( d o u b le c o m p le x z ) ;
  ca co sf     f l o a t c o m p le x c a c o s f ( f l o a t c o m p le x z ) ;
  cacosl       lo n g d o u b le c o m p le x c a c o s l ( l o n g d o u b le c o m p le x                       z);
   R etu rns   Complex arc cosine of z, with branch cuts outside the interval [-1, 4-1] along the
               real axis. The return value lies in a strip mathematically unbounded along the
               imaginary axis and in the interval [ 0 ,7i] along the real axis.              27.4
7 5 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a rd L ib ra ry F u n c tio n s


               c a c o s h                                                                                                  <complex.h>PONMLKJI
                                   C o m p le x A rc H y p e rb o lic C o s in e (C 9 9 ) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                   double complex cacosh(double complex z);
                  cacoshf          float complex cacoshf(float complex z);
                  cacoshl          long double complex cacoshl(long double complex z);cbaZYXWVUTSRQPON
                     R eturns onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   Complex arc hyperbolic cosine of z T with a branch cut at values less than 1 along
                                   the real axis. The return value lies in a half-strip of nonnegative values along the
                                   real axis and in the interval |-/K. +mJ along the imaginary axis.     27.4 aZYXWVUTSRQPONMLKJIHG

               C a 1 1 0 C         A llo c a te a n d C le a r M e m o ry B lo c k                                    <stdl i b .h>
                                   void *calloc(size__t nmemb, size__t size);
                                   Allocates a block of memory for an array with nmemb elements, each with s i z e
                                   bytes. The block is cleared by setting all bits to zero.
                     R eturns      A pointer to the beginning of the block. Returns a null poinler if a block of the
                                   requested size can’t be allocated.                                 17.3

                     c a rg        C o m p le x A rg u m e n t (C 9 9 )                                             <complex.h>
                                   double carg(double complex z);
                      cargf        float cargf(float complex z);
                      cargl        long double cargl(long double complex z);
                     R eturns      Argument (phase angle) of z, wilh a branch cut along the negative real axis. The
                                   return value lies in the interval [-n, 4-7t].                    27.4

                  c a s in         C o m p le x A rc S in e (C 9 9 )                                                <complex.h>
                                   double complex casin(double complex z);
                    casinf         float complex casinf(float complex z);
                    casinl         long double complex casinl(long double complex z);
                     R eturns      Complex arc sine of z. with branch cuts outside the interval [ - l . +1] along the real
                                   axis. The return value lies in a strip mathematically unbounded along the im agi­
                                   nary axis and in the interval [-7i/2, +7t/2] along the real axis.       27.4

               c a s in h          C o m p le x A r c H y p e rb o lic S in e (C 9 9 )                              <complex.h>
                                   double complex casinh(double complex z);
                  casinhf          float complex casinhf(float complex z);
                  casinhl          long double complex casinhl(long double complex z);
                     R etu rns     Complex arc hyperbolic sine of z, with branch cuts outside the interval [-L +/]
                                   along the imaginary axis. The return value lies in a strip mathematically unbounded
                                   along the real axis and in the interval [-m /2, +m/2] along the im aginary axis. 27.4

                  c a ta n         C o m p le x A r c T a n g e n t (C 9 9 )                                        < c o m p l e x . h>
                                   double complex catan(double complex z);
                   catanf          float complex catanf(float complex z);
                   catanl          long double complex catanl(long double complex z);
                                                      A p p e n d ix D                                                       753
                                                                         S ta n d a r d L ib r a r y F u n c tio n s hgfedcbaZYXWVUTSRQPONMLKJIHGFE


                    Complex arc tangent of z, with branch cuts outside the interval [-z\ +z] along the
   R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                   imaginary axis. The return value lies in a strip mathematically unbounded along
                   the imaginary axis and in the interval f-7t/2, +7i/2] along the real axis.  27.4 PONMLKJIHGFEDCBA

catanh             C o m p le x A rc H yperbolic T a n g en t (C 99)
               cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                                            <c o m p l e x . h>
                   d o u b le c o m p le x c a ta n h ( d o u b le c o m p le x z ) ;
c a ta n h f       f l o a t c o m p le x c a t a n h f ( f l o a t c o m p le x z ) ;
c a ta n h l       lo n g d o u b le c o m p le x c a t a n h l ( l o n g d o u b le c o m p le x z ) ;
   Returns         Comple/X arc hyperbolic tangent of z. with branch cuts outside the interval [-1, +1]
                   along the real axis. The return value lies in a strip mathematically unbounded
                   along the real axis and in the interval [-/n/2. +/7r/2] along the imaginary axis. 27.4

  cbrt             C u b e R o o t (C99)                                                                      <ma t h . h >
                   d o u b le c b r t( d o u b l e x ) ;
   c b r tf        flo a t c b r tf( flo a t x );
   c b r tl        lo n g d o u b le c b r t l ( l o n g d o u b le x ) ;
   Returns         Real cube root of x.                                                                                    23.4

  ccos             C o m p le x C o sin e (C 99)                                                         < c o m p le x . h>
                   d o u b le c o m p le x c c o s ( d o u b l e c o m p le x z ) ;
   ccosf           f l o a t c o m p le x c c o s f ( f l o a t c o m p le x z ) ;
   ccosl           lo n g d o u b le c o m p le x c c o s l ( l o n g d o u b le c o m p le x z ) ;
   Returns         Complex cosine of z.                                                                                    27.4

 ccosh             C o m p le x H yperbolic C o sin e (C 99)                                            < c o m p le x . h>
                   d o u b le c o m p le x c c o s h ( d o u b le c o m p le x z ) ;
 ccoshf            f l o a t c o m p le x c c o s h f ( f l o a t c o m p le x z ) ;
 ccoshl            lo n g d o u b le c o m p le x c c o s h l ( l o n g d o u b le c o m p le x z ) ;
   Returns         Complex hyperbolic cosine of z.                                                                         27.4 kjihgfedcbaZYXWVUT

  ceil             Ceiling                                                                                    < ma t h . h >
                   d o u b le c e i l ( d o u b l e x ) ;
   c e ilf         flo a t c e ilf( flo a t x );
   c e ill         lo n g d o u b le c e i l l ( l o n g d o u b le x ) ;
   Returns         Smallest integer that is greater than or equal to x .                                                   23.3

  cexp             C o m p le x B a s e -e E x p o n e n tia l (C 99)                                    < c o m p le x . h>
                   d o u b le c o m p le x c e x p ( d o u b le c o m p le x z ) ;
   cexpf           f l o a t c o m p le x c e x p f ( f l o a t c o m p le x z ) ;
   cexpl           lo n g d o u b le c o m p le x c e x p l ( lo n g d o u b le c o m p le x z ) ;
   Returns         Complex base-e exponential of z.                                                                        27.4

 cimag             Im aginary P art o f C o m p le x N u m b e r (C 99)                                 <c o m p l e x . h>
                   d o u b le c im a g (d o u b le       c o m p le x z ) ;
754      A p p e n d ix D
      ZYXWVUTSRQPONMLKJIHGFEDCBAS ta n d a r d L ib r a r y F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                 c ix n a g f      f l o a t c i m a g f ( f l o a t c o m p le x z ) ;
                 c im a g l        lo n g d o u b le c im a g l(lo n g d o u b le                     c o m p le x z ) ;
                   R eturns onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                 Imaginary part of z.                                                                                         27.4

       clearerr                    C le a r S t r e a m E r r o r                                                               < s td io .h >
                                   v o id       c le a re rr(F IL E         * s tre a m );
                                   Clears the end-of-file and error indicators for the stream pointed to by s t r e a m .
                                                                                                                                              22.3

               clock               P r o c e s s o r C lo c k                                                                      < tim e .h >
                                   c lo c k _ t c lo c k (v o id ) ;
                   R eturns        Elapsed processor time (measured in “clock ticks”) since the beginning of program
                                   execution. (To convert into seconds, divide by CLOCKS_PER_SEC.) Returns
                                    ( c lo c k _ _ t) ( - 1 ) iflh e lim e isu n a v a ila b Ie o rc a iT tb e re p re se n te d . 26.3

                  c l o g          C o m p le x N a tu ra l L o g a r ith m (C 9 9 )                                          < c o m p l e x . h>
                                   d o u b le c o m p le x c l o g ( d o u b l e c o m p le x z ) ;
                   c lo g f        f l o a t c o m p le x c l o g f ( f l o a t c o m p le x z ) ;
                   c lo g l        l o n g d o u b le c o m p le x c l o g l ( l o n g d o u b le c o m p le x z ) ;
                   R eturns        Complex natural (base-?) logarithm of z, with a branch cut along the negative real
                                   axis. The return value lies in a strip mathematically unbounded along the real axis
                                   and in the interval [-/K. +/7t| along the imaginary axis.           27.4

                  C O n j          C o m p le x C o n ju g a te (C 9 9 )                                                      < c o m p l e x . h>
                                   d o u b le c o m p le x c o n j (d o u b le c o m p le x z ) ;
                   c o n jf        f l o a t c o m p le x c o n j f ( f l o a t c o m p le x z ) ;
                   c o n jl        lo n g d o u b le c o m p le x c o n j l ( l o n g d o u b le c o m p le x z ) ;
                   R eturns        Complex conjugate of z.                                                                                    27.4

       c o p y s i g n             C o p y S ig n (C 9 9 )                                                                        < ma t h . h >
                                   d o u b le c o p y s ig n ( d o u b le x , d o u b le y ) ;
           c o p y s ig n f        flo a t c o p y s ig n f(flo a t x , flo a t y );
           c o p y s ig n l        lo n g d o u b le c o p y s ig n l (lo n g d o u b le x ,                    lo n g     d o u b le y ) ;
                   R eturns        A value with the magnitude o f x and the sign of y.                                                        23.4

                     co s          C o s in e                                                                                      < m a t h . h>
                                   d o u b le c o s ( d o u b le x ) ;
                     cosf          flo a t c o s f(flo a t x );
                     cosl          lo n g d o u b le c o s l (lo n g d o u b le x ) ;
                   R eturns        Cosine o f x (measured in radians).                                                                        23.3

                  C o sh           H y p e rb o lic C o s in e                                                                     < m a t h .h >
                                   d o u b le c o s h (d o u b le x ) ;
                   coshf           flo a t c o s h f(flo a t x );
                                                 A p p e n d ix D                                                      755PONMLKJIHGF
                                                                    S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONM


  coshl     long double coshl(long double x);
  Returns   Hyperbolic cosine of x. A range error occurs ifthe magnitude of x is too large.
                                                                                          23.3
 cpow       C o m p le x P o w e r ( C 9 9 )                                                         <complex.h>
            double complex cpow(double complex x,
                                double complex y);
  cpowf     float complex cpowf(float complex x,
                                float complex y);
  cpowl     long double complex cpowl(long double complex x,
                                      long double complex y);
  Returns   x raised to the power y, with a branch cut for the firstparameter along the negative
            real axis.                                                           27.4
cproj       C o m p le x P ro je c tio n (C 9 9 )                                                    <complex.h>
            double complex cproj (double complex z);
 cprojf     float complex cprojf(float complex z);
 cprojl     long double complex cprojl(long double complex z);
  Returns   Projection of z onto the Riemann sphere, z is returned unless one of its parts is
            infinite, in which case the return value is INFINITY + I * copysign(0.0,
            cimag (z) ).                                                     27.4
creal       R e a lP a r t o f C o m p le x N u m b e r ( C 9 9 )                                   <complex.h>
            double creal(double complex z);
 crealf     float crealf(float complex z);
 creall     long double creall(long double complex z);
  Returns   Real part of z.                                                                                             27.4
 c s in     C o m p le x S in e ( C 9 9 )                                                           <complex.h>
            double complex csin(double complex z);
  csinf     float complex csinf(float complex z);
  csinl     long double complex csinl(long double complex z);
  Returns   Complex sine of z.                                                                                          27.4
c S i n h   C o m p le x H y p e rb o lic S in e ( C 9 9 )                                          <comp 1e x .h >
            double complex csinh(double complex z);
 csinhf     float complex csinhf(float complex z);
 csinhl     long double complex csinhl(long double complex z);
  Returns   Complex hyperbolic sine of z.                                                                               27.4
csqrt       C o m p le x S q u a r e R o o t ( C 9 9 )                                              <complex.h>
            double complex csqrt(double complex z);
 csqrtf     float complex csqrtf(float complex z);
 csqrtl     long double complex csqrtl(long double complex z);
7 5 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a rd L ib r a r y F u n c tio n s


                                       Complex square root of z,   with a branch cut along the negative real axis. The
                      R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                          27.4cbaZYXWVU
                                    return value lies in the right half-plane (including the imaginary axis). PONMLKJIHGFEDCBA
                     c ta n          C o m p le x T a n g e n t (C 9 9 ) kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA   <complex.h>
                                     double complex ctan(double complex z);
                      ctanf          float complex ctanf(float complex z);
                      ctanl          long double complex ctanl(long double complex z);
                     R e tu rn s    Complex tangent of z.                                                                  27,4
                  c ta n h           C o m p le x H y p e r b o lic T a n g e n t (C 9 9 )                       <complex.h>
                                     double complex ctanh(double complex z);
                    ctanhf           float complex ctanhf(float complex z);
                    ctanhl           long double complex ctanhl(long double complex z);
                     R e tu rn s    Complex hyperbolic tangent of z.                                                       27.4
                  ctime              C o n v e r t C a le n d a r T im e to S tr in g                               <t ime.h>
                                    char *ctime(const time_t *timer);
                     R e tu r n s   A pointer to a string describing a local time equivalent to the calendar time pointed
                                    to by timer. Equivalent to asctime (localtime (timer) ).                               26.3
         difftime                    T im e D iffe re n c e                                                         <time.h>
                                    double difftime(time_t timel, time_t timeO);
                     R e tu rn s    Difference between tim e O (the earlier time) and t i m e l . measured in seconds.
                                                                                                                           26.3
                        div          In te g e r D iv is io n                                                     <stdl ib.h>
                                    div_t div(int numer, int denom);
                     R e tu rn s    A d i v _ t structure containing members named q u o t (the quotienl when n u m e r
                                    is divided by denom ) and re m (the remainder). The behavioris undefined if either
                                    part of the result can't be represented.                                      26.2
                        erf          E r r o r F u n c tio n (C 9 9 )                                               <math.h>
                                    double erf(double x);
                        erff        float erff(float x);
                        erfl        long double erfl(long double x);
                     R e tu rn s    erf(x). where erf is the Gaussian error function.                                      23.4
                     e r fc          C o m p le m e n ta ry E rr o r F u n c tio n (C 9 9 )                        <math.h >
                                    double erfc(double x);
                      erfcf         float erfcf(float x);
                      erfcl         long double erfcl (long double x);
                     R e tu rn s    erfc(x) = 1 - erf(x), where erf is the Gaussian error function. A range error occurs
                                    if x is too large.                                                              23.4
                                                   A p p e n d ix D                                                     757
                                                                        S ta n d a rd L ib ra ry F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


 exi t       E x it fro m P ro g ra m onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                          < s t d l i b . h>
             v o id e x i t ( i n t       s ta tu s );
             Calls all functions registered with a t e x i t , flushes all output buffers, closes all
             open streams, removes any files created by t m p f i l e . and terminates the pro­
             gram. The value of s t a t u s indicates whether the program terminated normally.
             The only portable values for s t a t u s are 0 and EXIT__SUCCESS (both indicate
             successful termination) plus EXIT_FAILURE (unsuccessful termination).cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                             9.5, 26.2

_Exi t       E x it fro m P ro g ra m (C 9 9 )                                                           < s t d l i b . h>
             v o i d _ _ _ E x it(in t s t a t u s ) ;
             Causes normal program termination. Doesn’t call functions registered with
             a t e x i t or signal handlers registered with s i g n a l . The status returned is deter­
             mined in the same way as for e x i t . Whether output buffers are flushed, open
             streams are closed, or temporary files are removed is implementation-defined.
                                                                                                   26.2

   exp       B a s e -e E x p o n e n tia l                                                                  < m a t h . h>
             d o u b le e x p (d o u b le x ) ;
   expf      flo a t e x p f(flo a t x );
   expl      lo n g d o u b le e x p l( lo n g            d o u b le x ) ;
 R eturns    e raised to the power x. A range error occurs if the magnitude of x is too large.
                                                                                              23.3

 exp2        B a s e -2 E x p o n e n tia l (C 9 9 )                                                         < m a t h . h>
             d o u b le e x p 2 (d o u b le x ) ;
 exp2f       flo a t e x p 2 f(flo a t x );
 exp21       lo n g d o u b le e x p 2 1 (lo n g            d o u b le x ) ;
 Returns     2 raised to the power x. A range error occurs if the magnitude o f x is too large.
                                                                                               23.4

expml        B a s e -e E x p o n e n tia l M in u s 1 (C 9 9 )                                              < m a t h . h>
             d o u b le exp m l (d o u b le x ) ;
e x p m lf   flo a t e x p m lf(flo a t x );
e x p m ll   lo n g d o u b le e x p m ll( lo n g d o u b le x ) ;
 R eturns    e raised to the power x. minus l . A range error occurs if x is too large.                                  23.4

 fab S       F lo a tin g A b s o lu te V a lu e                                                             < m a t h . h>
             d o u b le f a b s (d o u b le x ) ;
 fa b s f    flo a t fa b s f(flo a t x );
 fa b s l    lo n g d o u b le f a b s l ( l o n g d o u b le x ) ;
 R eturns    Absolute value of x.                                                                                        23.3
7 5 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a rd L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                fclose               C lo s e F ile onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                      <s t d i o . h >
                                     in t     fc lo s e (F IL E        * s tre a m );
                                     Closes the stream pointed to by s t r e a m . Flushes any unwritten output remaining
                                     in the stream ’s buffer. Deallocates the buffer if it was allocated automatically.
                      R e tu rn s    Zero if successful, EOF if an error was detected. cbaZYXWVUTSRQPONMLKJIHGFEDCBA                          22.2 PONMLKJI

                      fdim           P o s itiv e D iffe re n c e (C 9 9 )                                                           < m a t h . h>
                                     d o u b le fd im ( d o u b le x , d o u b le y ) ;
                       fd im f       flo a t fd im f(flo a t x, flo a t y );
                       fd im l       lo n g d o u b le f d i m l ( l o n g d o u b le x ,                   lo n g d o u b le y ) ;
                      R e tu rn s    Positive difference o f x and y:
                                          f
                                            x - y ifx > y
                                            4-0     if x < y
                                     A range error may occur.                                                                                 23.4

 feclearexcept                       C le a r F lo a tin g - P o in t E x c e p tio n s (C 9 9 )                                    <f e n v . h >
                                     in t     fe c le a r e x c e p t(in t          e x c e p ts );
                                     Attempts to clear the floating-point exceptions represented by e x c e p t s .
                      R e tu rn s    Zero if e x c e p t s is zero or if all specified exceptions were successfully cleared:
                                     otherwise, returns a nonzero value.                                                27.6

          fegetenv                   G e t F lo a tin g - P o in t E n v ir o n m e n t (C 9 9 )                                    < f e n v . h>
                                     in t     fe g e te n v (fe n v _ t         * e n v p );
                                     Attempts to store the current floating-point environment in the object pointed to by
                                     envp.
                      R e tu r n s   Zero if the environment was successfully stored: otherwise, returns a nonzero
                                     value.                                                                   27.6

fe g e te x c e p tfla g             G e t F lo a tin g - P o in t E x c e p tio n F la g s (C 9 9 )                                 < f e n v . h>
                                     in t     fe g e te x c e p tfla g (fe x c e p t_ t                * fla g p ,   in t   e x c e p ts );
                                     Attempts to retrieve the states of the floating-point status flags represented by
                                     e x c e p t s and store them in the object pointed to by f l a g p .
                      R e tu r n s   Zero if the states of the status flags were successfully stored: otherwise, returns a
                                     nonzero value.                                                                   27.6

    fegetround                       G e t F lo a tin g - P o in t R o u n d in g D ire c tio n (C 9 9 )                            < f e n v . h>
                                     in t     fe g e tr o u n d (v o id );
                      R e tu rn s    Value of the rounding-direction macro that represents the current rounding direc­
                                     tion. Returns a negative value ifth e current rounding direction can’t be determined
                                     or doesn’t match any rounding-direction macro.                                   27.6
                                                                    A p p e n d ix D                                                         759cbaZYXWVUTSRQPO
                                                                                           S ta n d a rd L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJ


fe h o ld e x c e p t                                                                                                            <f e n v . h>
                              S a v e F lo a tin g -P o in t E n v iro n m e n t (C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              in t    fe h o ld e x c e p t(fe n v _ t          * e n v p );
                              Saves the current floating-point environment in the object pointed to by e n v p ,
                              clears the floating-point status flags, and attempts to install a non-stop mode for all
                              floating-point exceptions.
                R e tu rn s   Zero ifnon-stop floating-point exception handling was successfully installed; oth­
                              erwise, returns a nonzero value.                                              27.6

                feof          T e st fo r E n d -o f-F ile                                                                     < s t d i o . h>
                              in t    fe o f(F IL E          * s tre a m );
                R e tu rn s   A nonzero value if the end-of-file indicator is set for the stream pointed to by
                              s t r e a m ; otherwise, returns zero.                                       22.3 PONMLKJIHGFEDCB

feraiseexcept                 R a is e F lo a tin g -P o in t E x c e p tio n s (C 9 9 )                                        <f e n v . h >
                              in t    fe r a is e e x c e p t(in t         e x c e p ts );
                              Attempts to raise supported floating-point exceptions represented by e x c e p t s .
                R e tu rn s   Zero if e x c e p t s is zero or if all specified exceptions were successfully raised;
                              otherwise, retums a nonzero value.                                                27.6

           ferror             T e st fo r F ile E rr o r                                                                      < s t d i o . h>
                              in t    fe rro r(F IL E           * s tre a m );
                R e tu rn s   A nonzero value if the error indicator is set for the stream pointed to by s t r e a m ;
                              otherwise, returns zero.                                                            22.3

       fe s e te n v          S e t F lo a tin g -P o in t E n v iro n m e n t (C 9 9 )                                         <f e n v . h >
                              in t    fe s e te n v (c o n s t       fe n v _ t     * e n v p );
                              Attempts to establish the floating-point environment represented by the object
                              pointed to by e n v p .
                R e tu rn s   Zero ifth e environment was successfully established: otherwise, returns a nonzero
                              value.                                                                        27.6

fe s e te x c e p tfla g      S e t F lo a tin g -P o in t E x c e p tio n F la g s (C 9 9 )                                     <f e n v . h >
                              in t    fe s e te x c e p tfla g (c o n s t fe x c e p t_ t                 * fla g p ,
                                                                 in t e x c e p ts );
                              Attempts to set the floating-point status flags represented by e x c e p t s to the
                              states stored in the object pointed to by f l a g p .
                R eturns      Zero i f e x c e p t s is zero or ifall specified exceptions were successfully set; other­
                              wise, returns a nonzero value.                                                        27.6

  fe s e tr o u n d           S e t F lo a tin g -P o in t R o u n d in g D ire c tio n (C 9 9 )                                 < f e n v . h>
                              in t    fe s e tr o u n d (in t        ro u n d );
7 6 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D    S ta n d a rd L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                     Attempts to establish the rounding direction represented by r o u n d .
                      R e tu rn s    Zero iflherequested rounding direction was established; otherwise, returns a non­
                                     zero value.cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                     27.6

 fe te s te x c e p t                Test F lo a tin g -P o in t E x c e p tio n F la g s (C 9 9 )                     < f e n v . h>
                                     in t    fe te s te x c e p t(in t           e x c e p ts );
                      R e tu rn s    Bitwise or of the floating-point exception macros corresponding to the currently
                                     set flags for the exceptions represented by e x c e p t s .                 27.6

 fe u p d a te e n v                 U p d a te F lo a tin g -P o in t E n v iro n m e n t (C 9 9 )                   < f e n v . h>
                                     in t    fe u p d a te e n v (c o n s t        fe n v _ t     * e n v p );
                                     Attempts to save the currently raised floating-point exceptions, install the floating­
                                     point environment represented by the object pointed to by e n v p , and then raise the
                                     saved exceptions.
                      R e tu rn s    Zero if all actions were successfully carried out; otherwise, returns a nonzero
                                     value.                                                                     27.6 kjihgf

                fflush               F lu s h F ile B u ffe r                                                         < s t d i o . h>
                                     in t    fflu s h (F IL E         * s tre a m );
                                     Writes any unwritten data in the buffer associated with s t r e a m , which points to a
                                     stream that was opened for output or updating. If s t r e a m is a null pointer,
                                     f f l u s h flushes all streams that have unwritten data stored in a buffer.
                      R e tu rn s    Zero if successful, EOF if a write error occurs.                                            22.2

                   fgetc             R e a d C h a ra c te r fro m F ile                                              < s t d i o . h>
                                     in t    fg e tc (F IL E        * s tre a m );
                                     Reads a character from the stream pointed to by s t r e a m .
                      R e tu rn s    Character read from the stream. If f g e t c encounters the end of the stream, it sets
                                     the stream’s end-ol-file indicator and returns EOF. If a read error occurs, f g e t c
                                     sets the streanfs error indicator and returns EOF.                                22.4

             fgetpos                 G e t F ile P o s itio n                                                         < s t d i o . h>
                                     in t    fg e tp o s (F IL E * r e s t r i c t s tre a m ,
                                                           fp o s_ t * r e s t r i c t p o s ) ;
                                     Stores the current position of the stream pointed to by s t r e a m in the object
                                     pointed to by p o s .
                      R e tu rn s    Zero ifsuccessful. Ifthe call fails, returns a nonzero value and stores an implemen­
                                     tation-defined positive value in e r r n o .                                     22.7

                   fgets             R e a d S trin g fro m F ile                                                     < s t d i o . h>
                                     ch a r * fg e ts (c h a r * r e s t r i c t                s, in t n,
                                                       F IL E * r e s t r i c t                 s tre a m );
                                                   A p p e n d ix D                                                       761
                                                                      S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                                                onmlkjihgfedcbaZYXWV




              Reads characters from the stream pointed to by s t r e a m and stores them in the
              array pointed to by s. Reading stops at the first new-line character (which is stored
              in the string), when n - l characters have been read, or at end-of-file. f g e t s
              appends a null character to the string.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
   R eturns   s (a pointer to the array in which the input is stored). Returns a null pointer if a
              read error occurs or f g e t s encounters the end of the stream before it has stored
              any characters. PONMLKJIHGFEDCBA                                                22.5
f g e tw c    R e a d W id e C h a r a c te r fro m F ile (C 9 9 )                                          <wchar.h>
              wint_t fgetwc(FILE *stream);
              W ide-character version of f g e t c .                                                                       25.5
f g e tw s    R e a d W id e S tr in g fro m F ile (C 9 9 )                                                 <wchar.h>
              wchar_t *fgetws(wchar_t * restrict s, int n,
                              FILE * restrict stream);
              W ide-character version of fgets.                                                                            25.5
 floor        F lo o r                                                                                        <math.h>
              double floor(double x);
   floorf     float floorf(float x);
   floorl     long double floorl(long double x);
   R eturns   Largest integer that is less than or equal to x.                                                             23.3

     fm a     F lo a tin g M u ltip ly - A d d (C 9 9 )                                                      <math.h>
              double fma(double x, double y, double z);
     fmaf     float fmaf(float x, float y t float z);
     fmal     long double fmal(long double x, long double y,
                                long double z);
   R eturns   (x x y) + z. The result is rounded only once, using thc rounding mode correspond­
              ing to FLT_ROUNDS. A range error may occur.                        23.4

   fm a x     F lo a tin g M a x im u m (C 9 9 )                                                               <math.h>
              double fmax(double x, double y);
    fmaxf     float fmaxf(float x t float y);
    fmaxl     long double fmaxl(long double x, long double y);
   R eturns   Maximum of x and y. If one argum ent is a NaN and the other is numeric, the
              numeric value is returned.                                   23.4

   fm in      Floating Minimum (C99)                                                                           <math.h>
              double fmin(double x, double y);
    fminf     float fminf(float x, float y);
    fminl     long double fminl(long double x, long double y ) ;
   R eturns   Minimum of x and y. If one argument is a NaN and the other is numeric, the
              numeric value is returned.                                  23.4
762      A p p e n d ix D
      ZYXWVUTSRQPONMLKJIHGFEDCBAS ta n d a r d L ib ra ry F u n c tio n s


                  fmod             F lo a tin g M o d u lu s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                         < m a t h . h>
                                  d o u b l e f m o d ( d o u b l e x , d o u b l e y ) ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                   fm o d f       f l o a t fin o d f ( f l o a t x , f l o a t y ) ;
                   fm o d l      lo n g d o u b le fm o d l ( lo n g d o u b le x , lo n g d o u b le y ) ;
                  R e tu rn s    R em ainder when x is divided by y. If y is zero, either a dom ain error occurs or
                                  zero is returned.                                                            23.3

                            fopen O p e n F ile                                                                            < s td io .h >
                                   F IL E    * fo p e n (c o n st c h a r           * r e s tr ic t      file n a m e ,
                                                         const char                 * r e s tr ic t      m o d e );
                                   Opens the file whose nam e is pointed to by f i l e n a m e and associates it with a
                                   stream , m o d e specifies the mode in which the file is to be opened. Clears the error
                                   and end-of-file indicators for the stream .
                  R etu rn s       A file pointer to be used when perform ing subsequent operations on the file.
                                   Returns a null pointer if the file can’t be opened.                     22.2

  fp c la s s ify                  F lo a tin g -P o in t C la s s ific a tio n (C 9 9 )                                       < m a th . h>
                                   in t     fp c la s s ify (r e a l-J lo a tin g     x) ;                                           m acro
                  R etu rn s       Either F P _ IN F IN IT E , FP_NAN. FP_NORMAL. FP_SUBNORMAL, or FP_ZERO,
                                   depending on w hether x is infinity, not a number, norm al, subnorm al, or zero,
                                   respectively.                                                               23.4

          fprintf                  F o rm a tte d F ile W rite                                                             <s t d i o . h >
                                   in t     f p r i n t f (F IL E * r e s t r i c t s t r e a m ,
                                                           c o n s t c h a r * r e s t r i c t fo rm a t,             ...) ;
                                   W rites output to the stream pointed to by s t r e a m . The string pointed to by
                                   f o r m a t specifies how subsequent argum ents will be displayed.
                  R e tu rn s      N um ber o f characters written. Returns a negative value if an error occurs.                        22.3

               fputc               W rite C h a ra c te r to F ile                                                         <s t d i o . h >
                                   in t     fp u tc (in t       c,     F IL E    * s tre a m );
                                   W rites the character c to the stream pointed to by s t r e a m .
                  R etu rn s       c (the character written). If a write error occurs, f p u t c sets the stream ’s error
                                   indicator and returns EOF.                                                        22.4

               fputs               W rite S trin g to F ile                                                                < s t d i o . h>
                                   in t     fp u ts (c o n s t c h a r * r e s t r i c t s,
                                                      F IL E * r e s t r i c t s t r e a m ) ;
                                   W rites the string pointed to by s to the stream pointed to by s t r e a m .
                  R etu rn s       A nonnego ative value if successful. Returns EOF if a w rite error occurs.                           22.5
                                                       A p p e n d ix D                                                        763
                                                                             S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHG


 fp u   tw c     W rite W id e C h a ra c te r to F ile (C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA        < w c h a r . h> cbaZYXWVUTSRQPONML
                 w in t_ t     fp u tw c (w c h a r _ t c ,         F IL E     ★ s tr e a m );
                 W ide-character version of f p u t c .                                                                         25.5

 f p u tw s      W rite W id e S trin g to F ile (C 9 9 )                                                         < w c h a r . h>
                 in t     fp u tw s (c o n s t w ch a r_ t * r e s t r i c t                s,
                                     F IL E * r e s t r i c t s t r e a m ) ;
                 W ide-character version of f p u t s .                                                                         25.5

  fread          R e a d B lo c k f r o m F ile                                                                  < s td io .h >
                 s iz e _ _ t f r e a d ( v o i d * r e s t r i c t p t r , s i z e _ t s i z e ,
                                          s i z e _ t nm em b, F IL E * r e s t r i c t s t r e a m ) ;
                 Attempts to read nmemb elements, each s i z e bytes long, from the stream pointed
                 to by s t r e a m and store them in the array pointed to by p t r .
     R eturns    Number of elements actually read. This number will be less than nmemb if f r e a d
                 encounters end-of-file or a read error occurs. Returns zero if either nmemb or
                 s iz e is z e ro .                                                22.6

    free         F r e e M e m o r y B lo c k                                                                  < s td lib .h >
                 v o id    fre e (v o id          * p tr);
                 Releases the memory block pointed to by p t r . (If p t r is a null pointer, the call
                 has no effect.) The block must have been allocated by a call of c a l l o c , m a l l o c ,
                 o rre a llo c .                                                                       17.4

freopen          R e o p e n F ile                                                                               < s td io .h >
                 F IL E * f r e o p e n ( c o n s t c h a r * r e s t r i c t f i l e n a m e ,
                                          c o n s t c h a r * r e s t r i c t m ode,
                                          F IL E * r e s t r i c t s t r e a m ) ;
                 Closes the file associated with s t r e a m , then opens the file whose name is pointed
                 to by f i l e n a m e and associates it with s t r e a m . The m ode param eter has the
                 same meaning as in a call of f o p e n . C99 change: lf f i l e n a m e is a null pointer,
                 f r e o p e n attempts to change the stream ’s mode to that specified by m ode.
     R eturns    Value of s t r e a m if the operation succeeds. Returns a null pointer if the file can’t
                 be opened.                                                             22.2

  frexp          S p lit in to F ra c tio n a n d E x p o n e n t                                                   < m a th . h>
                 d o u b le f r e x p ( d o u b le v a lu e , i n t * e x p );
    fr e x p f   f l o a t f r e x p f ( f l o a t v a lu e , i n t * e x p );
    fr e x p l   lo n g d o u b le f r e x p l ( l o n g d o u b le v a lu e ,                   in t     * e x p );
                 Splits v a l u e into a fractional p a rt/a n d an exponent n in such a way that
                 v a l u e = / x 2"
764      A p p e n d ix D
      ZYXWVUTSRQPONMLKJIHGFEDCBAS ta n d a r d L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                       < f < 1 o r / = 0. Stores n in the object pointed to by
                                   / i s normalized so that either 0.5 cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    exp.
                   R etu rn s      f , the fractional part o f v a l u e .                                                                       23.3

              fscanf                F o r m a t t e d F ile R e a d                                                                   < s td io .h >
                                   in t     f s c a n f (F IL E * r e s t r i c t s t r e a m ,
                                                         c o n s t c h a r * r e s t r i c t fo rm a t,                    ...) ;
                                   Reads input items from the stream pointed to by s t r e a m . The string pointed to by
                                   f o r m a t specifies the format of the items to be read. The argum ents that follow
                                   f o r m a t point to objects in which the items are to be stored.
                   R eturns        Num ber of input items successfully read and stored. Returns EOF if an input fail­
                                   ure occurs before any items can be read.                          22.3

                fsOGk.             F ile S e e k                                                                                      < s td io .h >
                                   in t     fse e k (F IL E         * s tre a m ,       lo n g     in t     o ffs e t,     in t     w h e n c e );
                                   Changes the file position indicator for the stream pointed to by s t r e a m . If
                                   w h e n c e is SEEK_SET, the new position is the beginning of the file plus o f f s e t
                                   bytes. If w h e n c e is SEEK__CUR, the new position is the current position plus
                                   o f f s e t bytes. If w h e n c e is SEEK_END, the new position is the end of the file
                                   plus o f f s e t bytes. The value of o f f s e t may be negative. For text streams,
                                   either o f f s e t must be zero or w h e n c e must be SEEK_SET and o f f s e t a
                                   value obtained by a previous call of f t e l l . For binary streams, f s e e k may not
                                   support calls in which w h e n c e is SEEK_END.
                   R etu rn s      Zero if the operation is successful, nonzero otherwise.                                                       22.7

          fsetpos                  S e t F ile P o s it io n                                                                          < s td io .h >
                                   in t     fs e tp o s (F IL E          * s tre a m ,       const        fp o s_ t     * p o s);
                                   Sets the file position indicator for the stream pointed to by s t r e a m according to
                                   the value pointed to by p o s (obtained from a previous call of f g e t p o s ) .
                   R etu rn s      Zero if successful, h' the call fails, returns a nonzero value and stores an im plem en­
                                   tation-defined positive value in e r r n o .                             22.7

                fte 11             D e te r m in e F ile P o s itio n                                                                <s t d i o . h >
                                   lo n g     in t     fte ll(F IL E           * s tre a m );
                   R etu rn s      Current file position indicator for the stream pointed to by s t r e a m . If the call
                                   fails, returns - l L and stores an im plem entation-defined positive value in e r r n o .
                                                                                                                        22.7

                f w   i d e        G e t a n d S e t S tr e a m O r ie n ta tio n (C 9 9 )                                            < w c h a r . h>
                                   in t     fw id e (F IL E         ^ s tr e a m ,      in t     m o d e );
                                   Determ ines the current orientation of a stream and, if desired, attempts to set its
                                   orientation. If m ode is greater than zero, f w i d e tries to make the stream wide-
                                   oriented if it has no orientation. If m o d e is less than zero, it tries to make the
                                                           A p p e n d ix D                                                       7 6 5 onmlkjihgfedcbaZYXWV
                                                                              S ta n d a r d L ib r a r y F u n c tio n s hgfedcbaZYXWVUTSRQPONMLKJIHGF


                     stream byte-oriented if it has no orientation. If m ode is zero, the orientation is not
                     chane<^ed.
      R e tu rn s    A positive value ifth e stream has wide orientation after the call, a negative value if
                     it has byte orientation, or zero ifit has no orientation. cbaZYXWVUTSRQPONMLKJIHGFEDCBA 25.5

fw p r in tf         W id e -C h a ra c te r F o rm a tt e d F ile W rite (C 9 9 )                                   < w c h a r . h>
                     in t    fw p r in tf( F I L E * r e s t r i c t s tr e a m ,
                                            c o n s t w char_t * r e s t r i c t                  fo r m a t,        ...) ;
                     W ide-character version of f p r i n t f .                                                                    25.5 kjihgfedcbaZYXWVU

   fwrite            W rite B lo c k to F ile                                                                      < s t d i o . h>
                     s iz e _ _ t f w r i t e ( c o n s t v o i d * r e s t r i c t p t r , s i z e _ t s i z e ,
                                                 s i z e _ _ t nm em b, F IL E * r e s t r i c t s t r e a m ) ;
                     Writes nmemb elements, each s i z e bytes long, from the array pointed to by p t r
                     to the stream pointed to by s t r e a m .
      R e tu rn s    Num ber of elements actually written. This number will be less than nmemb if a
                     write error occurs. In C99. returns zero if either nmemb or s i z e is zero. 22.6

 fw s c a n f        W id e -C h a ra c te r F o rm a tt e d F ile R e a d (C 9 9 )                                 < w c h a r . h>
                     in t    fw s c a n f(F IL E * r e s t r i c t s tr e a m ,
                                           c o n s t w char_t * r e s t r i c t                 fo r m a t,        ...) ;
                     W ide-character version of f s c a n f .                                                                      25.5

      getc           R e a d C h a ra c te r fro m F ile                                                            < s t d i o . h>
                     in t   g e tc (F IL E       * s tre a m );
                     Reads a character from the stream pointed to by s t r e a m . Note: g e t c is normally
                     implemented as a macro; it may evaluate s t r e a m more than once.
      R e tu rn s    Character read from the stream. I f g e t c encounters the end of the stream, il sets
                     the stream ’s end-of-file indicatorand returns EOF. If a read error occurs, g e t c sets
                     the stream ’s error indicator and returns EOF.                                      22.4

 getchar             R e a d C h a ra c te r                                                                        < s t d i o . h>
                     in t   g e tc h a r(v o id );
                     Reads a character from the s t d i n stream. Note: g e t c h a r is normally imple­
                     mented as a macro.
      R e tu r n s   Character read from the stream. I f g e t c h a r encounters the end of the stream, it
                     sets the stream ’s end-of-file indicator and returns EOF. If a read error occurs,
                     g e t c h a r sets the stream ’s error indicator and returns EOF.             7.3, 22.4

  getenv             G e t E n v iro n m e n t S tr in g                                                          < s t d l i b . h>
                     char      * g e te n v (c o n s t      c h a r * n a m e );
                     Searches the operating system ’s environment list to see if any string matches the
                     one pointed to by nam e.
7 6 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D      S ta n d a r d L ib r a r y F u n c tio n s


                                       A pointer to the string associated with the matching name. Returns a null pointer if
                      R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     no match is found. cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                             26.2 kjihgfedc

                     gets            R e a d S tr in g                                                                < s t d i o . h>
                                     c h a r * g e ts (c h a r * s);
                                     Reads characters from the s t d i n stream and stores them in the array pointed to
                                     by s. Reading stops at the first new-line character (which is discarded) or at end-
                                     of-file. g e t s appends a null character to the string.
                      R e tu rn s    s (a pointer to the array in which the input is stored). Returns a null pointer if a
                                     read error occurs or g e t s encounters the end of the stream before it has stored any
                                     characters.                                                                   13.3,22.5 PONMLKJIH

                   getwc             R e a d W id e C h a r a c te r fro m F ile (C 9 9 )                             < w c h a r . h>
                                      w in t_ _ t g e t w c ( F I L E      * s tre a m );
                                     Wide-character version of g e t c .                                                          25.5

          getwchar                   R e a d W id e C h a r a c te r (C 9 9 )                                         < w c h a r . h>
                                      w in t_ t g e tw c h a r (v o id );
                                     Wide-character version of g e t c h a r .                                                    25.5

                gmtime                C o n v e rt C a le n d a r T im e to B ro k e n -D o w n U T C T im e            < t i m e . h>
                                     s tru c t      tm * g m t i m e ( c o n s t t i m e _ t       * tim e r);
                      R e tu rn s    A pointer to a structure containing a broken-down UTC time equivalent to the cal­
                                     endar time pointed to by t i m e r . Returns a null pointer if the calendar time can’t
                                     be converted to UTC.                                                              26.3

                   hypot              H y p o te n u s e (C 9 9 )                                                       < m a t h . h>
                                      d o u b le h y p o t (d o u b le x , d o u b le y ) ;
                     h y p o tf       flo a t h y p o tf(flo a t x, flo a t y );
                     h y p o tl       lo n g d o u b le h y p o tl (lo n g d o u b le x , lo n g d o u b le y ) ;
                      R e tu rn s    J x 2 4- y 2 (the hypotenuse of a right triangle with legs x and y). A range error may
                                     occur.                                                                             23.4

                   ilogb              U n b ia s e d E x p o n e n t (C 9 9 )                                          < m a t h . h>
                                      in t    ilo g b (d o u b le x ) ;
                     ilo g b f        in t    ilo g b f(flo a t x );
                     ilo g b l        in t    i l o g b l ( l o n g d o u b le x ) ;
                      R e tu rn s    Exponent of x as a signed integer; equivalent to calling the corresponding l o g b
                                     function and casting the returned value to type i n t . Returns FP_ILOGBO i f x is
                                     zero. INT_MAX if x is infinite, and FP_ILOGBNAN i f x is a NaN; a domain error
                                     or range error may occur in these cases.                                      23.4

             imaxabs                  G re a te s t-W id th ln te g e r A b s o lu te V a lu e (C 9 9 )          < i n t t y p e s . h>
                                      i n t m a x _ t im a x a b s ( in tm a x _ t j ) ;
                                                            A p p e n d ix D                                                         767
                                                                                 S t a n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONML


                       Absolute value of j . The behavior is undefined if the absolute value of j
     R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                                                     can’t be
                   represented.PONMLKJIHGFEDCBA                                                                                    27.2
  imaxdiv          G r e a te s t- W id th I n t e g e r D iv is io n (C 9 9 )                                  < inttypes.h>
                   imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
     R e tu rn s   A structure of type i m a x d i v _ t containing members named q u o t (the quotient
                   when n u m e r is divided by denom ) and re m (the remainder). The behavior is
                   undefined if either part of the result can’t be represented.                    27.2
  isalnum          T e s t f o r A lp h a n u m e r ic                                                                 <ctype.h>
                   int isalnum(int c);
     R e tu rn s   A nonzero value if c is alphanumeric and zero otherwise, (c is alphanumeric if
                   e i t h e r i s a l p h a ( c ) o r i s d i g i t ( c ) istrue.)          23.5
  isalpha          T e s t f o r A lp h a b e tic                                                                     <ctype.h>
                   int isalpha(int c);
     R e tu rn s   A nonzero value if c is alphabetic and zero otherwise. In the "C" locale, c is
                   a lp h a b e tic if e ith e r is lo w e r ( c ) o r i s u p p e r ( c ) istrue. 23.5
  isblank          T e s t f o r B la n k (C 9 9 )                                                                   <ctype.h>
                   int isblank(int c);
     R e tu rn s   A nonzero value if c is a blank character that is used to separate words within a
                   line of text. In the "C" locale, the blank characters are space ( ' ') and horizontal
                   t a b ( '\ t ') .                                                                23.5
 iscntrl           T e s t f o r C o n tr o l C h a r a c te r                                                        <ctype.h >
                   int iscntrl(int c);
     R e tu rn s   A nonzero value if c is a control character and zero otherwise.                                                   23.5
  isdigit          T e s t f o r D ig it                                                                              <c type.h >
                   int isdigit(int c);
     R e tu rn s   A nonzero value if c is a decimal digit and zero otherwise.                                                       23.5
 isfinite          T e s t f o r F in ite N u m b e r (C 9 9 )                                                           <math.h>
                   int isfinite(real-floating x);                                                                                macro
     R e tu rn s   A nonzero value i f x is finite (zero, subnormal, or normal, but not infinite or NaN)
                   and zero otherwise.                                                               23.4
  isgraph          T e s t f o r G r a p h ic a l C h a r a c te r                                                     <ctype.h>
                   int isgraph(int c);
     R e tu rn s   A nonzero value if c is a printing character (except a space) and zero otherwise.
                                                                                                   23.5
isgreater          T e s t f o r G r e a te r T h a n (C 9 9 )                                                           <math.h>
                   int isgreater(real-floating x, real-Jloaiing y);                                                              macro
768       A p p e n d ix D   S ta n d a rd
      ZYXWVUTSRQPONMLKJIHGFEDCBA             L ib r a r y F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                 (x) > ( y ) . Unlike the > operator, i s g r e a t e r doesn’t raise the invalid floating­
                  Peturns onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                               point exception if one or both of the arguments is a NaN.                               23.4

is g r e a te r e q u a l       T e s t fo r G r e a te r T h a n o r E q u a l (C 9 9 )                                     < m a t h . h>
                                in t    i s g r e a t e r e q u a l (real-floating x ,              real-floating y ) ;             macro
                  Peturns        (x) >= ( y ) . Unlike the >= operator, i s g r e a t e r e q u a l doesn’t raise the
                                invalid floating-point exception if one or both of the arguments is a NaN.       23.4 PONMLK

               isinf            T e s t fo r In fin ity (C 9 9 )                                                            <m a t h . h >
                                in t    i s i n f (real-floating x ) ;                                                              macro
                  Returns       A nonzero value if x is infinity (positive or negative) and zero otherwise.                            23.4

             isless             T e s t fo r L e s s T h a n (C 9 9 )                                                        < m a t h . h>
                                in t    i s l e s s (real-floating x ,             real-floating y ) ;                              macro
                  Peturns        (x) < ( y ) . Unlike the < operator, i s l e s s doesn’t raise the invalid floating­
                                point exception if one or both of the arguments is a NaN.                        23.4

islessequal                     T e s t fo r L e s s T h a n o r E q u a l (C 9 9 )                                          < m a t h . h>
                                in t     i s l e s s e q u a l (real-floating x ,            real-floating y ) ;                    macro
                  Peturns        (x) <= ( y ) . Unlike the <= operator, i s l e s s e q u a l doesn’t raise the invalid
                                floating-point exception if one or both of the arguments is a NaN.                 23.4

is le s s g r e a te r          T e s t fo r L e s s T h a n o r G r e a te r T h a n (C 9 9 )                               < m a t h . h>
                                in t     is le s s g r e a te r (r e a l-flo a tin g x t          real-floating y ) ;               macro
                  Peturns        (x) < (y) | | (x) > ( y ) . U n l i k e t h i s e x p r e s s i o n , i s l e s s g r e a t e r d o e s n 't
                                raise the invalid floating-point exception if one or both of the arguments is a NaN;
                                also, x and y are evaluated only once.                                                                 23.4

          islower               T e s t fo r L o w e r - C a s e L e t t e r                                               < c t y p e . h>
                                in t     is lo w e r(in t           c );
                  Returns       A nonzero value if c is a lower-case letter and zero otherwise.                                        23.5

               isnan            T e s t fo r N a N (C 9 9 )                                                                  < m a t h . h>
                                in t     is n a n (r e a l-flo a tin g x ) ;                                                        macro
                  Returns       A nonzero value if x is a NaN value and zero otherwise.                                                23.4

       isnormal                 T e s t fo r N o r m a l N u m b e r (C 9 9 )                                                < m a t h . h>
                                in t    i s n o r m a l (real-floating x ) ;                                                        macro
                  Returns       A nonzero value if x has a normal value (not zero, subnormal, infinite, or NaN)
                                and zero otherwise.                                                         23.4

          isprint               T e s t f o r P r in tin g C h a r a c t e r                                               <ctype.h>
                                int isprint(int c);
                                                            A p p e n d ix D                                                       769
                                                                                S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPON
                                                                                                                                          cbaZYXWVUT




       R etu rns onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                       A nonzero value if c is a printing character (including a space) and zero otherwise.
                                                                                                                                    23.5

    ispunc t       T e s t fo r P u n c tu a tio n C h a r a c te r                                                   < c t y p e . h>
                   in t    is p u n c t(in t         c );
       R etu rns   A nonzero value if c is a punctuation character and zero otherwise. All printing
                   characters except the space ( ' ') and the alphanumeric characters are considered
                   punctuation. C99 change: In the "C" locale, all printing characters except those
                   for which i s s p a c e or i s a l n u m is true are considered punctuation.  23.5

    isspace        T e s t fo r W h ite -S p a c e C h a r a c te r                                                  < c t y p e . h>
                   in t    is s p a c e (in t        c );
       R eturns    A nonzero value if c is a white-space character and zero otherwise. In the "C"
                   locale, the white-space characters are space ( ' ' ), form feed ( ’ \ f ') , new-line
                   ( ' \ n ') , carriage return ( ' \ r ’ ), horizontal tab ( ' \ t ' ). and vertical tab ( ' \ v ' ).
                                                                                                                  23.5 PONMLKJIHG

isunordered        T e s t fo r U n o rd e re d (C 9 9 )                                                                < m a th .h >
                   in t    is u n o r d e r e d (r e a l-flo a tin g x ,       real-floating y ) ;                              macro
       R eturns    1 if x and y are unordered (at least one is a NaN) and 0 otherwise.                                             23.4

    isupper        T e s t fo r U p p e r-C a s e L e tte r                                                          < c t y p e . h>
                   in t    is u p p e r(in t c );
       R eturns    A nonzero vahie if c is an upper-case letter and zero otherwise.                                                23.5

   iswalnum        T e s t fo r A lp h a n u m e r ic W id e C h a r a c te r (C 9 9 )                             < w c t y p e . h>
                   in t    is w a ln u m (w in t_ t           w c );
       R etu rns   A nonzero value ifw c is alphanumeric and zero otherwise, (wc is alphanumeric if
                   e i t h e r i s w a l p h a ( w c ) o r i s w d i g i t ( w c ) istrue.) 25.6

   iswalpha        T e s t f o r A lp h a b e t ic W id e C h a r a c te r (C 9 9 )                                < w c t y p e . h>
                   in t    is w a lp h a ( w in t_ t           w c) ;
       R eturns    A nonzero value if wc is alphabetic and zero otherwise, (wc is alphabetic if
                   i s w u p p e r (wc) or i s w l o w e r (w c) is true. or ifw c is one o f a locale-specific
                   set of alphabetic wide characters for which none of i s w c n t r l . i s w d i g i t .
                   i s w p u n c t , or i s w s p a c e is true.)                               25.6

   iswblank        T e s t fo r B la n k W id e C h a r a c te r (C 9 9 )                                          < w c t y p e . h>
                   in t    is w b la n k (w in t_ t           w c );
       R etu rns   A nonzero value ifw c is a standard blank wide character or one of a locale-specific
                   sel of wide characters for which i s w s p a c e is true and that are used to separate
                   words within a line of text. In the ” C ” locale, i s w b l a n k returns true only for the
                   standard blank characters: space ( L ' ') and horizontal tab (L • \ t ’ ).             25.6
           A p p e n d ix D S ta n d a r d Library F u n ctio n s
770 cbaZYXWVUTSRQPONMLKJIHGFEDCBA


         i sw cn t r l          T est for C ontrol W ide C h a ra cter (C 99)                                     < w c t y p e . h>
                                in t   i s w c n t r l ( w in t_ _ t w c) ;
                   Returns      A nonzero value if wc is a control wide character and zero otherwise.                          25.6

        i SW C t y p e          T est T ype o f W ide C h a ra cter (C 99)                                        < w c t y p e . h>
                                in t   i s w c t y p e ( w i n t _ t w c,     w c ty p e _ t d e s c ) ;
                   Returns      A nonzero value if the wide character wc has the property described by d e s c .
                                ( d e s c must be a value returned by a call of w c ty p e ; the current setting of the
                                LC__CTYPE category must be the same during both calls.) Returns zero otherwise.
                                                                                                                   25.6

         i s w d ig i t         T est for Digit W id e C h a ra cte r (C 99)                                      < w c t y p e . h>
                                in t   is w d i g i t (w in t_ t    w c) ;
                   Returns      A nonzero value if wc corresponds to a decimal digit and zero otherwise.                       25.6

         i S w g ra p h         T est for G raphical W id e C h a ra c te r (C 99)                                < w c t y p e . h>
                                in t   is w g r a p h ( w in t_ t   w c) ;
                   Returns      A nonzero value if i s w p r i n t ( w c )          is true and i s w s p a c e ( w c )   is false.
                                Returns zero otherwise.                                                           25.6

         i s w lo w e r         T e st for L o w e r-C a se W ide C h a ra c te r (C 99)                          < w c t y p e . h>
                                in t   is w lo w e r (w in t_ t     w c );
                   Returns      A nonzero value if wc corresponds to a lower-case letter or is one of a locale-
                                specific set of wide characters for which none of i s w c n t r l , i s w d i g i t .
                                i s w p u n c t , or i s w s p a c e is true. Returns zero otherwise. 25.6

         i s w p r in t         T est for P rinting W ide C h a ra cter (C 99)                                    < w c t y p e . h>
                                in t   is w p r in t(w in t_ t      w c );
                   Returns      A nonzero value if wc is a printing wide character and zero otherwise.                         25.6

         i sw p u n c t         T est for P u n ctu a tio n W ide C h a ra cte r (C 99)                           < w c t y p e . h>
                                in t   is w p u n c t(w in t_ t     w c );
                   Returns      A nonzero value ifw c is a printing wide character that is one of a locale-specific
                                set ofpunctuation wide characters for which neither i s w s p a c e nor is w a ln u m
                                is true. Returns zero otherwise.                                     25.6

         i sw sp a c e          T est for W h ite -S p a c e W ide C h a ra cte r (C 99)                          < w c t y p e . h>
                                in t   is w s p a c e (w in t_ t    w c) ;
                   Returns      A nonzero value if wc is one of a locale-specific set of white-space wide characters
                                for which none of is w a ln u m , i s w g r a p h . or i s w p u n c t is true. Returns zero
                                otherwise.                                                                    25.6
                                                             A p p e n d ix D                                                         771
                                                                                   S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONML


 is w u p p e r                                                                                                        < w c ty p e . h>
                      T e s t fo r U p p e r- C a s e W id e C h a r a c te r ( C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                              i s w u p p e r ( w i n t _ t w c );
                      i n t cbaZYXWVUTSRQPONMLKJIHGFEDCBA
          Returns     A nonzero value if wc corresponds to an upper-case letter or is one of a locale-
                      specific set of wide characters for which none of i s w c n t r l , i s w d i g i t ,
                      i s w p u n c t , or i s w s p a c e is true. Returns zero otherwise. 25.6
i s w x d ig i t      T e s t fo r H e x a d e c im a l- D ig it W id e C h a r a c te r ( C 9 9 )                    < w c ty p e . h>
                      i n t i s w x d i g i t ( w i n t _ t w c );
          Returns     A nonzero value if wc corresponds to a hexadecimal digit (0 -9 , a - f , A -F ) and
                               zero otherwise.                                                        25.6
 i sxdig i t          T e s t fo r H e x a d e c im a l D ig it                                                        <c t y p e . h >
                      in t is x d ig it( in t c );
          Returns     A nonzero value if c is a hexadecimal digit ( 0 - 9 , a - f , A -F) and zero otherwise.
                                                                                                           23.5
         labs         L o n g ln t e g e r A b s o lu t e V a lu e                                                    < s t d l i b . h>
                      lo n g i n t l a b s ( l o n g i n t j ) ;
          Returns     Absolute value of j . The behavior is undefined if the absolute value of j ca ift be
                                represented.                                                          26.2
       1dexp          C om bin e Fraction a n d E xp o n en t                                                             < m a th . h>
                      d o u b le l d e x p ( d o u b l e x , i n t e x p ) ;
        ld e x p f    flo a t ld e x p f( flo a t x , in t e x p );
        ld e x p l    lo n g d o u b le l d e x p l ( l o n g d o u b le x ,                  in t    e x p );
          Returns     x x 2 e x p . A range error may occur.                                                                          23.3
         ldiv         L o n g In te g e r D iv is io n                                                                < s t d l i b . h>
                      l d i v _ t l d i v ( l o n g i n t n u m e r,             lo n g i n t d en o m );
          Returns     An l d i v _ t structure containing members named q u o t (the quotient when
                      n u m e r is divided by d en o m ) and re m (the remainder). The behavior is undefined
                                   if either part of the result c a ift be represented.                  26.2
     lg a m m a       L o g a rith m o f G a m m a F u n c tio n (C 9 9 )                                                 < m a th . h>
                      d o u b le lg a m m a ( d o u b le x ) ;
       lg a m n a f   f l o a t lg a m m a f(flo a t x ) ;
       lg a m m a l   lo n g d o u b le lg a m m a l(lo n g d o u b le x ) ;
          Returns     ln(IF(x)l), where T is the gamma function. A range error occurs if x is too large
                                  and may occur if x is a negative integer or zero.                23.4
       lla b s        L o n g L o n g ln t e g e r A b s o lu t e V a lu e (C 9 9 )                                   < s td lib .h >
                      lo n g lo n g i n t          ll a b s ( l o n g lo n g i n t j ) ;
7 7 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D    S ta n d a r d L ib ra ry F u n c tio n s

                                      Absolute value of j . The behavior is undefined if the absolute value of j
                     R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                                                         can’t be
                                   represented.                                                                                         2 6 . 2 PONMLK


                  lldiv            L o n g L o n g In te g e r D iv is io n (C 9 9 )                                      < s t d l i b . h> cbaZYXW
                                   lld iv _ t       lld iv (lo n g         lo n g i n t num er,
                                                             lo n g        lo n g i n t denom ) ;
                     R e tu rn s   An l l d i v _ t structure containing members named q u o t (the quotient when
                                   n u m e r is divided by denom ) and rem (the remainder). The behavior is undefined
                                   if either part of the result can’t be represented.                             2 6 .2


               llrint              R o u n d to L o n g L o n g In te g e r U s in g C u rre n t D ire c tio n (C 9 9 )       < m a t h . h>
                                   lo n g     lo n g    in t     llr in t( d o u b le     x );
                  llr in tf        lo n g lo n g i n t           llr in tf( flo a t x );
                  llr in tl        lo n g lo n g i n t           l l r i n t l (lo n g d o u b le x ) ;
                     R e tu rn s   x rounded to the nearest inte< g_.er usingG the current rounding^* direction. If the
                                   rounded value is outside the range of the l o n g l o n g i n t type, the result is
                                   unspecified and a domain or range error may occur.                              2 3 .4


            llround                 R o u n d to N e a re s t L o n g L o n g In te g e r (C 9 9 )                            < m a t h . h>
                                    lo n g lo n g       in t     llr o u n d (d o u b le x ) ;
                llr o u n d f       lo n g lo n g       in t     llr o u n d f(flo a t x );
                llr o u n d l       lo n g    lo n g    in t     llr o u n d l( lo n g     d o u b le   x );

                     R e tu rn s   x rounded to the nearest integer, with halfway cases rounded away from zero. If
                                   the rounded value is outside the range o fth e l o n g l o n g i n t type, the result is
                                   unspecified and a domain or range error may occur.                                 2 3 .4 kjihgfe


    localeconv                      G e t L o c a le C o n v e n tio n s                                                  < l o c a l e . h>
                                   s tru c t      lc o n v * lo c a le c o n v ( v o id ) ;
                     R e tu rn s   A pointer to a structure containing information about the current locale.                            2 5 .1


       localtime                    C o n v e rt C a le n d a r T im e to B ro k e n -D o w n L o c a l T im e                < t i m e . h>
                                    s tru c t     tm * l o c a l t i m e ( c o n s t     tim e _ t * tim e r ) ;
                     R e tu rn s   A pointer to a structure containing a broken-down local time equivalent to the cal­
                                   endar time pointed to by t i m e r . Returns a null pointer if the calendar time can’t
                                   be converted to local lime.                                                       2 6 .3


                       log          N a tu ra l L o g a rith m                                                                < m a t h . h>
                                   d o u b le lo g ( d o u b le x ) ;
                        lo g f     flo a t lo g f(flo a t x );
                        lo g l     lo n g d o u b le l o g l ( l o n g         d o u b le x ) ;
                     R e tu rn s   Logc^arithm of x lo the base e . A domain error occurs i f x is ^*n*egative. A r^a*nge error
                                   may occur i f x is zero.                                                                2 3 .3
                                                         A p p e n d ix D                                                          773
                                                                                S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLK


  loglO           C o m m o n L o g a rith m
              cbaZYXWVUTSRQPONMLKJIHGFEDCBA                                                                            <math.h>
                  double loglO(double x);
  lo g lO f       flo a t lo g lO f(flo a t x );
  lo g l0 1       lo n g d o u b le lo g l0 1 ( lo n g               d o u b le     x ) ; onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
   R etu rns      Logarithm of x to the base 10. A domain error occurs if x is negative. A range
                  error may occur if x is zero.                                              23.3 PONMLKJIHGFEDC

  loglp           N a tu ra l L o g a rith m o f 1 P lu s A r g u m e n t (C 9 9 )                                      <math.h>
                  d o u b le lo g lp ( d o u b le x ) ;
  lo g lp f       flo a t lo g lp f(flo a t x );
  1o g lp l       lo n g d o u b le l o g l p l (lo n g d o u b le x ) ;
   R eturns       Lo ogarithm of I + x to the base e. A domain error occurs if x is less d*ian - l . A
                  range error may occur if x is equal to - l.                                     23.4

   log2           B a s e - 2 L o g a rith m (C 9 9 )                                                                   <math.h>
                  d o u b le lo g 2 ( d o u b le x ) ;
   lo g 2 f       flo a t lo g 2 f(flo a t x );
   lo g 2 1       lo n g d o u b le lo g 2 1 ( lo n g              d o u b le     x );
   R etu rns      Logarithm o f x to the base 2. A domain error occurs i f x is negative. A range error
                  may occur if x is zero.                                                         23.4

   logb           R a d ix - In d e p e n d e n t E x p o n e n t (C 9 9 )                                             <math.h>
                  d o u b le lo g b ( d o u b le x ) ;
   lo g b f       flo a t lo g b f(flo a t x );
   lo g b l       lo n g d o u b le lo g b l( lo n g               d o u b le x ) ;
   R eturns       log/lxl). where r is the radix of floating-point arithmetic (defined by the macro
                  FLT_RADIX, which typically has the value 2). A domain error or range error may
                  occur if x is zero.                                                          23.4

longjmp           N o n lo c a l J u m p                                                                           <se tjm p .h>
                  void longjmp(jmp_buf env, int val);
                  Restores the environment stored in e n v and returns from the call of s e t j m p that
                  originally saved e n v . l f v a l is nonzero, it will be s e t j m p \ s return value; i f v a l
                  is 0, s e t j m p returns l .                                                               24.4

  lrint            R o u n d to L o n g In te g e r U sin g C u rre n t D irectio n (C 9 9 )                            <math.h>
                   lo n g    in t     lr in t(d o u b le x );
  lr in tf         lo n g    in t     lr in tf( flo a t x );
  lr in tl         lo n g    in t     l r i n t l (lo n g d o u b le x ) ;
   R eturns       x rounded to the nearest integer using the current rounding direction. Tf the
                  rounded value is outside the range o fth e l o n g i n t type, the result is unspecified
                  and a domain or range error may occur.                                              23.4
             A p p e n d ix D S t a n d a r d L ib ra ry F u n c tio n s PONMLKJIHGFEDCBA
7 7 4 cbaZYXWVUTSRQPONMLKJIHGFEDCBA


               lround               R o u n d to N e a r e s t L o n g In te g e r (C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA < m a t h . h>
                                    lo n g    in t     lr o u n d (d o u b le x ) ;
                  lr o u n d f      lo n g    in t     lr o u n d f(flo a t x );
                  lr o u n d l      lo n g    in t     l r o u n d l ( lo n g d o u b le       x ) ; ZYXWVUTSRQPONMLKJIHGFEDCBA
                      R e tu rn s   x rounded to the nearest integer, with halfway cases rounded away from zero. If
                                    the rounded value is outside the range of the l o n g i n t type, the result is unspeci­
                                    fied and a domain or range error may occur.                                         23.4 kjihgfe

               malloc               A llo c a te M e m o r y B lo c k                                                             < s t d l i b . h>
                                    v o id     * m a llo c (s iz e _ _ t s i z e ) ;
                                    Allocates a block of memory with s i z e bytes. The block is not cleared.
                      R e tu rn s   A pointer to the beginning of the block. Returns a null pointer if a block o f the
                                    requested size can’t be allocated.                                            17.2

                  mblen             L e n g th o f M u ltib y te C h a r a c te r                                              < s t d l i b . h>
                                    in t     m b le n (c o n s t c h a r * s ,         s iz e _ t n );
                      R e tu rn s   If s is a null pointer, returns a nonzero or zero value, depending on whether or not
                                    multibyte characters have state-dependent encodings, l.f s points to a null charac­
                                    ter. returns zero. Otherw ise, returns the number of bytes in Lhe multibyte character
                                    pointed to by s; returns -1 if the next n or fewer bytes don’t form a valid multibyte
                                    character.                                                                       25.2

               mbrlen               L e n g th o f M u ltib y te C h a r a c te r - R e s ta r ta b le (C 9 9 )                    < w c h a r . h>
                                    s iz e _ t    m b r le n (c o n s t c h a r * r e s t r i c t s , s i z e _ t                  n,
                                                              m b s ta te _ t * r e s t r i c t p s ) ;
                                    Determines the number o f bytes in the array pointed to by s that are required to
                                    com plete a multibyte character, p s should point to an object o fty p e m b s t a t e _ t
                                    that contains the current conversion state. A call o f m b r l e n is equivalent to

                                    mbrtowc(NULL, s, n, ps)

                                    except that i f p s is a null pointer, the address o fa n internal object is used instead.
                      R e tu rn s   S ee m b r t o w c .                                                                                       25.5

            mbrtowc                 C o n v e r t M u ltib y te C h a r a c te r to W id e C h a r a c te r - R e s ta r ta b le < w c h a r . h>
                                    (C 9 9 )
                                    s iz e _ t     m b r to w c (w c h a r _ t * r e s t r i c t p w c ,
                                                                 co n st char * r e s tr ic t s, s iz e _ t                          n,
                                                                 m b s ta te _ t * r e s t r i c t p s ) ;
                                    If s is a null pointer, a call o f m b r to w c is equivalent to

                                    mbrtowc(NULL,             ”", 1, ps)

                                    Otherwise, m b r to w c exam ines up to n bytes in the array pointed to by s to see if
                                                 A p p e n d ix D      S ta n d a r d Library F u n c tio n s hgfedcbaZYXWVUTSRQPONMLK
                                                                                                                      7 7 5 onmlkjihgfedcbaZ


                they complete a valid multibyte character, If so, the multibyte character is con­
                verted into a wide character. Lfpwc isn’t a null pointer, the wide character is stored
                in the object pointed to by pw c. The value o f p s should be a pointer to an object of
                type m b s t a t e _ t that contains the current conversion state. If p s is a null pointer,
                m b rto w c uses an internal object to store the conversion state. If the result of the
                conversion is the null wide character, the m b s t a t e _ t object used during the call
                is left in the initial conversion state.
     R eturns   0 if the conversion produces a null wide character. Returns a number between I
                and n if the conversion produces a wide character other than null, where the value
                returned is the number of bytes used to complete the multibyte character. Returns
                 ( s i z e _ t ) ( - 2 ) if the n bytes pointed to by s w eren’t enough to complete a
                multibyte character. Returns ( s i z e _ t ) ( - 1 ) and stores EiLSEQ in e r r n o ifan
                encoding error occurs.                                                  25.5 PONMLKJIHGFEDCBA
 mbsini t       T est for Initial C o n v e rsio n S ta te (C 99)                                           < w c h a r . h>
                in t   m b s in it(c o n s t    m b s ta te _ t       * p s);
     Returns    A nonzero value i f p s is a null pointer or it points to an m b s t a t e _ t object that
                describes an initial conversion state: otherwise, returns zero.           25.5
mbsrtowcs       C o n v e rt M ultib yte S trin g to W id e S trin g - R e s ta r ta b le (C 99)            < w c h a r . h>
                s iz e _ t   m b s r to w c s (w c h a r _ t * r e s t r i c t d s t ,
                                               c o n s t c h a r ** r e s t r i c t s r c ,
                                               s i z e _ t le n , m b s ta te _ t * r e s t r i c t p s ) ;
                Converts a sequence of multibyte characters from the array indirectly pointed to
                by s r c into a sequence ofcorresponding wide characters, p s should point to an
                object of type m b s t a t e _ t that contains the current conversion state. Ifth e argu­
                ment corresponding to p s is a null pointer, m b s r t o w c s uses an internal object to
                store the conversion state. If d s t isn’t a null pointer, the converted characters are
                stored in the array that it points lo. Conversion continues up to and including a ter­
                minating null character, which is also stored. Conversion stops earUer if a
                sequence of bytes is encountered that doesn’t form a valid multibyte character
                or— if d s t isn’t a null pointer— when l e n wide characters have been stored in
                the array. If d s t isn’t a null pointer, the object pointed to by s r c is assigned
                either a null pointer (if a terminating null character was reached) or the address
                just past the last multibyte character converted (if any). If the conversion ends at a
                null character and if d s t isn't a null pointer, the resulting state is the initial con­
                version state.
     Returns    Number of multibyte characters successfully converted, not including any termi­
                nating null character. Returns ( s i z e _ t ) ( - 1 ) and stores EILSEQ in e r r n o if
                an invalid multibyte character is encountered.                         25.5 kjihgfedcbaZYXWVUTSRQPONMLKJ
mb stowc s      C o n v e rt M ultibyte S trin g to W id e S trin g                                       < s t d l i b . h>
                s i z e _ t m b s to w c s (w c h a r_ t * r e s t r i c t p w cs,
                                            const char * r e s tr ic t s,                        s iz e     t n );
7 7 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D      S t a n d a r d L ib r a r y F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                                       Converts the sequence o fm u ltib y te characters pointed to by s into a sequence of
                                       wide characters, storing at most n wide characters in the array pointed to by p w c s .
                                       Conversion ends if a null character is encountered; it is converted into a null wide
                                       character.
                       R e tu rn s     Number o fa rra y elements modified, not including the null wide character, ifany.
                                                                                                                               25.2 kjihgfedc
                                       Returns ( s i z e _ t ) ( - 1 ) if an invalid multibyte character is encountered. cbaZYXWVUTSRQPONMLKJ

                mbtowc                 C o n v e r t M u ltib y te C h a r a c te r to W id e C h a r a c te r                          < s t d l i b . h>
                                       in t    m b to w c (w c h a r_ t * r e s t r i c t pw c,
                                                           const ch ar * r e s tr ic t s,                            s iz e _ t n ) ;
                                      If s isn’t a null pointer, converts the multibyte character pointed to by s into a wide
                                      character; at most n bytes will be examined, If the multibyte character is valid and
                                      pw c isn’t a null pointer, stores the vakie of the wide character in the object pointed
                                      to by pw c.
                       R e tu rn s     If s is a null pointer, returns a nonzero or zero value, depending on whether or not
                                       multibyte characters have state-dependent encodings. Lf s points to a null charac­
                                       ter, returns zero. Otherw ise, returns the num ber of bytes in the multibyte character
                                       pointed to by s; returns -1 if the next n or fewer bytes don’t form a valid multibyte
                                       character.                                                                        25.2

                memchr                 S e a rc h M e m o r y B lo c k f o r C h a r a c te r                                           < s t r i n g . h>
                                      v o id      * m e m c h r(c o n st v o id            *s,      in t    c,     s iz e _ t n );
                       R e tu rn s     A pointer to the first occurrence of the character c among the first n characters of
                                       the object pointed to by s . Returns a null pointer if c isn’t found.           23.6

                memcmp                 C o m p a re M e m o r y B lo c k s                                                              < s t r i n g . h>
                                       i n t m e m c m p (c o n st v o i d             * s l,    c o n s t v o id         * s2 ,   s iz e _ t n );
                       R e tu rn s     A negative, zero, or positive integer, depending on whether the first n characters of
                                       the object pointed to by s l are less than, equal to, or greater than the first n char­
                                       acters of the object pointed to by s 2 .                                           23.6

                memcpy                 C o p y M e m o r y B lo c k                                                                     <s t r i n g . h >
                                      v o id      * m e m c p y ( v o id * r e s t r i c t s l ,
                                                                c o n s t v o id * r e s t r i c t                 s2,     s iz e _ t     n );
                                       Copies n characters from the object pointed to by s 2 into the object pointed to by
                                       s l . The behavior is undefined if the objects overlap.
                       R e tu rn s     s l (a pointer to the destination).                                                                           23.6

             memmove                   C o p y M e m o r y B lo c k                                                                     <s t r i n g . h >
                                      v o id      * m e m m o v e (v o id       * s l,     c o n s t v o id        *s2,      s iz e _ t n );
                                       Copies n characters from the object pointed to by s 2 into the object pointed to by
                                       s l . Will work properly if the objects overlap.
                       R e tu rn s     s l (a pointer to the destination).                                                                           23.6
                                                                A p p e n d ix D                                                          777
                                                                                       S t a n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPON



     mems e t            In itia liz e M e m o r y B lo c k onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                    < s t r i n g . h>
                         v o i d * m e m s e t(v o id * s,              in t c,        s iz e _ t n );
                         Stores c in each o f(h e first n characters of the object pointed to by s .
           R e tu rn s   s (a pointer to the object).                                                                                      23.6

     mk time             C o n v e r t B r o k e n - D o w n L o c a l T im e to C a le n d a r T im e                        <t i m e. h >
                         tim e _ t m k tim e (s tru c t               tm * t i m e p t r ) ;
                         Converts a broken-down local time (stored in the structure pointed to by t i m e -
                         p t r ) into a calendar time. The m em bers of the structure aren’t required to be
                         within their legal ranges; also, the values of tm _ w d a y (day of the week) and
                         t m _ y d a y (day of the year) are ignored, m k tim e stores values in tm _ w d a y and
                         t m _ y d a y after adjusting the other mem bers to bring them into their proper
                         rangCzes.
           R e tu rn s   A calendar time corresponding to the structure pointed to by t i m e p t r . Returns
                                                                                                                                      26.3
                         ( t i m e _ t ) ( - 1 ) ifth e c a le n d a rtim e c a n ’tb e re p re se n te d . cbaZYXWVUTSRQPONMLKJIHGFEDCBA

          modf           S p lit in to I n te g e r a n d F ra c tio n a l P a rts                                             < m a t h . h>
                         d o u b le m o d f(d o u b le v a lu e ,               d o u b le      * ip tr);
           m o d ff      f l o a t m o d ff( flo a t v a lu e , f l o a t * i p tr ) ;
           m o d fl      lo n g d o u b le m o d fl( lo n g d o u b le v a lu e , lo n g d o u b le                               * ip tr );
                         Splits v a l u e into integer and fractional parts; stores the integer part in the object
                         pointed to by i p t r .
           R e tu rn s   Fractional part o f v a l u e .                                                                                   23.3

             nan         C re a te N a N ( C 9 9 )                                                                            < ma t h . h >
                         d o u b le n a n ( c o n s t c h a r * ta g p );
             nanf        f l o a t n a n f( c o n s t c h a r * ta g p );
             nanl        lo n g d o u b le n a n l( c o n s t c h a r * ta g p );
           R e tu rn s   A “quiet” NaN whose binary pattern is determ ined by the string pointed to by
                         t a g p . Returns zero ifq u iet NaNs arenT supported.                    23.4

n e a r b y in t         R o u n d to In te g r a l V a lu e U s in g C u r r e n t D ir e c tio n (C 9 9 )                   < m a t h . h>
                         d o u b le n e a r b y in t( d o u b le x ) ;
   n e a r b y in tf     flo a t n e a r b y in tf(flo a t x );
   n e a r b y in tl     lo n g d o u b le n e a r b y i n t l (lo n g               d o u b le     x );
           R e tu rn s   x rounded to an integer (in floating-point form al) using the current rounding direc­
                         tion. D oesn’t raise the inexcici floating-point exception.                      23.4

n e x ta fte r           N e x t N u m b e r A fte r (C 9 9 )                                                                  < m a th . h>
                         d o u b le n e x t a f t e r ( d o u b l e x , d o u b le y ) ;
   n e x ta fte r f      flo a t n e x ta fte r f(flo a t x, flo a t y );
   n e x ta fte r l      lo n g d o u b le n e x t a f t e r l ( l o n g d o u b le x ,                    lo n g     d o u b le y ) ;
7 7 8 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D    S ta n d a r d L ib r a r y F u n c tio n s


                                       Next representable value a fte rx in the direction o fy . Returns the v alu cju sl before
                      R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                     x if y < x or the valuejust after x if x < y. Returns y if x equals y. A range error
                                     may occur if the magnitude of x is the largest representable finite value and the
                                     result is infinite or not representable. cbaZYXWVUTSRQPONMLKJIHGFEDCBA          23.4

   n e x tto w a r d                 N e x t N u m b e r T o w a rd (C 9 9 )                                                    < m a t h . h>
                                     d o u b le n e x tto w a r d ( d o u b le x , lo n g d o u b le y ) ;
          n e x tto w a r d f        f l o a t n e x t t o w a r d f ( f l o a t x , lo n g d o u b le y ) ;
          n e x tto w a r d l        lo n g d o u b le n e x t t o w a r d l (lo n g d o u b le x t lo n g               d o u b le y ) ;
                      R e tu rn s    Next representable value after x in the direction of y (see n e x t a f t e r ) . Returns
                                     y converted to the function’s type if x equals y.                                    23.4 kjihgfedcba

               perror                P r in t E r r o r M e s s a g e                                                       < s t d i o . h>
                                     v o id p e r r o r ( c o n s t c h a r         * s);
                                     W rites the followingo messago e to the s t d e r r stream:
                                     s ir in g : error-m essage
                                     string is the string pointed to by s and error-m essage is an implementation-defined
                                     message that matches the one returned by the call s t r e r r o r ( e r r n o ) . 24.2

                        pow          Pow er                                                                                     < m a t h .h >
                                     d o u b le p o w (d o u b le x , d o u b le y ) ;
                        pow f        flo a t p o w f(flo a t x f flo a t y );
                        pow l        lo n g d o u b le p o w l (lo n g d o u b le x ,              lo n g   d o u b le   y) ;
                      R e tu r n s   x raised to the power y. A domain or range error may occur in certain cases, which
                                     vary between C89 and C99.                                                     23.3

               printf                F o r m a tte d W rite                                                                 < s t d i o . h>
                                     in t p rin tf(c o n s t             char * r e s tr ic t       fo rm a t,     ...) ;
                                     Writes output to the s t d o u t stream. The string pointed to by f o r m a t specifies
                                     how subsequent arguments will be displayed.
                      R e tu r n s   Number of characters written. Retum s a negative value if an error occurs. 3.1, 22.3
                     putc            W rite C h a r a c te r to F ile                                                       < s t d i o . h>
                                     in t p u tc (in t           c,     F IL E * s t r e a m ) ;
                                     Writes the character c to the stream pointed to by s t r e a m . Note: p u t c is nor­
                                     mally implemented as a macro; it may evaluate s t r e a m more than once.
                      R e tu r n s   c (the character written). If a write error occurs, p u t c sets the stream ’s error indi­
                                     cator and returns EOF.                                                                22.4

            putchar                  W rite C h a r a c te r                                                                <s t d i o . h >
                                     in t p u tc h a r(in t             c );
                                     W rites the character c to the s t d o u t stream. Note: p u t c h a r is norm ally im ple­
                                     mented as a macro.
                                                        A p p e n d ix D                                                       779cbaZYXWVUTSR
                                                                            S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONM

    R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                      c (the character written). If a write error occurs, p u t c h a r sets the strean fs error
                      indicator and returns EOF.                                                        7.3, 22.4

    puts         W r it e S tr in g                                                                              < s td io .h >
                 in t     p u ts (c o n s t    ch ar * s);
                 W rites the string pointed to by s to the s t d o u t stream , then writes a new-line
                 character.
    R etu rn s   A nonnegative value if successful. Returns EOF if a write error occurs.                                13.3, 22.5 PONMLKJIHGFE

  putwc          W rite W id e C h a ra c te r to F ile (C 9 9 )                                                 < w c h a r . h>
                 w in t_ t p u tw c (w c h a r _ t          ct     F IL E   ^ s tr e a m );

                 W ide-character version o f p u t c .                                                                         25.5

putwchar         W rite W id e C h a ra c te r (C 9 9 )                                                          < w c h a r . h>
                 w in t_ t p u tw c h a r (w c h a r _ t           c );

                 W ide-character version of p u t c h a r .                                                                    25.5

   qsort         S o r t A rra y                                                                               < s t d l i b . h>
                 v o id    q s o r t ( v o i d * b a s e , s i z e _ t nm em b, s i z e _ t s i z e ,
                                        i n t (* c o m p a r)( c o n s t v o id *, c o n s t v o id                       * ));
                 Sorts the array pointed to by b a s e . The array has nm em b elem ents, each s i z e
                 bytes long, c o m p a r is a pointer to a com parison function. W hen passed pointers
                 to two array elem ents, the com parison function m ust return a negative, zero, or
                 positive integer, depending on w hether the first array elem ent is less than, equal to,
                 or greater than the second.                                                    17.7, 26.2

   raise         R a is e S ig n a l                                                                           < s i g n a l . h>
                 in t     ra is e (in t       s ig );
                 Raises the signal whose number is s i g .
    R etu rn s   Zero ifsuccessful, nonzero otherwise.                                                                         24.3

    rand         G e n e ra te P s e u d o -R a n d o m N u m b e r                                            < s t d l i b . h>
                 in t     ra n d (v o id );
    R etu rn s   A pseudo-random integer between 0 and RAND_MAX (inclusive).                                                   26.2

 realloc         R e s iz e M e m o r y B lo c k                                                               <s t d l i b . h >
                 v o id     * re a llo c (v o id         * p tr,    s iz e _ t    s iz e );
                 p t r is assum ed to point to a block of mem ory previously obtained from c a l l o c .
                 m a l l o c , or r e a l l o c . r e a l l o c allocates a block of s i z e bytes, copying the
                 contents of the old block if necessary.
    R etu rn s   A pointer to the beginning of the new mem ory block. Returns a null pointer if a
                 block of the requested size can’t be allocated.                             17.3
7 8 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a r d L ib r a r y F u n c tio n s PONMLKJIHGFEDCBA


       remainder                      R e m a in d e r (C 9 9 )                                                                  < m a t h . h> cbaZYXW
                                      d o u b le r e m a in d e r (d o u b le x , d o u b le y ) ;
            r e m a in d e r f        flo a t r e m a in d e r f(flo a t x , flo a t y );
            r e m a in d e r l        lo n g d o u b le r e m a in d e r l( lo n g d o u b le x ,                lo n g   d o u b le   y );
                      R eturns       x - n y. where n is the integer nearest the exact value of x / y . (If x / y is halfway
                                     between two integers, n is even.) I f x - n y = 0, the return value has the sam e sign
                                     as x . If y is zero, either a domain error occurs or zero is returned.              23.4 kjihgfe

                remove                R e m o v e F ile                                                                        < s t d i o . h>
                                      in t    re m o v e (c o n st c h a r          * file n a m e );
                                     Deletes the file whose name is pointed to by f i l e n a m e .
                      R eturns       Zero if successful, nonzero otherwise.                                                                   22.2

                remquo                R e m a in d e r a n d Q u o tie n t (C 9 9 )                                              < m a t h . h>
                                      d o u b le r e m q u o (d o u b le x , d o u b le y , i n t * q u o );
                   rem q u o f        f l o a t r e m q u o f( flo a t x , f l o a t y , i n t * q u o );
                   rem quol           lo n g d o u b le r e m q u o l(lo n g d o u b le x , lo n g d o u b le y ,
                                                                        i n t * q u o );
                                     Computes both the remainder and the quotient when x is divided by y. The object
                                     pointed to by q u o is modified so that it contains n low-order bits of (he integer
                                     quotient lx /y l, where n is implem entation-defined but must be at least three. The
                                     value stored in this object will be negative if x / y < 0.
                      R eturns       Same value as the corresponding r e m a i n d e r function. If y is zero, either a
                                     domain error occurs or zero is returned.                                      23.4

                rename                R e n a m e F ile                                                                        < s t d i o . h>
                                      in t    re n a m e (c o n s t c h a r * o ld ,           c o n s t c h a r * n e w );
                                     Changes the name of a file, o l d and n ew point to strings containing the old name
                                     and new name, respectively.
                      R eturns       Zero if the renaming is successful. Returns a nonzero value if the operation fails
                                     (perhaps because the old file is currently open).                            22.2

                rewind                R e w in d F ile                                                                         < s t d i o . h>
                                     v o id     re w in d (F IL E        * s tre a m );
                                     Sets the file position indicator for the stream pointed to by s t r e a m to the begin­
                                     ning of the file. Clears the error and end-of-file indicators for the stream.      22.7

                      rint            R o u n d to In te g ra l V a lu e U s in g C u rr e n t D ire c tio n (C 9 9 )            < m a t h . h>
                                      d o u b le r i n t ( d o u b l e x ) ;
                       r in tf        flo a t r in tf( flo a t x );
                       r in tl        lo n g d o u b le r i n t l (lo n g             d o u b le x ) ;
                      R etu rns      x rounded to an integer (in lloating-point format) using the current rounding direc-
                                                      A p p e n d ix D                                                      781onmlkjihgfedcbaZYX
                                                                             S ta n d a r d L ibrary F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJ

                  tion. May raise the inexact floating-point exception if the result has a different
                  value than x.                                                                 23.4

   round          R o u n d to N e a r e s t In teg ra l V a lu e (C 9 9 )                                        < m a t h . h>
                  d o u b le r o u n d (d o u b le x ) ;
     roundf       flo a t r o u n d f(flo a t x );
     roundl       lo n g d o u b le r o u n d l( lo n g          d o u b le x ) ;
      R eturns    x rounded to the nearest integer (in floating-point format). Halfway cases are
                  rounded away from zero.                                          23.4

s c a lb ln       S c a le F lo a tin g -P o in t N u m b e r U sin g L o n g In te g e r (C 9 9 )                < m a t h . h>
                  d o u b le s c a lb ln ( d o u b le x f lo n g i n t n ) ;
  s c a lb ln f   f l o a t s c a l b l n f ( f l o a t x , lo n g i n t n ) ;
  s c a lb ln l   lo n g d o u b le s c a l b l n l (lo n g d o u b le x , lo n g                     in t    n );
      R eturns    x x FLT_RADIX n , computed in an efficient way. A range error may occur.                                   23.4

 S C a lb n       Scale Floating-Point Number Using Integer (C99)                                                 < m a t h . h>
                  d o u b le s c a lb n ( d o u b le x , i n t n ) ;
   s c a lb n f   flo a t s c a lb n f(flo a t x , in t n );
   s c a lb n l   lo n g d o u b le s c a l b n l ( l o n g d o u b le x ,               in t    n );
      R etu rns   x x FLT_RADIX n , computed in an efficient way. A range error may occur.                                   23.4

   scant          F o r m a tte d R e a d                                                                       < s td io .h >
                  in t     sc a n f(c o n st char           * r e s tr ic t        fo rm a t,        ...) ;
                  Reads input items from the s t d i n stream. The string pointed to by f o r m a t spec­
                  ifies the format of the items to be read. The arguments that follow f o r m a t point
                  to objects in which the items are to be stored.
      R eturns    Num ber of input items successfully read and stored. Returns EOF if an input fail­
                  ure occurs before any items can be read.                      3.2, 22.3

 setbuf           S e tB u ffe r                                                                                < s td io .h >
                  v o id      s e tb u f(F IL E * r e s t r i c t s tre a m ,
                                          char * r e s tr ic t b u f);
                  h b u f isn’t a null pointer, a call of s e t b u f is equivalent to:
                  (v o id )     s e t v b u f ( s t r e a m , b u f , __IOFBF, BUFSIZ);
                  Otherwise, it’s equivalent to:
                  (v o id )     s e tv b u f(s tre a m ,   NULL, _I0NBF, 0 ) ;                                              22.2
 Se tjmp          P re p a re for N o n lo c a l J u m p                                                      <s e t j m p. h >
                  in t     s e tjm p (jm p _ b u f e n v ) ;                                                              macro
                  Stores the current environment in e n v for use in a later call of lo n g jm p .
      R etu rns   Zero when called directly. Returns a nonzero value when returning from a call of
                  lo n g jm p .                                                    24.4
7 8 2 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



       setlocale                      S e t L o c a le onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA                            < l o c a l e . h>
                                      char * s e tlo c a le (in t                 c a te g o ry ,     c o n st ch ar * lo c a le );
                                      Sets a portion of the program ’s locale, c a t e g o r y indicates which portion is
                                      affected, l o c a l e points to a string representing the new locale.
                      R e tu rn s     Tf l o c a l e is a null pointer, returns a pointer to the string associated with c a t e ­
                                      g o r y for the current locale. Otherwise, returns a pointer to the string associated
                                      with c a t e g o r y for the new locale. Returns a null pointer ifth e operation fails.cbaZYXWVUTSRQ
                                                                                                                            25.1

             setvbuf                  S e tB u ffe r                                                                          < s td io .h >
                                      in t     s e tv b u f(F IL E * r e s t r i c t s tre a m ,
                                                             c h a r * r e s t r i c t b u f,
                                                             i n t m ode, s i z e _ t s i z e ) ;
                                      Changes the buffering of the stream pointed to by s t r e a m . The value o fm o d e
                                      can be either _ IO F B F (full buffering), _IO L B F (line buffering), or _IO N B F (no
                                      buffering). I f b u f is a null pointer, a buffer is automatically allocated if needed.
                                      Otherwise, b u f points to a memory block that can be used as the buffer; s i z e is
                                      the number o fb y tes in the block. Note: s e t v b u f must be called after the stream
                                      is opened but before any other operations are performed on it.
                      R e tu r n s   Zero if the operation is successful. Returns a nonzero value if m ode is invalid or
                                     the request c a n \ be honored.                                                22.2

                signal                In s ta ll S ig n a l H a n d le r                                                    < s i g n a l . h>
                                     v o id      (* s ig n a l(in t          s ig ,     v o id      (* fu n c )(in t)))(in t);
                                      Installs the function pointed to by f u n c as the handler for the signal whose num­
                                      ber is s i g . Passing SIG _D FL as the second argument causes default handling for
                                      the signal; passing S IG _IG N causes the signal to be ignored.
                      R e tu r n s   A pointer to the previous handler for this signal; returns SIG _ER R and stores a
                                     positive value in e r r n o if the handler can’t be installed.               24.3 PONMLKJIH

             signbit                  S ig n B it (C 9 9 )                                                                     < m a th . h>
                                      in t     s ig n b it(r e a l-flo a tin g x ) ;                                                  m acro
                      R e tu rn s     A nonzero value if the sign of x is negative and zero otherwise. The value o f x may
                                      be any number, including infinity and NaN.                                       23.4

                         sin          S in e                                                                                   < m a t h . h>
                                      d o u b le s in ( d o u b le x ) ;
                         s in f       flo a t s in f( flo a t x );
                         s in l       lo n g d o u b le s i n l (lo n g d o u b le x ) ;
                      R e tu r n s    Sine of x (measured in radians).                                                                   23.3

                      sinh            H y p e r b o lic S in e                                                                 < m a t h . h>
                                      d o u b le     s in h (d o u b le x ) ;
                                                       A p p e n d ix D                                                         783cbaZYXWVUTSRQPON
                                                                             S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJI


       s in h f    flo a t s in h f(flo a t x );
       s in h l    lo n g d o u b le s i n h l ( l o n g         d o u b le x ) ;
       R etu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                       Hyperbolic sine o f x . A range error occurs if the magnitude o f x is too large.                        23.3

s n p r in tf      B o u n d e d F o r m a tte d S tr in g W rite (C 9 9 )                                        < stdio.h >
                   in t     s n p r in tf(c h a r ★ r e s tr ic t s f s iz e _ t n,
                                           c o n s t c h a r * r e s t r i c t fo r m a t,                  ...) ;
                   Equivalent to f p r i n t f , bul stores characters in the array pointed to by s instead
                   of writing them to a stream. No more than n - 1 characters will be written to the
                   array. The string pointed to by f o r m a t specifies how subsequent arguments will
                   be displayed. Stores a null character in the array at the end ofoutput.
       R eturns   Num ber of characters that would have been stored in the array (not including the
                  null character) had there been no length restriction. Returns a negative value if an
                  encoding error occurs.                                                          22.8

 sprintf           F o rm a tte d S tr in g W rite                                                                < s t d i o . h>
                   in t     s p rin tf(c h a r * r e s tr ic t s,
                                        const char * r e s tr ic t                      fo rm a t,        . . .) ;
                   Equivalent to f p r i n t f . but stores characters in the array pointed to by s instead
                   of writing them to a stream. The string pointed to by f o r m a t specifies how subse­
                   quent arguments will be displayed. Stores a null character in the array at the end of
                   output.
       R eturns    Number ofcharacters stored in the array, not including the null character. In C99,
                   returns a nego ative value if an encodingo error occurs.                      22.8

      sqrt         S q u a re R o o t                                                                                < m a t h . h>
                   d o u b le s q r t ( d o u b l e x ) ;
       sqr ft      flo a t s q r tf( flo a t x );
       s q r tl    lo n g d o u b le s q r t l ( l o n g         d o u b le x ) ;
       R eturns    Nonnegative square root of x. A domain error occurs if x is negative.                                        23.3

     srand         S e e d P s e u d o -R a n d o m N u m b e r G e n e r a to r                               < s t d l i b . h>
                   v o id    s ra n d (u n s ig n e d     in t    se e d );
                   Uses s e e d to initialize the sequence ofpseudo-random numbers produced by call­
                   ing r a n d .                                                               26.2

   sscanf          F o rm a tt e d S tr in g R e a d                                                             <s t d i o . h >
                   in t     ssc a n f(c o n st ch ar          * r e s tr ic t         s,
                                      const char              * r e s tr ic t         fo rm a t,        ...) ;
                   Equivalent to f s c a n f . but reads characters from the string pointed to by s instead
                   of reading them from a stream. The string pointed to by f o r m a t specifies the for­
                   mat of the items to be read. The arguments that follow f o r m a t point to objects in
                   which the items are to be stored.
7 8 4 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D    S ta n d a rd L ib r a r y F u n c tio n s


                                       N um ber o f input items successfully read and stored. Returns EOF if an input fail­
                     R e tu r n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                    ure occurs before any items could be read. PONMLKJIHGFEDCBA                              22.8kjihgfedc
               strcat               S trin g C o n c a te n a tio n                                                  <string.h>
                                    char *strcat(char * restrict sl,
                                                 const char * restrict s2);
                                    Appends characters from the string pointed to by s 2 to the string pointed to by s l .
                     R e tu r n s   s l (a pointer lo the concatenated string).                                          13.5,23.6
               strchr               S e a rc h S trin g fo r C h a ra c te r                                         <string.h>
                                    char *strchr(const char *s, int c);
                     R e tu r n s   A pointer to the first occurrence of the character c in the string pointed to by s .
                                    Returns a null pointer if c isn’t found.                                       23.6
               strcmp               S trin g C o m p a ris o n                                                       <string.h>
                                    int strcmp(const char *sl, const char *s2);
                     R e tu r n s   A negative, zero, or positive integer, depending on w hether the string pointed to by
                                    s l is less than, equal to, o rg re a te r than the string pointed to by s 2 . 13.5,23.6
            strcoll                 S trin g C o m p a ris o n U s in g L o c a le -S p e c ific C o lla tin g       <string.h>
                                    S equence

                                    int strcoll(const char *sl, const char *s2);
                     R e tu r n s   A negative, zero, or positive integer, depending on w hether the string pointed to by
                                    s l is less than, equal to, o rg re ater than the string pointed to by s 2 . The com parison
                                    is perform ed according to the rules of the current locale’s LC_COLLATE category.
                                                                                                                             23.6
               strcpy               S trin g C o p y                                                                 <string.h>
                                    char *strcpy(char * restrict sl,
                                                 const char * restrict s2) ;
                                    Copies the string pointed to by s 2 into the array pointed to by s l .
                     R e tu r n s   s l (a pointer to the destination).                                                  13.5,23.6
            strcspn                 S e a rc h S trin g fo r In itia l S p a n o f C h a ra c te rs N o t in S e t   <string.h>
                                    size__t strcspn(const char *sl, const char *s2);
                     R e tu r n s   Length of the longest initial segm ent of the string pointed to by s l that doesn’t
                                    contain any character in the string pointed to by s 2 .                        23.6
         strerror                   C o n v e rt E rr o r N u m b e r to S trin g                                    <string.h>
                                    char *strerror(int errnum);
                     R e tu r n s   A pointer to a string containing an error message corresponding to the value of
                                    errnum.                                                                                  24.2
                                                         A p p e n d ix D                                                                 7 8 5 kjihgfedcbaZ
                                                                                S t a n d a r d L i b r a r y F u n c t i o n s onmlkjihgfedcbaZYXWVUTSRQPO



str ftime          W r it e F o r m a t t e d D a t e a n d T im e t o S t r i n g                                        < t i m e . h>
                   s iz e _ t    s t r f t i m e ( c h a r * r e s t r i c t s , s i z e _ t m a x s iz e ,
                                                    c o n s t c h a r * r e s t r i c t fo rm a t,
                                                    c o n s t s t r u c t tm * r e s t r i c t t i m e p t r ) ;
                   Stores characters in Lhe array pointed to by s under control o f the string pointed to
                   by f o r m a t . The format string may contain ordinary characters, which are copied
                   unchanged, and conversion specifiers, which are replaced by values from the struc­
                   ture pointed to by t i m e p t r . The m a x s i z e param eter limits the num ber o f char­
                   acters (including the null character) that can be stored.
    R e tu r n s   N um ber o f characters stored (not including the term inating null character). Returns
                   zero if the num ber of characters to be stored (including the null character) exceeds
                   m a x s iz e .                                                          2 6 .3

  Strlen           S tr in g L e n g th                                                                               < s tr in g .h >
                   s iz e _ t    s trle n (c o n s t         char       * s);
    R e tu r n s   Length of the string pointed to by s . not including the null character.                                      13.5, 2 3 .6

 strncat           B o u n d e d S t r in g C o n c a te n a tio n                                                     < s t r i n g . h>
                   char      * s trn c a t(c h a r * r e s t r ic t s l,
                                            const char * r e s t r ic t                          s2,      s iz e _ t       n );
                   Appends characters from the array pointed to by s 2 to the string pointed to by
                   s l . Copying stops when a null character is encountered o r n characters have been
                   copied.
    R e tu r n s   s l (a pointer to the concatenated string).                                                                   13.5, 2 3 .6

 Strncmp           B o u n d e d S t r in g C o m p a r is o n                                                         < s t r i n g . h>
                   in t    s trn c m p (c o n s t        char        * s l,   const         char        *s2,        s iz e _ t       n );
    R e tu r n s   A negative, zero, or positive integer, depending on w hether the first n characters of
                   the array pointed to by s l are less than, equal to, or greater than the first n charac­
                   ters of the array pointed to by s 2 . Com parison stops if a null character is encoun­
                   tered in either array.                                                  2 3 .6

 strncpy           B o u n d e d S tr in g C o p y                                                                     < s t r i n g . h>
                   char      * s tra c p y (c h a r * r e s t r ic t s l,
                                            const char * r e s tr ic t                           s2,      s iz e _ t n );
                   Copies the first n characters o fth e array pointed lo by s 2 into the array pointed to
                   by s l . If it encounters a null character in the array pointed to by s 2 , s t r n c p y
                   adds null characters to the array pointed to by s l until a total o f n characters have
                   been written.
    R e tu r n s   s l (a pointer to the destination).                                                                           13.5, 23 .6
7 8 6 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA



             strpbrk                                                                                                              < s t r i n g . h>
                                      S e a rc h S tr in g fo r O n e o f a S e t o f C h a ra c te rs onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                      c h a r * s trp b rk (c o n s t c h a r * s l,                 c o n st ch ar * s2 );
                      R e tu rn s     A pointer to the leftmost character in the string pointed to by s l that m atches any
                                      character in the string pointed to by s 2 . Returns a null pointer if no match is found.cbaZYXWVU
                                                                                                                          23.6

             strrchr                  S e a r c h S trin g in R e v e r s e fo r C h a r a c te r                                < s t r i n g . h>
                                      char      * s trrc h r(c o n s t             char    *s,      in t   c );
                      R e tu r n s    A pointer to the last occurrence of the character c in the string pointed to by s.
                                      Returns a null pointer if c isn’t found.                                      23.6

                strspn                S e a rc h S tr in g fo r In itia l S p a n o f C h a ra c te rs in S e t                  < s t r i n g . h>
                                      s iz e _ t     s trs p n (c o n s t          char    * s l,    const char          * s2 );
                      R e tu r n s   Length of the longest initial segm ent in the string pointed to by s l that consists
                                     entirely of characters in the string pointed to by s 2 .                       23.6

                strstr                S e a rc h S tr in g f o r S u b s tr in g                                                 < s t r i n g . h>
                                      char      * s trs tr(c o n s t          char        * s l,    const char         * s2 );
                      R e tu rn s    A pointer to the first occurrence in the string pointed to by s l of the sequence of
                                     characters in the string pointed to by s 2 . Returns a null pointer if no match is
                                     found.                                                                          23.6

                strtod                C o n v e rt S tr in g to D o u b le                                                       < s t d l i b . h>
                                      d o u b le    s tr to d ( c o n s t ch a r * r e s t r i c t n p tr,
                                                                 c h a r ** r e s t r i c t e n d p t r ) ;
                                     Skips white-space characters in the string pointed to by n p t r , then converts subse­
                                     quent characters into a d o u b l e value. If e n d p t r isn’t a null pointer, s t r t o d
                                     modifies the object pointed to by e n d p t r so that it points to the first leftover char­
                                     acter. If no d o u b l e value is found, or if it has the wrong form, s t r t o d stores
                                     n p t r in the object pointed to by e n d p t r . Lf the number is too large or smaU to
                                     represent, it stores ERANGE in e r r n o . C99 changes: The string pointed to by
                                     n p t r may contain a hexadecimal floating-point number, infinity, or NaN.
                                     W hether ERANGE is stored in e r r n o when the number is too small to represent is
                                     implementation-defined.
                      R e tu rn s    The converted number. Returns zero if no conversion could be performed. If the
                                     number is too large to represent, returns plus or minus HUGE_VAL, depending on
                                     the num ber’s sign. Returns zero if the number is too small to represent. C99
                                     change: lf the number is too small to represent, s t r t o d returns a value whose
                                     magnitude is no greater than the smaUest normalized positive d o u b l e .    26.2 PONMLKJIH

                strtof                C o n v e r t S tr in g to F lo a t (C 9 9 )                                               <s t d l i b . h >
                                      flo a t      s tr to f( c o n s t ch a r * r e s t r i c t n p tr ,
                                                               c h a r ** r e s t r i c t e n d p t r ) ;
                                                        A p p e n d ix D                                                        787onmlkjihgfedcbaZY
                                                                             S ta n d a r d L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONML


                   s t r t o f is identical to s t r t o d , except that it converts a string to a f l o a t value.
     R e tu rn s   T he converted num ber. R eturns zero if no conversion could be perform ed. If the
                   num ber is too large to represent, returns plus or m inus HUGE_VALF, depending on
                   the n u m b er’s sign. If the num ber is too sm all to represent, returns a value w hose
                                                                                                            26.2 PONMLKJIHGFED
                   m agnitude is no greater than the sm allest norm alized positive f l o a t . cbaZYXWVUTSRQPONMLKJIHGFEDCBA

strtoimax          C o n v e rt S tr in g to G re a te s t- W id th In te g e r (C 9 9 )                   < i n t t y p e s . h>
                   in tm a x _ t     s tr to im a x (c o n s t       char      * r e s tr ic t         n p tr ,
                                                         char      ** r e s t r i c t       e n d p tr ,      in t    b a se );
                   s t r t o i m a x is identical to s t r t o l , except that it converts a string to a value of
                   type i n t m a x _ t (the w idest signed integer type).
     R e tu rn s   T he converted num ber. Returns zero if no conversion could be perform ed. If the
                   n u m b e rc a n ’t be represented, returns INTMAX_MAX or INTMAX_MIN, depending
                   on the n um ber’s sig&n.                                                     27.2

   strtok          S e a rc h S trin g fo r T o ke n                                                           <s t r i n g . h >
                   char      * s trto k (c h a r * r e s t r i c t s l,
                                          const char * r e s tr ic t                       s2) ;
                   Searches the string pointed to by s l for a “token" consisting o fc h a ra c te rs not in
                   the string pointed to by s 2 . If a token exists, the character follow ing it is changed
                   to a null character. If s l is a null pointer, a search begun by the m ost recent call o f
                   s t r t o k is continued; the search begins im m ediately after the null ch aracter at the
                   end o f the previous token.
     R e tu rn s   A pointer to the first character o f the token. R eturns a null pointer if no token could
                   be found.                                                                            23.6

   strtol          C o n v e rt S trin g to L o n g In te g e r                                                 < s t d l i b . h>
                   lo n g    in t    s tr to l( c o n s t c h ar * r e s t r i c t n p tr,
                                                 c h a r ** r e s t r i c t e n d p t r , i n t                 b a se );
                   Skips w hite-space characters in the string pointed to by n p t r , then converts su b se­
                   quent characters into a l o n g i n t value. T f b a s e is betw een 2 and 36, it is used as
                   the radix o f the num ber, l f b a s e is zero, the num ber is assum ed to be decim al
                   unless it begins with 0 (octal) or w ith Ox or OX (hexadecim al). If e n d p t r isn’t a
                   null pointer, s t r t o l m odifies the object pointed to by e n d p t r so that it points
                   to the first leftover character. If no l o n g i n t value is found, or if it has the wrong
                   form , s t r t o l stores n p t r in the object pointed to by e n d p t r . If the num ber
                   c a n ’t be represented, it stores ERANGE in e r r n o .
     R e tu rn s   T he converted num ber. R eturns zero if no conversion could be perform ed. If the
                   num ber c a n ’t be represented, returns LONG_MAX or LONG_MIN, depending on the
                   num ber’s sigo n.                                                             26.2

  strtold          C o n v e rt S tr in g to L o n g D o u b le (C 9 9 )                                        < s t d l i b . h>
                   lo n g    d o u b le    s tr to ld (c o n s t       char       * r e s tr ic t        n p tr ,
                                                           char      **    r e s tr ic t      e n d p tr );
788 cbaZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D      S t a n d a r d L ib ra r y F u n c tio n s

                                     s t r t o l d is identical to s t r t o d . except that it converts a string to a l o n g d o u ­
                                     b l e value.
                      R e tu rn s    The converted number. Returns zero ifn o conversion could be perform ed. Ifth e num ­
                                     ber is too large to represent, returns plus or m inus HUGE__VALL, depending on the
                                     num ber’s sign. If the nnm ber is too sm all to represent, returns a value w hose m ag­
                                     nitude is no greater than the sm allest norm alized positive l o n g d o u b l e . 26.2

             s tr to ll               C o n v e r t S tr in g to L o n g L o n g I n te g e r (C 9 9 )                           <s t d l i b . h>
                                      lo n g    lo n g    in t     s tr to ll(c o n s t         char      * r e s tr ic t       n p tr ,
                                                                                    c h a r ** r e s t r i c t         e n d p tr ,
                                                                                    in t b a se );
                                     s t r t o l l is identical to s t r t o l . except that it converts a string to a l o n g l o n g
                                     i n t value.
                      R e tu rn s    T he converted number. Returns zero if no conversion could be perform ed. If the
                                     num ber c a n ’t be represented, returns LLONG_MAX or LLONG_MIN, depending on
                                     the num ber’s sign.                                                         26.2 kjihgfedcba

             strtoul                  C o n v e r t S tr in g to U n s ig n e d L o n g I n te g e r                              < s t d l i b . h>
                                     u n s ig n e d      lo n g    in t    s tr to u l( c o n s t ch ar * r e s t r i c t n p tr,
                                                                                         c h a r ** r e s t r i c t e n d p t r ,
                                                                                         in t b a se );
                                     s t r t o u l is identical to s t r t o l ,              except that it converts a string to an
                                     u n s i g n e d l o n g i n t value.
                      R e tu rn s    The converted number. Returns zero if no conversion could be perform ed. If the
                                     num ber c an ’t be represented, returns ULONG__MAX.                        26.2

          s tr to u ll               C o n v e r t S tr in g to U n s ig n e d L o n g L o n g I n te g e r (C 9 9 )              <s t d l i b . h>
                                     u n s ig n e d lo n g lo n g i n t s t r t o u l l (
                                         c o n st ch a r * r e s tr ic t n p tr ,
                                          char      **    r e s tr ic t        e n d p tr ,   in t     b a se );
                                     s t r t o u l l is identical to s t r t o l . except that it converts a string to an
                                     u n s i g n e d l o n g l o n g i n t value.
                      R e tu rn s    T he converted num ber. Returns zero if no conversion could be perform ed. If the
                                     num ber c a n 't be represented, returns ULLONG_MAX.                         26.2

       s tr to tu n a x              C o n v e r t S tr in g to U n s ig n e d G r e a te s t- W id th I n te g e r (C 9 9 ) < i n t t y p e s . h >
                                     u in tm a x _ t      s tr to u m a x (c o n s t c h a r * r e s t r i c t n p tr ,
                                                                           c h a r ** r e s t r i c t e n d p t r ,
                                                                           in t b a se );
                                     s t r t o u m a x is identical to s t r t o l . except that it converts a string to a value o f
                                     type u i n t m a x _ t (the widest unsigned integer type).
                      R e tu rn s    The converted number. Returns zero if no conversion could be perform ed. If the
                                     num ber c a n ’t be represented, returns UINTMAX_MAX.                      27.2
                                                         A p p e n d ix D                                                       789
                                                                              S ta n d a rd L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJI


 strxfrm              T ra n s fo rm S trin g                                                                   <string.h>onmlkjihgfedcbaZYXW
                                                                r e s tr ic t s l,
                      s i z e _ _ t s t r x f r m ( c h a r * cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                    const char * r e s tr ic t                s2 ,     s iz e _ t     n );
                      Transforms the string pointed to by s 2 , placing the first n characters of the
                      result— including the null character— in the array pointed to by s l . Calling
                      s t r c m p with two transformed strings should produce the same outcome (nega­
                      tive, zero, or positive) as calling s t r c o l l with the original strings. If n is zero,
                      s l is allowed to be a null pointer.
       R e tu r n s   Length of the transformed string. If this value is n or more, the contents o f the
                      array pointed to by s l are indeterminate.                                    23.6

s w p r in tf         W id e - C h a ra c te r F o rm a tte d S tr in g W rite (C 9 9 )                           < w c h a r. h>
                      in t   s w p r in tf(w c h a r _ t * r e s t r i c t s , s i z e _ t n ,
                                            c o n s t w c h a r_ t * r e s t r i c t fo r m a t,                  ...) ;
                      Equivalent to f w p r i n t f , but stores wide characters in the array pointed to by s
                      instead of writing them to a stream. The string pointed to by f o r m a t specifies
                      how subsequent arguments will be displayed. No more than n wide characters will
                      be written to the array, including a terminating null wide character.
       F le tu rn s   Number ofw id e characters stored in the array, not including the null wide charac­
                                                       •e if an encodins error occurs or the num ber of wide
                      ter. Returns a netgrf*ative val«u—
                      characters to be written is n or more.                                             25.5

 sw scanf             W id e -C h a ra c te r F o rm a tte d S trin g R e a d (C 9 9 )                            < w c h a r . h>
                      in t   s w s c a n f(c o n s t    w char_t        * r e s tr ic t        s,
                                           const        w ch a r_ t     * r e s tr ic t        fo r m a t,      ...) ;
                      Wide-character version of s s c a n f .                                                                   25.5

   system             P e rfo rm O p e ra tin g -S y s te m C o m m a n d                                       < s t d l i b . h>
                      in t   s y s te m (c o n s t c h a r      * s trin g );
                      Passes the string pointed to by s t r i n g to the operating system ’s command pro­
                      cessor (shell) to be executed. Program termination may occur as a result ofexecut-
                      ing<~- the command.
       R e tu rn s    If s t r i n g is a null pointer, returns a nonzero value if a command processor is
                      available. If s t r i n g isn’t a null pointer, s y s t e m returns an implementation-
                      defined value (if it returns at all).                                             26.2

         tan          Tangent                                                                                       < m a t h . h>
                      d o u b le ta n ( d o u b le x ) ;
          ta n f      flo a t ta n f(flo a t x );
          ta n l      lo n g d o u b le t a n l (lo n g d o u b le x ) ;
       R e tu rn s    Tangent of x (measured in radians).                                                                       23.3
790 ZYXWVUTSRQPONMLKJIHGFEDCBA
         A p p e n d ix D     S ta n d a rd L ib ra ry F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA


                     tanh           H y p e r b o lic T a n g e n t                                               < m a th . h>
                                    d o u b l e t a n h ( d o u b l e x ) ;cbaZYXWVUTSRQPONMLKJIHGFEDCBA
                      ta n h f      flo a t ta n h f(flo a t x );
                      ta n h l      lo n g d o u b le ta n h l (lo n g d o u b le x ) ;
                     R e tu rn s    Hyperbolic tangent of x.                                                                23.3

               tganuna              G a m m a F u n c tio n (C 9 9 )                                              < m a th . h>
                                    d o u b l e tg a m m a ( d o u b l e x ) ;
                  tg a m m a f      f l o a t tg a m m a f(flo a t x ) ;
                  tg a m m a l      lo n g d o u b le tg a m m a l(lo n g d o u b le                x );
                     R e tu rn s    T(x), where T is the gam m a function. A domain error or range error may occur i f x
                                    is a negative integer or zero. A range error may occur if the magnitude of x is too
                                    larfsc_/e or too small.                                                        23.4

                     time           C u rr e n t T im e                                                           < t i m e . h>
                                    tim e _ t      tim e (tim e _ t          * tim e r);
                     R e tu rn s    Current calendar time. Retum s ( t i m e _ t ) ( - 1 ) if the calendar time isn’t avail­
                                    able. I f t i m e r isn’t a null pointer, also stores the return value in the object pointed
                                    to b y tim e r.                                                                         26.3

            tmpfile                 C re a te T e m p o ra ry F ile                                             <s t d i o . h >
                                    F IL E     * tm p file (v o id );
                                    Creates a temporary file that will automatically be removed when it’s closed or the
                                    program ends. Opens the file in "w b+" mode.
                     R e tu rn s    A file pointer to be used when performing subsequent operations on the file.
                                    Returns a null pointer if a temporary file can’t be created.           22.2

               tmpnam               G e n e ra te T e m p o ra ry F ile N a m e                                  < s t d i o . h>
                                    char       * tm p n a m (c h a r * s ) ;
                                    Generates a name for a temporary file. If s is a null pointer, tm p n am stores the file
                                    name in a static object. Otherwise, it copies the file name into the character array
                                    pointed to by s. (The array must be long enough to store L _ tm p n am characters.)
                     R e tu rn s    A pointer to the file name. Returns a null pointer if a file name can’t be generated.
                                                                                                                            22.2

            tolower                 C o n v e rt to L o w e r C a s e                                            < c t y p e . h>
                                    in t     to lo w e r(in t         c );
                     R e tu rn s    If c is an upper-case letter, returns the corresponding lower-case letter. If c isn’t an
                                    upper-case letter, returns c unchanged.                                            23.5

            toupper                 C o n v e rt to U p p e r C a s e                                            < c t y p e . h>
                                    in t     to u p p e r(in t        c );
                                                          A p p e n d ix D                                                        791cbaZYXWVUTSRQPONM
                                                                                S ta n d a rd L ib r a r y F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJIH


         R eturns onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                       If c is a lower-case letter, returns the corresponding upper-case letter. If c isn’t a
                       lower-case letter, returns c unchanged.                                          23.5

to w c tr a n s      T ra n s lite ra te W id e C h a r a c te r (C 9 9 )                                         < w c t y p e . h>
                     w in t_ t      t o w c t r a n s ( w i n t _ _ t w c,    w c tr a n s _ t d e s c );
         R etu rns   Mapped value of wc using the mapping described by d e s c . ( d e s c must be a
                     value returned by a call of w c t r a n s ; the current setting of the LC_CTYPE cate­
                     gory must be the same during both calls.)                                        25.6

 to w lo w e r       C o n v e rt W id e C h a ra c te r to L o w e r C a s e (C 9 9 )                            < w c t y p e . h>
                     w in t_ t      to w lo w e r ( w in t_ t w c );
         R eturns    If i s w u p p e r ( w c ) is true, retums a corresponding wide character for which
                     i s w l o w e r is true in the current locale, if such a character exists. Otherwise,
                     returns wc unchanged.                                                            25.6

 to w u p p e r      C o n v e rt W id e C h a ra c te r to U p p e r C a s e (C 9 9 )                            < w c ty p e . h>
                     w in t_ t to w u p p e r ( w in t_ t w c );
         R eturns    If i s w l o w e r ( w c ) is true, returns a corresponding wide character for which
                     i s w u p p e r is true in the current locale, if such a character exists. Otherwise,
                     retum s wc unchang^ ed.                                                          25.6

       tr u n c      T ru n c a te to N e a r e s t In te g ra l V a lu e (C 9 9 )                                    < m a th . h>
                     d o u b le tr u n c ( d o u b le x ) ;
        tr u n c f   flo a t tr u n c f(flo a t x );
        tr u n c l   lo n g d o u b le t r u n c l (lo n g d o u b le x ) ;
         R eturns    x rounded to the integer (in floating-point format) nearest to it but no larger in
                     magnitude.                                                                    23.4

     ungetc          U n r e a d C h a r a c te r                                                                  < s t d i o . h>
                     in t u n g e tc (in t c,            F IL E * s t r e a m ) ;
                     Pushes the character c back onto the stream pointed to by s t r e a m and clears thc
                     stream ’s end-of-file indicator. The number of characters that can be pushed back
                     by consecutive calls of u n g e t c varies; only the first call is guaranteed to succeed.
                     Calling a file positioning function ( f s e e k , f s e t p o s , or r e w i n d ) causes the
                     pushed-back character(s) to be lost.
         R eturns    c (the pushed-back character). Returns EOF if an attempt is made to push back
                     EOF or to push back too many characters without a read or file positioning opera­
                               tion.                                                              22.4

   u n g e tw c      U n r e a d W id e C h a r a c te r (C 9 9 )                                                   < w c h a r . h>
                     w in t_ t u n g e tw c (w in t_ t              c,   F IL E * s t r e a m ) ;
                     W ide-character version o f u n g e t c .                                                                    25.5
792       A p p e n d ix D      S ta n d a r d L ibrary F u n c tio n s
      cbaZYXWVUTSRQPONMLKJIHGFEDCBA




             va__arg                  F e tc h A r g u m e n t fro m Variable A r g u m e n t L ist onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                                                < s t d a r g . h>
                                      type v a _ a r g (v a _ 1 i s t      a p , ty p e ) ;                                               m acro
                                      Fetches an argument in the variable argument list associated with a p , then modi­
                                      fies a p so that the next use of v a _ a r g fetches the following argument, a p must
                                      have been initialized by v a _ s t a r t (or v a _ c o p y in C99) prior to the first use of
                                      v a _ a rg .
                    R eturns          Value of the argument; assuming that its type (after the default argum ent prom o­
                                      tions have been applied) is compatible with type.                   26.1

          va_copy                     C o p y Variable A r g u m e n t L ist (C99)                                            < s t d a r g . h>
                                      v o id    v a _ c o p y (v a _ lis t     d e s t,    v a _ lis t     src );                         m acro
                                      Copies s r c into d e s t . The value o f d e s t will be the same as if v a _ s t a r t had
                                      been applied to d e s t followed by the same sequence o f v a _ a r g applications that
                                      was used to reach the present state of s r c .                                           26.1

             va_end                   E n d P r o c e s s in g o f Variable A r g u m e n t L ist                             < s t d a r g . h>
                                      v o id v a _ e n d ( v a _ lis t a p );                                                             m acro
                                      Ends the processing of the variable argument list associated with a p .                                26.1

       va_start                       S ta r t P r o c e s s in g o f Variable A r g u m e n t L ist                          < s t d a r g . h>
                                      v o id v a _ s t a r t ( v a _ l i s t     a p , p a rm N );                                        m acro
                                      Must be invoked before accessing a variable argument list. Initializes a p for later
                                      use by v a _ a r g and v a _ e n d . p a rm N is the name of the last ordinary parameter
                                      (the one followed by , . . .).                                                      26.1

       vfprintf                       F o r m a tte d File W rite U sin g Variable A r g u m e n t L ist                        < s t d i o . h>
                                      i n t v f p r in tf ( F I L E * r e s t r i c t s tre a m ,
                                                              c o n s t c h a r * r e s t r i c t fo rm a t,
                                                              v a _ lis t a rg );
                                      Equivalent to f p r i n t f with the variable argument list replaced by a r g .
                    R eturns                                                   gative value if an error occurs.
                                      Number of characters written. Retums a ne&                                                             26.1

          v fs c a n f                F o r m a tte d File R e a d U sin g V ariable A r g u m e n t L ist (C 9 9 )             < s t d i o . h>
                                      in t     v fs c a n f( F I L E * r e s t r i c t s tr e a m ,
                                                              c o n s t c h a r ★ r e s t r i c t fo r m a t,
                                                              v a _ lis t a rg );
                                      Equivalent to f s c a n f with the variable argument list replaced by a r g .
                    R eturns          Num ber of input items successfully read and stored. Returns EOF if an input fail­
                                      ure occurs before any items can be read.                          26.1

      v fw p r in t f                 W id e -C h a r a c te r F o r m a tte d File W rite U sin g V ariable                    < w c h a r . h>
                                      A r g u m e n t L ist (C 9 9 )
                                                         A p p e n d ix D     S ta n d a r d L ib ra ry F u n c tio n s hgfedcbaZYXWVUTSRQPONMLK
                                                                                                                                793


                      in t   v fw p r in tf( F I L E * r e s t r i c t s tr e a m ,
                                              c o n s t w ch a r_ t * r e s t r i c t fo r m a t,
                                              v a _ l i s t a r g ) ; onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                      W ide-character version o f v f «•o r i n t f .                                                         25.5

 v fw s c a n f       W id e -C h a r a c te r F o r m a tte d File R e a d U s in g V ariable                    < w c h a r . h>
                      A r g u m e n t L ist (C 9 9 )

                      in t   v fw s c a n f(F IL E * r e s t r i c t s tr e a m ,
                                             c o n s t w char_t * r e s t r i c t               fo r m a t,
                                             v a _ lis t a rg );

                      W ide-character version o f v f s c a n f .                                                              25.5 kjihgfedcbaZ

   vprintf            F o r m a tte d W rite U s in g V ariable A r g u m e n t L is t                            < s t d i o . h>
                      in t v p rin tf(c o n s t         char      * r e s tr ic t        fo rm a t,      v a _ lis t     a rg );
                      Equivalent to p r i n t f with the variable argum ent list replaced by a r g .
         R etu rn s   N um ber of characters written. Returns a negative value if an error occurs.                             26.1

     vscanf           F o r m a tte d R e a d U s in g V ariable A r g u m e n t L is t (C 9 9 )                  < s t d i o . h>
                      in t   v s c a n f(c o n s t    char      * r e s tr ic t       fo r m a t,      v a _ lis t      a rg );

                      Equivalent to s c a n f with the variable argum ent list replaced by a r g .
         R etu rn s   N um ber of input items successfully read and stored. Returns EOF if an input fail­
                      ure occurs before any items can be read.                                      26.1

v s n p r in tf       B o u n d e d F o r m a tte d S tr in g W rite U s in g V ariable A r g u m e n t           < s t d i o . h>
                      L ist (C 9 9 )

                      in t   v s n p r in tf(c h a r * r e s tr ic t s, s iz e _ t n,
                                              c o n s t c h a r * r e s t r i c t fo r m a t,
                                              v a _ lis t a rg );

                      Equivalent to s n p r i n t f with the variable argum ent list replaced by a r g .

        R etu rn s    N um ber of characters that would have been stored in the array pointed to by s (not
                      including the null character) had there been no length restriction. Returns a nega­
                      tive value if an encoding& error occurs.                                        26.1

 vsprintf             F o r m a tte d S tr in g W rite U sin g V ariable A r g u m e n t L is t                   < s t d i o . h>
                      in t   v s p rin tf(c h a r * r e s tr ic t s,
                                           const char * r e s tr ic t                     fo rm a t,
                                           v a _ _ lis t a rg ) ;
                      Equivalent to s p r i n t f with the variable argum ent list replaced by a r g .
         R etu rn s   N um ber of characters stored in the array pointed to by s , not including the null
                      character, In C99,• returns a ne^g>ative value if an encodingo error occurs.   26.1
794 ZYXWVUTSRQPONMLKJIHGFEDCBA
         A p p e n d ix D     S ta n d a rd L ib ra ry F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


            vsscanf                 F o rm a tted String R e a d U sing Variable A rg u m e n t List (C99)                  < s t d i o . h>
                                    in t v s s c a n f|c o n s t char * r e s t r i c t                s,
                                                        const char * r e s tr ic t                     fo r m a t,
                                                        v a _ lis t a rg );
                                   Equivalent to s s c a n f with the variable argument list replaced by a r g .
                     R e tu rn s   Number of input items successfully read and stored. Returns EOF if an input fail­
                                   ure occurs before any items can be read.                                    26.1
       v s w p r in tf             W id e-C haracter F orm atted String Write U sing Variable                               < w c h a r . h>
                                   A rg u m e n t List (C99)
                                    in t   v s w p r in tf(w c h a r _ t * r e s t r i c t s , s i z e _ t n,
                                                            c o n s t w ch a r_ t * r e s t r i c t fo r m a t,
                                                            v a _ lis t a rg );
                                   Equivalent to s w p r i n t f with the variable argument list replaced by a r g .
                     R e tu rn s   Number of wide characters stored in the array pointed to by s, not including the
                                   null wide character. Returns a negative value if an encoding error occurs or the
                                   number of wide characters to be written is n or more.                       25.5
         vsw scanf                 W id e-C haracter F orm atted String R e a d U sing Variable                             < w c h a r . h>
                                   A rg u m e n t List (C99)
                                    in t    v s w s c a n f(c o n s t w char_t           * r e s tr ic t     s,
                                                            c o n s t w cha r_ t         * r e s tr ic t     fo r m a t,
                                                            v a _ lis t a rg );
                                   Wide-characterversion o f v s s c a n f .                                                           25.5
         v w p r in tf             W id e-C haracter F orm atted Write U sing Variable A rg u m e n t                       < w c h a r . h>
                                   L ist (C99)
                                    in t   v w p r in tf( c o n s t w char_t             * r e s tr ic t      fo r m a t,
                                                          v a _ lis t a r g );
                                   Wide-character version of v p r i n t f .                                                          25.5
            vw scanf                W ide-C haracter F orm atted R e a d U sing Variable A rg u m e n t                     < w c h a r . h>
                                    List (C99)
                                    in t   v w s c a n f(c o n s t w ch a r_ t         * r e s tr ic t      fo r m a t,
                                                         v a _ lis t a rg );
                                   Wide-character version of v s c a n f .                                                             25.5
            w c r to n b            C onvert W ide C haracter to M ultibyte C haracter - R e sta rta b le < w c h a r . h>
                                    (C99)
                                    s iz e _ t   w c r t o m b ( c h a r * r e s t r i c t s , w c h a r _ t w c,
                                                                m b s ta te _ t * r e s t r i c t p s ) ;
                                   If s is a null pointer, a call o fw c rto m b is equivalent to kjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                   wcrtomb(buf, L'\0 1 , ps)
                                                   A p p e n d ix D                                                        795
                                                                           S ta n d a rd L ib ra ry F u n c tio n s kjihgfedcbaZYXWVUTSRQPONMLKJI


               where b u f is an internal buff*er. Otherwise, w c rto m b converts wc from a wide
               character into a multibyte character (possibly including shift sequences), which il
               stores in the array pointed to by s. The value o f p s should be a pointer to an object
               of type m b s t a t e _ t that contains the current conversion state. If p s is a null
               pointer, w c rto m b uses an internal object to store the conversion state. If wc is a
               null wide character, w c rto m b stores a null byte, preceded by a shift sequence if
               necessary to restore the initial shift state, and the m b s t a t e _ t object used during
               the call is left in the initial conversion state.
                     Number of bytes stored in the array, including shift sequences. If wc isn’t a valid
    R e tu rn s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                        25.5 PONMLKJIHGFEDCBA
               wide character, returns ( s i z e _ t ) ( - 1 ) and stores EILSEQ in e r r n o . cbaZYXWVUTSRQPONMLKJIHGFEDCBA

 wcscat        W id e -S trin g C o n c a te n a tio n (C 9 9 )                                               < w c h a r . h>
               w char_t       * w c s c a t(w c h a r _ t * r e s t r i c t s l ,
                                            c o n s t w char_t * r e s t r i c t                   s2 );
               Wide-character version of s t r c a t .                                                                     25.5

 wcschr        S e a r c h W id e S trin g for C h a ra c te r (C 9 9 )                                       < w c h a r . h>
               w char_t       * w c sc h r(c o n st       w char_t           *s,     w ch a r_ t      c );
               Wide-character version of s t r c h r .                                                                     25.5

  wcscmp        W id e -S trin g C o m p a r iso n (C 99)                                                     < w c h a r . h>
               in t    w c sc m p (c o n st w ch a r_ t           * s l,     const       w char_t         * s2 );
               Wide-character version of s t r c m p .                                                                     25.5

wcscoll        W id e -S trin g C o m p a r iso n U sin g L o c a le -S p e c ific C ollating                 < w c h a r . h>
               S e q u e n c e (C 99)
               in t    w c s c o ll(c o n s t     w ch a r_ t      * s l,      const       w char_t          * s2 );
               Wide-character version of s t r c o l l .                                                                   25.5

  wcscpy        W id e -S trin g C o p y (C 99)                                                               < w c h a r . h>
               w char_t       * w c sc p y (w c h a r_ t * r e s t r i c t s l ,
                                            c o n s t w char_t * r e s t r i c t                    s2 );
               Wide-character version of s t r c p y .                                                                     25.5

 wcscspn       S e a r c h W id e S trin g for Initial S p a n o f C h a r a c te r s N o t in S e t          < w c h a r . h>
               (C 99)
               s iz e _ t   w c sc sp n (c o n st       w char_t           * s l,    const        w char_t         * s2 );
               Wide-character version of s t r c s p n .                                                                   25.5

wcsftime        W rite F o rm a tte d D a te a n d T im e to W id e S trin g (C 9 9 )                         < w c h a r . h>
               s iz e _ t   w c s ftim e (w c h a r _ t * r e s t r i c t s , s i z e _ t m a x s iz e ,
                                          c o n s t w ch a r_ t * r e s t r i c t fo r m a t,
                                           c o n s t s t r u c t tm ★ r e s t r i c t t i m e p t r ) ;
               Wide-character version of s t r f t i m e .                                                                 25.5
           A p p e n d ix D S ta n d a r d Library F u n c tio n s PONMLKJIHGFEDCBA
796 cbaZYXWVUTSRQPONMLKJIHGFEDCBA


              wcslen              W id e-S trin g L e n g th (C 9 9 )                                                    < w c h a r . h>
                                  s iz e _ t   w c s le n (c o n s t    w char_t         * s);
                                 Wide-character version of s t r l e n .                                                            25.5

           wcsncat                B o u n d e d W id e -S trin g C o n c a te n a tio n (C 99)                           < w c h a r . h>
                                  w char_t       * w c s n c a t(w c h a r _ t * r e s t r i c t s l ,
                                                                 c o n s t w char_t * r e s t r i c t            s2t
                                                                 s iz e _ t n ) ;
                                 Wide-character version of s t r n c a t .                                                          25.5

           wcsncmp                B o u n d e d W id e -S trin g C o m p a riso n (C 99)                                 < w c h a r . h>
                                  in t   w c sn c m p (c o n st w ch a r_ t           * s l,   const     w char_t       *s2,
                                                      s iz e _ t n ) ;
                                 Wide-character version of s t r n c m p .                                                          25.5

           wcsncpy                B o u n d e d W id e-S trin g C o p y (C 99)                                           < w c h a r . h>
                                  w char_t       * w c sn c p y (w c h a r_ t * r e s t r i c t s l ,
                                                                 c o n s t w ch a r_ t * r e s t r i c t         s2 ,
                                                                 s iz e _ t n ) ;
                                 Wide-character version of s t r n c p y .                                                          25.5

           wcspbrk                S e a r c h W ide S trin g for O n e o f a S e t o f C h a ra c te rs (C 99)           < w c h a r . h>
                                  w char_t       * w c sp b rk (c o n st     w char_t          * s l,
                                                                const        w char_t          * s2 );
                                 Wide-character version of s t r p b r k .                                                          25.5
           wcsrchr                S e a r c h W id e S trin g in R e v e r s e for C h a ra c te r (C 99)                < w c h a r . h>
                                  w char_t       * w c src h r(c o n st w char_t               *s,   w ch a r_ t c );
                                 Wide-character version of s t r r c h r .                                                          25.5

      wcsrtombs                   C o n v e rt W ide S trin g to M ultibyte S trin g - R e s ta r ta b le (C 99)         < w c h a r . h>
                                  s iz e _ t   w c s r to m b s (c h a r * r e s t r i c t d s t ,
                                                                 c o n s t w c h a r _ t ** r e s t r i c t s r c ,
                                                                 s iz e _ t le n ,
                                                                 m b s ta te _ t * r e s t r i c t p s ) ;
                                 Converts a sequence of wide characters from the array indirectly pointed to by
                                 s r c into a sequence ofcorresponding multibyte characters that begins in the con­
                                 version state described by the object pointed to by p s . If p s is a nuU pointer,
                                 w c s r to m b s uses an internal object to store the conversion state. If d s t isn’t a
                                 null pointer, the converted characters are then stored in the array pointed to by
                                 d s t . Conversion continues up to and including a terminating null wide character,
                                 which is also stored. Conversion stops earlier if a wide character is reached that
                                 doesn’t correspond to a valid multibyte character or— if d s t isn’t a null pointer—
                                                       A p p e n d ix D                                                      797onmlkjihgfedcbaZ
                                                                             S ta n d a rd L ib ra ry F u n c tio n s kjihgfedcbaZYXWVUTSRQPONML


                   when the next multibyte character would exceed the Umil of l e n total bytes to be
                   stored in the array pointed to by d s t . I f d s t isn’t a null pointer, the object pointed
                   to by s r c is assigned either a null pointer (if a terminating null wide character was
                   reached) or the address just past the last wide character convened (if any). If the
                   conversion ends at a null wide character, the resultin ^g^ state is the initial conversion
                   state.cbaZYXWVUTSRQPONMLKJIHGFEDCBA
         Returns   Number of bytes in the resulting multibyte character sequence, not including any
                   terminating null character. Returns ( s iz e _ _ t) ( - 1 ) and stores EILSEQ in
                   e r r n o ifa wide character is encountered that doesn’t correspond to a valid multi­
                   byte character.                                                      25.5 PONMLKJIHGFEDCBA

     wcsspn        S e a rc h W id e S trin g fo r In itia l S p a n o f C h a ra c te rs in S e t (C 9 9 ) < w c h a r . h>

                   s iz e _ t    w c ssp n (c o n st      w ch a r_ t     ★ s l,     const        w char_t         * s2 );
                   Wide-character version of s t r s p n .                                                                   25.5

     w c s s t r   S e a rc h W id e S trin g fo r S u b s trin g (C 9 9 )                                      < w c h a r . h>
                   w char_t         * w c s s tr (c o n s t   w char_t * s l,            c o n s t w char_t            * s2 );
                   Wide-character version of s t r s t r .                                                                   25.5

     wcstod        C o n v e rt W id e S trin g to D o u b le (C 9 9 )                                          < w c h a r . h>
                   d o u b le    w c s to d (c o n s t w ch a r_ t * r e s t r i c t n p tr ,
                                             w c h a r _ t ** r e s t r i c t e n d p t r ) ;
                   Wide-character version of s t r t o d .                                                                    25.5

     WCB t o f     C o n v e rt W id e S trin g to F lo a t (C 9 9 )                                           < w c h a r . h>
                   flo a t      w c s to f(c o n s t w char_t * r e s t r i c t n p tr ,
                                           w c h a r _ t ** r e s t r i c t e n d p t r ) ;
                   Wide-character version of s t r t o f .                                                                    25.5

w c s to im a x    C o n v e rt W id e S trin g to G re a te s t-W id th In te g e r (C 9 9 )             < i n t t y p e s . h>
                   in tin a x _ t    w c s to im a x (c o n s t w c h a r_ t * r e s t r i c t n p tr ,
                                                      w c h a r _ t ** r e s t r i c t e n d p t r ,
                                                      in t b a se );
                   Wide-character version of s t r t o i m a x .                                                              27.2

     w c s to k    S e a rc h W id e S trin g fo r T oken (C 9 9 )                                              < w c h a r . h>
                   w char_t         * w c s to k (w c h a r _ t ★ r e s t r i c t s l ,
                                                  c o n s t w char_t * r e s t r i c t s2 ,
                                                  w char_t ★ * r e s t r i c t p t r ) ;
                   Searches the wide string pointed to by s l for a “token” consisting of wide charac­
                   ters not in the wide string pointed to by s 2 . lf a token e>xists. the character follow­
                   ing it is changed to a null wide character. If s l is a null pointer, a search begun by
                   a previous call of w c s t o k is continued; the search begins immediately after the
                   null wide character at the end of the previous token, p t r points to an object of
          A p p e n d ix D S ta n d a r d L ib ra ry F u n c tio n s onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
798 cbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                    type w c h a r _ t * that w c s t o k modifies to keep track of its progress. If s l is a
                                    null pointer, this object must be the same one used in a previous call of w c s t o k ; it
                                    determ ines which wide string is to be searched and where the search is to begin.
                     R eturns       A pointer to the first wide character of the token. Returns a null pointer if no token
                                               could be found.                                                         25.5 PONMLKJI

               WCS bol              C o n v e r t W id e S tr in g to L o n g I n te g e r (C 9 9 )                           < w c h a r . h>
                                    lo n g    in t     w c s to l(c o n st w ch a r_ t * r e s t r i c t n p tr ,
                                                                  w c h a r _ t ** r e s t r i c t e n d p t r , i n t           b a se );
                                    W ide-character version of s t r t o l .                                                             25.5

            WCStold                 C o n v e r t W id e S tr in g to L o n g D o u b le (C 9 9 )                             < w c h a r . h>
                                    lo n g    d o u b le    w c s to ld (c o n s t w char_t * r e s t r i c t n p tr ,
                                                                         w c h a r _ t ** r e s t r i c t e n d p t r ) ;
                                    W ide-character version of s t r t o l d .                                                           25.5

            wcs tol 1               C o n v e r t W id e S tr in g to L o n g L o n g In te g e r (C 9 9 )                    < w c h a r . h>
                                    lo n g    lo n g    in t    w c s t o ll (c o n st w char_t * r e s t r i c t n p tr ,
                                                                              w c h a r _ t ** r e s t r i c t e n d p t r ,
                                                                              in t b a se );
                                    W ide-character version of s t r t o l l .                                                           25.5

         WCStombs                   C o n v e r t W id e S tr in g to M u ltib y te S tr in g                               < s td lib .h >
                                    s i z e _ t w c s to m b s (c h a r * r e s t r i c t s ,
                                                                c o n s t w c h a r_ t * r e s t r i c t             pw cs,
                                                                s iz e _ t n ) ;
                                    Converts a sequence of wide characters into corresponding multibyte characters,
                                    p w c s points to an array containing the wide characters. The multibyte characters
                                    are stored in the array pointed to by s . Conversion ends if a null character is stored
                                    or if storing a multibyte character would exceed the limit o f n bytes.
                     R eturns       Number of bytes stored, not including the terminating null character, if any.
                                    Returns ( s i z e _ t ) ( - 1 ) if a wide character is encountered that doesn't corre­
                                              spond to a valid multibyte character.                                   25.2

            wcstoul                 C o n v e r t W id e S tr in g to U n s ig n e d L o n g I n te g e r (C 9 9 )            < w c h a r . h>
                                    u n s ig n e d lo n g i n t w c s to u l(
                                        c o n s t w char_t * r e s t r i c t n p tr ,
                                        w c h a r _ t ** r e s t r i c t e n d p t r , i n t            b a se );
                                    W ide-characterversion of s t r t o u l .                                                            25.5

          wcstoull                  C o n v e r t W id e S tr in g to U n s ig n e d L o n g L o n g In te g e r (C 9 9 )     < w c h a r . h>
                                    u n s ig n e d lo n g lo n g i n t w c s t o u l l (
                                        c o n s t w char_t * r e s t r i c t n p tr ,
                                        w c h a r _ t ** r e s t r i c t e n d p t r , i n t            b a se );
                                    W ide-character version of s t r t o u l l .                                                         25.5
                                                       A p p e n d ix D      S ta n d a r d Library F u n c tio n s GFEDCBA 799


w c s to u m a x   C o n v e rt W ide S trin g to U n sig n e d G re a te st-W id th In te g e r onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
                                                                                                    < i n t t y p e s . h>
                   (C 99)
                   u in tm a x _ t w c s to u m a x (c o n s t w c h a r_ t * r e s t r i c t n p t r ,
                                                     w c h a r _ t ** r e s t r i c t e n d p t r ,
                                                     in t b a se );
                   Wide-character version of s t r t o u m a x .                                                           27.2

   W C S X fr m    Transform W ide S trin g (C 99)                                                            < w c h a r . h>
                   s iz e _ t   w c s x fr m (w c h a r _ t * r e s t r i c t s l ,
                                              c o n s t w char_t * r e s t r i c t                 s2f    s iz e _ t n ) ;
                   Wide-character version of s t r x f r m .                                                               25.5

       w c to b    C o n v e rt W ide C h a ra c te r to B y te (C 99)                                        < w c h a r . h>
                   in t   w c to b (w in t_ t       c );
         Returns   Single-byte representation of c as an u n s i g n e d c h a r converted to i n t . Returns
                   EOF if c doesn’t correspond to one muItibyte character in the initial shift state.
                                                                                                         25.5

     WC tomb       C o n v e rt W ide C h a ra c te r to M uItibyte C h a ra c te r                         < s t d l i b . h>
                   i n t w c to m b ( c h a r * s ,        w c h a r_ t w c );
                   Converts the wide character stored in wc into a muItibyte character. If s isn't a null
                   pointer, stores the result in the array that s points lo.
         Returns   If s is a null pointer, returns a nonzero or zero value, depending on whether or not
                   multibyte characters have state-dependent encodings. Otherwise, returns the num­
                   ber of bytes in the muItibyte character that corresponds lo wc; returns -1 if wc
                   doesn’t correspond to a valid muItibyte character.                    25.2

   W C tr a n s    D efin e W id e-C h a ra c ter Mapping (C99)                                             < w c t y p e . h>
                   w c tr a n s _ t    w c tr a n s (c o n s t    char       * p r o p e r ty );
         Returns   If p r o p e r t y identifies a valid mapping of wide characters according to the
                   LC_CTYPE category ofthe current locale, retums a nonzero value that can be used
                   as the second argument to the t o w c t r a n s function; otherwise, returns zero.
                                                                                                      25.6

     WC t y p e    Define Wide-Character Class (C99)                                                       < w c t y p e . h>
                   w c ty p e _ t     w c ty p e (c o n s t   char        * p r o p e r ty );
         Returns   If p r o p e r t y identifies a valid class of wide characters according to the
                   LC_CTYPE category o fth e current locale, returns a nonzero value that can be used
                   as the second argument to the i s w c t y p e function; otherwise, returns zero. 25.6
   w m em chr      S e a r c h W id e-C h a ra c ter M e m o ry Block for C h a ra c te r (C99)               < w c h a r . h>
                   w char_t         * w m e m c h r(c o n st w c h a r _ t * s,         w ch a r_ t c,
                                                   s iz e _ t n) ;
                   Wide-character version of memchx^.                                                                     25.5
8 0 0 ZYXWVUTSRQPONMLKJIHGFEDCBA
           A p p e n d ix D     S ta n d a r d L ib r a r y F u n c tio n s cbaZYXWVUTSRQPONMLKJIHGFEDCBA


             wmemcmp                                                                                                              < w c h a i-. h>
                                     C o m p a re W id e -C h a ra c te r M e m o ry B lo c k s (C 9 9 ) onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA

                                     in t     w m e m c m p (c o n s t w c h a r _ t        * s l,      c o n s t w char_t       * s2,
                                                            s i z e _ t n) ;
                                     Wide-character version of memcmp.                                                                       25.5
             w m em cpy              C o p y W id e - C h a ra c te r M e m o r y B lo c k (C 9 9 )                             < w c h a r . h>
                                     w char_t         * w m e m c p y (w c h a r _ t * r e s t r i c t s l ,
                                                                      c o n s t w char_t * r e s t r i c t              s2,
                                                                      s iz e _ t n ) ;
                                     Wide-character version of memcpy.                                                                     25.5
          wmemmove                   C o p y W id e -C h a ra c te r M e m o r y B lo c k (C 9 9 )                              < w c h a r . h>
                                     w char_t         * w m e m m o v e (w c h a r _ t * s l ,        c o n s t w char_t      *s2,
                                                                        s i z e _ t n) ;
                                     Wide-character version of memmove.                                                                      25.5
            m em set                 In itia liz e W id e -C h a r a c te r M e m o r y B lo c k (C 9 9 )                       < w c h a r . h>
                                     w ch a r_ t      * w m e m s e t( w c h a r _ t      *s,     w char_t c f      s iz e _ t n );
                                     Wide-character version of m em set.                                                                     25.5

             w p r in tf             W id e -C h a r a c te r F o rm a tt e d W rite (C 9 9 )                                   < w c h a r . h>
                                     in t w p r in tf(c o n s t            w char_t         * re s tric t      fo r m a t,     ...) ;
                                     Wide-character version of p r i n t f .                                                                25.5
               w scanf               W id e - C h a r a c te r F o rm a tt e d R e a d (C 9 9 )                                 < w c h a r . h>
                                     i n t w s c a n f(c o n s t w ch a r_ t * r e s t r i c t               fo r m a t,     ...) ;
                                     Wide-character version of s c a n f .                                                                   25.5
A P P E N D IX E                aZYXWVUTSRQPONMLKJIHGFEDCBA



A S C II C h a r a c t e r S e t                                              cbaZYXWVUTSRQPONMLKJIHGFEDCBA




                 E scape Sequ en ce
D ecim al   Oct        H ex     C har      Character onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
     6                                                                                                         X
                                                                                                               .
            \o        \x O O              nul                 32                  64      @         96
     ]      \ *1      \x O l              soh    ( AA)        33         4i       65      A         97         a
                                                                         ft
    2       \2        \x O 2              stx    (^B)         34                  66      B         98         b
    3       \3        \x O 3              eLx    (^C)         35     #            67      C         99         c
    4       \4        \x O 4              eot    ( A D)       36     $            68      D        100         d
    5       \ ^       \x O 5              enq    ( A E)       37     %            69      E        101         e
    6       \6        \x O 6              ack    (AF)         38     &            70      F        102         f
                                                                     I
    7       \7        \x O 7      \a      bel    ( AG)        39                  71      G        103         g
    8       \1 0      \x O 8      \b      bs     (A H)        40         (        72      H        104         h
    9       \ 11      \x O 9      \t      ht     (A l)        41         )        73       1       105          i
   10       \1 2      \x O a      \n                          42     ❖            74      J        106
                                          lf     (^J)                                                          j
   II       \ 13      \x O b      \v      vt     (AK)         43     ^-           75      K        107         k
   12       \1 4      \x O c      \f      ff     ( A L)       44         •        76      L        108          I
   13       \ 15      \x O d      \ ^*    cr     (^M)         45         -        77      M        109        m
   14       \1 6      \x O e              so     (^N)         46                  78      N        110        n
   15       \ 17      \x O f              si     (A 0 )       47     /            79      0        111        o
   16       \2 0      \x lO               dle    (^P)         48     0            80      P        112         P
   17       \2 1      \x ll               dcl    (A Q)        49        1         81      Q        113         q
   18       \2 2      \x l2               dc2    ( AR)        50     2            82      R        114         r
   19       \2 3      \x l3               dc3    ( A S)       51     3            83       ^J
                                                                                                   115         s
   20       \2 4      \x l4               dc4    (^T)         s^     4            84      T        116         l
   21       \2 5      \x l5               nak    (^U)         ^3     5            85      U        117        u
   22       \2 6      \x l6               syn    (^V)         54     6            86      V        118        v
   23       \2 7      \s*zl 7             etb    (^W)         55     7            87      W        119        w
   24       \3 0      \x l8               can    (^X)         56     8            88      X        120        x
   25       \ 31      \x l9               ein    ( A Y)       57     9            89      Y        121         y
   26       \3 2      \x la               sub    ( AZ)        58      ••          90      z        122         V
   27       \ 33      \x lb               esc                 59       •»         91               123
                                                                                          [                    I
   28       \3 4      \x l c              fa                  60     <            92      \        124         I
   29       \ 35      \x ld                                   61     —            93       I       125
                                          gS                                                                   )
   30       \3 6      \x le                rs                 62     >            94       A
                                                                                                   126
   31       \3 7      \x lf                us                 63     9•           95       —       127        del



                                                                                                              801
B IB L IO G R A P H Y                       ZYXWVUTSRQPONMLKJIHGFEDCBA




                                                      T h e b e s t b o o k o n p r o g ra m m in g fo r th e la y m a n is
                                                           “A lic e in W o n d e rla n d ”; b u t t h a t ’s b e c a u s e i t ’s
                                                                th e b e s t b o o k o n a n y th in g fo r th e la y m a n . dcbaZYXWVUTSRQPONM




C P r o g r a m m in g onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
               The C P uzzle Book. Revised Printing, Addison-W esley, Reading,
Feuer, A. R., cbaZYXWVUTSRQPONMLKJIHGFEDCBA
    Mass., 1999. Contains numerous “puzzles”— small C program s whose output
    the reader is asked to predict. The book shows the correct output of each pro­
    gram and provides a detailed explanation of how it works. Good for testing
    your C knowledge and reviewing the fine points o f the language.
Harbison, S. P., Iff, and G. L. Steele, Jr., C: A R eference M anual, Fifth Edition,
    Prentice-H all, Upper Saddle River, N.J., 2002. The ultimate C reference—
    essential reading for the would-be C expert. Covers both C89 and C99 in con­
    siderable detail, with frequent discussions o f im plementation differences
    found in C compilers. Not a tutorial— assum es that the reader is already well
    versed in C.
Kernighan, B. W., and D. M. Ritchie, The C P rogram m ing L anguage, Second Edi­
    tion. Prentice-H all, Englewood Cliffs, N.J., 1988. The original C book, affec­
    tionately known as K&R or simply “the W hite Book.” Includes both a tutorial
    and a com plete C reference manual. The second edition reflects the changes
    made in C89.
Koenig, A., C Traps a n d P itfalls, Addison-Wesley, Reading, M ass., 1989. An
   excellent com pendium of common (and som e not-so-com m on) C pitfalls.
   Forewarned is forearmed.
Plauger, P. J., The Standard C Library. Prentice-H all, Englewood Cliffs, N.J.,
    1992. Not only explains all aspects of the C89 standard library, but provides
    com plete source code! T here’s no better way to learn the library than to study
    this book. Even if your interest in the library is minimal, the book is worth get-
    tin g ju st for the opportunity to study C code written by a master.



                                                                                                                         803
           B ib lio g ra p h y onmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
8 0 4 ZYXWVUTSRQPONMLKJIHGFEDCBA


                                                                                                                  H isto ry o f
                                      Ritchie, D. M., The development of tlie C programming language, in cbaZYXWVUTSRQPONMLKJIHGFE
                                          Program ming L anguages JI, edited by T. J. Bergin, Jr.. and R. G. Gibson. Jr..
                                          Addison-Wesley, Reading, Mass., 1996, pages 671-687. A brief history of C
                                          written by the language’s designer for the Second ACM SJGPLAN History of
                                          Pro K
                                              g»*ram m inss^ Lang^^uag^^*es Conference, which was held in 1993. The article is
                                          followed by transcripts of Ritchie’s presentation at the conference and the
                                          question-and-answer session with the audience.

                                      Ritchie, D. M., S. C. Johnson, M. E. Lesk, and B. W. Kernighan, UNIX tim e­
                                          sharing system: the C programming language, Bell System Technical Journal
                                          57, 6 (July-A ugust 1978), 1991-2019. A famous article that discusses the
                                          origins o fC and describes the language as it looked in 1978.

                                      Rosler, L., The UNIX system: the evolution of C— past and future, A T & T Bell
                                          Laboratories T echnicalJournal 63, 8 (October 1984), 1685-1699. Traces the
                                          evolution o fC from 1978 to 1984 and beyond.

                                      Summit, S., C Program m ing FAQs: F requentlyA sked Q uestions, Addison-Wesley.
                                         Reading, Mass., 1996. An expanded version of the FAQ list that has appeared
                                         for years in the Usenet com p.iang.c newsgroup.

                                      van der Linden, P., Expert C Programm ing, Prentice-Hall, Englewood Cliffs, N.J.,
                                           1994. Written by one o f the C wizards at Sun Microsystems, this book man­
                                          ages to entertain and inform in equal amounts. With its profusion of anecdotes
                                          andjokes, it makes learning the fine points o fC seem alm ost fun.dcbaZYXWVUTSRQPONMLKJIHGFE


                                      U N I X P r o g r a m m in g

                                      Rochkind, M. J., A dvanced UNJX Programming, Second Edition, Addison-Wesley,
                                         Boston, Mass., 2004. Covers UNIX system calls in considerable detail. This
                                         book, along with the one by Stevens and Rago, is a must-have for C program­
                                         mers who use the UNIX operating system or one of its variants.

                                      Stevens, W. R., and S. A. Rago, A dvanced Programm ing in the UNIX Environment,
                                          Second Edition, Addison-Wesley, Upper Saddle River. N.J., 2005. An excel­
                                          lent follow-up to this book for programmers working under the UNIX operat­
                                          ing system. Focuses on using UNIX system calls, including standard C library
                                          functions as well as functions that are specific to UNIX.


                                      P r o g r a m m in g in G e n e r a l

                                      Bentley, J., Program ming Pearls. Second Edition, Addison-Wesley, Reading,
                                          Mass., 2000. This updated version of Bentley’s classic programming book
                                          emphasizes writing efficient programs, but touches on other topics that are
                                          crucial for the professional programmer. The author’s light touch makes the
                                          book as enjoyable to read as it is informative.
                                                                         B ib lio g ra p h y hgfedcbaZYXWVUTSRQPONMLKJIHG
                                                                                                     8 0 5 onmlkjihgfedcbaZYXW


                                     T he P ra ctice o fP r o g ra m m in g , Addison-W esley,
K ernighan, B. W., and R. Pike, cbaZYXWVUTSRQPONMLKJIHGFEDCBA
     Reading, Mass., 1999. Read this book for advice on program m ing style, choos­
     ing the right algorithm , testing and debugging, and writing portable program s.
     Exam ples are drawn from C, C++, and Java.

M cConnell, S., C ode C om plete, Second Edition, M icrosoft Press. Redm ond, Wash.,
    2004. Tries to bridge the gap betw een program m ing theory and practice by pro­
    viding dow n-to-earth coding advice based on proven research. Includes plenty
    of exam ples in a variety of program m ing languages. Highly recom m ended.

Raym ond, E. S., ed., T h e N e w H a c k e r 's D ic tio n a r y , Third Edition. M IT Press, C am ­
    bridge, Mass., 1996. Explains much o f foe jargon that program m ers use, and it\s
   ogreat fun to read as well,dcbaZYXWVUTSRQPONMLKJIHGFEDCBA


W eb R esou rces

ANSI eStandards Store (w eb sto re.a n si.o rg ). The C99 standard (ISO ^E C
   9899:1999) can be purchased at this site. Each set of corrections to the stan­
   dard (known as a Technical C orrigendum ) can be downloaded for free.

co m p .la n g .c Frequently Asked Q uestions (c-fa q .c o m ). Steve Sum m it’s FAQ list for
     the co m p .la n g .c new sgroup is a m ust-read for any C program m er.

D inkum w are (w w w .d in ku m w a re.co m ). D inkum w are is owned by P. J. Plauger, the
     acknow ledged m aster of the C and C++ standard libraries. The web site in­
     cludes a handy C99 library reference, am ong other things.

G oogle Groups (g ro u p s.g o o g le .c o m ). One o fth e best ways to find answers to pro­
    gram m ing questions is to search the Usenet new sgroups using the Google
    Groups search engine, lfy o u have a question, it’s likely that som eone else has
    already asked the question on a new sgroup and the answ er has been posted.
    Groups of particular interest to C program m ers include a lt.co m p .la n g .lea rn .c-
    c + T (for C and C++ beginners), co m p .la n g .c (the prim ary C language group),
    and co m p .std .c (devoted lo discussion o f the C standard).

International Obfuscated C Code C ontest ( w w w .ioccc.org). Home o fa n annual con­
     test in which participants vie to see who can write the most obscure C program s.

ISO /IEC JTC l/SC 22A V G 14 (w w w .o p e n -std .o rg /jtc l/s c 2 2 /w g l4 /). T he official web
     site of W G14, the international w orking group that created the C99 standard
     and is responsible for updating it. O f particular interest am ong the many docu­
     m ents available at the site is the rationale for C99, which explains the reasons
     for the changes made in the standard.

Lysator (w w w .lysator.liu.se/cA - A collection of links to C -related web sites m ain­
    tained by Lysator. an academ ic com puter society located at S w eden's L in­
    koping University.
